// Bundled by esbuild for Vercel deployment

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __require = /* @__PURE__ */ ((x) => typeof require !== "undefined" ? require : typeof Proxy !== "undefined" ? new Proxy(x, {
  get: (a, b) => (typeof require !== "undefined" ? require : a)[b]
}) : x)(function(x) {
  if (typeof require !== "undefined") return require.apply(this, arguments);
  throw Error('Dynamic require of "' + x + '" is not supported');
});
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb2, mod) => function __require2() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/cookie/dist/index.js
var require_dist = __commonJS({
  "node_modules/cookie/dist/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parseCookie = parseCookie;
    exports2.parse = parseCookie;
    exports2.stringifyCookie = stringifyCookie;
    exports2.stringifySetCookie = stringifySetCookie;
    exports2.serialize = stringifySetCookie;
    exports2.parseSetCookie = parseSetCookie;
    exports2.stringifySetCookie = stringifySetCookie;
    exports2.serialize = stringifySetCookie;
    var cookieNameRegExp = /^[\u0021-\u003A\u003C\u003E-\u007E]+$/;
    var cookieValueRegExp = /^[\u0021-\u003A\u003C-\u007E]*$/;
    var domainValueRegExp = /^([.]?[a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)([.][a-z0-9]([a-z0-9-]{0,61}[a-z0-9])?)*$/i;
    var pathValueRegExp = /^[\u0020-\u003A\u003D-\u007E]*$/;
    var maxAgeRegExp = /^-?\d+$/;
    var __toString = Object.prototype.toString;
    var NullObject = /* @__PURE__ */ (() => {
      const C = function() {
      };
      C.prototype = /* @__PURE__ */ Object.create(null);
      return C;
    })();
    function parseCookie(str, options) {
      const obj2 = new NullObject();
      const len = str.length;
      if (len < 2)
        return obj2;
      const dec = options?.decode || decode;
      let index = 0;
      do {
        const eqIdx = eqIndex(str, index, len);
        if (eqIdx === -1)
          break;
        const endIdx = endIndex(str, index, len);
        if (eqIdx > endIdx) {
          index = str.lastIndexOf(";", eqIdx - 1) + 1;
          continue;
        }
        const key = valueSlice(str, index, eqIdx);
        if (obj2[key] === void 0) {
          obj2[key] = dec(valueSlice(str, eqIdx + 1, endIdx));
        }
        index = endIdx + 1;
      } while (index < len);
      return obj2;
    }
    function stringifyCookie(cookie, options) {
      const enc = options?.encode || encodeURIComponent;
      const cookieStrings = [];
      for (const name of Object.keys(cookie)) {
        const val = cookie[name];
        if (val === void 0)
          continue;
        if (!cookieNameRegExp.test(name)) {
          throw new TypeError(`cookie name is invalid: ${name}`);
        }
        const value = enc(val);
        if (!cookieValueRegExp.test(value)) {
          throw new TypeError(`cookie val is invalid: ${val}`);
        }
        cookieStrings.push(`${name}=${value}`);
      }
      return cookieStrings.join("; ");
    }
    function stringifySetCookie(_name, _val, _opts) {
      const cookie = typeof _name === "object" ? _name : { ..._opts, name: _name, value: String(_val) };
      const options = typeof _val === "object" ? _val : _opts;
      const enc = options?.encode || encodeURIComponent;
      if (!cookieNameRegExp.test(cookie.name)) {
        throw new TypeError(`argument name is invalid: ${cookie.name}`);
      }
      const value = cookie.value ? enc(cookie.value) : "";
      if (!cookieValueRegExp.test(value)) {
        throw new TypeError(`argument val is invalid: ${cookie.value}`);
      }
      let str = cookie.name + "=" + value;
      if (cookie.maxAge !== void 0) {
        if (!Number.isInteger(cookie.maxAge)) {
          throw new TypeError(`option maxAge is invalid: ${cookie.maxAge}`);
        }
        str += "; Max-Age=" + cookie.maxAge;
      }
      if (cookie.domain) {
        if (!domainValueRegExp.test(cookie.domain)) {
          throw new TypeError(`option domain is invalid: ${cookie.domain}`);
        }
        str += "; Domain=" + cookie.domain;
      }
      if (cookie.path) {
        if (!pathValueRegExp.test(cookie.path)) {
          throw new TypeError(`option path is invalid: ${cookie.path}`);
        }
        str += "; Path=" + cookie.path;
      }
      if (cookie.expires) {
        if (!isDate(cookie.expires) || !Number.isFinite(cookie.expires.valueOf())) {
          throw new TypeError(`option expires is invalid: ${cookie.expires}`);
        }
        str += "; Expires=" + cookie.expires.toUTCString();
      }
      if (cookie.httpOnly) {
        str += "; HttpOnly";
      }
      if (cookie.secure) {
        str += "; Secure";
      }
      if (cookie.partitioned) {
        str += "; Partitioned";
      }
      if (cookie.priority) {
        const priority = typeof cookie.priority === "string" ? cookie.priority.toLowerCase() : void 0;
        switch (priority) {
          case "low":
            str += "; Priority=Low";
            break;
          case "medium":
            str += "; Priority=Medium";
            break;
          case "high":
            str += "; Priority=High";
            break;
          default:
            throw new TypeError(`option priority is invalid: ${cookie.priority}`);
        }
      }
      if (cookie.sameSite) {
        const sameSite = typeof cookie.sameSite === "string" ? cookie.sameSite.toLowerCase() : cookie.sameSite;
        switch (sameSite) {
          case true:
          case "strict":
            str += "; SameSite=Strict";
            break;
          case "lax":
            str += "; SameSite=Lax";
            break;
          case "none":
            str += "; SameSite=None";
            break;
          default:
            throw new TypeError(`option sameSite is invalid: ${cookie.sameSite}`);
        }
      }
      return str;
    }
    function parseSetCookie(str, options) {
      const dec = options?.decode || decode;
      const len = str.length;
      const endIdx = endIndex(str, 0, len);
      const eqIdx = eqIndex(str, 0, endIdx);
      const setCookie = eqIdx === -1 ? { name: "", value: dec(valueSlice(str, 0, endIdx)) } : {
        name: valueSlice(str, 0, eqIdx),
        value: dec(valueSlice(str, eqIdx + 1, endIdx))
      };
      let index = endIdx + 1;
      while (index < len) {
        const endIdx2 = endIndex(str, index, len);
        const eqIdx2 = eqIndex(str, index, endIdx2);
        const attr = eqIdx2 === -1 ? valueSlice(str, index, endIdx2) : valueSlice(str, index, eqIdx2);
        const val = eqIdx2 === -1 ? void 0 : valueSlice(str, eqIdx2 + 1, endIdx2);
        switch (attr.toLowerCase()) {
          case "httponly":
            setCookie.httpOnly = true;
            break;
          case "secure":
            setCookie.secure = true;
            break;
          case "partitioned":
            setCookie.partitioned = true;
            break;
          case "domain":
            setCookie.domain = val;
            break;
          case "path":
            setCookie.path = val;
            break;
          case "max-age":
            if (val && maxAgeRegExp.test(val))
              setCookie.maxAge = Number(val);
            break;
          case "expires":
            if (!val)
              break;
            const date = new Date(val);
            if (Number.isFinite(date.valueOf()))
              setCookie.expires = date;
            break;
          case "priority":
            if (!val)
              break;
            const priority = val.toLowerCase();
            if (priority === "low" || priority === "medium" || priority === "high") {
              setCookie.priority = priority;
            }
            break;
          case "samesite":
            if (!val)
              break;
            const sameSite = val.toLowerCase();
            if (sameSite === "lax" || sameSite === "strict" || sameSite === "none") {
              setCookie.sameSite = sameSite;
            }
            break;
        }
        index = endIdx2 + 1;
      }
      return setCookie;
    }
    function endIndex(str, min2, len) {
      const index = str.indexOf(";", min2);
      return index === -1 ? len : index;
    }
    function eqIndex(str, min2, max2) {
      const index = str.indexOf("=", min2);
      return index < max2 ? index : -1;
    }
    function valueSlice(str, min2, max2) {
      let start = min2;
      let end = max2;
      do {
        const code = str.charCodeAt(start);
        if (code !== 32 && code !== 9)
          break;
      } while (++start < end);
      while (end > start) {
        const code = str.charCodeAt(end - 1);
        if (code !== 32 && code !== 9)
          break;
        end--;
      }
      return str.slice(start, end);
    }
    function decode(str) {
      if (str.indexOf("%") === -1)
        return str;
      try {
        return decodeURIComponent(str);
      } catch (e) {
        return str;
      }
    }
    function isDate(val) {
      return __toString.call(val) === "[object Date]";
    }
  }
});

// node_modules/underscore/modules/_setup.js
var VERSION, root, ArrayProto, ObjProto, SymbolProto, push, slice, toString, hasOwnProperty, supportsArrayBuffer, supportsDataView, nativeIsArray, nativeKeys, nativeCreate, nativeIsView, _isNaN, _isFinite, hasEnumBug, nonEnumerableProps, MAX_ARRAY_INDEX;
var init_setup = __esm({
  "node_modules/underscore/modules/_setup.js"() {
    VERSION = "1.13.7";
    root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
    ArrayProto = Array.prototype;
    ObjProto = Object.prototype;
    SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
    push = ArrayProto.push;
    slice = ArrayProto.slice;
    toString = ObjProto.toString;
    hasOwnProperty = ObjProto.hasOwnProperty;
    supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
    supportsDataView = typeof DataView !== "undefined";
    nativeIsArray = Array.isArray;
    nativeKeys = Object.keys;
    nativeCreate = Object.create;
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
    _isNaN = isNaN;
    _isFinite = isFinite;
    hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
    nonEnumerableProps = [
      "valueOf",
      "isPrototypeOf",
      "toString",
      "propertyIsEnumerable",
      "hasOwnProperty",
      "toLocaleString"
    ];
    MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  }
});

// node_modules/underscore/modules/restArguments.js
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index = 0;
    for (; index < length; index++) {
      rest2[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest2);
      case 1:
        return func.call(this, arguments[0], rest2);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest2;
    return func.apply(this, args);
  };
}
var init_restArguments = __esm({
  "node_modules/underscore/modules/restArguments.js"() {
  }
});

// node_modules/underscore/modules/isObject.js
function isObject2(obj2) {
  var type = typeof obj2;
  return type === "function" || type === "object" && !!obj2;
}
var init_isObject = __esm({
  "node_modules/underscore/modules/isObject.js"() {
  }
});

// node_modules/underscore/modules/isNull.js
function isNull(obj2) {
  return obj2 === null;
}
var init_isNull = __esm({
  "node_modules/underscore/modules/isNull.js"() {
  }
});

// node_modules/underscore/modules/isUndefined.js
function isUndefined(obj2) {
  return obj2 === void 0;
}
var init_isUndefined = __esm({
  "node_modules/underscore/modules/isUndefined.js"() {
  }
});

// node_modules/underscore/modules/isBoolean.js
function isBoolean(obj2) {
  return obj2 === true || obj2 === false || toString.call(obj2) === "[object Boolean]";
}
var init_isBoolean = __esm({
  "node_modules/underscore/modules/isBoolean.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/isElement.js
function isElement(obj2) {
  return !!(obj2 && obj2.nodeType === 1);
}
var init_isElement = __esm({
  "node_modules/underscore/modules/isElement.js"() {
  }
});

// node_modules/underscore/modules/_tagTester.js
function tagTester(name) {
  var tag = "[object " + name + "]";
  return function(obj2) {
    return toString.call(obj2) === tag;
  };
}
var init_tagTester = __esm({
  "node_modules/underscore/modules/_tagTester.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/isString.js
var isString_default;
var init_isString = __esm({
  "node_modules/underscore/modules/isString.js"() {
    init_tagTester();
    isString_default = tagTester("String");
  }
});

// node_modules/underscore/modules/isNumber.js
var isNumber_default;
var init_isNumber = __esm({
  "node_modules/underscore/modules/isNumber.js"() {
    init_tagTester();
    isNumber_default = tagTester("Number");
  }
});

// node_modules/underscore/modules/isDate.js
var isDate_default;
var init_isDate = __esm({
  "node_modules/underscore/modules/isDate.js"() {
    init_tagTester();
    isDate_default = tagTester("Date");
  }
});

// node_modules/underscore/modules/isRegExp.js
var isRegExp_default;
var init_isRegExp = __esm({
  "node_modules/underscore/modules/isRegExp.js"() {
    init_tagTester();
    isRegExp_default = tagTester("RegExp");
  }
});

// node_modules/underscore/modules/isError.js
var isError_default;
var init_isError = __esm({
  "node_modules/underscore/modules/isError.js"() {
    init_tagTester();
    isError_default = tagTester("Error");
  }
});

// node_modules/underscore/modules/isSymbol.js
var isSymbol_default;
var init_isSymbol = __esm({
  "node_modules/underscore/modules/isSymbol.js"() {
    init_tagTester();
    isSymbol_default = tagTester("Symbol");
  }
});

// node_modules/underscore/modules/isArrayBuffer.js
var isArrayBuffer_default;
var init_isArrayBuffer = __esm({
  "node_modules/underscore/modules/isArrayBuffer.js"() {
    init_tagTester();
    isArrayBuffer_default = tagTester("ArrayBuffer");
  }
});

// node_modules/underscore/modules/isFunction.js
var isFunction, nodelist, isFunction_default;
var init_isFunction = __esm({
  "node_modules/underscore/modules/isFunction.js"() {
    init_tagTester();
    init_setup();
    isFunction = tagTester("Function");
    nodelist = root.document && root.document.childNodes;
    if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
      isFunction = function(obj2) {
        return typeof obj2 == "function" || false;
      };
    }
    isFunction_default = isFunction;
  }
});

// node_modules/underscore/modules/_hasObjectTag.js
var hasObjectTag_default;
var init_hasObjectTag = __esm({
  "node_modules/underscore/modules/_hasObjectTag.js"() {
    init_tagTester();
    hasObjectTag_default = tagTester("Object");
  }
});

// node_modules/underscore/modules/_stringTagBug.js
var hasDataViewBug, isIE11;
var init_stringTagBug = __esm({
  "node_modules/underscore/modules/_stringTagBug.js"() {
    init_setup();
    init_hasObjectTag();
    hasDataViewBug = supportsDataView && (!/\[native code\]/.test(String(DataView)) || hasObjectTag_default(new DataView(new ArrayBuffer(8))));
    isIE11 = typeof Map !== "undefined" && hasObjectTag_default(/* @__PURE__ */ new Map());
  }
});

// node_modules/underscore/modules/isDataView.js
function alternateIsDataView(obj2) {
  return obj2 != null && isFunction_default(obj2.getInt8) && isArrayBuffer_default(obj2.buffer);
}
var isDataView, isDataView_default;
var init_isDataView = __esm({
  "node_modules/underscore/modules/isDataView.js"() {
    init_tagTester();
    init_isFunction();
    init_isArrayBuffer();
    init_stringTagBug();
    isDataView = tagTester("DataView");
    isDataView_default = hasDataViewBug ? alternateIsDataView : isDataView;
  }
});

// node_modules/underscore/modules/isArray.js
var isArray_default;
var init_isArray = __esm({
  "node_modules/underscore/modules/isArray.js"() {
    init_setup();
    init_tagTester();
    isArray_default = nativeIsArray || tagTester("Array");
  }
});

// node_modules/underscore/modules/_has.js
function has(obj2, key) {
  return obj2 != null && hasOwnProperty.call(obj2, key);
}
var init_has = __esm({
  "node_modules/underscore/modules/_has.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/isArguments.js
var isArguments, isArguments_default;
var init_isArguments = __esm({
  "node_modules/underscore/modules/isArguments.js"() {
    init_tagTester();
    init_has();
    isArguments = tagTester("Arguments");
    (function() {
      if (!isArguments(arguments)) {
        isArguments = function(obj2) {
          return has(obj2, "callee");
        };
      }
    })();
    isArguments_default = isArguments;
  }
});

// node_modules/underscore/modules/isFinite.js
function isFinite2(obj2) {
  return !isSymbol_default(obj2) && _isFinite(obj2) && !isNaN(parseFloat(obj2));
}
var init_isFinite = __esm({
  "node_modules/underscore/modules/isFinite.js"() {
    init_setup();
    init_isSymbol();
  }
});

// node_modules/underscore/modules/isNaN.js
function isNaN2(obj2) {
  return isNumber_default(obj2) && _isNaN(obj2);
}
var init_isNaN = __esm({
  "node_modules/underscore/modules/isNaN.js"() {
    init_setup();
    init_isNumber();
  }
});

// node_modules/underscore/modules/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var init_constant = __esm({
  "node_modules/underscore/modules/constant.js"() {
  }
});

// node_modules/underscore/modules/_createSizePropertyCheck.js
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}
var init_createSizePropertyCheck = __esm({
  "node_modules/underscore/modules/_createSizePropertyCheck.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/_shallowProperty.js
function shallowProperty(key) {
  return function(obj2) {
    return obj2 == null ? void 0 : obj2[key];
  };
}
var init_shallowProperty = __esm({
  "node_modules/underscore/modules/_shallowProperty.js"() {
  }
});

// node_modules/underscore/modules/_getByteLength.js
var getByteLength_default;
var init_getByteLength = __esm({
  "node_modules/underscore/modules/_getByteLength.js"() {
    init_shallowProperty();
    getByteLength_default = shallowProperty("byteLength");
  }
});

// node_modules/underscore/modules/_isBufferLike.js
var isBufferLike_default;
var init_isBufferLike = __esm({
  "node_modules/underscore/modules/_isBufferLike.js"() {
    init_createSizePropertyCheck();
    init_getByteLength();
    isBufferLike_default = createSizePropertyCheck(getByteLength_default);
  }
});

// node_modules/underscore/modules/isTypedArray.js
function isTypedArray(obj2) {
  return nativeIsView ? nativeIsView(obj2) && !isDataView_default(obj2) : isBufferLike_default(obj2) && typedArrayPattern.test(toString.call(obj2));
}
var typedArrayPattern, isTypedArray_default;
var init_isTypedArray = __esm({
  "node_modules/underscore/modules/isTypedArray.js"() {
    init_setup();
    init_isDataView();
    init_constant();
    init_isBufferLike();
    typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    isTypedArray_default = supportsArrayBuffer ? isTypedArray : constant(false);
  }
});

// node_modules/underscore/modules/_getLength.js
var getLength_default;
var init_getLength = __esm({
  "node_modules/underscore/modules/_getLength.js"() {
    init_shallowProperty();
    getLength_default = shallowProperty("length");
  }
});

// node_modules/underscore/modules/_collectNonEnumProps.js
function emulatedSet(keys2) {
  var hash = {};
  for (var l2 = keys2.length, i = 0; i < l2; ++i) hash[keys2[i]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys2.push(key);
    }
  };
}
function collectNonEnumProps(obj2, keys2) {
  keys2 = emulatedSet(keys2);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj2.constructor;
  var proto = isFunction_default(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has(obj2, prop) && !keys2.contains(prop)) keys2.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj2 && obj2[prop] !== proto[prop] && !keys2.contains(prop)) {
      keys2.push(prop);
    }
  }
}
var init_collectNonEnumProps = __esm({
  "node_modules/underscore/modules/_collectNonEnumProps.js"() {
    init_setup();
    init_isFunction();
    init_has();
  }
});

// node_modules/underscore/modules/keys.js
function keys(obj2) {
  if (!isObject2(obj2)) return [];
  if (nativeKeys) return nativeKeys(obj2);
  var keys2 = [];
  for (var key in obj2) if (has(obj2, key)) keys2.push(key);
  if (hasEnumBug) collectNonEnumProps(obj2, keys2);
  return keys2;
}
var init_keys = __esm({
  "node_modules/underscore/modules/keys.js"() {
    init_isObject();
    init_setup();
    init_has();
    init_collectNonEnumProps();
  }
});

// node_modules/underscore/modules/isEmpty.js
function isEmpty(obj2) {
  if (obj2 == null) return true;
  var length = getLength_default(obj2);
  if (typeof length == "number" && (isArray_default(obj2) || isString_default(obj2) || isArguments_default(obj2))) return length === 0;
  return getLength_default(keys(obj2)) === 0;
}
var init_isEmpty = __esm({
  "node_modules/underscore/modules/isEmpty.js"() {
    init_getLength();
    init_isArray();
    init_isString();
    init_isArguments();
    init_keys();
  }
});

// node_modules/underscore/modules/isMatch.js
function isMatch(object2, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object2 == null) return !length;
  var obj2 = Object(object2);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj2[key] || !(key in obj2)) return false;
  }
  return true;
}
var init_isMatch = __esm({
  "node_modules/underscore/modules/isMatch.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/underscore.js
function _(obj2) {
  if (obj2 instanceof _) return obj2;
  if (!(this instanceof _)) return new _(obj2);
  this._wrapped = obj2;
}
var init_underscore = __esm({
  "node_modules/underscore/modules/underscore.js"() {
    init_setup();
    _.VERSION = VERSION;
    _.prototype.value = function() {
      return this._wrapped;
    };
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    _.prototype.toString = function() {
      return String(this._wrapped);
    };
  }
});

// node_modules/underscore/modules/_toBufferView.js
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength_default(bufferSource)
  );
}
var init_toBufferView = __esm({
  "node_modules/underscore/modules/_toBufferView.js"() {
    init_getByteLength();
  }
});

// node_modules/underscore/modules/isEqual.js
function eq(a, b, aStack, bStack) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  if (a == null || b == null) return false;
  if (a !== a) return b !== b;
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object") return false;
  return deepEq(a, b, aStack, bStack);
}
function deepEq(a, b, aStack, bStack) {
  if (a instanceof _) a = a._wrapped;
  if (b instanceof _) b = b._wrapped;
  var className = toString.call(a);
  if (className !== toString.call(b)) return false;
  if (hasDataViewBug && className == "[object Object]" && isDataView_default(a)) {
    if (!isDataView_default(b)) return false;
    className = tagDataView;
  }
  switch (className) {
    // These types are compared by value.
    case "[object RegExp]":
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case "[object String]":
      return "" + a === "" + b;
    case "[object Number]":
      if (+a !== +a) return +b !== +b;
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray_default(a)) {
    var byteLength = getByteLength_default(a);
    if (byteLength !== getByteLength_default(b)) return false;
    if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") return false;
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction_default(aCtor) && aCtor instanceof aCtor && isFunction_default(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a) return bStack[length] === b;
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    length = a.length;
    if (length !== b.length) return false;
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  } else {
    var _keys = keys(a), key;
    length = _keys.length;
    if (keys(b).length !== length) return false;
    while (length--) {
      key = _keys[length];
      if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual(a, b) {
  return eq(a, b);
}
var tagDataView;
var init_isEqual = __esm({
  "node_modules/underscore/modules/isEqual.js"() {
    init_underscore();
    init_setup();
    init_getByteLength();
    init_isTypedArray();
    init_isFunction();
    init_stringTagBug();
    init_isDataView();
    init_keys();
    init_has();
    init_toBufferView();
    tagDataView = "[object DataView]";
  }
});

// node_modules/underscore/modules/allKeys.js
function allKeys(obj2) {
  if (!isObject2(obj2)) return [];
  var keys2 = [];
  for (var key in obj2) keys2.push(key);
  if (hasEnumBug) collectNonEnumProps(obj2, keys2);
  return keys2;
}
var init_allKeys = __esm({
  "node_modules/underscore/modules/allKeys.js"() {
    init_isObject();
    init_setup();
    init_collectNonEnumProps();
  }
});

// node_modules/underscore/modules/_methodFingerprint.js
function ie11fingerprint(methods) {
  var length = getLength_default(methods);
  return function(obj2) {
    if (obj2 == null) return false;
    var keys2 = allKeys(obj2);
    if (getLength_default(keys2)) return false;
    for (var i = 0; i < length; i++) {
      if (!isFunction_default(obj2[methods[i]])) return false;
    }
    return methods !== weakMapMethods || !isFunction_default(obj2[forEachName]);
  };
}
var forEachName, hasName, commonInit, mapTail, mapMethods, weakMapMethods, setMethods;
var init_methodFingerprint = __esm({
  "node_modules/underscore/modules/_methodFingerprint.js"() {
    init_getLength();
    init_isFunction();
    init_allKeys();
    forEachName = "forEach";
    hasName = "has";
    commonInit = ["clear", "delete"];
    mapTail = ["get", hasName, "set"];
    mapMethods = commonInit.concat(forEachName, mapTail);
    weakMapMethods = commonInit.concat(mapTail);
    setMethods = ["add"].concat(commonInit, forEachName, hasName);
  }
});

// node_modules/underscore/modules/isMap.js
var isMap_default;
var init_isMap = __esm({
  "node_modules/underscore/modules/isMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isMap_default = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
  }
});

// node_modules/underscore/modules/isWeakMap.js
var isWeakMap_default;
var init_isWeakMap = __esm({
  "node_modules/underscore/modules/isWeakMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isWeakMap_default = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
  }
});

// node_modules/underscore/modules/isSet.js
var isSet_default;
var init_isSet = __esm({
  "node_modules/underscore/modules/isSet.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isSet_default = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
  }
});

// node_modules/underscore/modules/isWeakSet.js
var isWeakSet_default;
var init_isWeakSet = __esm({
  "node_modules/underscore/modules/isWeakSet.js"() {
    init_tagTester();
    isWeakSet_default = tagTester("WeakSet");
  }
});

// node_modules/underscore/modules/values.js
function values(obj2) {
  var _keys = keys(obj2);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i = 0; i < length; i++) {
    values2[i] = obj2[_keys[i]];
  }
  return values2;
}
var init_values = __esm({
  "node_modules/underscore/modules/values.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/pairs.js
function pairs(obj2) {
  var _keys = keys(obj2);
  var length = _keys.length;
  var pairs2 = Array(length);
  for (var i = 0; i < length; i++) {
    pairs2[i] = [_keys[i], obj2[_keys[i]]];
  }
  return pairs2;
}
var init_pairs = __esm({
  "node_modules/underscore/modules/pairs.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/invert.js
function invert(obj2) {
  var result2 = {};
  var _keys = keys(obj2);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result2[obj2[_keys[i]]] = _keys[i];
  }
  return result2;
}
var init_invert = __esm({
  "node_modules/underscore/modules/invert.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/functions.js
function functions(obj2) {
  var names = [];
  for (var key in obj2) {
    if (isFunction_default(obj2[key])) names.push(key);
  }
  return names.sort();
}
var init_functions = __esm({
  "node_modules/underscore/modules/functions.js"() {
    init_isFunction();
  }
});

// node_modules/underscore/modules/_createAssigner.js
function createAssigner(keysFunc, defaults) {
  return function(obj2) {
    var length = arguments.length;
    if (defaults) obj2 = Object(obj2);
    if (length < 2 || obj2 == null) return obj2;
    for (var index = 1; index < length; index++) {
      var source = arguments[index], keys2 = keysFunc(source), l2 = keys2.length;
      for (var i = 0; i < l2; i++) {
        var key = keys2[i];
        if (!defaults || obj2[key] === void 0) obj2[key] = source[key];
      }
    }
    return obj2;
  };
}
var init_createAssigner = __esm({
  "node_modules/underscore/modules/_createAssigner.js"() {
  }
});

// node_modules/underscore/modules/extend.js
var extend_default;
var init_extend = __esm({
  "node_modules/underscore/modules/extend.js"() {
    init_createAssigner();
    init_allKeys();
    extend_default = createAssigner(allKeys);
  }
});

// node_modules/underscore/modules/extendOwn.js
var extendOwn_default;
var init_extendOwn = __esm({
  "node_modules/underscore/modules/extendOwn.js"() {
    init_createAssigner();
    init_keys();
    extendOwn_default = createAssigner(keys);
  }
});

// node_modules/underscore/modules/defaults.js
var defaults_default;
var init_defaults = __esm({
  "node_modules/underscore/modules/defaults.js"() {
    init_createAssigner();
    init_allKeys();
    defaults_default = createAssigner(allKeys, true);
  }
});

// node_modules/underscore/modules/_baseCreate.js
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject2(prototype)) return {};
  if (nativeCreate) return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}
var init_baseCreate = __esm({
  "node_modules/underscore/modules/_baseCreate.js"() {
    init_isObject();
    init_setup();
  }
});

// node_modules/underscore/modules/create.js
function create(prototype, props) {
  var result2 = baseCreate(prototype);
  if (props) extendOwn_default(result2, props);
  return result2;
}
var init_create = __esm({
  "node_modules/underscore/modules/create.js"() {
    init_baseCreate();
    init_extendOwn();
  }
});

// node_modules/underscore/modules/clone.js
function clone(obj2) {
  if (!isObject2(obj2)) return obj2;
  return isArray_default(obj2) ? obj2.slice() : extend_default({}, obj2);
}
var init_clone = __esm({
  "node_modules/underscore/modules/clone.js"() {
    init_isObject();
    init_isArray();
    init_extend();
  }
});

// node_modules/underscore/modules/tap.js
function tap(obj2, interceptor) {
  interceptor(obj2);
  return obj2;
}
var init_tap = __esm({
  "node_modules/underscore/modules/tap.js"() {
  }
});

// node_modules/underscore/modules/toPath.js
function toPath(path) {
  return isArray_default(path) ? path : [path];
}
var init_toPath = __esm({
  "node_modules/underscore/modules/toPath.js"() {
    init_underscore();
    init_isArray();
    _.toPath = toPath;
  }
});

// node_modules/underscore/modules/_toPath.js
function toPath2(path) {
  return _.toPath(path);
}
var init_toPath2 = __esm({
  "node_modules/underscore/modules/_toPath.js"() {
    init_underscore();
    init_toPath();
  }
});

// node_modules/underscore/modules/_deepGet.js
function deepGet(obj2, path) {
  var length = path.length;
  for (var i = 0; i < length; i++) {
    if (obj2 == null) return void 0;
    obj2 = obj2[path[i]];
  }
  return length ? obj2 : void 0;
}
var init_deepGet = __esm({
  "node_modules/underscore/modules/_deepGet.js"() {
  }
});

// node_modules/underscore/modules/get.js
function get(object2, path, defaultValue) {
  var value = deepGet(object2, toPath2(path));
  return isUndefined(value) ? defaultValue : value;
}
var init_get = __esm({
  "node_modules/underscore/modules/get.js"() {
    init_toPath2();
    init_deepGet();
    init_isUndefined();
  }
});

// node_modules/underscore/modules/has.js
function has2(obj2, path) {
  path = toPath2(path);
  var length = path.length;
  for (var i = 0; i < length; i++) {
    var key = path[i];
    if (!has(obj2, key)) return false;
    obj2 = obj2[key];
  }
  return !!length;
}
var init_has2 = __esm({
  "node_modules/underscore/modules/has.js"() {
    init_has();
    init_toPath2();
  }
});

// node_modules/underscore/modules/identity.js
function identity(value) {
  return value;
}
var init_identity = __esm({
  "node_modules/underscore/modules/identity.js"() {
  }
});

// node_modules/underscore/modules/matcher.js
function matcher(attrs) {
  attrs = extendOwn_default({}, attrs);
  return function(obj2) {
    return isMatch(obj2, attrs);
  };
}
var init_matcher = __esm({
  "node_modules/underscore/modules/matcher.js"() {
    init_extendOwn();
    init_isMatch();
  }
});

// node_modules/underscore/modules/property.js
function property(path) {
  path = toPath2(path);
  return function(obj2) {
    return deepGet(obj2, path);
  };
}
var init_property = __esm({
  "node_modules/underscore/modules/property.js"() {
    init_deepGet();
    init_toPath2();
  }
});

// node_modules/underscore/modules/_optimizeCb.js
function optimizeCb(func, context, argCount) {
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func.call(context, value);
      };
    // The 2-argument case is omitted because weâ€™re not using it.
    case 3:
      return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
    case 4:
      return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
  }
  return function() {
    return func.apply(context, arguments);
  };
}
var init_optimizeCb = __esm({
  "node_modules/underscore/modules/_optimizeCb.js"() {
  }
});

// node_modules/underscore/modules/_baseIteratee.js
function baseIteratee(value, context, argCount) {
  if (value == null) return identity;
  if (isFunction_default(value)) return optimizeCb(value, context, argCount);
  if (isObject2(value) && !isArray_default(value)) return matcher(value);
  return property(value);
}
var init_baseIteratee = __esm({
  "node_modules/underscore/modules/_baseIteratee.js"() {
    init_identity();
    init_isFunction();
    init_isObject();
    init_isArray();
    init_matcher();
    init_property();
    init_optimizeCb();
  }
});

// node_modules/underscore/modules/iteratee.js
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
var init_iteratee = __esm({
  "node_modules/underscore/modules/iteratee.js"() {
    init_underscore();
    init_baseIteratee();
    _.iteratee = iteratee;
  }
});

// node_modules/underscore/modules/_cb.js
function cb(value, context, argCount) {
  if (_.iteratee !== iteratee) return _.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}
var init_cb = __esm({
  "node_modules/underscore/modules/_cb.js"() {
    init_underscore();
    init_baseIteratee();
    init_iteratee();
  }
});

// node_modules/underscore/modules/mapObject.js
function mapObject(obj2, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = keys(obj2), length = _keys.length, results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee2(obj2[currentKey], currentKey, obj2);
  }
  return results;
}
var init_mapObject = __esm({
  "node_modules/underscore/modules/mapObject.js"() {
    init_cb();
    init_keys();
  }
});

// node_modules/underscore/modules/noop.js
function noop() {
}
var init_noop = __esm({
  "node_modules/underscore/modules/noop.js"() {
  }
});

// node_modules/underscore/modules/propertyOf.js
function propertyOf(obj2) {
  if (obj2 == null) return noop;
  return function(path) {
    return get(obj2, path);
  };
}
var init_propertyOf = __esm({
  "node_modules/underscore/modules/propertyOf.js"() {
    init_noop();
    init_get();
  }
});

// node_modules/underscore/modules/times.js
function times(n, iteratee2, context) {
  var accum = Array(Math.max(0, n));
  iteratee2 = optimizeCb(iteratee2, context, 1);
  for (var i = 0; i < n; i++) accum[i] = iteratee2(i);
  return accum;
}
var init_times = __esm({
  "node_modules/underscore/modules/times.js"() {
    init_optimizeCb();
  }
});

// node_modules/underscore/modules/random.js
function random(min2, max2) {
  if (max2 == null) {
    max2 = min2;
    min2 = 0;
  }
  return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
}
var init_random = __esm({
  "node_modules/underscore/modules/random.js"() {
  }
});

// node_modules/underscore/modules/now.js
var now_default;
var init_now = __esm({
  "node_modules/underscore/modules/now.js"() {
    now_default = Date.now || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
  }
});

// node_modules/underscore/modules/_createEscaper.js
function createEscaper(map2) {
  var escaper = function(match) {
    return map2[match];
  };
  var source = "(?:" + keys(map2).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}
var init_createEscaper = __esm({
  "node_modules/underscore/modules/_createEscaper.js"() {
    init_keys();
  }
});

// node_modules/underscore/modules/_escapeMap.js
var escapeMap_default;
var init_escapeMap = __esm({
  "node_modules/underscore/modules/_escapeMap.js"() {
    escapeMap_default = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
  }
});

// node_modules/underscore/modules/escape.js
var escape_default;
var init_escape = __esm({
  "node_modules/underscore/modules/escape.js"() {
    init_createEscaper();
    init_escapeMap();
    escape_default = createEscaper(escapeMap_default);
  }
});

// node_modules/underscore/modules/_unescapeMap.js
var unescapeMap_default;
var init_unescapeMap = __esm({
  "node_modules/underscore/modules/_unescapeMap.js"() {
    init_invert();
    init_escapeMap();
    unescapeMap_default = invert(escapeMap_default);
  }
});

// node_modules/underscore/modules/unescape.js
var unescape_default;
var init_unescape = __esm({
  "node_modules/underscore/modules/unescape.js"() {
    init_createEscaper();
    init_unescapeMap();
    unescape_default = createEscaper(unescapeMap_default);
  }
});

// node_modules/underscore/modules/templateSettings.js
var templateSettings_default;
var init_templateSettings = __esm({
  "node_modules/underscore/modules/templateSettings.js"() {
    init_underscore();
    templateSettings_default = _.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };
  }
});

// node_modules/underscore/modules/template.js
function escapeChar(match) {
  return "\\" + escapes[match];
}
function template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = defaults_default({}, settings, _.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index = 0;
  var source = "__p+='";
  text.replace(matcher2, function(match, escape2, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match.length;
    if (escape2) {
      source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }
    return match;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument)) throw new Error(
      "variable is not a bare identifier: " + argument
    );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render;
  try {
    render = new Function(argument, "_", source);
  } catch (e) {
    e.source = source;
    throw e;
  }
  var template2 = function(data) {
    return render.call(this, data, _);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}
var noMatch, escapes, escapeRegExp, bareIdentifier;
var init_template = __esm({
  "node_modules/underscore/modules/template.js"() {
    init_defaults();
    init_underscore();
    init_templateSettings();
    noMatch = /(.)^/;
    escapes = {
      "'": "'",
      "\\": "\\",
      "\r": "r",
      "\n": "n",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
    bareIdentifier = /^\s*(\w|\$)+\s*$/;
  }
});

// node_modules/underscore/modules/result.js
function result(obj2, path, fallback) {
  path = toPath2(path);
  var length = path.length;
  if (!length) {
    return isFunction_default(fallback) ? fallback.call(obj2) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj2 == null ? void 0 : obj2[path[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length;
    }
    obj2 = isFunction_default(prop) ? prop.call(obj2) : prop;
  }
  return obj2;
}
var init_result = __esm({
  "node_modules/underscore/modules/result.js"() {
    init_isFunction();
    init_toPath2();
  }
});

// node_modules/underscore/modules/uniqueId.js
function uniqueId(prefix) {
  var id = ++idCounter + "";
  return prefix ? prefix + id : id;
}
var idCounter;
var init_uniqueId = __esm({
  "node_modules/underscore/modules/uniqueId.js"() {
    idCounter = 0;
  }
});

// node_modules/underscore/modules/chain.js
function chain(obj2) {
  var instance = _(obj2);
  instance._chain = true;
  return instance;
}
var init_chain = __esm({
  "node_modules/underscore/modules/chain.js"() {
    init_underscore();
  }
});

// node_modules/underscore/modules/_executeBound.js
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject2(result2)) return result2;
  return self2;
}
var init_executeBound = __esm({
  "node_modules/underscore/modules/_executeBound.js"() {
    init_baseCreate();
    init_isObject();
  }
});

// node_modules/underscore/modules/partial.js
var partial, partial_default;
var init_partial = __esm({
  "node_modules/underscore/modules/partial.js"() {
    init_restArguments();
    init_executeBound();
    init_underscore();
    partial = restArguments(function(func, boundArgs) {
      var placeholder = partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        }
        while (position < arguments.length) args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });
    partial.placeholder = _;
    partial_default = partial;
  }
});

// node_modules/underscore/modules/bind.js
var bind_default;
var init_bind = __esm({
  "node_modules/underscore/modules/bind.js"() {
    init_restArguments();
    init_isFunction();
    init_executeBound();
    bind_default = restArguments(function(func, context, args) {
      if (!isFunction_default(func)) throw new TypeError("Bind must be called on a function");
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context, this, args.concat(callArgs));
      });
      return bound;
    });
  }
});

// node_modules/underscore/modules/_isArrayLike.js
var isArrayLike_default;
var init_isArrayLike = __esm({
  "node_modules/underscore/modules/_isArrayLike.js"() {
    init_createSizePropertyCheck();
    init_getLength();
    isArrayLike_default = createSizePropertyCheck(getLength_default);
  }
});

// node_modules/underscore/modules/_flatten.js
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = getLength_default(input); i < length; i++) {
    var value = input[i];
    if (isArrayLike_default(value) && (isArray_default(value) || isArguments_default(value))) {
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}
var init_flatten = __esm({
  "node_modules/underscore/modules/_flatten.js"() {
    init_getLength();
    init_isArrayLike();
    init_isArray();
    init_isArguments();
  }
});

// node_modules/underscore/modules/bindAll.js
var bindAll_default;
var init_bindAll = __esm({
  "node_modules/underscore/modules/bindAll.js"() {
    init_restArguments();
    init_flatten();
    init_bind();
    bindAll_default = restArguments(function(obj2, keys2) {
      keys2 = flatten(keys2, false, false);
      var index = keys2.length;
      if (index < 1) throw new Error("bindAll must be passed function names");
      while (index--) {
        var key = keys2[index];
        obj2[key] = bind_default(obj2[key], obj2);
      }
      return obj2;
    });
  }
});

// node_modules/underscore/modules/memoize.js
function memoize(func, hasher) {
  var memoize2 = function(key) {
    var cache = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize2.cache = {};
  return memoize2;
}
var init_memoize = __esm({
  "node_modules/underscore/modules/memoize.js"() {
    init_has();
  }
});

// node_modules/underscore/modules/delay.js
var delay_default;
var init_delay = __esm({
  "node_modules/underscore/modules/delay.js"() {
    init_restArguments();
    delay_default = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });
  }
});

// node_modules/underscore/modules/defer.js
var defer_default;
var init_defer = __esm({
  "node_modules/underscore/modules/defer.js"() {
    init_partial();
    init_delay();
    init_underscore();
    defer_default = partial_default(delay_default, _, 1);
  }
});

// node_modules/underscore/modules/throttle.js
function throttle(func, wait, options) {
  var timeout, context, args, result2;
  var previous = 0;
  if (!options) options = {};
  var later = function() {
    previous = options.leading === false ? 0 : now_default();
    timeout = null;
    result2 = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  var throttled = function() {
    var _now = now_default();
    if (!previous && options.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}
var init_throttle = __esm({
  "node_modules/underscore/modules/throttle.js"() {
    init_now();
  }
});

// node_modules/underscore/modules/debounce.js
function debounce(func, wait, immediate) {
  var timeout, previous, args, result2, context;
  var later = function() {
    var passed = now_default() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result2 = func.apply(context, args);
      if (!timeout) args = context = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now_default();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result2 = func.apply(context, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}
var init_debounce = __esm({
  "node_modules/underscore/modules/debounce.js"() {
    init_restArguments();
    init_now();
  }
});

// node_modules/underscore/modules/wrap.js
function wrap(func, wrapper) {
  return partial_default(wrapper, func);
}
var init_wrap = __esm({
  "node_modules/underscore/modules/wrap.js"() {
    init_partial();
  }
});

// node_modules/underscore/modules/negate.js
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
var init_negate = __esm({
  "node_modules/underscore/modules/negate.js"() {
  }
});

// node_modules/underscore/modules/compose.js
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result2 = args[start].apply(this, arguments);
    while (i--) result2 = args[i].call(this, result2);
    return result2;
  };
}
var init_compose = __esm({
  "node_modules/underscore/modules/compose.js"() {
  }
});

// node_modules/underscore/modules/after.js
function after(times2, func) {
  return function() {
    if (--times2 < 1) {
      return func.apply(this, arguments);
    }
  };
}
var init_after = __esm({
  "node_modules/underscore/modules/after.js"() {
  }
});

// node_modules/underscore/modules/before.js
function before(times2, func) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func.apply(this, arguments);
    }
    if (times2 <= 1) func = null;
    return memo;
  };
}
var init_before = __esm({
  "node_modules/underscore/modules/before.js"() {
  }
});

// node_modules/underscore/modules/once.js
var once_default;
var init_once = __esm({
  "node_modules/underscore/modules/once.js"() {
    init_partial();
    init_before();
    once_default = partial_default(before, 2);
  }
});

// node_modules/underscore/modules/findKey.js
function findKey(obj2, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj2), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj2[key], key, obj2)) return key;
  }
}
var init_findKey = __esm({
  "node_modules/underscore/modules/findKey.js"() {
    init_cb();
    init_keys();
  }
});

// node_modules/underscore/modules/_createPredicateIndexFinder.js
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength_default(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array)) return index;
    }
    return -1;
  };
}
var init_createPredicateIndexFinder = __esm({
  "node_modules/underscore/modules/_createPredicateIndexFinder.js"() {
    init_cb();
    init_getLength();
  }
});

// node_modules/underscore/modules/findIndex.js
var findIndex_default;
var init_findIndex = __esm({
  "node_modules/underscore/modules/findIndex.js"() {
    init_createPredicateIndexFinder();
    findIndex_default = createPredicateIndexFinder(1);
  }
});

// node_modules/underscore/modules/findLastIndex.js
var findLastIndex_default;
var init_findLastIndex = __esm({
  "node_modules/underscore/modules/findLastIndex.js"() {
    init_createPredicateIndexFinder();
    findLastIndex_default = createPredicateIndexFinder(-1);
  }
});

// node_modules/underscore/modules/sortedIndex.js
function sortedIndex(array, obj2, iteratee2, context) {
  iteratee2 = cb(iteratee2, context, 1);
  var value = iteratee2(obj2);
  var low = 0, high = getLength_default(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value) low = mid + 1;
    else high = mid;
  }
  return low;
}
var init_sortedIndex = __esm({
  "node_modules/underscore/modules/sortedIndex.js"() {
    init_cb();
    init_getLength();
  }
});

// node_modules/underscore/modules/_createIndexFinder.js
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i = 0, length = getLength_default(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i, length), isNaN2);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}
var init_createIndexFinder = __esm({
  "node_modules/underscore/modules/_createIndexFinder.js"() {
    init_getLength();
    init_setup();
    init_isNaN();
  }
});

// node_modules/underscore/modules/indexOf.js
var indexOf_default;
var init_indexOf = __esm({
  "node_modules/underscore/modules/indexOf.js"() {
    init_sortedIndex();
    init_findIndex();
    init_createIndexFinder();
    indexOf_default = createIndexFinder(1, findIndex_default, sortedIndex);
  }
});

// node_modules/underscore/modules/lastIndexOf.js
var lastIndexOf_default;
var init_lastIndexOf = __esm({
  "node_modules/underscore/modules/lastIndexOf.js"() {
    init_findLastIndex();
    init_createIndexFinder();
    lastIndexOf_default = createIndexFinder(-1, findLastIndex_default);
  }
});

// node_modules/underscore/modules/find.js
function find(obj2, predicate, context) {
  var keyFinder = isArrayLike_default(obj2) ? findIndex_default : findKey;
  var key = keyFinder(obj2, predicate, context);
  if (key !== void 0 && key !== -1) return obj2[key];
}
var init_find = __esm({
  "node_modules/underscore/modules/find.js"() {
    init_isArrayLike();
    init_findIndex();
    init_findKey();
  }
});

// node_modules/underscore/modules/findWhere.js
function findWhere(obj2, attrs) {
  return find(obj2, matcher(attrs));
}
var init_findWhere = __esm({
  "node_modules/underscore/modules/findWhere.js"() {
    init_find();
    init_matcher();
  }
});

// node_modules/underscore/modules/each.js
function each(obj2, iteratee2, context) {
  iteratee2 = optimizeCb(iteratee2, context);
  var i, length;
  if (isArrayLike_default(obj2)) {
    for (i = 0, length = obj2.length; i < length; i++) {
      iteratee2(obj2[i], i, obj2);
    }
  } else {
    var _keys = keys(obj2);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee2(obj2[_keys[i]], _keys[i], obj2);
    }
  }
  return obj2;
}
var init_each = __esm({
  "node_modules/underscore/modules/each.js"() {
    init_optimizeCb();
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/map.js
function map(obj2, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = !isArrayLike_default(obj2) && keys(obj2), length = (_keys || obj2).length, results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee2(obj2[currentKey], currentKey, obj2);
  }
  return results;
}
var init_map = __esm({
  "node_modules/underscore/modules/map.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/_createReduce.js
function createReduce(dir) {
  var reducer = function(obj2, iteratee2, memo, initial2) {
    var _keys = !isArrayLike_default(obj2) && keys(obj2), length = (_keys || obj2).length, index = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj2[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee2(memo, obj2[currentKey], currentKey, obj2);
    }
    return memo;
  };
  return function(obj2, iteratee2, memo, context) {
    var initial2 = arguments.length >= 3;
    return reducer(obj2, optimizeCb(iteratee2, context, 4), memo, initial2);
  };
}
var init_createReduce = __esm({
  "node_modules/underscore/modules/_createReduce.js"() {
    init_isArrayLike();
    init_keys();
    init_optimizeCb();
  }
});

// node_modules/underscore/modules/reduce.js
var reduce_default;
var init_reduce = __esm({
  "node_modules/underscore/modules/reduce.js"() {
    init_createReduce();
    reduce_default = createReduce(1);
  }
});

// node_modules/underscore/modules/reduceRight.js
var reduceRight_default;
var init_reduceRight = __esm({
  "node_modules/underscore/modules/reduceRight.js"() {
    init_createReduce();
    reduceRight_default = createReduce(-1);
  }
});

// node_modules/underscore/modules/filter.js
function filter(obj2, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj2, function(value, index, list) {
    if (predicate(value, index, list)) results.push(value);
  });
  return results;
}
var init_filter = __esm({
  "node_modules/underscore/modules/filter.js"() {
    init_cb();
    init_each();
  }
});

// node_modules/underscore/modules/reject.js
function reject(obj2, predicate, context) {
  return filter(obj2, negate(cb(predicate)), context);
}
var init_reject = __esm({
  "node_modules/underscore/modules/reject.js"() {
    init_filter();
    init_negate();
    init_cb();
  }
});

// node_modules/underscore/modules/every.js
function every(obj2, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj2) && keys(obj2), length = (_keys || obj2).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj2[currentKey], currentKey, obj2)) return false;
  }
  return true;
}
var init_every = __esm({
  "node_modules/underscore/modules/every.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/some.js
function some(obj2, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj2) && keys(obj2), length = (_keys || obj2).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj2[currentKey], currentKey, obj2)) return true;
  }
  return false;
}
var init_some = __esm({
  "node_modules/underscore/modules/some.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/contains.js
function contains(obj2, item, fromIndex, guard) {
  if (!isArrayLike_default(obj2)) obj2 = values(obj2);
  if (typeof fromIndex != "number" || guard) fromIndex = 0;
  return indexOf_default(obj2, item, fromIndex) >= 0;
}
var init_contains = __esm({
  "node_modules/underscore/modules/contains.js"() {
    init_isArrayLike();
    init_values();
    init_indexOf();
  }
});

// node_modules/underscore/modules/invoke.js
var invoke_default;
var init_invoke = __esm({
  "node_modules/underscore/modules/invoke.js"() {
    init_restArguments();
    init_isFunction();
    init_map();
    init_deepGet();
    init_toPath2();
    invoke_default = restArguments(function(obj2, path, args) {
      var contextPath, func;
      if (isFunction_default(path)) {
        func = path;
      } else {
        path = toPath2(path);
        contextPath = path.slice(0, -1);
        path = path[path.length - 1];
      }
      return map(obj2, function(context) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context = deepGet(context, contextPath);
          }
          if (context == null) return void 0;
          method = context[path];
        }
        return method == null ? method : method.apply(context, args);
      });
    });
  }
});

// node_modules/underscore/modules/pluck.js
function pluck(obj2, key) {
  return map(obj2, property(key));
}
var init_pluck = __esm({
  "node_modules/underscore/modules/pluck.js"() {
    init_map();
    init_property();
  }
});

// node_modules/underscore/modules/where.js
function where(obj2, attrs) {
  return filter(obj2, matcher(attrs));
}
var init_where = __esm({
  "node_modules/underscore/modules/where.js"() {
    init_filter();
    init_matcher();
  }
});

// node_modules/underscore/modules/max.js
function max(obj2, iteratee2, context) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj2[0] != "object" && obj2 != null) {
    obj2 = isArrayLike_default(obj2) ? obj2 : values(obj2);
    for (var i = 0, length = obj2.length; i < length; i++) {
      value = obj2[i];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj2, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_max = __esm({
  "node_modules/underscore/modules/max.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// node_modules/underscore/modules/min.js
function min(obj2, iteratee2, context) {
  var result2 = Infinity, lastComputed = Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj2[0] != "object" && obj2 != null) {
    obj2 = isArrayLike_default(obj2) ? obj2 : values(obj2);
    for (var i = 0, length = obj2.length; i < length; i++) {
      value = obj2[i];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj2, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_min = __esm({
  "node_modules/underscore/modules/min.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// node_modules/underscore/modules/toArray.js
function toArray(obj2) {
  if (!obj2) return [];
  if (isArray_default(obj2)) return slice.call(obj2);
  if (isString_default(obj2)) {
    return obj2.match(reStrSymbol);
  }
  if (isArrayLike_default(obj2)) return map(obj2, identity);
  return values(obj2);
}
var reStrSymbol;
var init_toArray = __esm({
  "node_modules/underscore/modules/toArray.js"() {
    init_isArray();
    init_setup();
    init_isString();
    init_isArrayLike();
    init_map();
    init_identity();
    init_values();
    reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  }
});

// node_modules/underscore/modules/sample.js
function sample(obj2, n, guard) {
  if (n == null || guard) {
    if (!isArrayLike_default(obj2)) obj2 = values(obj2);
    return obj2[random(obj2.length - 1)];
  }
  var sample2 = toArray(obj2);
  var length = getLength_default(sample2);
  n = Math.max(Math.min(n, length), 0);
  var last2 = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = random(index, last2);
    var temp = sample2[index];
    sample2[index] = sample2[rand];
    sample2[rand] = temp;
  }
  return sample2.slice(0, n);
}
var init_sample = __esm({
  "node_modules/underscore/modules/sample.js"() {
    init_isArrayLike();
    init_values();
    init_getLength();
    init_random();
    init_toArray();
  }
});

// node_modules/underscore/modules/shuffle.js
function shuffle(obj2) {
  return sample(obj2, Infinity);
}
var init_shuffle = __esm({
  "node_modules/underscore/modules/shuffle.js"() {
    init_sample();
  }
});

// node_modules/underscore/modules/sortBy.js
function sortBy(obj2, iteratee2, context) {
  var index = 0;
  iteratee2 = cb(iteratee2, context);
  return pluck(map(obj2, function(value, key, list) {
    return {
      value,
      index: index++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0) return 1;
      if (a < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), "value");
}
var init_sortBy = __esm({
  "node_modules/underscore/modules/sortBy.js"() {
    init_cb();
    init_pluck();
    init_map();
  }
});

// node_modules/underscore/modules/_group.js
function group(behavior, partition) {
  return function(obj2, iteratee2, context) {
    var result2 = partition ? [[], []] : {};
    iteratee2 = cb(iteratee2, context);
    each(obj2, function(value, index) {
      var key = iteratee2(value, index, obj2);
      behavior(result2, value, key);
    });
    return result2;
  };
}
var init_group = __esm({
  "node_modules/underscore/modules/_group.js"() {
    init_cb();
    init_each();
  }
});

// node_modules/underscore/modules/groupBy.js
var groupBy_default;
var init_groupBy = __esm({
  "node_modules/underscore/modules/groupBy.js"() {
    init_group();
    init_has();
    groupBy_default = group(function(result2, value, key) {
      if (has(result2, key)) result2[key].push(value);
      else result2[key] = [value];
    });
  }
});

// node_modules/underscore/modules/indexBy.js
var indexBy_default;
var init_indexBy = __esm({
  "node_modules/underscore/modules/indexBy.js"() {
    init_group();
    indexBy_default = group(function(result2, value, key) {
      result2[key] = value;
    });
  }
});

// node_modules/underscore/modules/countBy.js
var countBy_default;
var init_countBy = __esm({
  "node_modules/underscore/modules/countBy.js"() {
    init_group();
    init_has();
    countBy_default = group(function(result2, value, key) {
      if (has(result2, key)) result2[key]++;
      else result2[key] = 1;
    });
  }
});

// node_modules/underscore/modules/partition.js
var partition_default;
var init_partition = __esm({
  "node_modules/underscore/modules/partition.js"() {
    init_group();
    partition_default = group(function(result2, value, pass) {
      result2[pass ? 0 : 1].push(value);
    }, true);
  }
});

// node_modules/underscore/modules/size.js
function size(obj2) {
  if (obj2 == null) return 0;
  return isArrayLike_default(obj2) ? obj2.length : keys(obj2).length;
}
var init_size = __esm({
  "node_modules/underscore/modules/size.js"() {
    init_isArrayLike();
    init_keys();
  }
});

// node_modules/underscore/modules/_keyInObj.js
function keyInObj(value, key, obj2) {
  return key in obj2;
}
var init_keyInObj = __esm({
  "node_modules/underscore/modules/_keyInObj.js"() {
  }
});

// node_modules/underscore/modules/pick.js
var pick_default;
var init_pick = __esm({
  "node_modules/underscore/modules/pick.js"() {
    init_restArguments();
    init_isFunction();
    init_optimizeCb();
    init_allKeys();
    init_keyInObj();
    init_flatten();
    pick_default = restArguments(function(obj2, keys2) {
      var result2 = {}, iteratee2 = keys2[0];
      if (obj2 == null) return result2;
      if (isFunction_default(iteratee2)) {
        if (keys2.length > 1) iteratee2 = optimizeCb(iteratee2, keys2[1]);
        keys2 = allKeys(obj2);
      } else {
        iteratee2 = keyInObj;
        keys2 = flatten(keys2, false, false);
        obj2 = Object(obj2);
      }
      for (var i = 0, length = keys2.length; i < length; i++) {
        var key = keys2[i];
        var value = obj2[key];
        if (iteratee2(value, key, obj2)) result2[key] = value;
      }
      return result2;
    });
  }
});

// node_modules/underscore/modules/omit.js
var omit_default;
var init_omit = __esm({
  "node_modules/underscore/modules/omit.js"() {
    init_restArguments();
    init_isFunction();
    init_negate();
    init_map();
    init_flatten();
    init_contains();
    init_pick();
    omit_default = restArguments(function(obj2, keys2) {
      var iteratee2 = keys2[0], context;
      if (isFunction_default(iteratee2)) {
        iteratee2 = negate(iteratee2);
        if (keys2.length > 1) context = keys2[1];
      } else {
        keys2 = map(flatten(keys2, false, false), String);
        iteratee2 = function(value, key) {
          return !contains(keys2, key);
        };
      }
      return pick_default(obj2, iteratee2, context);
    });
  }
});

// node_modules/underscore/modules/initial.js
function initial(array, n, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}
var init_initial = __esm({
  "node_modules/underscore/modules/initial.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/first.js
function first(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[0];
  return initial(array, array.length - n);
}
var init_first = __esm({
  "node_modules/underscore/modules/first.js"() {
    init_initial();
  }
});

// node_modules/underscore/modules/rest.js
function rest(array, n, guard) {
  return slice.call(array, n == null || guard ? 1 : n);
}
var init_rest = __esm({
  "node_modules/underscore/modules/rest.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/last.js
function last(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n));
}
var init_last = __esm({
  "node_modules/underscore/modules/last.js"() {
    init_rest();
  }
});

// node_modules/underscore/modules/compact.js
function compact(array) {
  return filter(array, Boolean);
}
var init_compact = __esm({
  "node_modules/underscore/modules/compact.js"() {
    init_filter();
  }
});

// node_modules/underscore/modules/flatten.js
function flatten2(array, depth) {
  return flatten(array, depth, false);
}
var init_flatten2 = __esm({
  "node_modules/underscore/modules/flatten.js"() {
    init_flatten();
  }
});

// node_modules/underscore/modules/difference.js
var difference_default;
var init_difference = __esm({
  "node_modules/underscore/modules/difference.js"() {
    init_restArguments();
    init_flatten();
    init_filter();
    init_contains();
    difference_default = restArguments(function(array, rest2) {
      rest2 = flatten(rest2, true, true);
      return filter(array, function(value) {
        return !contains(rest2, value);
      });
    });
  }
});

// node_modules/underscore/modules/without.js
var without_default;
var init_without = __esm({
  "node_modules/underscore/modules/without.js"() {
    init_restArguments();
    init_difference();
    without_default = restArguments(function(array, otherArrays) {
      return difference_default(array, otherArrays);
    });
  }
});

// node_modules/underscore/modules/uniq.js
function uniq(array, isSorted, iteratee2, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null) iteratee2 = cb(iteratee2, context);
  var result2 = [];
  var seen = [];
  for (var i = 0, length = getLength_default(array); i < length; i++) {
    var value = array[i], computed = iteratee2 ? iteratee2(value, i, array) : value;
    if (isSorted && !iteratee2) {
      if (!i || seen !== computed) result2.push(value);
      seen = computed;
    } else if (iteratee2) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}
var init_uniq = __esm({
  "node_modules/underscore/modules/uniq.js"() {
    init_isBoolean();
    init_cb();
    init_getLength();
    init_contains();
  }
});

// node_modules/underscore/modules/union.js
var union_default;
var init_union = __esm({
  "node_modules/underscore/modules/union.js"() {
    init_restArguments();
    init_uniq();
    init_flatten();
    union_default = restArguments(function(arrays) {
      return uniq(flatten(arrays, true, true));
    });
  }
});

// node_modules/underscore/modules/intersection.js
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i = 0, length = getLength_default(array); i < length; i++) {
    var item = array[i];
    if (contains(result2, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item)) break;
    }
    if (j === argsLength) result2.push(item);
  }
  return result2;
}
var init_intersection = __esm({
  "node_modules/underscore/modules/intersection.js"() {
    init_getLength();
    init_contains();
  }
});

// node_modules/underscore/modules/unzip.js
function unzip(array) {
  var length = array && max(array, getLength_default).length || 0;
  var result2 = Array(length);
  for (var index = 0; index < length; index++) {
    result2[index] = pluck(array, index);
  }
  return result2;
}
var init_unzip = __esm({
  "node_modules/underscore/modules/unzip.js"() {
    init_max();
    init_getLength();
    init_pluck();
  }
});

// node_modules/underscore/modules/zip.js
var zip_default;
var init_zip = __esm({
  "node_modules/underscore/modules/zip.js"() {
    init_restArguments();
    init_unzip();
    zip_default = restArguments(unzip);
  }
});

// node_modules/underscore/modules/object.js
function object(list, values2) {
  var result2 = {};
  for (var i = 0, length = getLength_default(list); i < length; i++) {
    if (values2) {
      result2[list[i]] = values2[i];
    } else {
      result2[list[i][0]] = list[i][1];
    }
  }
  return result2;
}
var init_object = __esm({
  "node_modules/underscore/modules/object.js"() {
    init_getLength();
  }
});

// node_modules/underscore/modules/range.js
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range2 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range2[idx] = start;
  }
  return range2;
}
var init_range = __esm({
  "node_modules/underscore/modules/range.js"() {
  }
});

// node_modules/underscore/modules/chunk.js
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result2 = [];
  var i = 0, length = array.length;
  while (i < length) {
    result2.push(slice.call(array, i, i += count));
  }
  return result2;
}
var init_chunk = __esm({
  "node_modules/underscore/modules/chunk.js"() {
    init_setup();
  }
});

// node_modules/underscore/modules/_chainResult.js
function chainResult(instance, obj2) {
  return instance._chain ? _(obj2).chain() : obj2;
}
var init_chainResult = __esm({
  "node_modules/underscore/modules/_chainResult.js"() {
    init_underscore();
  }
});

// node_modules/underscore/modules/mixin.js
function mixin(obj2) {
  each(functions(obj2), function(name) {
    var func = _[name] = obj2[name];
    _.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_, args));
    };
  });
  return _;
}
var init_mixin = __esm({
  "node_modules/underscore/modules/mixin.js"() {
    init_underscore();
    init_each();
    init_functions();
    init_setup();
    init_chainResult();
  }
});

// node_modules/underscore/modules/underscore-array-methods.js
var underscore_array_methods_default;
var init_underscore_array_methods = __esm({
  "node_modules/underscore/modules/underscore-array-methods.js"() {
    init_underscore();
    init_each();
    init_setup();
    init_chainResult();
    each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj2 = this._wrapped;
        if (obj2 != null) {
          method.apply(obj2, arguments);
          if ((name === "shift" || name === "splice") && obj2.length === 0) {
            delete obj2[0];
          }
        }
        return chainResult(this, obj2);
      };
    });
    each(["concat", "join", "slice"], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj2 = this._wrapped;
        if (obj2 != null) obj2 = method.apply(obj2, arguments);
        return chainResult(this, obj2);
      };
    });
    underscore_array_methods_default = _;
  }
});

// node_modules/underscore/modules/index.js
var modules_exports = {};
__export(modules_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every,
  allKeys: () => allKeys,
  any: () => some,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => underscore_array_methods_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each,
  escape: () => escape_default,
  every: () => every,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject2,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_modules = __esm({
  "node_modules/underscore/modules/index.js"() {
    init_setup();
    init_restArguments();
    init_isObject();
    init_isNull();
    init_isUndefined();
    init_isBoolean();
    init_isElement();
    init_isString();
    init_isNumber();
    init_isDate();
    init_isRegExp();
    init_isError();
    init_isSymbol();
    init_isArrayBuffer();
    init_isDataView();
    init_isArray();
    init_isFunction();
    init_isArguments();
    init_isFinite();
    init_isNaN();
    init_isTypedArray();
    init_isEmpty();
    init_isMatch();
    init_isEqual();
    init_isMap();
    init_isWeakMap();
    init_isSet();
    init_isWeakSet();
    init_keys();
    init_allKeys();
    init_values();
    init_pairs();
    init_invert();
    init_functions();
    init_extend();
    init_extendOwn();
    init_defaults();
    init_create();
    init_clone();
    init_tap();
    init_get();
    init_has2();
    init_mapObject();
    init_identity();
    init_constant();
    init_noop();
    init_toPath();
    init_property();
    init_propertyOf();
    init_matcher();
    init_times();
    init_random();
    init_now();
    init_escape();
    init_unescape();
    init_templateSettings();
    init_template();
    init_result();
    init_uniqueId();
    init_chain();
    init_iteratee();
    init_partial();
    init_bind();
    init_bindAll();
    init_memoize();
    init_delay();
    init_defer();
    init_throttle();
    init_debounce();
    init_wrap();
    init_negate();
    init_compose();
    init_after();
    init_before();
    init_once();
    init_findKey();
    init_findIndex();
    init_findLastIndex();
    init_sortedIndex();
    init_indexOf();
    init_lastIndexOf();
    init_find();
    init_findWhere();
    init_each();
    init_map();
    init_reduce();
    init_reduceRight();
    init_filter();
    init_reject();
    init_every();
    init_some();
    init_contains();
    init_invoke();
    init_pluck();
    init_where();
    init_max();
    init_min();
    init_shuffle();
    init_sample();
    init_sortBy();
    init_groupBy();
    init_indexBy();
    init_countBy();
    init_partition();
    init_toArray();
    init_size();
    init_pick();
    init_omit();
    init_first();
    init_initial();
    init_last();
    init_rest();
    init_compact();
    init_flatten2();
    init_without();
    init_uniq();
    init_union();
    init_intersection();
    init_difference();
    init_unzip();
    init_zip();
    init_object();
    init_range();
    init_chunk();
    init_mixin();
    init_underscore_array_methods();
  }
});

// node_modules/underscore/modules/index-default.js
var _2, index_default_default;
var init_index_default = __esm({
  "node_modules/underscore/modules/index-default.js"() {
    init_modules();
    init_modules();
    _2 = mixin(modules_exports);
    _2._ = _2;
    index_default_default = _2;
  }
});

// node_modules/underscore/modules/index-all.js
var index_all_exports = {};
__export(index_all_exports, {
  VERSION: () => VERSION,
  after: () => after,
  all: () => every,
  allKeys: () => allKeys,
  any: () => some,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => index_default_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each,
  escape: () => escape_default,
  every: () => every,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject2,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_index_all = __esm({
  "node_modules/underscore/modules/index-all.js"() {
    init_index_default();
    init_modules();
  }
});

// node_modules/bluebird/js/release/es5.js
var require_es5 = __commonJS({
  "node_modules/bluebird/js/release/es5.js"(exports2, module2) {
    var isES5 = (function() {
      "use strict";
      return this === void 0;
    })();
    if (isES5) {
      module2.exports = {
        freeze: Object.freeze,
        defineProperty: Object.defineProperty,
        getDescriptor: Object.getOwnPropertyDescriptor,
        keys: Object.keys,
        names: Object.getOwnPropertyNames,
        getPrototypeOf: Object.getPrototypeOf,
        isArray: Array.isArray,
        isES5,
        propertyIsWritable: function(obj2, prop) {
          var descriptor = Object.getOwnPropertyDescriptor(obj2, prop);
          return !!(!descriptor || descriptor.writable || descriptor.set);
        }
      };
    } else {
      has3 = {}.hasOwnProperty;
      str = {}.toString;
      proto = {}.constructor.prototype;
      ObjectKeys = function(o) {
        var ret2 = [];
        for (var key in o) {
          if (has3.call(o, key)) {
            ret2.push(key);
          }
        }
        return ret2;
      };
      ObjectGetDescriptor = function(o, key) {
        return { value: o[key] };
      };
      ObjectDefineProperty = function(o, key, desc) {
        o[key] = desc.value;
        return o;
      };
      ObjectFreeze = function(obj2) {
        return obj2;
      };
      ObjectGetPrototypeOf = function(obj2) {
        try {
          return Object(obj2).constructor.prototype;
        } catch (e) {
          return proto;
        }
      };
      ArrayIsArray = function(obj2) {
        try {
          return str.call(obj2) === "[object Array]";
        } catch (e) {
          return false;
        }
      };
      module2.exports = {
        isArray: ArrayIsArray,
        keys: ObjectKeys,
        names: ObjectKeys,
        defineProperty: ObjectDefineProperty,
        getDescriptor: ObjectGetDescriptor,
        freeze: ObjectFreeze,
        getPrototypeOf: ObjectGetPrototypeOf,
        isES5,
        propertyIsWritable: function() {
          return true;
        }
      };
    }
    var has3;
    var str;
    var proto;
    var ObjectKeys;
    var ObjectGetDescriptor;
    var ObjectDefineProperty;
    var ObjectFreeze;
    var ObjectGetPrototypeOf;
    var ArrayIsArray;
  }
});

// node_modules/bluebird/js/release/util.js
var require_util = __commonJS({
  "node_modules/bluebird/js/release/util.js"(exports, module) {
    "use strict";
    var es5 = require_es5();
    var canEvaluate = typeof navigator == "undefined";
    var errorObj = { e: {} };
    var tryCatchTarget;
    var globalObject = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports !== void 0 ? exports : null;
    function tryCatcher() {
      try {
        var target = tryCatchTarget;
        tryCatchTarget = null;
        return target.apply(this, arguments);
      } catch (e) {
        errorObj.e = e;
        return errorObj;
      }
    }
    function tryCatch(fn) {
      tryCatchTarget = fn;
      return tryCatcher;
    }
    var inherits = function(Child, Parent) {
      var hasProp = {}.hasOwnProperty;
      function T() {
        this.constructor = Child;
        this.constructor$ = Parent;
        for (var propertyName in Parent.prototype) {
          if (hasProp.call(Parent.prototype, propertyName) && propertyName.charAt(propertyName.length - 1) !== "$") {
            this[propertyName + "$"] = Parent.prototype[propertyName];
          }
        }
      }
      T.prototype = Parent.prototype;
      Child.prototype = new T();
      return Child.prototype;
    };
    function isPrimitive(val) {
      return val == null || val === true || val === false || typeof val === "string" || typeof val === "number";
    }
    function isObject(value) {
      return typeof value === "function" || typeof value === "object" && value !== null;
    }
    function maybeWrapAsError(maybeError) {
      if (!isPrimitive(maybeError)) return maybeError;
      return new Error(safeToString(maybeError));
    }
    function withAppended(target, appendee) {
      var len = target.length;
      var ret2 = new Array(len + 1);
      var i;
      for (i = 0; i < len; ++i) {
        ret2[i] = target[i];
      }
      ret2[i] = appendee;
      return ret2;
    }
    function getDataPropertyOrDefault(obj2, key, defaultValue) {
      if (es5.isES5) {
        var desc = Object.getOwnPropertyDescriptor(obj2, key);
        if (desc != null) {
          return desc.get == null && desc.set == null ? desc.value : defaultValue;
        }
      } else {
        return {}.hasOwnProperty.call(obj2, key) ? obj2[key] : void 0;
      }
    }
    function notEnumerableProp(obj2, name, value) {
      if (isPrimitive(obj2)) return obj2;
      var descriptor = {
        value,
        configurable: true,
        enumerable: false,
        writable: true
      };
      es5.defineProperty(obj2, name, descriptor);
      return obj2;
    }
    function thrower(r) {
      throw r;
    }
    var inheritedDataKeys = (function() {
      var excludedPrototypes = [
        Array.prototype,
        Object.prototype,
        Function.prototype
      ];
      var isExcludedProto = function(val) {
        for (var i = 0; i < excludedPrototypes.length; ++i) {
          if (excludedPrototypes[i] === val) {
            return true;
          }
        }
        return false;
      };
      if (es5.isES5) {
        var getKeys = Object.getOwnPropertyNames;
        return function(obj2) {
          var ret2 = [];
          var visitedKeys = /* @__PURE__ */ Object.create(null);
          while (obj2 != null && !isExcludedProto(obj2)) {
            var keys2;
            try {
              keys2 = getKeys(obj2);
            } catch (e) {
              return ret2;
            }
            for (var i = 0; i < keys2.length; ++i) {
              var key = keys2[i];
              if (visitedKeys[key]) continue;
              visitedKeys[key] = true;
              var desc = Object.getOwnPropertyDescriptor(obj2, key);
              if (desc != null && desc.get == null && desc.set == null) {
                ret2.push(key);
              }
            }
            obj2 = es5.getPrototypeOf(obj2);
          }
          return ret2;
        };
      } else {
        var hasProp = {}.hasOwnProperty;
        return function(obj2) {
          if (isExcludedProto(obj2)) return [];
          var ret2 = [];
          enumeration: for (var key in obj2) {
            if (hasProp.call(obj2, key)) {
              ret2.push(key);
            } else {
              for (var i = 0; i < excludedPrototypes.length; ++i) {
                if (hasProp.call(excludedPrototypes[i], key)) {
                  continue enumeration;
                }
              }
              ret2.push(key);
            }
          }
          return ret2;
        };
      }
    })();
    var thisAssignmentPattern = /this\s*\.\s*\S+\s*=/;
    function isClass(fn) {
      try {
        if (typeof fn === "function") {
          var keys2 = es5.names(fn.prototype);
          var hasMethods = es5.isES5 && keys2.length > 1;
          var hasMethodsOtherThanConstructor = keys2.length > 0 && !(keys2.length === 1 && keys2[0] === "constructor");
          var hasThisAssignmentAndStaticMethods = thisAssignmentPattern.test(fn + "") && es5.names(fn).length > 0;
          if (hasMethods || hasMethodsOtherThanConstructor || hasThisAssignmentAndStaticMethods) {
            return true;
          }
        }
        return false;
      } catch (e) {
        return false;
      }
    }
    function toFastProperties(obj) {
      function FakeConstructor() {
      }
      FakeConstructor.prototype = obj;
      var l = 8;
      while (l--) new FakeConstructor();
      return obj;
      eval(obj);
    }
    var rident = /^[a-z$_][a-z$_0-9]*$/i;
    function isIdentifier(str) {
      return rident.test(str);
    }
    function filledRange(count, prefix, suffix) {
      var ret2 = new Array(count);
      for (var i = 0; i < count; ++i) {
        ret2[i] = prefix + i + suffix;
      }
      return ret2;
    }
    function safeToString(obj2) {
      try {
        return obj2 + "";
      } catch (e) {
        return "[no string representation]";
      }
    }
    function isError(obj2) {
      return obj2 !== null && typeof obj2 === "object" && typeof obj2.message === "string" && typeof obj2.name === "string";
    }
    function markAsOriginatingFromRejection(e) {
      try {
        notEnumerableProp(e, "isOperational", true);
      } catch (ignore) {
      }
    }
    function originatesFromRejection(e) {
      if (e == null) return false;
      return e instanceof Error["__BluebirdErrorTypes__"].OperationalError || e["isOperational"] === true;
    }
    function canAttachTrace(obj2) {
      return isError(obj2) && es5.propertyIsWritable(obj2, "stack");
    }
    var ensureErrorObject = (function() {
      if (!("stack" in new Error())) {
        return function(value) {
          if (canAttachTrace(value)) return value;
          try {
            throw new Error(safeToString(value));
          } catch (err) {
            return err;
          }
        };
      } else {
        return function(value) {
          if (canAttachTrace(value)) return value;
          return new Error(safeToString(value));
        };
      }
    })();
    function classString(obj2) {
      return {}.toString.call(obj2);
    }
    function copyDescriptors(from, to, filter2) {
      var keys2 = es5.names(from);
      for (var i = 0; i < keys2.length; ++i) {
        var key = keys2[i];
        if (filter2(key)) {
          try {
            es5.defineProperty(to, key, es5.getDescriptor(from, key));
          } catch (ignore) {
          }
        }
      }
    }
    var asArray = function(v) {
      if (es5.isArray(v)) {
        return v;
      }
      return null;
    };
    if (typeof Symbol !== "undefined" && Symbol.iterator) {
      ArrayFrom = typeof Array.from === "function" ? function(v) {
        return Array.from(v);
      } : function(v) {
        var ret2 = [];
        var it = v[Symbol.iterator]();
        var itResult;
        while (!(itResult = it.next()).done) {
          ret2.push(itResult.value);
        }
        return ret2;
      };
      asArray = function(v) {
        if (es5.isArray(v)) {
          return v;
        } else if (v != null && typeof v[Symbol.iterator] === "function") {
          return ArrayFrom(v);
        }
        return null;
      };
    }
    var ArrayFrom;
    var isNode = typeof process !== "undefined" && classString(process).toLowerCase() === "[object process]";
    var hasEnvVariables = typeof process !== "undefined" && typeof process.env !== "undefined";
    function env(key) {
      return hasEnvVariables ? process.env[key] : void 0;
    }
    function getNativePromise() {
      if (typeof Promise === "function") {
        try {
          var promise = new Promise(function() {
          });
          if ({}.toString.call(promise) === "[object Promise]") {
            return Promise;
          }
        } catch (e) {
        }
      }
    }
    function domainBind(self2, cb2) {
      return self2.bind(cb2);
    }
    var ret = {
      isClass,
      isIdentifier,
      inheritedDataKeys,
      getDataPropertyOrDefault,
      thrower,
      isArray: es5.isArray,
      asArray,
      notEnumerableProp,
      isPrimitive,
      isObject,
      isError,
      canEvaluate,
      errorObj,
      tryCatch,
      inherits,
      withAppended,
      maybeWrapAsError,
      toFastProperties,
      filledRange,
      toString: safeToString,
      canAttachTrace,
      ensureErrorObject,
      originatesFromRejection,
      markAsOriginatingFromRejection,
      classString,
      copyDescriptors,
      hasDevTools: typeof chrome !== "undefined" && chrome && typeof chrome.loadTimes === "function",
      isNode,
      hasEnvVariables,
      env,
      global: globalObject,
      getNativePromise,
      domainBind
    };
    ret.isRecentNode = ret.isNode && (function() {
      var version2 = process.versions.node.split(".").map(Number);
      return version2[0] === 0 && version2[1] > 10 || version2[0] > 0;
    })();
    if (ret.isNode) ret.toFastProperties(process);
    try {
      throw new Error();
    } catch (e) {
      ret.lastLineError = e;
    }
    module.exports = ret;
  }
});

// node_modules/bluebird/js/release/schedule.js
var require_schedule = __commonJS({
  "node_modules/bluebird/js/release/schedule.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var schedule;
    var noAsyncScheduler = function() {
      throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
    };
    var NativePromise = util.getNativePromise();
    if (util.isNode && typeof MutationObserver === "undefined") {
      GlobalSetImmediate = global.setImmediate;
      ProcessNextTick = process.nextTick;
      schedule = util.isRecentNode ? function(fn) {
        GlobalSetImmediate.call(global, fn);
      } : function(fn) {
        ProcessNextTick.call(process, fn);
      };
    } else if (typeof NativePromise === "function" && typeof NativePromise.resolve === "function") {
      nativePromise = NativePromise.resolve();
      schedule = function(fn) {
        nativePromise.then(fn);
      };
    } else if (typeof MutationObserver !== "undefined" && !(typeof window !== "undefined" && window.navigator && (window.navigator.standalone || window.cordova))) {
      schedule = (function() {
        var div = document.createElement("div");
        var opts = { attributes: true };
        var toggleScheduled = false;
        var div2 = document.createElement("div");
        var o2 = new MutationObserver(function() {
          div.classList.toggle("foo");
          toggleScheduled = false;
        });
        o2.observe(div2, opts);
        var scheduleToggle = function() {
          if (toggleScheduled) return;
          toggleScheduled = true;
          div2.classList.toggle("foo");
        };
        return function schedule2(fn) {
          var o = new MutationObserver(function() {
            o.disconnect();
            fn();
          });
          o.observe(div, opts);
          scheduleToggle();
        };
      })();
    } else if (typeof setImmediate !== "undefined") {
      schedule = function(fn) {
        setImmediate(fn);
      };
    } else if (typeof setTimeout !== "undefined") {
      schedule = function(fn) {
        setTimeout(fn, 0);
      };
    } else {
      schedule = noAsyncScheduler;
    }
    var GlobalSetImmediate;
    var ProcessNextTick;
    var nativePromise;
    module2.exports = schedule;
  }
});

// node_modules/bluebird/js/release/queue.js
var require_queue = __commonJS({
  "node_modules/bluebird/js/release/queue.js"(exports2, module2) {
    "use strict";
    function arrayMove(src, srcIndex, dst, dstIndex, len) {
      for (var j = 0; j < len; ++j) {
        dst[j + dstIndex] = src[j + srcIndex];
        src[j + srcIndex] = void 0;
      }
    }
    function Queue(capacity) {
      this._capacity = capacity;
      this._length = 0;
      this._front = 0;
    }
    Queue.prototype._willBeOverCapacity = function(size2) {
      return this._capacity < size2;
    };
    Queue.prototype._pushOne = function(arg) {
      var length = this.length();
      this._checkCapacity(length + 1);
      var i = this._front + length & this._capacity - 1;
      this[i] = arg;
      this._length = length + 1;
    };
    Queue.prototype.push = function(fn, receiver, arg) {
      var length = this.length() + 3;
      if (this._willBeOverCapacity(length)) {
        this._pushOne(fn);
        this._pushOne(receiver);
        this._pushOne(arg);
        return;
      }
      var j = this._front + length - 3;
      this._checkCapacity(length);
      var wrapMask = this._capacity - 1;
      this[j + 0 & wrapMask] = fn;
      this[j + 1 & wrapMask] = receiver;
      this[j + 2 & wrapMask] = arg;
      this._length = length;
    };
    Queue.prototype.shift = function() {
      var front = this._front, ret2 = this[front];
      this[front] = void 0;
      this._front = front + 1 & this._capacity - 1;
      this._length--;
      return ret2;
    };
    Queue.prototype.length = function() {
      return this._length;
    };
    Queue.prototype._checkCapacity = function(size2) {
      if (this._capacity < size2) {
        this._resizeTo(this._capacity << 1);
      }
    };
    Queue.prototype._resizeTo = function(capacity) {
      var oldCapacity = this._capacity;
      this._capacity = capacity;
      var front = this._front;
      var length = this._length;
      var moveItemsCount = front + length & oldCapacity - 1;
      arrayMove(this, 0, this, oldCapacity, moveItemsCount);
    };
    module2.exports = Queue;
  }
});

// node_modules/bluebird/js/release/async.js
var require_async = __commonJS({
  "node_modules/bluebird/js/release/async.js"(exports2, module2) {
    "use strict";
    var firstLineError;
    try {
      throw new Error();
    } catch (e) {
      firstLineError = e;
    }
    var schedule = require_schedule();
    var Queue = require_queue();
    var util = require_util();
    function Async() {
      this._customScheduler = false;
      this._isTickUsed = false;
      this._lateQueue = new Queue(16);
      this._normalQueue = new Queue(16);
      this._haveDrainedQueues = false;
      this._trampolineEnabled = true;
      var self2 = this;
      this.drainQueues = function() {
        self2._drainQueues();
      };
      this._schedule = schedule;
    }
    Async.prototype.setScheduler = function(fn) {
      var prev = this._schedule;
      this._schedule = fn;
      this._customScheduler = true;
      return prev;
    };
    Async.prototype.hasCustomScheduler = function() {
      return this._customScheduler;
    };
    Async.prototype.enableTrampoline = function() {
      this._trampolineEnabled = true;
    };
    Async.prototype.disableTrampolineIfNecessary = function() {
      if (util.hasDevTools) {
        this._trampolineEnabled = false;
      }
    };
    Async.prototype.haveItemsQueued = function() {
      return this._isTickUsed || this._haveDrainedQueues;
    };
    Async.prototype.fatalError = function(e, isNode2) {
      if (isNode2) {
        process.stderr.write("Fatal " + (e instanceof Error ? e.stack : e) + "\n");
        process.exit(2);
      } else {
        this.throwLater(e);
      }
    };
    Async.prototype.throwLater = function(fn, arg) {
      if (arguments.length === 1) {
        arg = fn;
        fn = function() {
          throw arg;
        };
      }
      if (typeof setTimeout !== "undefined") {
        setTimeout(function() {
          fn(arg);
        }, 0);
      } else try {
        this._schedule(function() {
          fn(arg);
        });
      } catch (e) {
        throw new Error("No async scheduler available\n\n    See http://goo.gl/MqrFmX\n");
      }
    };
    function AsyncInvokeLater(fn, receiver, arg) {
      this._lateQueue.push(fn, receiver, arg);
      this._queueTick();
    }
    function AsyncInvoke(fn, receiver, arg) {
      this._normalQueue.push(fn, receiver, arg);
      this._queueTick();
    }
    function AsyncSettlePromises(promise) {
      this._normalQueue._pushOne(promise);
      this._queueTick();
    }
    if (!util.hasDevTools) {
      Async.prototype.invokeLater = AsyncInvokeLater;
      Async.prototype.invoke = AsyncInvoke;
      Async.prototype.settlePromises = AsyncSettlePromises;
    } else {
      Async.prototype.invokeLater = function(fn, receiver, arg) {
        if (this._trampolineEnabled) {
          AsyncInvokeLater.call(this, fn, receiver, arg);
        } else {
          this._schedule(function() {
            setTimeout(function() {
              fn.call(receiver, arg);
            }, 100);
          });
        }
      };
      Async.prototype.invoke = function(fn, receiver, arg) {
        if (this._trampolineEnabled) {
          AsyncInvoke.call(this, fn, receiver, arg);
        } else {
          this._schedule(function() {
            fn.call(receiver, arg);
          });
        }
      };
      Async.prototype.settlePromises = function(promise) {
        if (this._trampolineEnabled) {
          AsyncSettlePromises.call(this, promise);
        } else {
          this._schedule(function() {
            promise._settlePromises();
          });
        }
      };
    }
    Async.prototype._drainQueue = function(queue2) {
      while (queue2.length() > 0) {
        var fn = queue2.shift();
        if (typeof fn !== "function") {
          fn._settlePromises();
          continue;
        }
        var receiver = queue2.shift();
        var arg = queue2.shift();
        fn.call(receiver, arg);
      }
    };
    Async.prototype._drainQueues = function() {
      this._drainQueue(this._normalQueue);
      this._reset();
      this._haveDrainedQueues = true;
      this._drainQueue(this._lateQueue);
    };
    Async.prototype._queueTick = function() {
      if (!this._isTickUsed) {
        this._isTickUsed = true;
        this._schedule(this.drainQueues);
      }
    };
    Async.prototype._reset = function() {
      this._isTickUsed = false;
    };
    module2.exports = Async;
    module2.exports.firstLineError = firstLineError;
  }
});

// node_modules/bluebird/js/release/errors.js
var require_errors = __commonJS({
  "node_modules/bluebird/js/release/errors.js"(exports2, module2) {
    "use strict";
    var es52 = require_es5();
    var Objectfreeze = es52.freeze;
    var util = require_util();
    var inherits2 = util.inherits;
    var notEnumerableProp2 = util.notEnumerableProp;
    function subError(nameProperty, defaultMessage) {
      function SubError(message) {
        if (!(this instanceof SubError)) return new SubError(message);
        notEnumerableProp2(
          this,
          "message",
          typeof message === "string" ? message : defaultMessage
        );
        notEnumerableProp2(this, "name", nameProperty);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          Error.call(this);
        }
      }
      inherits2(SubError, Error);
      return SubError;
    }
    var _TypeError;
    var _RangeError;
    var Warning = subError("Warning", "warning");
    var CancellationError = subError("CancellationError", "cancellation error");
    var TimeoutError = subError("TimeoutError", "timeout error");
    var AggregateError = subError("AggregateError", "aggregate error");
    try {
      _TypeError = TypeError;
      _RangeError = RangeError;
    } catch (e) {
      _TypeError = subError("TypeError", "type error");
      _RangeError = subError("RangeError", "range error");
    }
    var methods = "join pop push shift unshift slice filter forEach some every map indexOf lastIndexOf reduce reduceRight sort reverse".split(" ");
    for (i = 0; i < methods.length; ++i) {
      if (typeof Array.prototype[methods[i]] === "function") {
        AggregateError.prototype[methods[i]] = Array.prototype[methods[i]];
      }
    }
    var i;
    es52.defineProperty(AggregateError.prototype, "length", {
      value: 0,
      configurable: false,
      writable: true,
      enumerable: true
    });
    AggregateError.prototype["isOperational"] = true;
    var level = 0;
    AggregateError.prototype.toString = function() {
      var indent = Array(level * 4 + 1).join(" ");
      var ret2 = "\n" + indent + "AggregateError of:\n";
      level++;
      indent = Array(level * 4 + 1).join(" ");
      for (var i2 = 0; i2 < this.length; ++i2) {
        var str = this[i2] === this ? "[Circular AggregateError]" : this[i2] + "";
        var lines = str.split("\n");
        for (var j = 0; j < lines.length; ++j) {
          lines[j] = indent + lines[j];
        }
        str = lines.join("\n");
        ret2 += str + "\n";
      }
      level--;
      return ret2;
    };
    function OperationalError(message) {
      if (!(this instanceof OperationalError))
        return new OperationalError(message);
      notEnumerableProp2(this, "name", "OperationalError");
      notEnumerableProp2(this, "message", message);
      this.cause = message;
      this["isOperational"] = true;
      if (message instanceof Error) {
        notEnumerableProp2(this, "message", message.message);
        notEnumerableProp2(this, "stack", message.stack);
      } else if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
    inherits2(OperationalError, Error);
    var errorTypes = Error["__BluebirdErrorTypes__"];
    if (!errorTypes) {
      errorTypes = Objectfreeze({
        CancellationError,
        TimeoutError,
        OperationalError,
        RejectionError: OperationalError,
        AggregateError
      });
      es52.defineProperty(Error, "__BluebirdErrorTypes__", {
        value: errorTypes,
        writable: false,
        enumerable: false,
        configurable: false
      });
    }
    module2.exports = {
      Error,
      TypeError: _TypeError,
      RangeError: _RangeError,
      CancellationError: errorTypes.CancellationError,
      OperationalError: errorTypes.OperationalError,
      TimeoutError: errorTypes.TimeoutError,
      AggregateError: errorTypes.AggregateError,
      Warning
    };
  }
});

// node_modules/bluebird/js/release/thenables.js
var require_thenables = __commonJS({
  "node_modules/bluebird/js/release/thenables.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL2) {
      var util = require_util();
      var errorObj2 = util.errorObj;
      var isObject3 = util.isObject;
      function tryConvertToPromise(obj2, context) {
        if (isObject3(obj2)) {
          if (obj2 instanceof Promise2) return obj2;
          var then = getThen(obj2);
          if (then === errorObj2) {
            if (context) context._pushContext();
            var ret2 = Promise2.reject(then.e);
            if (context) context._popContext();
            return ret2;
          } else if (typeof then === "function") {
            if (isAnyBluebirdPromise(obj2)) {
              var ret2 = new Promise2(INTERNAL2);
              obj2._then(
                ret2._fulfill,
                ret2._reject,
                void 0,
                ret2,
                null
              );
              return ret2;
            }
            return doThenable(obj2, then, context);
          }
        }
        return obj2;
      }
      function doGetThen(obj2) {
        return obj2.then;
      }
      function getThen(obj2) {
        try {
          return doGetThen(obj2);
        } catch (e) {
          errorObj2.e = e;
          return errorObj2;
        }
      }
      var hasProp = {}.hasOwnProperty;
      function isAnyBluebirdPromise(obj2) {
        try {
          return hasProp.call(obj2, "_promise0");
        } catch (e) {
          return false;
        }
      }
      function doThenable(x, then, context) {
        var promise = new Promise2(INTERNAL2);
        var ret2 = promise;
        if (context) context._pushContext();
        promise._captureStackTrace();
        if (context) context._popContext();
        var synchronous = true;
        var result2 = util.tryCatch(then).call(x, resolve, reject2);
        synchronous = false;
        if (promise && result2 === errorObj2) {
          promise._rejectCallback(result2.e, true, true);
          promise = null;
        }
        function resolve(value) {
          if (!promise) return;
          promise._resolveCallback(value);
          promise = null;
        }
        function reject2(reason) {
          if (!promise) return;
          promise._rejectCallback(reason, synchronous, true);
          promise = null;
        }
        return ret2;
      }
      return tryConvertToPromise;
    };
  }
});

// node_modules/bluebird/js/release/promise_array.js
var require_promise_array = __commonJS({
  "node_modules/bluebird/js/release/promise_array.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL2, tryConvertToPromise, apiRejection, Proxyable) {
      var util = require_util();
      var isArray = util.isArray;
      function toResolutionValue(val) {
        switch (val) {
          case -2:
            return [];
          case -3:
            return {};
        }
      }
      function PromiseArray(values2) {
        var promise = this._promise = new Promise2(INTERNAL2);
        if (values2 instanceof Promise2) {
          promise._propagateFrom(values2, 3);
        }
        promise._setOnCancel(this);
        this._values = values2;
        this._length = 0;
        this._totalResolved = 0;
        this._init(void 0, -2);
      }
      util.inherits(PromiseArray, Proxyable);
      PromiseArray.prototype.length = function() {
        return this._length;
      };
      PromiseArray.prototype.promise = function() {
        return this._promise;
      };
      PromiseArray.prototype._init = function init(_3, resolveValueIfEmpty) {
        var values2 = tryConvertToPromise(this._values, this._promise);
        if (values2 instanceof Promise2) {
          values2 = values2._target();
          var bitField = values2._bitField;
          ;
          this._values = values2;
          if ((bitField & 50397184) === 0) {
            this._promise._setAsyncGuaranteed();
            return values2._then(
              init,
              this._reject,
              void 0,
              this,
              resolveValueIfEmpty
            );
          } else if ((bitField & 33554432) !== 0) {
            values2 = values2._value();
          } else if ((bitField & 16777216) !== 0) {
            return this._reject(values2._reason());
          } else {
            return this._cancel();
          }
        }
        values2 = util.asArray(values2);
        if (values2 === null) {
          var err = apiRejection(
            "expecting an array or an iterable object but got " + util.classString(values2)
          ).reason();
          this._promise._rejectCallback(err, false);
          return;
        }
        if (values2.length === 0) {
          if (resolveValueIfEmpty === -5) {
            this._resolveEmptyArray();
          } else {
            this._resolve(toResolutionValue(resolveValueIfEmpty));
          }
          return;
        }
        this._iterate(values2);
      };
      PromiseArray.prototype._iterate = function(values2) {
        var len = this.getActualLength(values2.length);
        this._length = len;
        this._values = this.shouldCopyValues() ? new Array(len) : this._values;
        var result2 = this._promise;
        var isResolved = false;
        var bitField = null;
        for (var i = 0; i < len; ++i) {
          var maybePromise = tryConvertToPromise(values2[i], result2);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            bitField = maybePromise._bitField;
          } else {
            bitField = null;
          }
          if (isResolved) {
            if (bitField !== null) {
              maybePromise.suppressUnhandledRejections();
            }
          } else if (bitField !== null) {
            if ((bitField & 50397184) === 0) {
              maybePromise._proxy(this, i);
              this._values[i] = maybePromise;
            } else if ((bitField & 33554432) !== 0) {
              isResolved = this._promiseFulfilled(maybePromise._value(), i);
            } else if ((bitField & 16777216) !== 0) {
              isResolved = this._promiseRejected(maybePromise._reason(), i);
            } else {
              isResolved = this._promiseCancelled(i);
            }
          } else {
            isResolved = this._promiseFulfilled(maybePromise, i);
          }
        }
        if (!isResolved) result2._setAsyncGuaranteed();
      };
      PromiseArray.prototype._isResolved = function() {
        return this._values === null;
      };
      PromiseArray.prototype._resolve = function(value) {
        this._values = null;
        this._promise._fulfill(value);
      };
      PromiseArray.prototype._cancel = function() {
        if (this._isResolved() || !this._promise._isCancellable()) return;
        this._values = null;
        this._promise._cancel();
      };
      PromiseArray.prototype._reject = function(reason) {
        this._values = null;
        this._promise._rejectCallback(reason, false);
      };
      PromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      PromiseArray.prototype._promiseCancelled = function() {
        this._cancel();
        return true;
      };
      PromiseArray.prototype._promiseRejected = function(reason) {
        this._totalResolved++;
        this._reject(reason);
        return true;
      };
      PromiseArray.prototype._resultCancelled = function() {
        if (this._isResolved()) return;
        var values2 = this._values;
        this._cancel();
        if (values2 instanceof Promise2) {
          values2.cancel();
        } else {
          for (var i = 0; i < values2.length; ++i) {
            if (values2[i] instanceof Promise2) {
              values2[i].cancel();
            }
          }
        }
      };
      PromiseArray.prototype.shouldCopyValues = function() {
        return true;
      };
      PromiseArray.prototype.getActualLength = function(len) {
        return len;
      };
      return PromiseArray;
    };
  }
});

// node_modules/bluebird/js/release/context.js
var require_context = __commonJS({
  "node_modules/bluebird/js/release/context.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var longStackTraces = false;
      var contextStack = [];
      Promise2.prototype._promiseCreated = function() {
      };
      Promise2.prototype._pushContext = function() {
      };
      Promise2.prototype._popContext = function() {
        return null;
      };
      Promise2._peekContext = Promise2.prototype._peekContext = function() {
      };
      function Context() {
        this._trace = new Context.CapturedTrace(peekContext());
      }
      Context.prototype._pushContext = function() {
        if (this._trace !== void 0) {
          this._trace._promiseCreated = null;
          contextStack.push(this._trace);
        }
      };
      Context.prototype._popContext = function() {
        if (this._trace !== void 0) {
          var trace = contextStack.pop();
          var ret2 = trace._promiseCreated;
          trace._promiseCreated = null;
          return ret2;
        }
        return null;
      };
      function createContext() {
        if (longStackTraces) return new Context();
      }
      function peekContext() {
        var lastIndex = contextStack.length - 1;
        if (lastIndex >= 0) {
          return contextStack[lastIndex];
        }
        return void 0;
      }
      Context.CapturedTrace = null;
      Context.create = createContext;
      Context.deactivateLongStackTraces = function() {
      };
      Context.activateLongStackTraces = function() {
        var Promise_pushContext = Promise2.prototype._pushContext;
        var Promise_popContext = Promise2.prototype._popContext;
        var Promise_PeekContext = Promise2._peekContext;
        var Promise_peekContext = Promise2.prototype._peekContext;
        var Promise_promiseCreated = Promise2.prototype._promiseCreated;
        Context.deactivateLongStackTraces = function() {
          Promise2.prototype._pushContext = Promise_pushContext;
          Promise2.prototype._popContext = Promise_popContext;
          Promise2._peekContext = Promise_PeekContext;
          Promise2.prototype._peekContext = Promise_peekContext;
          Promise2.prototype._promiseCreated = Promise_promiseCreated;
          longStackTraces = false;
        };
        longStackTraces = true;
        Promise2.prototype._pushContext = Context.prototype._pushContext;
        Promise2.prototype._popContext = Context.prototype._popContext;
        Promise2._peekContext = Promise2.prototype._peekContext = peekContext;
        Promise2.prototype._promiseCreated = function() {
          var ctx = this._peekContext();
          if (ctx && ctx._promiseCreated == null) ctx._promiseCreated = this;
        };
      };
      return Context;
    };
  }
});

// node_modules/bluebird/js/release/debuggability.js
var require_debuggability = __commonJS({
  "node_modules/bluebird/js/release/debuggability.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, Context) {
      var getDomain = Promise2._getDomain;
      var async = Promise2._async;
      var Warning = require_errors().Warning;
      var util = require_util();
      var canAttachTrace2 = util.canAttachTrace;
      var unhandledRejectionHandled;
      var possiblyUnhandledRejection;
      var bluebirdFramePattern = /[\\\/]bluebird[\\\/]js[\\\/](release|debug|instrumented)/;
      var nodeFramePattern = /\((?:timers\.js):\d+:\d+\)/;
      var parseLinePattern = /[\/<\(](.+?):(\d+):(\d+)\)?\s*$/;
      var stackFramePattern = null;
      var formatStack = null;
      var indentStackFrames = false;
      var printWarning;
      var debugging = !!(util.env("BLUEBIRD_DEBUG") != 0 && (util.env("BLUEBIRD_DEBUG") || util.env("NODE_ENV") === "development"));
      var warnings = !!(util.env("BLUEBIRD_WARNINGS") != 0 && (debugging || util.env("BLUEBIRD_WARNINGS")));
      var longStackTraces = !!(util.env("BLUEBIRD_LONG_STACK_TRACES") != 0 && (debugging || util.env("BLUEBIRD_LONG_STACK_TRACES")));
      var wForgottenReturn = util.env("BLUEBIRD_W_FORGOTTEN_RETURN") != 0 && (warnings || !!util.env("BLUEBIRD_W_FORGOTTEN_RETURN"));
      Promise2.prototype.suppressUnhandledRejections = function() {
        var target = this._target();
        target._bitField = target._bitField & ~1048576 | 524288;
      };
      Promise2.prototype._ensurePossibleRejectionHandled = function() {
        if ((this._bitField & 524288) !== 0) return;
        this._setRejectionIsUnhandled();
        async.invokeLater(this._notifyUnhandledRejection, this, void 0);
      };
      Promise2.prototype._notifyUnhandledRejectionIsHandled = function() {
        fireRejectionEvent(
          "rejectionHandled",
          unhandledRejectionHandled,
          void 0,
          this
        );
      };
      Promise2.prototype._setReturnedNonUndefined = function() {
        this._bitField = this._bitField | 268435456;
      };
      Promise2.prototype._returnedNonUndefined = function() {
        return (this._bitField & 268435456) !== 0;
      };
      Promise2.prototype._notifyUnhandledRejection = function() {
        if (this._isRejectionUnhandled()) {
          var reason = this._settledValue();
          this._setUnhandledRejectionIsNotified();
          fireRejectionEvent(
            "unhandledRejection",
            possiblyUnhandledRejection,
            reason,
            this
          );
        }
      };
      Promise2.prototype._setUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField | 262144;
      };
      Promise2.prototype._unsetUnhandledRejectionIsNotified = function() {
        this._bitField = this._bitField & ~262144;
      };
      Promise2.prototype._isUnhandledRejectionNotified = function() {
        return (this._bitField & 262144) > 0;
      };
      Promise2.prototype._setRejectionIsUnhandled = function() {
        this._bitField = this._bitField | 1048576;
      };
      Promise2.prototype._unsetRejectionIsUnhandled = function() {
        this._bitField = this._bitField & ~1048576;
        if (this._isUnhandledRejectionNotified()) {
          this._unsetUnhandledRejectionIsNotified();
          this._notifyUnhandledRejectionIsHandled();
        }
      };
      Promise2.prototype._isRejectionUnhandled = function() {
        return (this._bitField & 1048576) > 0;
      };
      Promise2.prototype._warn = function(message, shouldUseOwnTrace, promise) {
        return warn2(message, shouldUseOwnTrace, promise || this);
      };
      Promise2.onPossiblyUnhandledRejection = function(fn) {
        var domain = getDomain();
        possiblyUnhandledRejection = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : void 0;
      };
      Promise2.onUnhandledRejectionHandled = function(fn) {
        var domain = getDomain();
        unhandledRejectionHandled = typeof fn === "function" ? domain === null ? fn : util.domainBind(domain, fn) : void 0;
      };
      var disableLongStackTraces = function() {
      };
      Promise2.longStackTraces = function() {
        if (async.haveItemsQueued() && !config2.longStackTraces) {
          throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
        }
        if (!config2.longStackTraces && longStackTracesIsSupported()) {
          var Promise_captureStackTrace = Promise2.prototype._captureStackTrace;
          var Promise_attachExtraTrace = Promise2.prototype._attachExtraTrace;
          config2.longStackTraces = true;
          disableLongStackTraces = function() {
            if (async.haveItemsQueued() && !config2.longStackTraces) {
              throw new Error("cannot enable long stack traces after promises have been created\n\n    See http://goo.gl/MqrFmX\n");
            }
            Promise2.prototype._captureStackTrace = Promise_captureStackTrace;
            Promise2.prototype._attachExtraTrace = Promise_attachExtraTrace;
            Context.deactivateLongStackTraces();
            async.enableTrampoline();
            config2.longStackTraces = false;
          };
          Promise2.prototype._captureStackTrace = longStackTracesCaptureStackTrace;
          Promise2.prototype._attachExtraTrace = longStackTracesAttachExtraTrace;
          Context.activateLongStackTraces();
          async.disableTrampolineIfNecessary();
        }
      };
      Promise2.hasLongStackTraces = function() {
        return config2.longStackTraces && longStackTracesIsSupported();
      };
      var fireDomEvent = (function() {
        try {
          if (typeof CustomEvent === "function") {
            var event = new CustomEvent("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = new CustomEvent(name.toLowerCase(), {
                detail: event2,
                cancelable: true
              });
              return !util.global.dispatchEvent(domEvent);
            };
          } else if (typeof Event === "function") {
            var event = new Event("CustomEvent");
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = new Event(name.toLowerCase(), {
                cancelable: true
              });
              domEvent.detail = event2;
              return !util.global.dispatchEvent(domEvent);
            };
          } else {
            var event = document.createEvent("CustomEvent");
            event.initCustomEvent("testingtheevent", false, true, {});
            util.global.dispatchEvent(event);
            return function(name, event2) {
              var domEvent = document.createEvent("CustomEvent");
              domEvent.initCustomEvent(
                name.toLowerCase(),
                false,
                true,
                event2
              );
              return !util.global.dispatchEvent(domEvent);
            };
          }
        } catch (e) {
        }
        return function() {
          return false;
        };
      })();
      var fireGlobalEvent = (function() {
        if (util.isNode) {
          return function() {
            return process.emit.apply(process, arguments);
          };
        } else {
          if (!util.global) {
            return function() {
              return false;
            };
          }
          return function(name) {
            var methodName = "on" + name.toLowerCase();
            var method = util.global[methodName];
            if (!method) return false;
            method.apply(util.global, [].slice.call(arguments, 1));
            return true;
          };
        }
      })();
      function generatePromiseLifecycleEventObject(name, promise) {
        return { promise };
      }
      var eventToObjectGenerator = {
        promiseCreated: generatePromiseLifecycleEventObject,
        promiseFulfilled: generatePromiseLifecycleEventObject,
        promiseRejected: generatePromiseLifecycleEventObject,
        promiseResolved: generatePromiseLifecycleEventObject,
        promiseCancelled: generatePromiseLifecycleEventObject,
        promiseChained: function(name, promise, child) {
          return { promise, child };
        },
        warning: function(name, warning) {
          return { warning };
        },
        unhandledRejection: function(name, reason, promise) {
          return { reason, promise };
        },
        rejectionHandled: generatePromiseLifecycleEventObject
      };
      var activeFireEvent = function(name) {
        var globalEventFired = false;
        try {
          globalEventFired = fireGlobalEvent.apply(null, arguments);
        } catch (e) {
          async.throwLater(e);
          globalEventFired = true;
        }
        var domEventFired = false;
        try {
          domEventFired = fireDomEvent(
            name,
            eventToObjectGenerator[name].apply(null, arguments)
          );
        } catch (e) {
          async.throwLater(e);
          domEventFired = true;
        }
        return domEventFired || globalEventFired;
      };
      Promise2.config = function(opts) {
        opts = Object(opts);
        if ("longStackTraces" in opts) {
          if (opts.longStackTraces) {
            Promise2.longStackTraces();
          } else if (!opts.longStackTraces && Promise2.hasLongStackTraces()) {
            disableLongStackTraces();
          }
        }
        if ("warnings" in opts) {
          var warningsOption = opts.warnings;
          config2.warnings = !!warningsOption;
          wForgottenReturn = config2.warnings;
          if (util.isObject(warningsOption)) {
            if ("wForgottenReturn" in warningsOption) {
              wForgottenReturn = !!warningsOption.wForgottenReturn;
            }
          }
        }
        if ("cancellation" in opts && opts.cancellation && !config2.cancellation) {
          if (async.haveItemsQueued()) {
            throw new Error(
              "cannot enable cancellation after promises are in use"
            );
          }
          Promise2.prototype._clearCancellationData = cancellationClearCancellationData;
          Promise2.prototype._propagateFrom = cancellationPropagateFrom;
          Promise2.prototype._onCancel = cancellationOnCancel;
          Promise2.prototype._setOnCancel = cancellationSetOnCancel;
          Promise2.prototype._attachCancellationCallback = cancellationAttachCancellationCallback;
          Promise2.prototype._execute = cancellationExecute;
          propagateFromFunction = cancellationPropagateFrom;
          config2.cancellation = true;
        }
        if ("monitoring" in opts) {
          if (opts.monitoring && !config2.monitoring) {
            config2.monitoring = true;
            Promise2.prototype._fireEvent = activeFireEvent;
          } else if (!opts.monitoring && config2.monitoring) {
            config2.monitoring = false;
            Promise2.prototype._fireEvent = defaultFireEvent;
          }
        }
        return Promise2;
      };
      function defaultFireEvent() {
        return false;
      }
      Promise2.prototype._fireEvent = defaultFireEvent;
      Promise2.prototype._execute = function(executor, resolve, reject2) {
        try {
          executor(resolve, reject2);
        } catch (e) {
          return e;
        }
      };
      Promise2.prototype._onCancel = function() {
      };
      Promise2.prototype._setOnCancel = function(handler2) {
        ;
      };
      Promise2.prototype._attachCancellationCallback = function(onCancel) {
        ;
      };
      Promise2.prototype._captureStackTrace = function() {
      };
      Promise2.prototype._attachExtraTrace = function() {
      };
      Promise2.prototype._clearCancellationData = function() {
      };
      Promise2.prototype._propagateFrom = function(parent, flags) {
        ;
        ;
      };
      function cancellationExecute(executor, resolve, reject2) {
        var promise = this;
        try {
          executor(resolve, reject2, function(onCancel) {
            if (typeof onCancel !== "function") {
              throw new TypeError("onCancel must be a function, got: " + util.toString(onCancel));
            }
            promise._attachCancellationCallback(onCancel);
          });
        } catch (e) {
          return e;
        }
      }
      function cancellationAttachCancellationCallback(onCancel) {
        if (!this._isCancellable()) return this;
        var previousOnCancel = this._onCancel();
        if (previousOnCancel !== void 0) {
          if (util.isArray(previousOnCancel)) {
            previousOnCancel.push(onCancel);
          } else {
            this._setOnCancel([previousOnCancel, onCancel]);
          }
        } else {
          this._setOnCancel(onCancel);
        }
      }
      function cancellationOnCancel() {
        return this._onCancelField;
      }
      function cancellationSetOnCancel(onCancel) {
        this._onCancelField = onCancel;
      }
      function cancellationClearCancellationData() {
        this._cancellationParent = void 0;
        this._onCancelField = void 0;
      }
      function cancellationPropagateFrom(parent, flags) {
        if ((flags & 1) !== 0) {
          this._cancellationParent = parent;
          var branchesRemainingToCancel = parent._branchesRemainingToCancel;
          if (branchesRemainingToCancel === void 0) {
            branchesRemainingToCancel = 0;
          }
          parent._branchesRemainingToCancel = branchesRemainingToCancel + 1;
        }
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      function bindingPropagateFrom(parent, flags) {
        if ((flags & 2) !== 0 && parent._isBound()) {
          this._setBoundTo(parent._boundTo);
        }
      }
      var propagateFromFunction = bindingPropagateFrom;
      function boundValueFunction() {
        var ret2 = this._boundTo;
        if (ret2 !== void 0) {
          if (ret2 instanceof Promise2) {
            if (ret2.isFulfilled()) {
              return ret2.value();
            } else {
              return void 0;
            }
          }
        }
        return ret2;
      }
      function longStackTracesCaptureStackTrace() {
        this._trace = new CapturedTrace(this._peekContext());
      }
      function longStackTracesAttachExtraTrace(error, ignoreSelf) {
        if (canAttachTrace2(error)) {
          var trace = this._trace;
          if (trace !== void 0) {
            if (ignoreSelf) trace = trace._parent;
          }
          if (trace !== void 0) {
            trace.attachExtraTrace(error);
          } else if (!error.__stackCleaned__) {
            var parsed = parseStackAndMessage(error);
            util.notEnumerableProp(
              error,
              "stack",
              parsed.message + "\n" + parsed.stack.join("\n")
            );
            util.notEnumerableProp(error, "__stackCleaned__", true);
          }
        }
      }
      function checkForgottenReturns(returnValue, promiseCreated, name, promise, parent) {
        if (returnValue === void 0 && promiseCreated !== null && wForgottenReturn) {
          if (parent !== void 0 && parent._returnedNonUndefined()) return;
          if ((promise._bitField & 65535) === 0) return;
          if (name) name = name + " ";
          var handlerLine = "";
          var creatorLine = "";
          if (promiseCreated._trace) {
            var traceLines = promiseCreated._trace.stack.split("\n");
            var stack = cleanStack(traceLines);
            for (var i = stack.length - 1; i >= 0; --i) {
              var line = stack[i];
              if (!nodeFramePattern.test(line)) {
                var lineMatches = line.match(parseLinePattern);
                if (lineMatches) {
                  handlerLine = "at " + lineMatches[1] + ":" + lineMatches[2] + ":" + lineMatches[3] + " ";
                }
                break;
              }
            }
            if (stack.length > 0) {
              var firstUserLine = stack[0];
              for (var i = 0; i < traceLines.length; ++i) {
                if (traceLines[i] === firstUserLine) {
                  if (i > 0) {
                    creatorLine = "\n" + traceLines[i - 1];
                  }
                  break;
                }
              }
            }
          }
          var msg = "a promise was created in a " + name + "handler " + handlerLine + "but was not returned from it, see http://goo.gl/rRqMUw" + creatorLine;
          promise._warn(msg, true, promiseCreated);
        }
      }
      function deprecated2(name, replacement) {
        var message = name + " is deprecated and will be removed in a future version.";
        if (replacement) message += " Use " + replacement + " instead.";
        return warn2(message);
      }
      function warn2(message, shouldUseOwnTrace, promise) {
        if (!config2.warnings) return;
        var warning = new Warning(message);
        var ctx;
        if (shouldUseOwnTrace) {
          promise._attachExtraTrace(warning);
        } else if (config2.longStackTraces && (ctx = Promise2._peekContext())) {
          ctx.attachExtraTrace(warning);
        } else {
          var parsed = parseStackAndMessage(warning);
          warning.stack = parsed.message + "\n" + parsed.stack.join("\n");
        }
        if (!activeFireEvent("warning", warning)) {
          formatAndLogError(warning, "", true);
        }
      }
      function reconstructStack(message, stacks) {
        for (var i = 0; i < stacks.length - 1; ++i) {
          stacks[i].push("From previous event:");
          stacks[i] = stacks[i].join("\n");
        }
        if (i < stacks.length) {
          stacks[i] = stacks[i].join("\n");
        }
        return message + "\n" + stacks.join("\n");
      }
      function removeDuplicateOrEmptyJumps(stacks) {
        for (var i = 0; i < stacks.length; ++i) {
          if (stacks[i].length === 0 || i + 1 < stacks.length && stacks[i][0] === stacks[i + 1][0]) {
            stacks.splice(i, 1);
            i--;
          }
        }
      }
      function removeCommonRoots(stacks) {
        var current = stacks[0];
        for (var i = 1; i < stacks.length; ++i) {
          var prev = stacks[i];
          var currentLastIndex = current.length - 1;
          var currentLastLine = current[currentLastIndex];
          var commonRootMeetPoint = -1;
          for (var j = prev.length - 1; j >= 0; --j) {
            if (prev[j] === currentLastLine) {
              commonRootMeetPoint = j;
              break;
            }
          }
          for (var j = commonRootMeetPoint; j >= 0; --j) {
            var line = prev[j];
            if (current[currentLastIndex] === line) {
              current.pop();
              currentLastIndex--;
            } else {
              break;
            }
          }
          current = prev;
        }
      }
      function cleanStack(stack) {
        var ret2 = [];
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          var isTraceLine = "    (No stack trace)" === line || stackFramePattern.test(line);
          var isInternalFrame = isTraceLine && shouldIgnore(line);
          if (isTraceLine && !isInternalFrame) {
            if (indentStackFrames && line.charAt(0) !== " ") {
              line = "    " + line;
            }
            ret2.push(line);
          }
        }
        return ret2;
      }
      function stackFramesAsArray(error) {
        var stack = error.stack.replace(/\s+$/g, "").split("\n");
        for (var i = 0; i < stack.length; ++i) {
          var line = stack[i];
          if ("    (No stack trace)" === line || stackFramePattern.test(line)) {
            break;
          }
        }
        if (i > 0 && error.name != "SyntaxError") {
          stack = stack.slice(i);
        }
        return stack;
      }
      function parseStackAndMessage(error) {
        var stack = error.stack;
        var message = error.toString();
        stack = typeof stack === "string" && stack.length > 0 ? stackFramesAsArray(error) : ["    (No stack trace)"];
        return {
          message,
          stack: error.name == "SyntaxError" ? stack : cleanStack(stack)
        };
      }
      function formatAndLogError(error, title, isSoft) {
        if (typeof console !== "undefined") {
          var message;
          if (util.isObject(error)) {
            var stack = error.stack;
            message = title + formatStack(stack, error);
          } else {
            message = title + String(error);
          }
          if (typeof printWarning === "function") {
            printWarning(message, isSoft);
          } else if (typeof console.log === "function" || typeof console.log === "object") {
            console.log(message);
          }
        }
      }
      function fireRejectionEvent(name, localHandler, reason, promise) {
        var localEventFired = false;
        try {
          if (typeof localHandler === "function") {
            localEventFired = true;
            if (name === "rejectionHandled") {
              localHandler(promise);
            } else {
              localHandler(reason, promise);
            }
          }
        } catch (e) {
          async.throwLater(e);
        }
        if (name === "unhandledRejection") {
          if (!activeFireEvent(name, reason, promise) && !localEventFired) {
            formatAndLogError(reason, "Unhandled rejection ");
          }
        } else {
          activeFireEvent(name, promise);
        }
      }
      function formatNonError(obj2) {
        var str;
        if (typeof obj2 === "function") {
          str = "[function " + (obj2.name || "anonymous") + "]";
        } else {
          str = obj2 && typeof obj2.toString === "function" ? obj2.toString() : util.toString(obj2);
          var ruselessToString = /\[object [a-zA-Z0-9$_]+\]/;
          if (ruselessToString.test(str)) {
            try {
              var newStr = JSON.stringify(obj2);
              str = newStr;
            } catch (e) {
            }
          }
          if (str.length === 0) {
            str = "(empty array)";
          }
        }
        return "(<" + snip(str) + ">, no stack trace)";
      }
      function snip(str) {
        var maxChars = 41;
        if (str.length < maxChars) {
          return str;
        }
        return str.substr(0, maxChars - 3) + "...";
      }
      function longStackTracesIsSupported() {
        return typeof captureStackTrace === "function";
      }
      var shouldIgnore = function() {
        return false;
      };
      var parseLineInfoRegex = /[\/<\(]([^:\/]+):(\d+):(?:\d+)\)?\s*$/;
      function parseLineInfo(line) {
        var matches = line.match(parseLineInfoRegex);
        if (matches) {
          return {
            fileName: matches[1],
            line: parseInt(matches[2], 10)
          };
        }
      }
      function setBounds(firstLineError, lastLineError) {
        if (!longStackTracesIsSupported()) return;
        var firstStackLines = firstLineError.stack.split("\n");
        var lastStackLines = lastLineError.stack.split("\n");
        var firstIndex = -1;
        var lastIndex = -1;
        var firstFileName;
        var lastFileName;
        for (var i = 0; i < firstStackLines.length; ++i) {
          var result2 = parseLineInfo(firstStackLines[i]);
          if (result2) {
            firstFileName = result2.fileName;
            firstIndex = result2.line;
            break;
          }
        }
        for (var i = 0; i < lastStackLines.length; ++i) {
          var result2 = parseLineInfo(lastStackLines[i]);
          if (result2) {
            lastFileName = result2.fileName;
            lastIndex = result2.line;
            break;
          }
        }
        if (firstIndex < 0 || lastIndex < 0 || !firstFileName || !lastFileName || firstFileName !== lastFileName || firstIndex >= lastIndex) {
          return;
        }
        shouldIgnore = function(line) {
          if (bluebirdFramePattern.test(line)) return true;
          var info2 = parseLineInfo(line);
          if (info2) {
            if (info2.fileName === firstFileName && (firstIndex <= info2.line && info2.line <= lastIndex)) {
              return true;
            }
          }
          return false;
        };
      }
      function CapturedTrace(parent) {
        this._parent = parent;
        this._promisesCreated = 0;
        var length = this._length = 1 + (parent === void 0 ? 0 : parent._length);
        captureStackTrace(this, CapturedTrace);
        if (length > 32) this.uncycle();
      }
      util.inherits(CapturedTrace, Error);
      Context.CapturedTrace = CapturedTrace;
      CapturedTrace.prototype.uncycle = function() {
        var length = this._length;
        if (length < 2) return;
        var nodes = [];
        var stackToIndex = {};
        for (var i = 0, node = this; node !== void 0; ++i) {
          nodes.push(node);
          node = node._parent;
        }
        length = this._length = i;
        for (var i = length - 1; i >= 0; --i) {
          var stack = nodes[i].stack;
          if (stackToIndex[stack] === void 0) {
            stackToIndex[stack] = i;
          }
        }
        for (var i = 0; i < length; ++i) {
          var currentStack = nodes[i].stack;
          var index = stackToIndex[currentStack];
          if (index !== void 0 && index !== i) {
            if (index > 0) {
              nodes[index - 1]._parent = void 0;
              nodes[index - 1]._length = 1;
            }
            nodes[i]._parent = void 0;
            nodes[i]._length = 1;
            var cycleEdgeNode = i > 0 ? nodes[i - 1] : this;
            if (index < length - 1) {
              cycleEdgeNode._parent = nodes[index + 1];
              cycleEdgeNode._parent.uncycle();
              cycleEdgeNode._length = cycleEdgeNode._parent._length + 1;
            } else {
              cycleEdgeNode._parent = void 0;
              cycleEdgeNode._length = 1;
            }
            var currentChildLength = cycleEdgeNode._length + 1;
            for (var j = i - 2; j >= 0; --j) {
              nodes[j]._length = currentChildLength;
              currentChildLength++;
            }
            return;
          }
        }
      };
      CapturedTrace.prototype.attachExtraTrace = function(error) {
        if (error.__stackCleaned__) return;
        this.uncycle();
        var parsed = parseStackAndMessage(error);
        var message = parsed.message;
        var stacks = [parsed.stack];
        var trace = this;
        while (trace !== void 0) {
          stacks.push(cleanStack(trace.stack.split("\n")));
          trace = trace._parent;
        }
        removeCommonRoots(stacks);
        removeDuplicateOrEmptyJumps(stacks);
        util.notEnumerableProp(error, "stack", reconstructStack(message, stacks));
        util.notEnumerableProp(error, "__stackCleaned__", true);
      };
      var captureStackTrace = (function stackDetection() {
        var v8stackFramePattern = /^\s*at\s*/;
        var v8stackFormatter = function(stack, error) {
          if (typeof stack === "string") return stack;
          if (error.name !== void 0 && error.message !== void 0) {
            return error.toString();
          }
          return formatNonError(error);
        };
        if (typeof Error.stackTraceLimit === "number" && typeof Error.captureStackTrace === "function") {
          Error.stackTraceLimit += 6;
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          var captureStackTrace2 = Error.captureStackTrace;
          shouldIgnore = function(line) {
            return bluebirdFramePattern.test(line);
          };
          return function(receiver, ignoreUntil) {
            Error.stackTraceLimit += 6;
            captureStackTrace2(receiver, ignoreUntil);
            Error.stackTraceLimit -= 6;
          };
        }
        var err = new Error();
        if (typeof err.stack === "string" && err.stack.split("\n")[0].indexOf("stackDetection@") >= 0) {
          stackFramePattern = /@/;
          formatStack = v8stackFormatter;
          indentStackFrames = true;
          return function captureStackTrace3(o) {
            o.stack = new Error().stack;
          };
        }
        var hasStackAfterThrow;
        try {
          throw new Error();
        } catch (e) {
          hasStackAfterThrow = "stack" in e;
        }
        if (!("stack" in err) && hasStackAfterThrow && typeof Error.stackTraceLimit === "number") {
          stackFramePattern = v8stackFramePattern;
          formatStack = v8stackFormatter;
          return function captureStackTrace3(o) {
            Error.stackTraceLimit += 6;
            try {
              throw new Error();
            } catch (e) {
              o.stack = e.stack;
            }
            Error.stackTraceLimit -= 6;
          };
        }
        formatStack = function(stack, error) {
          if (typeof stack === "string") return stack;
          if ((typeof error === "object" || typeof error === "function") && error.name !== void 0 && error.message !== void 0) {
            return error.toString();
          }
          return formatNonError(error);
        };
        return null;
      })([]);
      if (typeof console !== "undefined" && typeof console.warn !== "undefined") {
        printWarning = function(message) {
          console.warn(message);
        };
        if (util.isNode && process.stderr.isTTY) {
          printWarning = function(message, isSoft) {
            var color = isSoft ? "\x1B[33m" : "\x1B[31m";
            console.warn(color + message + "\x1B[0m\n");
          };
        } else if (!util.isNode && typeof new Error().stack === "string") {
          printWarning = function(message, isSoft) {
            console.warn(
              "%c" + message,
              isSoft ? "color: darkorange" : "color: red"
            );
          };
        }
      }
      var config2 = {
        warnings,
        longStackTraces: false,
        cancellation: false,
        monitoring: false
      };
      if (longStackTraces) Promise2.longStackTraces();
      return {
        longStackTraces: function() {
          return config2.longStackTraces;
        },
        warnings: function() {
          return config2.warnings;
        },
        cancellation: function() {
          return config2.cancellation;
        },
        monitoring: function() {
          return config2.monitoring;
        },
        propagateFromFunction: function() {
          return propagateFromFunction;
        },
        boundValueFunction: function() {
          return boundValueFunction;
        },
        checkForgottenReturns,
        setBounds,
        warn: warn2,
        deprecated: deprecated2,
        CapturedTrace,
        fireDomEvent,
        fireGlobalEvent
      };
    };
  }
});

// node_modules/bluebird/js/release/finally.js
var require_finally = __commonJS({
  "node_modules/bluebird/js/release/finally.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, tryConvertToPromise) {
      var util = require_util();
      var CancellationError = Promise2.CancellationError;
      var errorObj2 = util.errorObj;
      function PassThroughHandlerContext(promise, type, handler2) {
        this.promise = promise;
        this.type = type;
        this.handler = handler2;
        this.called = false;
        this.cancelPromise = null;
      }
      PassThroughHandlerContext.prototype.isFinallyHandler = function() {
        return this.type === 0;
      };
      function FinallyHandlerCancelReaction(finallyHandler2) {
        this.finallyHandler = finallyHandler2;
      }
      FinallyHandlerCancelReaction.prototype._resultCancelled = function() {
        checkCancel(this.finallyHandler);
      };
      function checkCancel(ctx, reason) {
        if (ctx.cancelPromise != null) {
          if (arguments.length > 1) {
            ctx.cancelPromise._reject(reason);
          } else {
            ctx.cancelPromise._cancel();
          }
          ctx.cancelPromise = null;
          return true;
        }
        return false;
      }
      function succeed() {
        return finallyHandler.call(this, this.promise._target()._settledValue());
      }
      function fail(reason) {
        if (checkCancel(this, reason)) return;
        errorObj2.e = reason;
        return errorObj2;
      }
      function finallyHandler(reasonOrValue) {
        var promise = this.promise;
        var handler2 = this.handler;
        if (!this.called) {
          this.called = true;
          var ret2 = this.isFinallyHandler() ? handler2.call(promise._boundValue()) : handler2.call(promise._boundValue(), reasonOrValue);
          if (ret2 !== void 0) {
            promise._setReturnedNonUndefined();
            var maybePromise = tryConvertToPromise(ret2, promise);
            if (maybePromise instanceof Promise2) {
              if (this.cancelPromise != null) {
                if (maybePromise._isCancelled()) {
                  var reason = new CancellationError("late cancellation observer");
                  promise._attachExtraTrace(reason);
                  errorObj2.e = reason;
                  return errorObj2;
                } else if (maybePromise.isPending()) {
                  maybePromise._attachCancellationCallback(
                    new FinallyHandlerCancelReaction(this)
                  );
                }
              }
              return maybePromise._then(
                succeed,
                fail,
                void 0,
                this,
                void 0
              );
            }
          }
        }
        if (promise.isRejected()) {
          checkCancel(this);
          errorObj2.e = reasonOrValue;
          return errorObj2;
        } else {
          checkCancel(this);
          return reasonOrValue;
        }
      }
      Promise2.prototype._passThrough = function(handler2, type, success, fail2) {
        if (typeof handler2 !== "function") return this.then();
        return this._then(
          success,
          fail2,
          void 0,
          new PassThroughHandlerContext(this, type, handler2),
          void 0
        );
      };
      Promise2.prototype.lastly = Promise2.prototype["finally"] = function(handler2) {
        return this._passThrough(
          handler2,
          0,
          finallyHandler,
          finallyHandler
        );
      };
      Promise2.prototype.tap = function(handler2) {
        return this._passThrough(handler2, 1, finallyHandler);
      };
      return PassThroughHandlerContext;
    };
  }
});

// node_modules/bluebird/js/release/catch_filter.js
var require_catch_filter = __commonJS({
  "node_modules/bluebird/js/release/catch_filter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(NEXT_FILTER) {
      var util = require_util();
      var getKeys = require_es5().keys;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function catchFilter(instances, cb2, promise) {
        return function(e) {
          var boundTo = promise._boundValue();
          predicateLoop: for (var i = 0; i < instances.length; ++i) {
            var item = instances[i];
            if (item === Error || item != null && item.prototype instanceof Error) {
              if (e instanceof item) {
                return tryCatch2(cb2).call(boundTo, e);
              }
            } else if (typeof item === "function") {
              var matchesPredicate = tryCatch2(item).call(boundTo, e);
              if (matchesPredicate === errorObj2) {
                return matchesPredicate;
              } else if (matchesPredicate) {
                return tryCatch2(cb2).call(boundTo, e);
              }
            } else if (util.isObject(e)) {
              var keys2 = getKeys(item);
              for (var j = 0; j < keys2.length; ++j) {
                var key = keys2[j];
                if (item[key] != e[key]) {
                  continue predicateLoop;
                }
              }
              return tryCatch2(cb2).call(boundTo, e);
            }
          }
          return NEXT_FILTER;
        };
      }
      return catchFilter;
    };
  }
});

// node_modules/bluebird/js/release/nodeback.js
var require_nodeback = __commonJS({
  "node_modules/bluebird/js/release/nodeback.js"(exports2, module2) {
    "use strict";
    var util = require_util();
    var maybeWrapAsError2 = util.maybeWrapAsError;
    var errors = require_errors();
    var OperationalError = errors.OperationalError;
    var es52 = require_es5();
    function isUntypedError(obj2) {
      return obj2 instanceof Error && es52.getPrototypeOf(obj2) === Error.prototype;
    }
    var rErrorKey = /^(?:name|message|stack|cause)$/;
    function wrapAsOperationalError(obj2) {
      var ret2;
      if (isUntypedError(obj2)) {
        ret2 = new OperationalError(obj2);
        ret2.name = obj2.name;
        ret2.message = obj2.message;
        ret2.stack = obj2.stack;
        var keys2 = es52.keys(obj2);
        for (var i = 0; i < keys2.length; ++i) {
          var key = keys2[i];
          if (!rErrorKey.test(key)) {
            ret2[key] = obj2[key];
          }
        }
        return ret2;
      }
      util.markAsOriginatingFromRejection(obj2);
      return obj2;
    }
    function nodebackForPromise(promise, multiArgs) {
      return function(err, value) {
        if (promise === null) return;
        if (err) {
          var wrapped = wrapAsOperationalError(maybeWrapAsError2(err));
          promise._attachExtraTrace(wrapped);
          promise._reject(wrapped);
        } else if (!multiArgs) {
          promise._fulfill(value);
        } else {
          var $_len = arguments.length;
          var args = new Array(Math.max($_len - 1, 0));
          for (var $_i = 1; $_i < $_len; ++$_i) {
            args[$_i - 1] = arguments[$_i];
          }
          ;
          promise._fulfill(args);
        }
        promise = null;
      };
    }
    module2.exports = nodebackForPromise;
  }
});

// node_modules/bluebird/js/release/method.js
var require_method = __commonJS({
  "node_modules/bluebird/js/release/method.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL2, tryConvertToPromise, apiRejection, debug) {
      var util = require_util();
      var tryCatch2 = util.tryCatch;
      Promise2.method = function(fn) {
        if (typeof fn !== "function") {
          throw new Promise2.TypeError("expecting a function but got " + util.classString(fn));
        }
        return function() {
          var ret2 = new Promise2(INTERNAL2);
          ret2._captureStackTrace();
          ret2._pushContext();
          var value = tryCatch2(fn).apply(this, arguments);
          var promiseCreated = ret2._popContext();
          debug.checkForgottenReturns(
            value,
            promiseCreated,
            "Promise.method",
            ret2
          );
          ret2._resolveFromSyncValue(value);
          return ret2;
        };
      };
      Promise2.attempt = Promise2["try"] = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var ret2 = new Promise2(INTERNAL2);
        ret2._captureStackTrace();
        ret2._pushContext();
        var value;
        if (arguments.length > 1) {
          debug.deprecated("calling Promise.try with more than 1 argument");
          var arg = arguments[1];
          var ctx = arguments[2];
          value = util.isArray(arg) ? tryCatch2(fn).apply(ctx, arg) : tryCatch2(fn).call(ctx, arg);
        } else {
          value = tryCatch2(fn)();
        }
        var promiseCreated = ret2._popContext();
        debug.checkForgottenReturns(
          value,
          promiseCreated,
          "Promise.try",
          ret2
        );
        ret2._resolveFromSyncValue(value);
        return ret2;
      };
      Promise2.prototype._resolveFromSyncValue = function(value) {
        if (value === util.errorObj) {
          this._rejectCallback(value.e, false);
        } else {
          this._resolveCallback(value, true);
        }
      };
    };
  }
});

// node_modules/bluebird/js/release/bind.js
var require_bind = __commonJS({
  "node_modules/bluebird/js/release/bind.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL2, tryConvertToPromise, debug) {
      var calledBind = false;
      var rejectThis = function(_3, e) {
        this._reject(e);
      };
      var targetRejected = function(e, context) {
        context.promiseRejectionQueued = true;
        context.bindingPromise._then(rejectThis, rejectThis, null, this, e);
      };
      var bindingResolved = function(thisArg, context) {
        if ((this._bitField & 50397184) === 0) {
          this._resolveCallback(context.target);
        }
      };
      var bindingRejected = function(e, context) {
        if (!context.promiseRejectionQueued) this._reject(e);
      };
      Promise2.prototype.bind = function(thisArg) {
        if (!calledBind) {
          calledBind = true;
          Promise2.prototype._propagateFrom = debug.propagateFromFunction();
          Promise2.prototype._boundValue = debug.boundValueFunction();
        }
        var maybePromise = tryConvertToPromise(thisArg);
        var ret2 = new Promise2(INTERNAL2);
        ret2._propagateFrom(this, 1);
        var target = this._target();
        ret2._setBoundTo(maybePromise);
        if (maybePromise instanceof Promise2) {
          var context = {
            promiseRejectionQueued: false,
            promise: ret2,
            target,
            bindingPromise: maybePromise
          };
          target._then(INTERNAL2, targetRejected, void 0, ret2, context);
          maybePromise._then(
            bindingResolved,
            bindingRejected,
            void 0,
            ret2,
            context
          );
          ret2._setOnCancel(maybePromise);
        } else {
          ret2._resolveCallback(target);
        }
        return ret2;
      };
      Promise2.prototype._setBoundTo = function(obj2) {
        if (obj2 !== void 0) {
          this._bitField = this._bitField | 2097152;
          this._boundTo = obj2;
        } else {
          this._bitField = this._bitField & ~2097152;
        }
      };
      Promise2.prototype._isBound = function() {
        return (this._bitField & 2097152) === 2097152;
      };
      Promise2.bind = function(thisArg, value) {
        return Promise2.resolve(value).bind(thisArg);
      };
    };
  }
});

// node_modules/bluebird/js/release/cancel.js
var require_cancel = __commonJS({
  "node_modules/bluebird/js/release/cancel.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, debug) {
      var util = require_util();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      Promise2.prototype["break"] = Promise2.prototype.cancel = function() {
        if (!debug.cancellation()) return this._warn("cancellation is disabled");
        var promise = this;
        var child = promise;
        while (promise._isCancellable()) {
          if (!promise._cancelBy(child)) {
            if (child._isFollowing()) {
              child._followee().cancel();
            } else {
              child._cancelBranched();
            }
            break;
          }
          var parent = promise._cancellationParent;
          if (parent == null || !parent._isCancellable()) {
            if (promise._isFollowing()) {
              promise._followee().cancel();
            } else {
              promise._cancelBranched();
            }
            break;
          } else {
            if (promise._isFollowing()) promise._followee().cancel();
            promise._setWillBeCancelled();
            child = promise;
            promise = parent;
          }
        }
      };
      Promise2.prototype._branchHasCancelled = function() {
        this._branchesRemainingToCancel--;
      };
      Promise2.prototype._enoughBranchesHaveCancelled = function() {
        return this._branchesRemainingToCancel === void 0 || this._branchesRemainingToCancel <= 0;
      };
      Promise2.prototype._cancelBy = function(canceller) {
        if (canceller === this) {
          this._branchesRemainingToCancel = 0;
          this._invokeOnCancel();
          return true;
        } else {
          this._branchHasCancelled();
          if (this._enoughBranchesHaveCancelled()) {
            this._invokeOnCancel();
            return true;
          }
        }
        return false;
      };
      Promise2.prototype._cancelBranched = function() {
        if (this._enoughBranchesHaveCancelled()) {
          this._cancel();
        }
      };
      Promise2.prototype._cancel = function() {
        if (!this._isCancellable()) return;
        this._setCancelled();
        async.invoke(this._cancelPromises, this, void 0);
      };
      Promise2.prototype._cancelPromises = function() {
        if (this._length() > 0) this._settlePromises();
      };
      Promise2.prototype._unsetOnCancel = function() {
        this._onCancelField = void 0;
      };
      Promise2.prototype._isCancellable = function() {
        return this.isPending() && !this._isCancelled();
      };
      Promise2.prototype.isCancellable = function() {
        return this.isPending() && !this.isCancelled();
      };
      Promise2.prototype._doInvokeOnCancel = function(onCancelCallback, internalOnly) {
        if (util.isArray(onCancelCallback)) {
          for (var i = 0; i < onCancelCallback.length; ++i) {
            this._doInvokeOnCancel(onCancelCallback[i], internalOnly);
          }
        } else if (onCancelCallback !== void 0) {
          if (typeof onCancelCallback === "function") {
            if (!internalOnly) {
              var e = tryCatch2(onCancelCallback).call(this._boundValue());
              if (e === errorObj2) {
                this._attachExtraTrace(e.e);
                async.throwLater(e.e);
              }
            }
          } else {
            onCancelCallback._resultCancelled(this);
          }
        }
      };
      Promise2.prototype._invokeOnCancel = function() {
        var onCancelCallback = this._onCancel();
        this._unsetOnCancel();
        async.invoke(this._doInvokeOnCancel, this, onCancelCallback);
      };
      Promise2.prototype._invokeInternalOnCancel = function() {
        if (this._isCancellable()) {
          this._doInvokeOnCancel(this._onCancel(), true);
          this._unsetOnCancel();
        }
      };
      Promise2.prototype._resultCancelled = function() {
        this.cancel();
      };
    };
  }
});

// node_modules/bluebird/js/release/direct_resolve.js
var require_direct_resolve = __commonJS({
  "node_modules/bluebird/js/release/direct_resolve.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      function returner() {
        return this.value;
      }
      function thrower2() {
        throw this.reason;
      }
      Promise2.prototype["return"] = Promise2.prototype.thenReturn = function(value) {
        if (value instanceof Promise2) value.suppressUnhandledRejections();
        return this._then(
          returner,
          void 0,
          void 0,
          { value },
          void 0
        );
      };
      Promise2.prototype["throw"] = Promise2.prototype.thenThrow = function(reason) {
        return this._then(
          thrower2,
          void 0,
          void 0,
          { reason },
          void 0
        );
      };
      Promise2.prototype.catchThrow = function(reason) {
        if (arguments.length <= 1) {
          return this._then(
            void 0,
            thrower2,
            void 0,
            { reason },
            void 0
          );
        } else {
          var _reason = arguments[1];
          var handler2 = function() {
            throw _reason;
          };
          return this.caught(reason, handler2);
        }
      };
      Promise2.prototype.catchReturn = function(value) {
        if (arguments.length <= 1) {
          if (value instanceof Promise2) value.suppressUnhandledRejections();
          return this._then(
            void 0,
            returner,
            void 0,
            { value },
            void 0
          );
        } else {
          var _value = arguments[1];
          if (_value instanceof Promise2) _value.suppressUnhandledRejections();
          var handler2 = function() {
            return _value;
          };
          return this.caught(value, handler2);
        }
      };
    };
  }
});

// node_modules/bluebird/js/release/synchronous_inspection.js
var require_synchronous_inspection = __commonJS({
  "node_modules/bluebird/js/release/synchronous_inspection.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      function PromiseInspection(promise) {
        if (promise !== void 0) {
          promise = promise._target();
          this._bitField = promise._bitField;
          this._settledValueField = promise._isFateSealed() ? promise._settledValue() : void 0;
        } else {
          this._bitField = 0;
          this._settledValueField = void 0;
        }
      }
      PromiseInspection.prototype._settledValue = function() {
        return this._settledValueField;
      };
      var value = PromiseInspection.prototype.value = function() {
        if (!this.isFulfilled()) {
          throw new TypeError("cannot get fulfillment value of a non-fulfilled promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var reason = PromiseInspection.prototype.error = PromiseInspection.prototype.reason = function() {
        if (!this.isRejected()) {
          throw new TypeError("cannot get rejection reason of a non-rejected promise\n\n    See http://goo.gl/MqrFmX\n");
        }
        return this._settledValue();
      };
      var isFulfilled = PromiseInspection.prototype.isFulfilled = function() {
        return (this._bitField & 33554432) !== 0;
      };
      var isRejected = PromiseInspection.prototype.isRejected = function() {
        return (this._bitField & 16777216) !== 0;
      };
      var isPending = PromiseInspection.prototype.isPending = function() {
        return (this._bitField & 50397184) === 0;
      };
      var isResolved = PromiseInspection.prototype.isResolved = function() {
        return (this._bitField & 50331648) !== 0;
      };
      PromiseInspection.prototype.isCancelled = function() {
        return (this._bitField & 8454144) !== 0;
      };
      Promise2.prototype.__isCancelled = function() {
        return (this._bitField & 65536) === 65536;
      };
      Promise2.prototype._isCancelled = function() {
        return this._target().__isCancelled();
      };
      Promise2.prototype.isCancelled = function() {
        return (this._target()._bitField & 8454144) !== 0;
      };
      Promise2.prototype.isPending = function() {
        return isPending.call(this._target());
      };
      Promise2.prototype.isRejected = function() {
        return isRejected.call(this._target());
      };
      Promise2.prototype.isFulfilled = function() {
        return isFulfilled.call(this._target());
      };
      Promise2.prototype.isResolved = function() {
        return isResolved.call(this._target());
      };
      Promise2.prototype.value = function() {
        return value.call(this._target());
      };
      Promise2.prototype.reason = function() {
        var target = this._target();
        target._unsetRejectionIsUnhandled();
        return reason.call(target);
      };
      Promise2.prototype._value = function() {
        return this._settledValue();
      };
      Promise2.prototype._reason = function() {
        this._unsetRejectionIsUnhandled();
        return this._settledValue();
      };
      Promise2.PromiseInspection = PromiseInspection;
    };
  }
});

// node_modules/bluebird/js/release/join.js
var require_join = __commonJS({
  "node_modules/bluebird/js/release/join.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, INTERNAL2, async, getDomain) {
      var util = require_util();
      var canEvaluate2 = util.canEvaluate;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var reject2;
      if (true) {
        if (canEvaluate2) {
          var thenCallback = function(i2) {
            return new Function("value", "holder", "                             \n            'use strict';                                                    \n            holder.pIndex = value;                                           \n            holder.checkFulfillment(this);                                   \n            ".replace(/Index/g, i2));
          };
          var promiseSetter = function(i2) {
            return new Function("promise", "holder", "                           \n            'use strict';                                                    \n            holder.pIndex = promise;                                         \n            ".replace(/Index/g, i2));
          };
          var generateHolderClass = function(total) {
            var props = new Array(total);
            for (var i2 = 0; i2 < props.length; ++i2) {
              props[i2] = "this.p" + (i2 + 1);
            }
            var assignment = props.join(" = ") + " = null;";
            var cancellationCode = "var promise;\n" + props.map(function(prop) {
              return "                                                         \n                promise = " + prop + ";                                      \n                if (promise instanceof Promise) {                            \n                    promise.cancel();                                        \n                }                                                            \n            ";
            }).join("\n");
            var passedArguments = props.join(", ");
            var name = "Holder$" + total;
            var code = "return function(tryCatch, errorObj, Promise, async) {    \n            'use strict';                                                    \n            function [TheName](fn) {                                         \n                [TheProperties]                                              \n                this.fn = fn;                                                \n                this.asyncNeeded = true;                                     \n                this.now = 0;                                                \n            }                                                                \n                                                                             \n            [TheName].prototype._callFunction = function(promise) {          \n                promise._pushContext();                                      \n                var ret = tryCatch(this.fn)([ThePassedArguments]);           \n                promise._popContext();                                       \n                if (ret === errorObj) {                                      \n                    promise._rejectCallback(ret.e, false);                   \n                } else {                                                     \n                    promise._resolveCallback(ret);                           \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype.checkFulfillment = function(promise) {       \n                var now = ++this.now;                                        \n                if (now === [TheTotal]) {                                    \n                    if (this.asyncNeeded) {                                  \n                        async.invoke(this._callFunction, this, promise);     \n                    } else {                                                 \n                        this._callFunction(promise);                         \n                    }                                                        \n                                                                             \n                }                                                            \n            };                                                               \n                                                                             \n            [TheName].prototype._resultCancelled = function() {              \n                [CancellationCode]                                           \n            };                                                               \n                                                                             \n            return [TheName];                                                \n        }(tryCatch, errorObj, Promise, async);                               \n        ";
            code = code.replace(/\[TheName\]/g, name).replace(/\[TheTotal\]/g, total).replace(/\[ThePassedArguments\]/g, passedArguments).replace(/\[TheProperties\]/g, assignment).replace(/\[CancellationCode\]/g, cancellationCode);
            return new Function("tryCatch", "errorObj", "Promise", "async", code)(tryCatch2, errorObj2, Promise2, async);
          };
          var holderClasses = [];
          var thenCallbacks = [];
          var promiseSetters = [];
          for (var i = 0; i < 8; ++i) {
            holderClasses.push(generateHolderClass(i + 1));
            thenCallbacks.push(thenCallback(i + 1));
            promiseSetters.push(promiseSetter(i + 1));
          }
          reject2 = function(reason) {
            this._reject(reason);
          };
        }
      }
      Promise2.join = function() {
        var last2 = arguments.length - 1;
        var fn;
        if (last2 > 0 && typeof arguments[last2] === "function") {
          fn = arguments[last2];
          if (true) {
            if (last2 <= 8 && canEvaluate2) {
              var ret2 = new Promise2(INTERNAL2);
              ret2._captureStackTrace();
              var HolderClass = holderClasses[last2 - 1];
              var holder = new HolderClass(fn);
              var callbacks = thenCallbacks;
              for (var i2 = 0; i2 < last2; ++i2) {
                var maybePromise = tryConvertToPromise(arguments[i2], ret2);
                if (maybePromise instanceof Promise2) {
                  maybePromise = maybePromise._target();
                  var bitField = maybePromise._bitField;
                  ;
                  if ((bitField & 50397184) === 0) {
                    maybePromise._then(
                      callbacks[i2],
                      reject2,
                      void 0,
                      ret2,
                      holder
                    );
                    promiseSetters[i2](maybePromise, holder);
                    holder.asyncNeeded = false;
                  } else if ((bitField & 33554432) !== 0) {
                    callbacks[i2].call(
                      ret2,
                      maybePromise._value(),
                      holder
                    );
                  } else if ((bitField & 16777216) !== 0) {
                    ret2._reject(maybePromise._reason());
                  } else {
                    ret2._cancel();
                  }
                } else {
                  callbacks[i2].call(ret2, maybePromise, holder);
                }
              }
              if (!ret2._isFateSealed()) {
                if (holder.asyncNeeded) {
                  var domain = getDomain();
                  if (domain !== null) {
                    holder.fn = util.domainBind(domain, holder.fn);
                  }
                }
                ret2._setAsyncGuaranteed();
                ret2._setOnCancel(holder);
              }
              return ret2;
            }
          }
        }
        var $_len = arguments.length;
        var args = new Array($_len);
        for (var $_i = 0; $_i < $_len; ++$_i) {
          args[$_i] = arguments[$_i];
        }
        ;
        if (fn) args.pop();
        var ret2 = new PromiseArray(args).promise();
        return fn !== void 0 ? ret2.spread(fn) : ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/map.js
var require_map = __commonJS({
  "node_modules/bluebird/js/release/map.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL2, debug) {
      var getDomain = Promise2._getDomain;
      var util = require_util();
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      var async = Promise2._async;
      function MappingPromiseArray(promises, fn, limit, _filter) {
        this.constructor$(promises);
        this._promise._captureStackTrace();
        var domain = getDomain();
        this._callback = domain === null ? fn : util.domainBind(domain, fn);
        this._preservedValues = _filter === INTERNAL2 ? new Array(this.length()) : null;
        this._limit = limit;
        this._inFlight = 0;
        this._queue = [];
        async.invoke(this._asyncInit, this, void 0);
      }
      util.inherits(MappingPromiseArray, PromiseArray);
      MappingPromiseArray.prototype._asyncInit = function() {
        this._init$(void 0, -2);
      };
      MappingPromiseArray.prototype._init = function() {
      };
      MappingPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var values2 = this._values;
        var length = this.length();
        var preservedValues = this._preservedValues;
        var limit = this._limit;
        if (index < 0) {
          index = index * -1 - 1;
          values2[index] = value;
          if (limit >= 1) {
            this._inFlight--;
            this._drainQueue();
            if (this._isResolved()) return true;
          }
        } else {
          if (limit >= 1 && this._inFlight >= limit) {
            values2[index] = value;
            this._queue.push(index);
            return false;
          }
          if (preservedValues !== null) preservedValues[index] = value;
          var promise = this._promise;
          var callback = this._callback;
          var receiver = promise._boundValue();
          promise._pushContext();
          var ret2 = tryCatch2(callback).call(receiver, value, index, length);
          var promiseCreated = promise._popContext();
          debug.checkForgottenReturns(
            ret2,
            promiseCreated,
            preservedValues !== null ? "Promise.filter" : "Promise.map",
            promise
          );
          if (ret2 === errorObj2) {
            this._reject(ret2.e);
            return true;
          }
          var maybePromise = tryConvertToPromise(ret2, this._promise);
          if (maybePromise instanceof Promise2) {
            maybePromise = maybePromise._target();
            var bitField = maybePromise._bitField;
            ;
            if ((bitField & 50397184) === 0) {
              if (limit >= 1) this._inFlight++;
              values2[index] = maybePromise;
              maybePromise._proxy(this, (index + 1) * -1);
              return false;
            } else if ((bitField & 33554432) !== 0) {
              ret2 = maybePromise._value();
            } else if ((bitField & 16777216) !== 0) {
              this._reject(maybePromise._reason());
              return true;
            } else {
              this._cancel();
              return true;
            }
          }
          values2[index] = ret2;
        }
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= length) {
          if (preservedValues !== null) {
            this._filter(values2, preservedValues);
          } else {
            this._resolve(values2);
          }
          return true;
        }
        return false;
      };
      MappingPromiseArray.prototype._drainQueue = function() {
        var queue2 = this._queue;
        var limit = this._limit;
        var values2 = this._values;
        while (queue2.length > 0 && this._inFlight < limit) {
          if (this._isResolved()) return;
          var index = queue2.pop();
          this._promiseFulfilled(values2[index], index);
        }
      };
      MappingPromiseArray.prototype._filter = function(booleans, values2) {
        var len = values2.length;
        var ret2 = new Array(len);
        var j = 0;
        for (var i = 0; i < len; ++i) {
          if (booleans[i]) ret2[j++] = values2[i];
        }
        ret2.length = j;
        this._resolve(ret2);
      };
      MappingPromiseArray.prototype.preservedValues = function() {
        return this._preservedValues;
      };
      function map2(promises, fn, options, _filter) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var limit = 0;
        if (options !== void 0) {
          if (typeof options === "object" && options !== null) {
            if (typeof options.concurrency !== "number") {
              return Promise2.reject(
                new TypeError("'concurrency' must be a number but it is " + util.classString(options.concurrency))
              );
            }
            limit = options.concurrency;
          } else {
            return Promise2.reject(new TypeError(
              "options argument must be an object but it is " + util.classString(options)
            ));
          }
        }
        limit = typeof limit === "number" && isFinite(limit) && limit >= 1 ? limit : 0;
        return new MappingPromiseArray(promises, fn, limit, _filter).promise();
      }
      Promise2.prototype.map = function(fn, options) {
        return map2(this, fn, options, null);
      };
      Promise2.map = function(promises, fn, options, _filter) {
        return map2(promises, fn, options, _filter);
      };
    };
  }
});

// node_modules/bluebird/js/release/call_get.js
var require_call_get = __commonJS({
  "node_modules/bluebird/js/release/call_get.js"(exports2, module2) {
    "use strict";
    var cr = Object.create;
    if (cr) {
      callerCache = cr(null);
      getterCache = cr(null);
      callerCache[" size"] = getterCache[" size"] = 0;
    }
    var callerCache;
    var getterCache;
    module2.exports = function(Promise2) {
      var util = require_util();
      var canEvaluate2 = util.canEvaluate;
      var isIdentifier2 = util.isIdentifier;
      var getMethodCaller;
      var getGetter;
      if (true) {
        var makeMethodCaller = function(methodName) {
          return new Function("ensureMethod", "                                    \n        return function(obj) {                                               \n            'use strict'                                                     \n            var len = this.length;                                           \n            ensureMethod(obj, 'methodName');                                 \n            switch(len) {                                                    \n                case 1: return obj.methodName(this[0]);                      \n                case 2: return obj.methodName(this[0], this[1]);             \n                case 3: return obj.methodName(this[0], this[1], this[2]);    \n                case 0: return obj.methodName();                             \n                default:                                                     \n                    return obj.methodName.apply(obj, this);                  \n            }                                                                \n        };                                                                   \n        ".replace(/methodName/g, methodName))(ensureMethod);
        };
        var makeGetter = function(propertyName) {
          return new Function("obj", "                                             \n        'use strict';                                                        \n        return obj.propertyName;                                             \n        ".replace("propertyName", propertyName));
        };
        var getCompiled = function(name, compiler, cache) {
          var ret2 = cache[name];
          if (typeof ret2 !== "function") {
            if (!isIdentifier2(name)) {
              return null;
            }
            ret2 = compiler(name);
            cache[name] = ret2;
            cache[" size"]++;
            if (cache[" size"] > 512) {
              var keys2 = Object.keys(cache);
              for (var i = 0; i < 256; ++i) delete cache[keys2[i]];
              cache[" size"] = keys2.length - 256;
            }
          }
          return ret2;
        };
        getMethodCaller = function(name) {
          return getCompiled(name, makeMethodCaller, callerCache);
        };
        getGetter = function(name) {
          return getCompiled(name, makeGetter, getterCache);
        };
      }
      function ensureMethod(obj2, methodName) {
        var fn;
        if (obj2 != null) fn = obj2[methodName];
        if (typeof fn !== "function") {
          var message = "Object " + util.classString(obj2) + " has no method '" + util.toString(methodName) + "'";
          throw new Promise2.TypeError(message);
        }
        return fn;
      }
      function caller(obj2) {
        var methodName = this.pop();
        var fn = ensureMethod(obj2, methodName);
        return fn.apply(obj2, this);
      }
      Promise2.prototype.call = function(methodName) {
        var $_len = arguments.length;
        var args = new Array(Math.max($_len - 1, 0));
        for (var $_i = 1; $_i < $_len; ++$_i) {
          args[$_i - 1] = arguments[$_i];
        }
        ;
        if (true) {
          if (canEvaluate2) {
            var maybeCaller = getMethodCaller(methodName);
            if (maybeCaller !== null) {
              return this._then(
                maybeCaller,
                void 0,
                void 0,
                args,
                void 0
              );
            }
          }
        }
        args.push(methodName);
        return this._then(caller, void 0, void 0, args, void 0);
      };
      function namedGetter(obj2) {
        return obj2[this];
      }
      function indexedGetter(obj2) {
        var index = +this;
        if (index < 0) index = Math.max(0, index + obj2.length);
        return obj2[index];
      }
      Promise2.prototype.get = function(propertyName) {
        var isIndex = typeof propertyName === "number";
        var getter;
        if (!isIndex) {
          if (canEvaluate2) {
            var maybeGetter = getGetter(propertyName);
            getter = maybeGetter !== null ? maybeGetter : namedGetter;
          } else {
            getter = namedGetter;
          }
        } else {
          getter = indexedGetter;
        }
        return this._then(getter, void 0, void 0, propertyName, void 0);
      };
    };
  }
});

// node_modules/bluebird/js/release/using.js
var require_using = __commonJS({
  "node_modules/bluebird/js/release/using.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL2, debug) {
      var util = require_util();
      var TypeError2 = require_errors().TypeError;
      var inherits2 = require_util().inherits;
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var NULL = {};
      function thrower2(e) {
        setTimeout(function() {
          throw e;
        }, 0);
      }
      function castPreservingDisposable(thenable) {
        var maybePromise = tryConvertToPromise(thenable);
        if (maybePromise !== thenable && typeof thenable._isDisposable === "function" && typeof thenable._getDisposer === "function" && thenable._isDisposable()) {
          maybePromise._setDisposable(thenable._getDisposer());
        }
        return maybePromise;
      }
      function dispose(resources, inspection) {
        var i = 0;
        var len = resources.length;
        var ret2 = new Promise2(INTERNAL2);
        function iterator() {
          if (i >= len) return ret2._fulfill();
          var maybePromise = castPreservingDisposable(resources[i++]);
          if (maybePromise instanceof Promise2 && maybePromise._isDisposable()) {
            try {
              maybePromise = tryConvertToPromise(
                maybePromise._getDisposer().tryDispose(inspection),
                resources.promise
              );
            } catch (e) {
              return thrower2(e);
            }
            if (maybePromise instanceof Promise2) {
              return maybePromise._then(
                iterator,
                thrower2,
                null,
                null,
                null
              );
            }
          }
          iterator();
        }
        iterator();
        return ret2;
      }
      function Disposer(data, promise, context) {
        this._data = data;
        this._promise = promise;
        this._context = context;
      }
      Disposer.prototype.data = function() {
        return this._data;
      };
      Disposer.prototype.promise = function() {
        return this._promise;
      };
      Disposer.prototype.resource = function() {
        if (this.promise().isFulfilled()) {
          return this.promise().value();
        }
        return NULL;
      };
      Disposer.prototype.tryDispose = function(inspection) {
        var resource = this.resource();
        var context = this._context;
        if (context !== void 0) context._pushContext();
        var ret2 = resource !== NULL ? this.doDispose(resource, inspection) : null;
        if (context !== void 0) context._popContext();
        this._promise._unsetDisposable();
        this._data = null;
        return ret2;
      };
      Disposer.isDisposer = function(d) {
        return d != null && typeof d.resource === "function" && typeof d.tryDispose === "function";
      };
      function FunctionDisposer(fn, promise, context) {
        this.constructor$(fn, promise, context);
      }
      inherits2(FunctionDisposer, Disposer);
      FunctionDisposer.prototype.doDispose = function(resource, inspection) {
        var fn = this.data();
        return fn.call(resource, resource, inspection);
      };
      function maybeUnwrapDisposer(value) {
        if (Disposer.isDisposer(value)) {
          this.resources[this.index]._setDisposable(value);
          return value.promise();
        }
        return value;
      }
      function ResourceList(length) {
        this.length = length;
        this.promise = null;
        this[length - 1] = null;
      }
      ResourceList.prototype._resultCancelled = function() {
        var len = this.length;
        for (var i = 0; i < len; ++i) {
          var item = this[i];
          if (item instanceof Promise2) {
            item.cancel();
          }
        }
      };
      Promise2.using = function() {
        var len = arguments.length;
        if (len < 2) return apiRejection(
          "you must pass at least 2 arguments to Promise.using"
        );
        var fn = arguments[len - 1];
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var input;
        var spreadArgs = true;
        if (len === 2 && Array.isArray(arguments[0])) {
          input = arguments[0];
          len = input.length;
          spreadArgs = false;
        } else {
          input = arguments;
          len--;
        }
        var resources = new ResourceList(len);
        for (var i = 0; i < len; ++i) {
          var resource = input[i];
          if (Disposer.isDisposer(resource)) {
            var disposer = resource;
            resource = resource.promise();
            resource._setDisposable(disposer);
          } else {
            var maybePromise = tryConvertToPromise(resource);
            if (maybePromise instanceof Promise2) {
              resource = maybePromise._then(maybeUnwrapDisposer, null, null, {
                resources,
                index: i
              }, void 0);
            }
          }
          resources[i] = resource;
        }
        var reflectedResources = new Array(resources.length);
        for (var i = 0; i < reflectedResources.length; ++i) {
          reflectedResources[i] = Promise2.resolve(resources[i]).reflect();
        }
        var resultPromise = Promise2.all(reflectedResources).then(function(inspections) {
          for (var i2 = 0; i2 < inspections.length; ++i2) {
            var inspection = inspections[i2];
            if (inspection.isRejected()) {
              errorObj2.e = inspection.error();
              return errorObj2;
            } else if (!inspection.isFulfilled()) {
              resultPromise.cancel();
              return;
            }
            inspections[i2] = inspection.value();
          }
          promise._pushContext();
          fn = tryCatch2(fn);
          var ret2 = spreadArgs ? fn.apply(void 0, inspections) : fn(inspections);
          var promiseCreated = promise._popContext();
          debug.checkForgottenReturns(
            ret2,
            promiseCreated,
            "Promise.using",
            promise
          );
          return ret2;
        });
        var promise = resultPromise.lastly(function() {
          var inspection = new Promise2.PromiseInspection(resultPromise);
          return dispose(resources, inspection);
        });
        resources.promise = promise;
        promise._setOnCancel(resources);
        return promise;
      };
      Promise2.prototype._setDisposable = function(disposer) {
        this._bitField = this._bitField | 131072;
        this._disposer = disposer;
      };
      Promise2.prototype._isDisposable = function() {
        return (this._bitField & 131072) > 0;
      };
      Promise2.prototype._getDisposer = function() {
        return this._disposer;
      };
      Promise2.prototype._unsetDisposable = function() {
        this._bitField = this._bitField & ~131072;
        this._disposer = void 0;
      };
      Promise2.prototype.disposer = function(fn) {
        if (typeof fn === "function") {
          return new FunctionDisposer(fn, this, createContext());
        }
        throw new TypeError2();
      };
    };
  }
});

// node_modules/bluebird/js/release/timers.js
var require_timers = __commonJS({
  "node_modules/bluebird/js/release/timers.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL2, debug) {
      var util = require_util();
      var TimeoutError = Promise2.TimeoutError;
      function HandleWrapper(handle) {
        this.handle = handle;
      }
      HandleWrapper.prototype._resultCancelled = function() {
        clearTimeout(this.handle);
      };
      var afterValue = function(value) {
        return delay(+this).thenReturn(value);
      };
      var delay = Promise2.delay = function(ms, value) {
        var ret2;
        var handle;
        if (value !== void 0) {
          ret2 = Promise2.resolve(value)._then(afterValue, null, null, ms, void 0);
          if (debug.cancellation() && value instanceof Promise2) {
            ret2._setOnCancel(value);
          }
        } else {
          ret2 = new Promise2(INTERNAL2);
          handle = setTimeout(function() {
            ret2._fulfill();
          }, +ms);
          if (debug.cancellation()) {
            ret2._setOnCancel(new HandleWrapper(handle));
          }
          ret2._captureStackTrace();
        }
        ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.prototype.delay = function(ms) {
        return delay(ms, this);
      };
      var afterTimeout = function(promise, message, parent) {
        var err;
        if (typeof message !== "string") {
          if (message instanceof Error) {
            err = message;
          } else {
            err = new TimeoutError("operation timed out");
          }
        } else {
          err = new TimeoutError(message);
        }
        util.markAsOriginatingFromRejection(err);
        promise._attachExtraTrace(err);
        promise._reject(err);
        if (parent != null) {
          parent.cancel();
        }
      };
      function successClear(value) {
        clearTimeout(this.handle);
        return value;
      }
      function failureClear(reason) {
        clearTimeout(this.handle);
        throw reason;
      }
      Promise2.prototype.timeout = function(ms, message) {
        ms = +ms;
        var ret2, parent;
        var handleWrapper = new HandleWrapper(setTimeout(function timeoutTimeout() {
          if (ret2.isPending()) {
            afterTimeout(ret2, message, parent);
          }
        }, ms));
        if (debug.cancellation()) {
          parent = this.then();
          ret2 = parent._then(
            successClear,
            failureClear,
            void 0,
            handleWrapper,
            void 0
          );
          ret2._setOnCancel(handleWrapper);
        } else {
          ret2 = this._then(
            successClear,
            failureClear,
            void 0,
            handleWrapper,
            void 0
          );
        }
        return ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/generators.js
var require_generators = __commonJS({
  "node_modules/bluebird/js/release/generators.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, apiRejection, INTERNAL2, tryConvertToPromise, Proxyable, debug) {
      var errors = require_errors();
      var TypeError2 = errors.TypeError;
      var util = require_util();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      var yieldHandlers = [];
      function promiseFromYieldHandler(value, yieldHandlers2, traceParent) {
        for (var i = 0; i < yieldHandlers2.length; ++i) {
          traceParent._pushContext();
          var result2 = tryCatch2(yieldHandlers2[i])(value);
          traceParent._popContext();
          if (result2 === errorObj2) {
            traceParent._pushContext();
            var ret2 = Promise2.reject(errorObj2.e);
            traceParent._popContext();
            return ret2;
          }
          var maybePromise = tryConvertToPromise(result2, traceParent);
          if (maybePromise instanceof Promise2) return maybePromise;
        }
        return null;
      }
      function PromiseSpawn(generatorFunction, receiver, yieldHandler, stack) {
        if (debug.cancellation()) {
          var internal = new Promise2(INTERNAL2);
          var _finallyPromise = this._finallyPromise = new Promise2(INTERNAL2);
          this._promise = internal.lastly(function() {
            return _finallyPromise;
          });
          internal._captureStackTrace();
          internal._setOnCancel(this);
        } else {
          var promise = this._promise = new Promise2(INTERNAL2);
          promise._captureStackTrace();
        }
        this._stack = stack;
        this._generatorFunction = generatorFunction;
        this._receiver = receiver;
        this._generator = void 0;
        this._yieldHandlers = typeof yieldHandler === "function" ? [yieldHandler].concat(yieldHandlers) : yieldHandlers;
        this._yieldedPromise = null;
        this._cancellationPhase = false;
      }
      util.inherits(PromiseSpawn, Proxyable);
      PromiseSpawn.prototype._isResolved = function() {
        return this._promise === null;
      };
      PromiseSpawn.prototype._cleanup = function() {
        this._promise = this._generator = null;
        if (debug.cancellation() && this._finallyPromise !== null) {
          this._finallyPromise._fulfill();
          this._finallyPromise = null;
        }
      };
      PromiseSpawn.prototype._promiseCancelled = function() {
        if (this._isResolved()) return;
        var implementsReturn = typeof this._generator["return"] !== "undefined";
        var result2;
        if (!implementsReturn) {
          var reason = new Promise2.CancellationError(
            "generator .return() sentinel"
          );
          Promise2.coroutine.returnSentinel = reason;
          this._promise._attachExtraTrace(reason);
          this._promise._pushContext();
          result2 = tryCatch2(this._generator["throw"]).call(
            this._generator,
            reason
          );
          this._promise._popContext();
        } else {
          this._promise._pushContext();
          result2 = tryCatch2(this._generator["return"]).call(
            this._generator,
            void 0
          );
          this._promise._popContext();
        }
        this._cancellationPhase = true;
        this._yieldedPromise = null;
        this._continue(result2);
      };
      PromiseSpawn.prototype._promiseFulfilled = function(value) {
        this._yieldedPromise = null;
        this._promise._pushContext();
        var result2 = tryCatch2(this._generator.next).call(this._generator, value);
        this._promise._popContext();
        this._continue(result2);
      };
      PromiseSpawn.prototype._promiseRejected = function(reason) {
        this._yieldedPromise = null;
        this._promise._attachExtraTrace(reason);
        this._promise._pushContext();
        var result2 = tryCatch2(this._generator["throw"]).call(this._generator, reason);
        this._promise._popContext();
        this._continue(result2);
      };
      PromiseSpawn.prototype._resultCancelled = function() {
        if (this._yieldedPromise instanceof Promise2) {
          var promise = this._yieldedPromise;
          this._yieldedPromise = null;
          promise.cancel();
        }
      };
      PromiseSpawn.prototype.promise = function() {
        return this._promise;
      };
      PromiseSpawn.prototype._run = function() {
        this._generator = this._generatorFunction.call(this._receiver);
        this._receiver = this._generatorFunction = void 0;
        this._promiseFulfilled(void 0);
      };
      PromiseSpawn.prototype._continue = function(result2) {
        var promise = this._promise;
        if (result2 === errorObj2) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._rejectCallback(result2.e, false);
          }
        }
        var value = result2.value;
        if (result2.done === true) {
          this._cleanup();
          if (this._cancellationPhase) {
            return promise.cancel();
          } else {
            return promise._resolveCallback(value);
          }
        } else {
          var maybePromise = tryConvertToPromise(value, this._promise);
          if (!(maybePromise instanceof Promise2)) {
            maybePromise = promiseFromYieldHandler(
              maybePromise,
              this._yieldHandlers,
              this._promise
            );
            if (maybePromise === null) {
              this._promiseRejected(
                new TypeError2(
                  "A value %s was yielded that could not be treated as a promise\n\n    See http://goo.gl/MqrFmX\n\n".replace("%s", value) + "From coroutine:\n" + this._stack.split("\n").slice(1, -7).join("\n")
                )
              );
              return;
            }
          }
          maybePromise = maybePromise._target();
          var bitField = maybePromise._bitField;
          ;
          if ((bitField & 50397184) === 0) {
            this._yieldedPromise = maybePromise;
            maybePromise._proxy(this, null);
          } else if ((bitField & 33554432) !== 0) {
            Promise2._async.invoke(
              this._promiseFulfilled,
              this,
              maybePromise._value()
            );
          } else if ((bitField & 16777216) !== 0) {
            Promise2._async.invoke(
              this._promiseRejected,
              this,
              maybePromise._reason()
            );
          } else {
            this._promiseCancelled();
          }
        }
      };
      Promise2.coroutine = function(generatorFunction, options) {
        if (typeof generatorFunction !== "function") {
          throw new TypeError2("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var yieldHandler = Object(options).yieldHandler;
        var PromiseSpawn$ = PromiseSpawn;
        var stack = new Error().stack;
        return function() {
          var generator = generatorFunction.apply(this, arguments);
          var spawn = new PromiseSpawn$(
            void 0,
            void 0,
            yieldHandler,
            stack
          );
          var ret2 = spawn.promise();
          spawn._generator = generator;
          spawn._promiseFulfilled(void 0);
          return ret2;
        };
      };
      Promise2.coroutine.addYieldHandler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        yieldHandlers.push(fn);
      };
      Promise2.spawn = function(generatorFunction) {
        debug.deprecated("Promise.spawn()", "Promise.coroutine()");
        if (typeof generatorFunction !== "function") {
          return apiRejection("generatorFunction must be a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        var spawn = new PromiseSpawn(generatorFunction, this);
        var ret2 = spawn.promise();
        spawn._run(Promise2.spawn);
        return ret2;
      };
    };
  }
});

// node_modules/bluebird/js/release/nodeify.js
var require_nodeify = __commonJS({
  "node_modules/bluebird/js/release/nodeify.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var util = require_util();
      var async = Promise2._async;
      var tryCatch2 = util.tryCatch;
      var errorObj2 = util.errorObj;
      function spreadAdapter(val, nodeback) {
        var promise = this;
        if (!util.isArray(val)) return successAdapter.call(promise, val, nodeback);
        var ret2 = tryCatch2(nodeback).apply(promise._boundValue(), [null].concat(val));
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function successAdapter(val, nodeback) {
        var promise = this;
        var receiver = promise._boundValue();
        var ret2 = val === void 0 ? tryCatch2(nodeback).call(receiver, null) : tryCatch2(nodeback).call(receiver, null, val);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      function errorAdapter(reason, nodeback) {
        var promise = this;
        if (!reason) {
          var newReason = new Error(reason + "");
          newReason.cause = reason;
          reason = newReason;
        }
        var ret2 = tryCatch2(nodeback).call(promise._boundValue(), reason);
        if (ret2 === errorObj2) {
          async.throwLater(ret2.e);
        }
      }
      Promise2.prototype.asCallback = Promise2.prototype.nodeify = function(nodeback, options) {
        if (typeof nodeback == "function") {
          var adapter = successAdapter;
          if (options !== void 0 && Object(options).spread) {
            adapter = spreadAdapter;
          }
          this._then(
            adapter,
            errorAdapter,
            void 0,
            this,
            nodeback
          );
        }
        return this;
      };
    };
  }
});

// node_modules/bluebird/js/release/promisify.js
var require_promisify = __commonJS({
  "node_modules/bluebird/js/release/promisify.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL2) {
      var THIS = {};
      var util = require_util();
      var nodebackForPromise = require_nodeback();
      var withAppended2 = util.withAppended;
      var maybeWrapAsError2 = util.maybeWrapAsError;
      var canEvaluate2 = util.canEvaluate;
      var TypeError2 = require_errors().TypeError;
      var defaultSuffix = "Async";
      var defaultPromisified = { __isPromisified__: true };
      var noCopyProps = [
        "arity",
        "length",
        "name",
        "arguments",
        "caller",
        "callee",
        "prototype",
        "__isPromisified__"
      ];
      var noCopyPropsPattern = new RegExp("^(?:" + noCopyProps.join("|") + ")$");
      var defaultFilter = function(name) {
        return util.isIdentifier(name) && name.charAt(0) !== "_" && name !== "constructor";
      };
      function propsFilter(key) {
        return !noCopyPropsPattern.test(key);
      }
      function isPromisified(fn) {
        try {
          return fn.__isPromisified__ === true;
        } catch (e) {
          return false;
        }
      }
      function hasPromisified(obj2, key, suffix) {
        var val = util.getDataPropertyOrDefault(
          obj2,
          key + suffix,
          defaultPromisified
        );
        return val ? isPromisified(val) : false;
      }
      function checkValid(ret2, suffix, suffixRegexp) {
        for (var i = 0; i < ret2.length; i += 2) {
          var key = ret2[i];
          if (suffixRegexp.test(key)) {
            var keyWithoutAsyncSuffix = key.replace(suffixRegexp, "");
            for (var j = 0; j < ret2.length; j += 2) {
              if (ret2[j] === keyWithoutAsyncSuffix) {
                throw new TypeError2("Cannot promisify an API that has normal methods with '%s'-suffix\n\n    See http://goo.gl/MqrFmX\n".replace("%s", suffix));
              }
            }
          }
        }
      }
      function promisifiableMethods(obj2, suffix, suffixRegexp, filter2) {
        var keys2 = util.inheritedDataKeys(obj2);
        var ret2 = [];
        for (var i = 0; i < keys2.length; ++i) {
          var key = keys2[i];
          var value = obj2[key];
          var passesDefaultFilter = filter2 === defaultFilter ? true : defaultFilter(key, value, obj2);
          if (typeof value === "function" && !isPromisified(value) && !hasPromisified(obj2, key, suffix) && filter2(key, value, obj2, passesDefaultFilter)) {
            ret2.push(key, value);
          }
        }
        checkValid(ret2, suffix, suffixRegexp);
        return ret2;
      }
      var escapeIdentRegex = function(str) {
        return str.replace(/([$])/, "\\$");
      };
      var makeNodePromisifiedEval;
      if (true) {
        var switchCaseArgumentOrder = function(likelyArgumentCount) {
          var ret2 = [likelyArgumentCount];
          var min2 = Math.max(0, likelyArgumentCount - 1 - 3);
          for (var i = likelyArgumentCount - 1; i >= min2; --i) {
            ret2.push(i);
          }
          for (var i = likelyArgumentCount + 1; i <= 3; ++i) {
            ret2.push(i);
          }
          return ret2;
        };
        var argumentSequence = function(argumentCount) {
          return util.filledRange(argumentCount, "_arg", "");
        };
        var parameterDeclaration = function(parameterCount2) {
          return util.filledRange(
            Math.max(parameterCount2, 3),
            "_arg",
            ""
          );
        };
        var parameterCount = function(fn) {
          if (typeof fn.length === "number") {
            return Math.max(Math.min(fn.length, 1023 + 1), 0);
          }
          return 0;
        };
        makeNodePromisifiedEval = function(callback, receiver, originalName, fn, _3, multiArgs) {
          var newParameterCount = Math.max(0, parameterCount(fn) - 1);
          var argumentOrder = switchCaseArgumentOrder(newParameterCount);
          var shouldProxyThis = typeof callback === "string" || receiver === THIS;
          function generateCallForArgumentCount(count) {
            var args = argumentSequence(count).join(", ");
            var comma = count > 0 ? ", " : "";
            var ret2;
            if (shouldProxyThis) {
              ret2 = "ret = callback.call(this, {{args}}, nodeback); break;\n";
            } else {
              ret2 = receiver === void 0 ? "ret = callback({{args}}, nodeback); break;\n" : "ret = callback.call(receiver, {{args}}, nodeback); break;\n";
            }
            return ret2.replace("{{args}}", args).replace(", ", comma);
          }
          function generateArgumentSwitchCase() {
            var ret2 = "";
            for (var i = 0; i < argumentOrder.length; ++i) {
              ret2 += "case " + argumentOrder[i] + ":" + generateCallForArgumentCount(argumentOrder[i]);
            }
            ret2 += "                                                             \n        default:                                                             \n            var args = new Array(len + 1);                                   \n            var i = 0;                                                       \n            for (var i = 0; i < len; ++i) {                                  \n               args[i] = arguments[i];                                       \n            }                                                                \n            args[i] = nodeback;                                              \n            [CodeForCall]                                                    \n            break;                                                           \n        ".replace("[CodeForCall]", shouldProxyThis ? "ret = callback.apply(this, args);\n" : "ret = callback.apply(receiver, args);\n");
            return ret2;
          }
          var getFunctionCode = typeof callback === "string" ? "this != null ? this['" + callback + "'] : fn" : "fn";
          var body = "'use strict';                                                \n        var ret = function (Parameters) {                                    \n            'use strict';                                                    \n            var len = arguments.length;                                      \n            var promise = new Promise(INTERNAL);                             \n            promise._captureStackTrace();                                    \n            var nodeback = nodebackForPromise(promise, " + multiArgs + ");   \n            var ret;                                                         \n            var callback = tryCatch([GetFunctionCode]);                      \n            switch(len) {                                                    \n                [CodeForSwitchCase]                                          \n            }                                                                \n            if (ret === errorObj) {                                          \n                promise._rejectCallback(maybeWrapAsError(ret.e), true, true);\n            }                                                                \n            if (!promise._isFateSealed()) promise._setAsyncGuaranteed();     \n            return promise;                                                  \n        };                                                                   \n        notEnumerableProp(ret, '__isPromisified__', true);                   \n        return ret;                                                          \n    ".replace("[CodeForSwitchCase]", generateArgumentSwitchCase()).replace("[GetFunctionCode]", getFunctionCode);
          body = body.replace("Parameters", parameterDeclaration(newParameterCount));
          return new Function(
            "Promise",
            "fn",
            "receiver",
            "withAppended",
            "maybeWrapAsError",
            "nodebackForPromise",
            "tryCatch",
            "errorObj",
            "notEnumerableProp",
            "INTERNAL",
            body
          )(
            Promise2,
            fn,
            receiver,
            withAppended2,
            maybeWrapAsError2,
            nodebackForPromise,
            util.tryCatch,
            util.errorObj,
            util.notEnumerableProp,
            INTERNAL2
          );
        };
      }
      function makeNodePromisifiedClosure(callback, receiver, _3, fn, __, multiArgs) {
        var defaultThis = /* @__PURE__ */ (function() {
          return this;
        })();
        var method = callback;
        if (typeof method === "string") {
          callback = fn;
        }
        function promisified() {
          var _receiver = receiver;
          if (receiver === THIS) _receiver = this;
          var promise = new Promise2(INTERNAL2);
          promise._captureStackTrace();
          var cb2 = typeof method === "string" && this !== defaultThis ? this[method] : callback;
          var fn2 = nodebackForPromise(promise, multiArgs);
          try {
            cb2.apply(_receiver, withAppended2(arguments, fn2));
          } catch (e) {
            promise._rejectCallback(maybeWrapAsError2(e), true, true);
          }
          if (!promise._isFateSealed()) promise._setAsyncGuaranteed();
          return promise;
        }
        util.notEnumerableProp(promisified, "__isPromisified__", true);
        return promisified;
      }
      var makeNodePromisified = canEvaluate2 ? makeNodePromisifiedEval : makeNodePromisifiedClosure;
      function promisifyAll(obj2, suffix, filter2, promisifier, multiArgs) {
        var suffixRegexp = new RegExp(escapeIdentRegex(suffix) + "$");
        var methods = promisifiableMethods(obj2, suffix, suffixRegexp, filter2);
        for (var i = 0, len = methods.length; i < len; i += 2) {
          var key = methods[i];
          var fn = methods[i + 1];
          var promisifiedKey = key + suffix;
          if (promisifier === makeNodePromisified) {
            obj2[promisifiedKey] = makeNodePromisified(key, THIS, key, fn, suffix, multiArgs);
          } else {
            var promisified = promisifier(fn, function() {
              return makeNodePromisified(
                key,
                THIS,
                key,
                fn,
                suffix,
                multiArgs
              );
            });
            util.notEnumerableProp(promisified, "__isPromisified__", true);
            obj2[promisifiedKey] = promisified;
          }
        }
        util.toFastProperties(obj2);
        return obj2;
      }
      function promisify(callback, receiver, multiArgs) {
        return makeNodePromisified(
          callback,
          receiver,
          void 0,
          callback,
          null,
          multiArgs
        );
      }
      Promise2.promisify = function(fn, options) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        if (isPromisified(fn)) {
          return fn;
        }
        options = Object(options);
        var receiver = options.context === void 0 ? THIS : options.context;
        var multiArgs = !!options.multiArgs;
        var ret2 = promisify(fn, receiver, multiArgs);
        util.copyDescriptors(fn, ret2, propsFilter);
        return ret2;
      };
      Promise2.promisifyAll = function(target, options) {
        if (typeof target !== "function" && typeof target !== "object") {
          throw new TypeError2("the target of promisifyAll must be an object or a function\n\n    See http://goo.gl/MqrFmX\n");
        }
        options = Object(options);
        var multiArgs = !!options.multiArgs;
        var suffix = options.suffix;
        if (typeof suffix !== "string") suffix = defaultSuffix;
        var filter2 = options.filter;
        if (typeof filter2 !== "function") filter2 = defaultFilter;
        var promisifier = options.promisifier;
        if (typeof promisifier !== "function") promisifier = makeNodePromisified;
        if (!util.isIdentifier(suffix)) {
          throw new RangeError("suffix must be a valid identifier\n\n    See http://goo.gl/MqrFmX\n");
        }
        var keys2 = util.inheritedDataKeys(target);
        for (var i = 0; i < keys2.length; ++i) {
          var value = target[keys2[i]];
          if (keys2[i] !== "constructor" && util.isClass(value)) {
            promisifyAll(
              value.prototype,
              suffix,
              filter2,
              promisifier,
              multiArgs
            );
            promisifyAll(value, suffix, filter2, promisifier, multiArgs);
          }
        }
        return promisifyAll(target, suffix, filter2, promisifier, multiArgs);
      };
    };
  }
});

// node_modules/bluebird/js/release/props.js
var require_props = __commonJS({
  "node_modules/bluebird/js/release/props.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, tryConvertToPromise, apiRejection) {
      var util = require_util();
      var isObject3 = util.isObject;
      var es52 = require_es5();
      var Es6Map;
      if (typeof Map === "function") Es6Map = Map;
      var mapToEntries = /* @__PURE__ */ (function() {
        var index = 0;
        var size2 = 0;
        function extractEntry(value, key) {
          this[index] = value;
          this[index + size2] = key;
          index++;
        }
        return function mapToEntries2(map2) {
          size2 = map2.size;
          index = 0;
          var ret2 = new Array(map2.size * 2);
          map2.forEach(extractEntry, ret2);
          return ret2;
        };
      })();
      var entriesToMap = function(entries) {
        var ret2 = new Es6Map();
        var length = entries.length / 2 | 0;
        for (var i = 0; i < length; ++i) {
          var key = entries[length + i];
          var value = entries[i];
          ret2.set(key, value);
        }
        return ret2;
      };
      function PropertiesPromiseArray(obj2) {
        var isMap = false;
        var entries;
        if (Es6Map !== void 0 && obj2 instanceof Es6Map) {
          entries = mapToEntries(obj2);
          isMap = true;
        } else {
          var keys2 = es52.keys(obj2);
          var len = keys2.length;
          entries = new Array(len * 2);
          for (var i = 0; i < len; ++i) {
            var key = keys2[i];
            entries[i] = obj2[key];
            entries[i + len] = key;
          }
        }
        this.constructor$(entries);
        this._isMap = isMap;
        this._init$(void 0, -3);
      }
      util.inherits(PropertiesPromiseArray, PromiseArray);
      PropertiesPromiseArray.prototype._init = function() {
      };
      PropertiesPromiseArray.prototype._promiseFulfilled = function(value, index) {
        this._values[index] = value;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          var val;
          if (this._isMap) {
            val = entriesToMap(this._values);
          } else {
            val = {};
            var keyOffset = this.length();
            for (var i = 0, len = this.length(); i < len; ++i) {
              val[this._values[i + keyOffset]] = this._values[i];
            }
          }
          this._resolve(val);
          return true;
        }
        return false;
      };
      PropertiesPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      PropertiesPromiseArray.prototype.getActualLength = function(len) {
        return len >> 1;
      };
      function props(promises) {
        var ret2;
        var castValue = tryConvertToPromise(promises);
        if (!isObject3(castValue)) {
          return apiRejection("cannot await properties of a non-object\n\n    See http://goo.gl/MqrFmX\n");
        } else if (castValue instanceof Promise2) {
          ret2 = castValue._then(
            Promise2.props,
            void 0,
            void 0,
            void 0,
            void 0
          );
        } else {
          ret2 = new PropertiesPromiseArray(castValue).promise();
        }
        if (castValue instanceof Promise2) {
          ret2._propagateFrom(castValue, 2);
        }
        return ret2;
      }
      Promise2.prototype.props = function() {
        return props(this);
      };
      Promise2.props = function(promises) {
        return props(promises);
      };
    };
  }
});

// node_modules/bluebird/js/release/race.js
var require_race = __commonJS({
  "node_modules/bluebird/js/release/race.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL2, tryConvertToPromise, apiRejection) {
      var util = require_util();
      var raceLater = function(promise) {
        return promise.then(function(array) {
          return race(array, promise);
        });
      };
      function race(promises, parent) {
        var maybePromise = tryConvertToPromise(promises);
        if (maybePromise instanceof Promise2) {
          return raceLater(maybePromise);
        } else {
          promises = util.asArray(promises);
          if (promises === null)
            return apiRejection("expecting an array or an iterable object but got " + util.classString(promises));
        }
        var ret2 = new Promise2(INTERNAL2);
        if (parent !== void 0) {
          ret2._propagateFrom(parent, 3);
        }
        var fulfill = ret2._fulfill;
        var reject2 = ret2._reject;
        for (var i = 0, len = promises.length; i < len; ++i) {
          var val = promises[i];
          if (val === void 0 && !(i in promises)) {
            continue;
          }
          Promise2.cast(val)._then(fulfill, reject2, void 0, ret2, null);
        }
        return ret2;
      }
      Promise2.race = function(promises) {
        return race(promises, void 0);
      };
      Promise2.prototype.race = function() {
        return race(this, void 0);
      };
    };
  }
});

// node_modules/bluebird/js/release/reduce.js
var require_reduce = __commonJS({
  "node_modules/bluebird/js/release/reduce.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL2, debug) {
      var getDomain = Promise2._getDomain;
      var util = require_util();
      var tryCatch2 = util.tryCatch;
      function ReductionPromiseArray(promises, fn, initialValue, _each) {
        this.constructor$(promises);
        var domain = getDomain();
        this._fn = domain === null ? fn : util.domainBind(domain, fn);
        if (initialValue !== void 0) {
          initialValue = Promise2.resolve(initialValue);
          initialValue._attachCancellationCallback(this);
        }
        this._initialValue = initialValue;
        this._currentCancellable = null;
        if (_each === INTERNAL2) {
          this._eachValues = Array(this._length);
        } else if (_each === 0) {
          this._eachValues = null;
        } else {
          this._eachValues = void 0;
        }
        this._promise._captureStackTrace();
        this._init$(void 0, -5);
      }
      util.inherits(ReductionPromiseArray, PromiseArray);
      ReductionPromiseArray.prototype._gotAccum = function(accum) {
        if (this._eachValues !== void 0 && this._eachValues !== null && accum !== INTERNAL2) {
          this._eachValues.push(accum);
        }
      };
      ReductionPromiseArray.prototype._eachComplete = function(value) {
        if (this._eachValues !== null) {
          this._eachValues.push(value);
        }
        return this._eachValues;
      };
      ReductionPromiseArray.prototype._init = function() {
      };
      ReductionPromiseArray.prototype._resolveEmptyArray = function() {
        this._resolve(this._eachValues !== void 0 ? this._eachValues : this._initialValue);
      };
      ReductionPromiseArray.prototype.shouldCopyValues = function() {
        return false;
      };
      ReductionPromiseArray.prototype._resolve = function(value) {
        this._promise._resolveCallback(value);
        this._values = null;
      };
      ReductionPromiseArray.prototype._resultCancelled = function(sender) {
        if (sender === this._initialValue) return this._cancel();
        if (this._isResolved()) return;
        this._resultCancelled$();
        if (this._currentCancellable instanceof Promise2) {
          this._currentCancellable.cancel();
        }
        if (this._initialValue instanceof Promise2) {
          this._initialValue.cancel();
        }
      };
      ReductionPromiseArray.prototype._iterate = function(values2) {
        this._values = values2;
        var value;
        var i;
        var length = values2.length;
        if (this._initialValue !== void 0) {
          value = this._initialValue;
          i = 0;
        } else {
          value = Promise2.resolve(values2[0]);
          i = 1;
        }
        this._currentCancellable = value;
        if (!value.isRejected()) {
          for (; i < length; ++i) {
            var ctx = {
              accum: null,
              value: values2[i],
              index: i,
              length,
              array: this
            };
            value = value._then(gotAccum, void 0, void 0, ctx, void 0);
          }
        }
        if (this._eachValues !== void 0) {
          value = value._then(this._eachComplete, void 0, void 0, this, void 0);
        }
        value._then(completed, completed, void 0, value, this);
      };
      Promise2.prototype.reduce = function(fn, initialValue) {
        return reduce(this, fn, initialValue, null);
      };
      Promise2.reduce = function(promises, fn, initialValue, _each) {
        return reduce(promises, fn, initialValue, _each);
      };
      function completed(valueOrReason, array) {
        if (this.isFulfilled()) {
          array._resolve(valueOrReason);
        } else {
          array._reject(valueOrReason);
        }
      }
      function reduce(promises, fn, initialValue, _each) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        var array = new ReductionPromiseArray(promises, fn, initialValue, _each);
        return array.promise();
      }
      function gotAccum(accum) {
        this.accum = accum;
        this.array._gotAccum(accum);
        var value = tryConvertToPromise(this.value, this.array._promise);
        if (value instanceof Promise2) {
          this.array._currentCancellable = value;
          return value._then(gotValue, void 0, void 0, this, void 0);
        } else {
          return gotValue.call(this, value);
        }
      }
      function gotValue(value) {
        var array = this.array;
        var promise = array._promise;
        var fn = tryCatch2(array._fn);
        promise._pushContext();
        var ret2;
        if (array._eachValues !== void 0) {
          ret2 = fn.call(promise._boundValue(), value, this.index, this.length);
        } else {
          ret2 = fn.call(
            promise._boundValue(),
            this.accum,
            value,
            this.index,
            this.length
          );
        }
        if (ret2 instanceof Promise2) {
          array._currentCancellable = ret2;
        }
        var promiseCreated = promise._popContext();
        debug.checkForgottenReturns(
          ret2,
          promiseCreated,
          array._eachValues !== void 0 ? "Promise.each" : "Promise.reduce",
          promise
        );
        return ret2;
      }
    };
  }
});

// node_modules/bluebird/js/release/settle.js
var require_settle = __commonJS({
  "node_modules/bluebird/js/release/settle.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, debug) {
      var PromiseInspection = Promise2.PromiseInspection;
      var util = require_util();
      function SettledPromiseArray(values2) {
        this.constructor$(values2);
      }
      util.inherits(SettledPromiseArray, PromiseArray);
      SettledPromiseArray.prototype._promiseResolved = function(index, inspection) {
        this._values[index] = inspection;
        var totalResolved = ++this._totalResolved;
        if (totalResolved >= this._length) {
          this._resolve(this._values);
          return true;
        }
        return false;
      };
      SettledPromiseArray.prototype._promiseFulfilled = function(value, index) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 33554432;
        ret2._settledValueField = value;
        return this._promiseResolved(index, ret2);
      };
      SettledPromiseArray.prototype._promiseRejected = function(reason, index) {
        var ret2 = new PromiseInspection();
        ret2._bitField = 16777216;
        ret2._settledValueField = reason;
        return this._promiseResolved(index, ret2);
      };
      Promise2.settle = function(promises) {
        debug.deprecated(".settle()", ".reflect()");
        return new SettledPromiseArray(promises).promise();
      };
      Promise2.prototype.settle = function() {
        return Promise2.settle(this);
      };
    };
  }
});

// node_modules/bluebird/js/release/some.js
var require_some = __commonJS({
  "node_modules/bluebird/js/release/some.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, PromiseArray, apiRejection) {
      var util = require_util();
      var RangeError2 = require_errors().RangeError;
      var AggregateError = require_errors().AggregateError;
      var isArray = util.isArray;
      var CANCELLATION = {};
      function SomePromiseArray(values2) {
        this.constructor$(values2);
        this._howMany = 0;
        this._unwrap = false;
        this._initialized = false;
      }
      util.inherits(SomePromiseArray, PromiseArray);
      SomePromiseArray.prototype._init = function() {
        if (!this._initialized) {
          return;
        }
        if (this._howMany === 0) {
          this._resolve([]);
          return;
        }
        this._init$(void 0, -5);
        var isArrayResolved = isArray(this._values);
        if (!this._isResolved() && isArrayResolved && this._howMany > this._canPossiblyFulfill()) {
          this._reject(this._getRangeError(this.length()));
        }
      };
      SomePromiseArray.prototype.init = function() {
        this._initialized = true;
        this._init();
      };
      SomePromiseArray.prototype.setUnwrap = function() {
        this._unwrap = true;
      };
      SomePromiseArray.prototype.howMany = function() {
        return this._howMany;
      };
      SomePromiseArray.prototype.setHowMany = function(count) {
        this._howMany = count;
      };
      SomePromiseArray.prototype._promiseFulfilled = function(value) {
        this._addFulfilled(value);
        if (this._fulfilled() === this.howMany()) {
          this._values.length = this.howMany();
          if (this.howMany() === 1 && this._unwrap) {
            this._resolve(this._values[0]);
          } else {
            this._resolve(this._values);
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._promiseRejected = function(reason) {
        this._addRejected(reason);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._promiseCancelled = function() {
        if (this._values instanceof Promise2 || this._values == null) {
          return this._cancel();
        }
        this._addRejected(CANCELLATION);
        return this._checkOutcome();
      };
      SomePromiseArray.prototype._checkOutcome = function() {
        if (this.howMany() > this._canPossiblyFulfill()) {
          var e = new AggregateError();
          for (var i = this.length(); i < this._values.length; ++i) {
            if (this._values[i] !== CANCELLATION) {
              e.push(this._values[i]);
            }
          }
          if (e.length > 0) {
            this._reject(e);
          } else {
            this._cancel();
          }
          return true;
        }
        return false;
      };
      SomePromiseArray.prototype._fulfilled = function() {
        return this._totalResolved;
      };
      SomePromiseArray.prototype._rejected = function() {
        return this._values.length - this.length();
      };
      SomePromiseArray.prototype._addRejected = function(reason) {
        this._values.push(reason);
      };
      SomePromiseArray.prototype._addFulfilled = function(value) {
        this._values[this._totalResolved++] = value;
      };
      SomePromiseArray.prototype._canPossiblyFulfill = function() {
        return this.length() - this._rejected();
      };
      SomePromiseArray.prototype._getRangeError = function(count) {
        var message = "Input array must contain at least " + this._howMany + " items but contains only " + count + " items";
        return new RangeError2(message);
      };
      SomePromiseArray.prototype._resolveEmptyArray = function() {
        this._reject(this._getRangeError(0));
      };
      function some2(promises, howMany) {
        if ((howMany | 0) !== howMany || howMany < 0) {
          return apiRejection("expecting a positive integer\n\n    See http://goo.gl/MqrFmX\n");
        }
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(howMany);
        ret2.init();
        return promise;
      }
      Promise2.some = function(promises, howMany) {
        return some2(promises, howMany);
      };
      Promise2.prototype.some = function(howMany) {
        return some2(this, howMany);
      };
      Promise2._SomePromiseArray = SomePromiseArray;
    };
  }
});

// node_modules/bluebird/js/release/filter.js
var require_filter = __commonJS({
  "node_modules/bluebird/js/release/filter.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL2) {
      var PromiseMap = Promise2.map;
      Promise2.prototype.filter = function(fn, options) {
        return PromiseMap(this, fn, options, INTERNAL2);
      };
      Promise2.filter = function(promises, fn, options) {
        return PromiseMap(promises, fn, options, INTERNAL2);
      };
    };
  }
});

// node_modules/bluebird/js/release/each.js
var require_each = __commonJS({
  "node_modules/bluebird/js/release/each.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2, INTERNAL2) {
      var PromiseReduce = Promise2.reduce;
      var PromiseAll = Promise2.all;
      function promiseAllThis() {
        return PromiseAll(this);
      }
      function PromiseMapSeries(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL2, INTERNAL2);
      }
      Promise2.prototype.each = function(fn) {
        return PromiseReduce(this, fn, INTERNAL2, 0)._then(promiseAllThis, void 0, void 0, this, void 0);
      };
      Promise2.prototype.mapSeries = function(fn) {
        return PromiseReduce(this, fn, INTERNAL2, INTERNAL2);
      };
      Promise2.each = function(promises, fn) {
        return PromiseReduce(promises, fn, INTERNAL2, 0)._then(promiseAllThis, void 0, void 0, promises, void 0);
      };
      Promise2.mapSeries = PromiseMapSeries;
    };
  }
});

// node_modules/bluebird/js/release/any.js
var require_any = __commonJS({
  "node_modules/bluebird/js/release/any.js"(exports2, module2) {
    "use strict";
    module2.exports = function(Promise2) {
      var SomePromiseArray = Promise2._SomePromiseArray;
      function any(promises) {
        var ret2 = new SomePromiseArray(promises);
        var promise = ret2.promise();
        ret2.setHowMany(1);
        ret2.setUnwrap();
        ret2.init();
        return promise;
      }
      Promise2.any = function(promises) {
        return any(promises);
      };
      Promise2.prototype.any = function() {
        return any(this);
      };
    };
  }
});

// node_modules/bluebird/js/release/promise.js
var require_promise = __commonJS({
  "node_modules/bluebird/js/release/promise.js"(exports2, module2) {
    "use strict";
    module2.exports = function() {
      var makeSelfResolutionError = function() {
        return new TypeError2("circular promise resolution chain\n\n    See http://goo.gl/MqrFmX\n");
      };
      var reflectHandler = function() {
        return new Promise2.PromiseInspection(this._target());
      };
      var apiRejection = function(msg) {
        return Promise2.reject(new TypeError2(msg));
      };
      function Proxyable() {
      }
      var UNDEFINED_BINDING = {};
      var util = require_util();
      var getDomain;
      if (util.isNode) {
        getDomain = function() {
          var ret2 = process.domain;
          if (ret2 === void 0) ret2 = null;
          return ret2;
        };
      } else {
        getDomain = function() {
          return null;
        };
      }
      util.notEnumerableProp(Promise2, "_getDomain", getDomain);
      var es52 = require_es5();
      var Async = require_async();
      var async = new Async();
      es52.defineProperty(Promise2, "_async", { value: async });
      var errors = require_errors();
      var TypeError2 = Promise2.TypeError = errors.TypeError;
      Promise2.RangeError = errors.RangeError;
      var CancellationError = Promise2.CancellationError = errors.CancellationError;
      Promise2.TimeoutError = errors.TimeoutError;
      Promise2.OperationalError = errors.OperationalError;
      Promise2.RejectionError = errors.OperationalError;
      Promise2.AggregateError = errors.AggregateError;
      var INTERNAL2 = function() {
      };
      var APPLY = {};
      var NEXT_FILTER = {};
      var tryConvertToPromise = require_thenables()(Promise2, INTERNAL2);
      var PromiseArray = require_promise_array()(
        Promise2,
        INTERNAL2,
        tryConvertToPromise,
        apiRejection,
        Proxyable
      );
      var Context = require_context()(Promise2);
      var createContext = Context.create;
      var debug = require_debuggability()(Promise2, Context);
      var CapturedTrace = debug.CapturedTrace;
      var PassThroughHandlerContext = require_finally()(Promise2, tryConvertToPromise);
      var catchFilter = require_catch_filter()(NEXT_FILTER);
      var nodebackForPromise = require_nodeback();
      var errorObj2 = util.errorObj;
      var tryCatch2 = util.tryCatch;
      function check(self2, executor) {
        if (typeof executor !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(executor));
        }
        if (self2.constructor !== Promise2) {
          throw new TypeError2("the promise constructor cannot be invoked directly\n\n    See http://goo.gl/MqrFmX\n");
        }
      }
      function Promise2(executor) {
        this._bitField = 0;
        this._fulfillmentHandler0 = void 0;
        this._rejectionHandler0 = void 0;
        this._promise0 = void 0;
        this._receiver0 = void 0;
        if (executor !== INTERNAL2) {
          check(this, executor);
          this._resolveFromExecutor(executor);
        }
        this._promiseCreated();
        this._fireEvent("promiseCreated", this);
      }
      Promise2.prototype.toString = function() {
        return "[object Promise]";
      };
      Promise2.prototype.caught = Promise2.prototype["catch"] = function(fn) {
        var len = arguments.length;
        if (len > 1) {
          var catchInstances = new Array(len - 1), j = 0, i;
          for (i = 0; i < len - 1; ++i) {
            var item = arguments[i];
            if (util.isObject(item)) {
              catchInstances[j++] = item;
            } else {
              return apiRejection("expecting an object but got A catch statement predicate " + util.classString(item));
            }
          }
          catchInstances.length = j;
          fn = arguments[i];
          return this.then(void 0, catchFilter(catchInstances, fn, this));
        }
        return this.then(void 0, fn);
      };
      Promise2.prototype.reflect = function() {
        return this._then(
          reflectHandler,
          reflectHandler,
          void 0,
          this,
          void 0
        );
      };
      Promise2.prototype.then = function(didFulfill, didReject) {
        if (debug.warnings() && arguments.length > 0 && typeof didFulfill !== "function" && typeof didReject !== "function") {
          var msg = ".then() only accepts functions but was passed: " + util.classString(didFulfill);
          if (arguments.length > 1) {
            msg += ", " + util.classString(didReject);
          }
          this._warn(msg);
        }
        return this._then(didFulfill, didReject, void 0, void 0, void 0);
      };
      Promise2.prototype.done = function(didFulfill, didReject) {
        var promise = this._then(didFulfill, didReject, void 0, void 0, void 0);
        promise._setIsFinal();
      };
      Promise2.prototype.spread = function(fn) {
        if (typeof fn !== "function") {
          return apiRejection("expecting a function but got " + util.classString(fn));
        }
        return this.all()._then(fn, void 0, void 0, APPLY, void 0);
      };
      Promise2.prototype.toJSON = function() {
        var ret2 = {
          isFulfilled: false,
          isRejected: false,
          fulfillmentValue: void 0,
          rejectionReason: void 0
        };
        if (this.isFulfilled()) {
          ret2.fulfillmentValue = this.value();
          ret2.isFulfilled = true;
        } else if (this.isRejected()) {
          ret2.rejectionReason = this.reason();
          ret2.isRejected = true;
        }
        return ret2;
      };
      Promise2.prototype.all = function() {
        if (arguments.length > 0) {
          this._warn(".all() was passed arguments but it does not take any");
        }
        return new PromiseArray(this).promise();
      };
      Promise2.prototype.error = function(fn) {
        return this.caught(util.originatesFromRejection, fn);
      };
      Promise2.getNewLibraryCopy = module2.exports;
      Promise2.is = function(val) {
        return val instanceof Promise2;
      };
      Promise2.fromNode = Promise2.fromCallback = function(fn) {
        var ret2 = new Promise2(INTERNAL2);
        ret2._captureStackTrace();
        var multiArgs = arguments.length > 1 ? !!Object(arguments[1]).multiArgs : false;
        var result2 = tryCatch2(fn)(nodebackForPromise(ret2, multiArgs));
        if (result2 === errorObj2) {
          ret2._rejectCallback(result2.e, true);
        }
        if (!ret2._isFateSealed()) ret2._setAsyncGuaranteed();
        return ret2;
      };
      Promise2.all = function(promises) {
        return new PromiseArray(promises).promise();
      };
      Promise2.cast = function(obj2) {
        var ret2 = tryConvertToPromise(obj2);
        if (!(ret2 instanceof Promise2)) {
          ret2 = new Promise2(INTERNAL2);
          ret2._captureStackTrace();
          ret2._setFulfilled();
          ret2._rejectionHandler0 = obj2;
        }
        return ret2;
      };
      Promise2.resolve = Promise2.fulfilled = Promise2.cast;
      Promise2.reject = Promise2.rejected = function(reason) {
        var ret2 = new Promise2(INTERNAL2);
        ret2._captureStackTrace();
        ret2._rejectCallback(reason, true);
        return ret2;
      };
      Promise2.setScheduler = function(fn) {
        if (typeof fn !== "function") {
          throw new TypeError2("expecting a function but got " + util.classString(fn));
        }
        return async.setScheduler(fn);
      };
      Promise2.prototype._then = function(didFulfill, didReject, _3, receiver, internalData) {
        var haveInternalData = internalData !== void 0;
        var promise = haveInternalData ? internalData : new Promise2(INTERNAL2);
        var target = this._target();
        var bitField = target._bitField;
        if (!haveInternalData) {
          promise._propagateFrom(this, 3);
          promise._captureStackTrace();
          if (receiver === void 0 && (this._bitField & 2097152) !== 0) {
            if (!((bitField & 50397184) === 0)) {
              receiver = this._boundValue();
            } else {
              receiver = target === this ? void 0 : this._boundTo;
            }
          }
          this._fireEvent("promiseChained", this, promise);
        }
        var domain = getDomain();
        if (!((bitField & 50397184) === 0)) {
          var handler2, value, settler = target._settlePromiseCtx;
          if ((bitField & 33554432) !== 0) {
            value = target._rejectionHandler0;
            handler2 = didFulfill;
          } else if ((bitField & 16777216) !== 0) {
            value = target._fulfillmentHandler0;
            handler2 = didReject;
            target._unsetRejectionIsUnhandled();
          } else {
            settler = target._settlePromiseLateCancellationObserver;
            value = new CancellationError("late cancellation observer");
            target._attachExtraTrace(value);
            handler2 = didReject;
          }
          async.invoke(settler, target, {
            handler: domain === null ? handler2 : typeof handler2 === "function" && util.domainBind(domain, handler2),
            promise,
            receiver,
            value
          });
        } else {
          target._addCallbacks(didFulfill, didReject, promise, receiver, domain);
        }
        return promise;
      };
      Promise2.prototype._length = function() {
        return this._bitField & 65535;
      };
      Promise2.prototype._isFateSealed = function() {
        return (this._bitField & 117506048) !== 0;
      };
      Promise2.prototype._isFollowing = function() {
        return (this._bitField & 67108864) === 67108864;
      };
      Promise2.prototype._setLength = function(len) {
        this._bitField = this._bitField & -65536 | len & 65535;
      };
      Promise2.prototype._setFulfilled = function() {
        this._bitField = this._bitField | 33554432;
        this._fireEvent("promiseFulfilled", this);
      };
      Promise2.prototype._setRejected = function() {
        this._bitField = this._bitField | 16777216;
        this._fireEvent("promiseRejected", this);
      };
      Promise2.prototype._setFollowing = function() {
        this._bitField = this._bitField | 67108864;
        this._fireEvent("promiseResolved", this);
      };
      Promise2.prototype._setIsFinal = function() {
        this._bitField = this._bitField | 4194304;
      };
      Promise2.prototype._isFinal = function() {
        return (this._bitField & 4194304) > 0;
      };
      Promise2.prototype._unsetCancelled = function() {
        this._bitField = this._bitField & ~65536;
      };
      Promise2.prototype._setCancelled = function() {
        this._bitField = this._bitField | 65536;
        this._fireEvent("promiseCancelled", this);
      };
      Promise2.prototype._setWillBeCancelled = function() {
        this._bitField = this._bitField | 8388608;
      };
      Promise2.prototype._setAsyncGuaranteed = function() {
        if (async.hasCustomScheduler()) return;
        this._bitField = this._bitField | 134217728;
      };
      Promise2.prototype._receiverAt = function(index) {
        var ret2 = index === 0 ? this._receiver0 : this[index * 4 - 4 + 3];
        if (ret2 === UNDEFINED_BINDING) {
          return void 0;
        } else if (ret2 === void 0 && this._isBound()) {
          return this._boundValue();
        }
        return ret2;
      };
      Promise2.prototype._promiseAt = function(index) {
        return this[index * 4 - 4 + 2];
      };
      Promise2.prototype._fulfillmentHandlerAt = function(index) {
        return this[index * 4 - 4 + 0];
      };
      Promise2.prototype._rejectionHandlerAt = function(index) {
        return this[index * 4 - 4 + 1];
      };
      Promise2.prototype._boundValue = function() {
      };
      Promise2.prototype._migrateCallback0 = function(follower) {
        var bitField = follower._bitField;
        var fulfill = follower._fulfillmentHandler0;
        var reject2 = follower._rejectionHandler0;
        var promise = follower._promise0;
        var receiver = follower._receiverAt(0);
        if (receiver === void 0) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject2, promise, receiver, null);
      };
      Promise2.prototype._migrateCallbackAt = function(follower, index) {
        var fulfill = follower._fulfillmentHandlerAt(index);
        var reject2 = follower._rejectionHandlerAt(index);
        var promise = follower._promiseAt(index);
        var receiver = follower._receiverAt(index);
        if (receiver === void 0) receiver = UNDEFINED_BINDING;
        this._addCallbacks(fulfill, reject2, promise, receiver, null);
      };
      Promise2.prototype._addCallbacks = function(fulfill, reject2, promise, receiver, domain) {
        var index = this._length();
        if (index >= 65535 - 4) {
          index = 0;
          this._setLength(0);
        }
        if (index === 0) {
          this._promise0 = promise;
          this._receiver0 = receiver;
          if (typeof fulfill === "function") {
            this._fulfillmentHandler0 = domain === null ? fulfill : util.domainBind(domain, fulfill);
          }
          if (typeof reject2 === "function") {
            this._rejectionHandler0 = domain === null ? reject2 : util.domainBind(domain, reject2);
          }
        } else {
          var base = index * 4 - 4;
          this[base + 2] = promise;
          this[base + 3] = receiver;
          if (typeof fulfill === "function") {
            this[base + 0] = domain === null ? fulfill : util.domainBind(domain, fulfill);
          }
          if (typeof reject2 === "function") {
            this[base + 1] = domain === null ? reject2 : util.domainBind(domain, reject2);
          }
        }
        this._setLength(index + 1);
        return index;
      };
      Promise2.prototype._proxy = function(proxyable, arg) {
        this._addCallbacks(void 0, void 0, arg, proxyable, null);
      };
      Promise2.prototype._resolveCallback = function(value, shouldBind) {
        if ((this._bitField & 117506048) !== 0) return;
        if (value === this)
          return this._rejectCallback(makeSelfResolutionError(), false);
        var maybePromise = tryConvertToPromise(value, this);
        if (!(maybePromise instanceof Promise2)) return this._fulfill(value);
        if (shouldBind) this._propagateFrom(maybePromise, 2);
        var promise = maybePromise._target();
        if (promise === this) {
          this._reject(makeSelfResolutionError());
          return;
        }
        var bitField = promise._bitField;
        if ((bitField & 50397184) === 0) {
          var len = this._length();
          if (len > 0) promise._migrateCallback0(this);
          for (var i = 1; i < len; ++i) {
            promise._migrateCallbackAt(this, i);
          }
          this._setFollowing();
          this._setLength(0);
          this._setFollowee(promise);
        } else if ((bitField & 33554432) !== 0) {
          this._fulfill(promise._value());
        } else if ((bitField & 16777216) !== 0) {
          this._reject(promise._reason());
        } else {
          var reason = new CancellationError("late cancellation observer");
          promise._attachExtraTrace(reason);
          this._reject(reason);
        }
      };
      Promise2.prototype._rejectCallback = function(reason, synchronous, ignoreNonErrorWarnings) {
        var trace = util.ensureErrorObject(reason);
        var hasStack = trace === reason;
        if (!hasStack && !ignoreNonErrorWarnings && debug.warnings()) {
          var message = "a promise was rejected with a non-error: " + util.classString(reason);
          this._warn(message, true);
        }
        this._attachExtraTrace(trace, synchronous ? hasStack : false);
        this._reject(reason);
      };
      Promise2.prototype._resolveFromExecutor = function(executor) {
        var promise = this;
        this._captureStackTrace();
        this._pushContext();
        var synchronous = true;
        var r = this._execute(executor, function(value) {
          promise._resolveCallback(value);
        }, function(reason) {
          promise._rejectCallback(reason, synchronous);
        });
        synchronous = false;
        this._popContext();
        if (r !== void 0) {
          promise._rejectCallback(r, true);
        }
      };
      Promise2.prototype._settlePromiseFromHandler = function(handler2, receiver, value, promise) {
        var bitField = promise._bitField;
        if ((bitField & 65536) !== 0) return;
        promise._pushContext();
        var x;
        if (receiver === APPLY) {
          if (!value || typeof value.length !== "number") {
            x = errorObj2;
            x.e = new TypeError2("cannot .spread() a non-array: " + util.classString(value));
          } else {
            x = tryCatch2(handler2).apply(this._boundValue(), value);
          }
        } else {
          x = tryCatch2(handler2).call(receiver, value);
        }
        var promiseCreated = promise._popContext();
        bitField = promise._bitField;
        if ((bitField & 65536) !== 0) return;
        if (x === NEXT_FILTER) {
          promise._reject(value);
        } else if (x === errorObj2) {
          promise._rejectCallback(x.e, false);
        } else {
          debug.checkForgottenReturns(x, promiseCreated, "", promise, this);
          promise._resolveCallback(x);
        }
      };
      Promise2.prototype._target = function() {
        var ret2 = this;
        while (ret2._isFollowing()) ret2 = ret2._followee();
        return ret2;
      };
      Promise2.prototype._followee = function() {
        return this._rejectionHandler0;
      };
      Promise2.prototype._setFollowee = function(promise) {
        this._rejectionHandler0 = promise;
      };
      Promise2.prototype._settlePromise = function(promise, handler2, receiver, value) {
        var isPromise = promise instanceof Promise2;
        var bitField = this._bitField;
        var asyncGuaranteed = (bitField & 134217728) !== 0;
        if ((bitField & 65536) !== 0) {
          if (isPromise) promise._invokeInternalOnCancel();
          if (receiver instanceof PassThroughHandlerContext && receiver.isFinallyHandler()) {
            receiver.cancelPromise = promise;
            if (tryCatch2(handler2).call(receiver, value) === errorObj2) {
              promise._reject(errorObj2.e);
            }
          } else if (handler2 === reflectHandler) {
            promise._fulfill(reflectHandler.call(receiver));
          } else if (receiver instanceof Proxyable) {
            receiver._promiseCancelled(promise);
          } else if (isPromise || promise instanceof PromiseArray) {
            promise._cancel();
          } else {
            receiver.cancel();
          }
        } else if (typeof handler2 === "function") {
          if (!isPromise) {
            handler2.call(receiver, value, promise);
          } else {
            if (asyncGuaranteed) promise._setAsyncGuaranteed();
            this._settlePromiseFromHandler(handler2, receiver, value, promise);
          }
        } else if (receiver instanceof Proxyable) {
          if (!receiver._isResolved()) {
            if ((bitField & 33554432) !== 0) {
              receiver._promiseFulfilled(value, promise);
            } else {
              receiver._promiseRejected(value, promise);
            }
          }
        } else if (isPromise) {
          if (asyncGuaranteed) promise._setAsyncGuaranteed();
          if ((bitField & 33554432) !== 0) {
            promise._fulfill(value);
          } else {
            promise._reject(value);
          }
        }
      };
      Promise2.prototype._settlePromiseLateCancellationObserver = function(ctx) {
        var handler2 = ctx.handler;
        var promise = ctx.promise;
        var receiver = ctx.receiver;
        var value = ctx.value;
        if (typeof handler2 === "function") {
          if (!(promise instanceof Promise2)) {
            handler2.call(receiver, value, promise);
          } else {
            this._settlePromiseFromHandler(handler2, receiver, value, promise);
          }
        } else if (promise instanceof Promise2) {
          promise._reject(value);
        }
      };
      Promise2.prototype._settlePromiseCtx = function(ctx) {
        this._settlePromise(ctx.promise, ctx.handler, ctx.receiver, ctx.value);
      };
      Promise2.prototype._settlePromise0 = function(handler2, value, bitField) {
        var promise = this._promise0;
        var receiver = this._receiverAt(0);
        this._promise0 = void 0;
        this._receiver0 = void 0;
        this._settlePromise(promise, handler2, receiver, value);
      };
      Promise2.prototype._clearCallbackDataAtIndex = function(index) {
        var base = index * 4 - 4;
        this[base + 2] = this[base + 3] = this[base + 0] = this[base + 1] = void 0;
      };
      Promise2.prototype._fulfill = function(value) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        if (value === this) {
          var err = makeSelfResolutionError();
          this._attachExtraTrace(err);
          return this._reject(err);
        }
        this._setFulfilled();
        this._rejectionHandler0 = value;
        if ((bitField & 65535) > 0) {
          if ((bitField & 134217728) !== 0) {
            this._settlePromises();
          } else {
            async.settlePromises(this);
          }
        }
      };
      Promise2.prototype._reject = function(reason) {
        var bitField = this._bitField;
        if ((bitField & 117506048) >>> 16) return;
        this._setRejected();
        this._fulfillmentHandler0 = reason;
        if (this._isFinal()) {
          return async.fatalError(reason, util.isNode);
        }
        if ((bitField & 65535) > 0) {
          async.settlePromises(this);
        } else {
          this._ensurePossibleRejectionHandled();
        }
      };
      Promise2.prototype._fulfillPromises = function(len, value) {
        for (var i = 1; i < len; i++) {
          var handler2 = this._fulfillmentHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler2, receiver, value);
        }
      };
      Promise2.prototype._rejectPromises = function(len, reason) {
        for (var i = 1; i < len; i++) {
          var handler2 = this._rejectionHandlerAt(i);
          var promise = this._promiseAt(i);
          var receiver = this._receiverAt(i);
          this._clearCallbackDataAtIndex(i);
          this._settlePromise(promise, handler2, receiver, reason);
        }
      };
      Promise2.prototype._settlePromises = function() {
        var bitField = this._bitField;
        var len = bitField & 65535;
        if (len > 0) {
          if ((bitField & 16842752) !== 0) {
            var reason = this._fulfillmentHandler0;
            this._settlePromise0(this._rejectionHandler0, reason, bitField);
            this._rejectPromises(len, reason);
          } else {
            var value = this._rejectionHandler0;
            this._settlePromise0(this._fulfillmentHandler0, value, bitField);
            this._fulfillPromises(len, value);
          }
          this._setLength(0);
        }
        this._clearCancellationData();
      };
      Promise2.prototype._settledValue = function() {
        var bitField = this._bitField;
        if ((bitField & 33554432) !== 0) {
          return this._rejectionHandler0;
        } else if ((bitField & 16777216) !== 0) {
          return this._fulfillmentHandler0;
        }
      };
      function deferResolve(v) {
        this.promise._resolveCallback(v);
      }
      function deferReject(v) {
        this.promise._rejectCallback(v, false);
      }
      Promise2.defer = Promise2.pending = function() {
        debug.deprecated("Promise.defer", "new Promise");
        var promise = new Promise2(INTERNAL2);
        return {
          promise,
          resolve: deferResolve,
          reject: deferReject
        };
      };
      util.notEnumerableProp(
        Promise2,
        "_makeSelfResolutionError",
        makeSelfResolutionError
      );
      require_method()(
        Promise2,
        INTERNAL2,
        tryConvertToPromise,
        apiRejection,
        debug
      );
      require_bind()(Promise2, INTERNAL2, tryConvertToPromise, debug);
      require_cancel()(Promise2, PromiseArray, apiRejection, debug);
      require_direct_resolve()(Promise2);
      require_synchronous_inspection()(Promise2);
      require_join()(
        Promise2,
        PromiseArray,
        tryConvertToPromise,
        INTERNAL2,
        async,
        getDomain
      );
      Promise2.Promise = Promise2;
      Promise2.version = "3.4.7";
      require_map()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL2, debug);
      require_call_get()(Promise2);
      require_using()(Promise2, apiRejection, tryConvertToPromise, createContext, INTERNAL2, debug);
      require_timers()(Promise2, INTERNAL2, debug);
      require_generators()(Promise2, apiRejection, INTERNAL2, tryConvertToPromise, Proxyable, debug);
      require_nodeify()(Promise2);
      require_promisify()(Promise2, INTERNAL2);
      require_props()(Promise2, PromiseArray, tryConvertToPromise, apiRejection);
      require_race()(Promise2, INTERNAL2, tryConvertToPromise, apiRejection);
      require_reduce()(Promise2, PromiseArray, apiRejection, tryConvertToPromise, INTERNAL2, debug);
      require_settle()(Promise2, PromiseArray, debug);
      require_some()(Promise2, PromiseArray, apiRejection);
      require_filter()(Promise2, INTERNAL2);
      require_each()(Promise2, INTERNAL2);
      require_any()(Promise2);
      util.toFastProperties(Promise2);
      util.toFastProperties(Promise2.prototype);
      function fillTypes(value) {
        var p = new Promise2(INTERNAL2);
        p._fulfillmentHandler0 = value;
        p._rejectionHandler0 = value;
        p._promise0 = value;
        p._receiver0 = value;
      }
      fillTypes({ a: 1 });
      fillTypes({ b: 2 });
      fillTypes({ c: 3 });
      fillTypes(1);
      fillTypes(function() {
      });
      fillTypes(void 0);
      fillTypes(false);
      fillTypes(new Promise2(INTERNAL2));
      debug.setBounds(Async.firstLineError, util.lastLineError);
      return Promise2;
    };
  }
});

// node_modules/mammoth/lib/promises.js
var require_promises = __commonJS({
  "node_modules/mammoth/lib/promises.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var bluebird = require_promise()();
    exports2.defer = defer;
    exports2.when = bluebird.resolve;
    exports2.resolve = bluebird.resolve;
    exports2.all = bluebird.all;
    exports2.props = bluebird.props;
    exports2.reject = bluebird.reject;
    exports2.promisify = bluebird.promisify;
    exports2.mapSeries = bluebird.mapSeries;
    exports2.attempt = bluebird.attempt;
    exports2.nfcall = function(func) {
      var args = Array.prototype.slice.call(arguments, 1);
      var promisedFunc = bluebird.promisify(func);
      return promisedFunc.apply(null, args);
    };
    bluebird.prototype.fail = bluebird.prototype.caught;
    bluebird.prototype.also = function(func) {
      return this.then(function(value) {
        var returnValue = _3.extend({}, value, func(value));
        return bluebird.props(returnValue);
      });
    };
    function defer() {
      var resolve;
      var reject2;
      var promise = new bluebird.Promise(function(resolveArg, rejectArg) {
        resolve = resolveArg;
        reject2 = rejectArg;
      });
      return {
        resolve,
        reject: reject2,
        promise
      };
    }
  }
});

// node_modules/mammoth/lib/documents.js
var require_documents = __commonJS({
  "node_modules/mammoth/lib/documents.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var types = exports2.types = {
      document: "document",
      paragraph: "paragraph",
      run: "run",
      text: "text",
      tab: "tab",
      checkbox: "checkbox",
      hyperlink: "hyperlink",
      noteReference: "noteReference",
      image: "image",
      note: "note",
      commentReference: "commentReference",
      comment: "comment",
      table: "table",
      tableRow: "tableRow",
      tableCell: "tableCell",
      "break": "break",
      bookmarkStart: "bookmarkStart"
    };
    function Document(children, options) {
      options = options || {};
      return {
        type: types.document,
        children,
        notes: options.notes || new Notes({}),
        comments: options.comments || []
      };
    }
    function Paragraph(children, properties) {
      properties = properties || {};
      var indent = properties.indent || {};
      return {
        type: types.paragraph,
        children,
        styleId: properties.styleId || null,
        styleName: properties.styleName || null,
        numbering: properties.numbering || null,
        alignment: properties.alignment || null,
        indent: {
          start: indent.start || null,
          end: indent.end || null,
          firstLine: indent.firstLine || null,
          hanging: indent.hanging || null
        }
      };
    }
    function Run(children, properties) {
      properties = properties || {};
      return {
        type: types.run,
        children,
        styleId: properties.styleId || null,
        styleName: properties.styleName || null,
        isBold: !!properties.isBold,
        isUnderline: !!properties.isUnderline,
        isItalic: !!properties.isItalic,
        isStrikethrough: !!properties.isStrikethrough,
        isAllCaps: !!properties.isAllCaps,
        isSmallCaps: !!properties.isSmallCaps,
        verticalAlignment: properties.verticalAlignment || verticalAlignment.baseline,
        font: properties.font || null,
        fontSize: properties.fontSize || null,
        highlight: properties.highlight || null
      };
    }
    var verticalAlignment = {
      baseline: "baseline",
      superscript: "superscript",
      subscript: "subscript"
    };
    function Text(value) {
      return {
        type: types.text,
        value
      };
    }
    function Tab() {
      return {
        type: types.tab
      };
    }
    function Checkbox(options) {
      return {
        type: types.checkbox,
        checked: options.checked
      };
    }
    function Hyperlink(children, options) {
      return {
        type: types.hyperlink,
        children,
        href: options.href,
        anchor: options.anchor,
        targetFrame: options.targetFrame
      };
    }
    function NoteReference(options) {
      return {
        type: types.noteReference,
        noteType: options.noteType,
        noteId: options.noteId
      };
    }
    function Notes(notes) {
      this._notes = _3.indexBy(notes, function(note) {
        return noteKey(note.noteType, note.noteId);
      });
    }
    Notes.prototype.resolve = function(reference) {
      return this.findNoteByKey(noteKey(reference.noteType, reference.noteId));
    };
    Notes.prototype.findNoteByKey = function(key) {
      return this._notes[key] || null;
    };
    function Note(options) {
      return {
        type: types.note,
        noteType: options.noteType,
        noteId: options.noteId,
        body: options.body
      };
    }
    function commentReference(options) {
      return {
        type: types.commentReference,
        commentId: options.commentId
      };
    }
    function comment(options) {
      return {
        type: types.comment,
        commentId: options.commentId,
        body: options.body,
        authorName: options.authorName,
        authorInitials: options.authorInitials
      };
    }
    function noteKey(noteType, id) {
      return noteType + "-" + id;
    }
    function Image2(options) {
      return {
        type: types.image,
        // `read` is retained for backwards compatibility, but other read
        // methods should be preferred.
        read: function(encoding) {
          if (encoding) {
            return options.readImage(encoding);
          } else {
            return options.readImage().then(function(arrayBuffer) {
              return Buffer.from(arrayBuffer);
            });
          }
        },
        readAsArrayBuffer: function() {
          return options.readImage();
        },
        readAsBase64String: function() {
          return options.readImage("base64");
        },
        readAsBuffer: function() {
          return options.readImage().then(function(arrayBuffer) {
            return Buffer.from(arrayBuffer);
          });
        },
        altText: options.altText,
        contentType: options.contentType
      };
    }
    function Table2(children, properties) {
      properties = properties || {};
      return {
        type: types.table,
        children,
        styleId: properties.styleId || null,
        styleName: properties.styleName || null
      };
    }
    function TableRow(children, options) {
      options = options || {};
      return {
        type: types.tableRow,
        children,
        isHeader: options.isHeader || false
      };
    }
    function TableCell(children, options) {
      options = options || {};
      return {
        type: types.tableCell,
        children,
        colSpan: options.colSpan == null ? 1 : options.colSpan,
        rowSpan: options.rowSpan == null ? 1 : options.rowSpan
      };
    }
    function Break(breakType) {
      return {
        type: types["break"],
        breakType
      };
    }
    function BookmarkStart(options) {
      return {
        type: types.bookmarkStart,
        name: options.name
      };
    }
    exports2.document = exports2.Document = Document;
    exports2.paragraph = exports2.Paragraph = Paragraph;
    exports2.run = exports2.Run = Run;
    exports2.text = exports2.Text = Text;
    exports2.tab = exports2.Tab = Tab;
    exports2.checkbox = exports2.Checkbox = Checkbox;
    exports2.Hyperlink = Hyperlink;
    exports2.noteReference = exports2.NoteReference = NoteReference;
    exports2.Notes = Notes;
    exports2.Note = Note;
    exports2.commentReference = commentReference;
    exports2.comment = comment;
    exports2.Image = Image2;
    exports2.Table = Table2;
    exports2.TableRow = TableRow;
    exports2.TableCell = TableCell;
    exports2.lineBreak = Break("line");
    exports2.pageBreak = Break("page");
    exports2.columnBreak = Break("column");
    exports2.BookmarkStart = BookmarkStart;
    exports2.verticalAlignment = verticalAlignment;
  }
});

// node_modules/mammoth/lib/results.js
var require_results = __commonJS({
  "node_modules/mammoth/lib/results.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    exports2.Result = Result;
    exports2.success = success;
    exports2.warning = warning;
    exports2.error = error;
    function Result(value, messages) {
      this.value = value;
      this.messages = messages || [];
    }
    Result.prototype.map = function(func) {
      return new Result(func(this.value), this.messages);
    };
    Result.prototype.flatMap = function(func) {
      var funcResult = func(this.value);
      return new Result(funcResult.value, combineMessages([this, funcResult]));
    };
    Result.prototype.flatMapThen = function(func) {
      var that = this;
      return func(this.value).then(function(otherResult) {
        return new Result(otherResult.value, combineMessages([that, otherResult]));
      });
    };
    Result.combine = function(results) {
      var values2 = _3.flatten(_3.pluck(results, "value"));
      var messages = combineMessages(results);
      return new Result(values2, messages);
    };
    function success(value) {
      return new Result(value, []);
    }
    function warning(message) {
      return {
        type: "warning",
        message
      };
    }
    function error(exception) {
      return {
        type: "error",
        message: exception.message,
        error: exception
      };
    }
    function combineMessages(results) {
      var messages = [];
      _3.flatten(_3.pluck(results, "messages"), true).forEach(function(message) {
        if (!containsMessage(messages, message)) {
          messages.push(message);
        }
      });
      return messages;
    }
    function containsMessage(messages, message) {
      return _3.find(messages, isSameMessage.bind(null, message)) !== void 0;
    }
    function isSameMessage(first2, second) {
      return first2.type === second.type && first2.message === second.message;
    }
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports2) {
    "use strict";
    exports2.byteLength = byteLength;
    exports2.toByteArray = toByteArray;
    exports2.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
  }
});

// node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// node_modules/isarray/index.js
var require_isarray = __commonJS({
  "node_modules/isarray/index.js"(exports2, module2) {
    var toString2 = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = __require("stream");
  }
});

// node_modules/readable-stream/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/readable-stream/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size2, fill, encoding) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size2);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size2);
    };
    SafeBuffer.allocUnsafeSlow = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size2);
    };
  }
});

// node_modules/core-util-is/lib/util.js
var require_util2 = __commonJS({
  "node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean2(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean2;
    function isNull2(arg) {
      return arg === null;
    }
    exports2.isNull = isNull2;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined2(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined2;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject3(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject3;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError2(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError2;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction2;
    function isPrimitive2(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive2;
    exports2.isBuffer = __require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits2(ctor2, superCtor) {
        if (superCtor) {
          ctor2.super_ = superCtor;
          ctor2.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor2,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits2(ctor2, superCtor) {
        if (superCtor) {
          ctor2.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor2.prototype = new TempCtor();
          ctor2.prototype.constructor = ctor2;
        }
      };
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = __require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = __require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = (function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push2(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret2 = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret2;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret2 = "" + p.data;
        while (p = p.next) {
          ret2 += s + p.data;
        }
        return ret2;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret2 = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret2, i);
          i += p.data.length;
          p = p.next;
        }
        return ret2;
      };
      return BufferList;
    })();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj2 = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj2;
      };
    }
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb2) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb2) {
          cb2(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb2 && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb2) {
          cb2(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = __require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk2) {
      return Buffer2.from(chunk2);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_3) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object2) {
          if (realHasInstance.call(this, object2)) return true;
          if (this !== Writable) return false;
          return object2 && object2._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object2) {
        return object2 instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb2) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb2, er);
    }
    function validChunk(stream, state, chunk2, cb2) {
      var valid = true;
      var er = false;
      if (chunk2 === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk2 !== "string" && chunk2 !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb2, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk2, encoding, cb2) {
      var state = this._writableState;
      var ret2 = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk2);
      if (isBuf && !Buffer2.isBuffer(chunk2)) {
        chunk2 = _uint8ArrayToBuffer(chunk2);
      }
      if (typeof encoding === "function") {
        cb2 = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb2 !== "function") cb2 = nop;
      if (state.ended) writeAfterEnd(this, cb2);
      else if (isBuf || validChunk(this, state, chunk2, cb2)) {
        state.pendingcb++;
        ret2 = writeOrBuffer(this, state, isBuf, chunk2, encoding, cb2);
      }
      return ret2;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk2, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk2 === "string") {
        chunk2 = Buffer2.from(chunk2, encoding);
      }
      return chunk2;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk2, encoding, cb2) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk2, encoding);
        if (chunk2 !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk2 = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk2.length;
      state.length += len;
      var ret2 = state.length < state.highWaterMark;
      if (!ret2) state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk: chunk2,
          encoding,
          isBuf,
          callback: cb2,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk2, encoding, cb2);
      }
      return ret2;
    }
    function doWrite(stream, state, writev, len, chunk2, encoding, cb2) {
      state.writelen = len;
      state.writecb = cb2;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk2, state.onwrite);
      else stream._write(chunk2, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb2) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb2, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb2(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb2 = state.writecb;
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb2);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb2);
        } else {
          afterWrite(stream, state, finished, cb2);
        }
      }
    }
    function afterWrite(stream, state, finished, cb2) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb2();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l2 = state.bufferedRequestCount;
        var buffer = new Array(l2);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk2 = entry.chunk;
          var encoding = entry.encoding;
          var cb2 = entry.callback;
          var len = state.objectMode ? 1 : chunk2.length;
          doWrite(stream, state, false, len, chunk2, encoding, cb2);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk2, encoding, cb2) {
      cb2(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk2, encoding, cb2) {
      var state = this._writableState;
      if (typeof chunk2 === "function") {
        cb2 = chunk2;
        chunk2 = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb2 = encoding;
        encoding = null;
      }
      if (chunk2 !== null && chunk2 !== void 0) this.write(chunk2, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb2);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb2) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb2) {
        if (state.finished) pna.nextTick(cb2);
        else stream.once("finish", cb2);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb2 = entry.callback;
        state.pendingcb--;
        cb2(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb2) {
      this.end();
      cb2(err);
    };
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj2) {
      var keys3 = [];
      for (var key in obj2) {
        keys3.push(key);
      }
      return keys3;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys2 = objectKeys(Writable.prototype);
      for (v = 0; v < keys2.length; v++) {
        method = keys2[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys2;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false) this.readable = false;
      if (options && options.writable === false) this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended) return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb2) {
      this.push(null);
      this.end();
      pna.nextTick(cb2, err);
    };
  }
});

// node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer2 = __commonJS({
  "node_modules/string_decoder/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = __require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size2, fill, encoding) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size2);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size2);
    };
    SafeBuffer.allocUnsafeSlow = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size2);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer2().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = __require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk2) {
      return Buffer2.from(chunk2);
    }
    function _isUint8Array(obj2) {
      return Buffer2.isBuffer(obj2) || obj2 instanceof OurUint8Array;
    }
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    var debugUtil = __require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb2) {
      this.push(null);
      cb2(err);
    };
    Readable.prototype.push = function(chunk2, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk2 === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk2 = Buffer2.from(chunk2, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk2, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk2) {
      return readableAddChunk(this, chunk2, null, true, false);
    };
    function readableAddChunk(stream, chunk2, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk2 === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk2);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk2 && chunk2.length > 0) {
          if (typeof chunk2 !== "string" && !state.objectMode && Object.getPrototypeOf(chunk2) !== Buffer2.prototype) {
            chunk2 = _uint8ArrayToBuffer(chunk2);
          }
          if (addToFront) {
            if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
            else addChunk(stream, state, chunk2, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk2 = state.decoder.write(chunk2);
              if (state.objectMode || chunk2.length !== 0) addChunk(stream, state, chunk2, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk2, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk2, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk2);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk2.length;
        if (addToFront) state.buffer.unshift(chunk2);
        else state.buffer.push(chunk2);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk2) {
      var er;
      if (!_isUint8Array(chunk2) && typeof chunk2 !== "string" && chunk2 !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret2;
      if (n > 0) ret2 = fromList(n, state);
      else ret2 = null;
      if (ret2 === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret2 !== null) this.emit("data", ret2);
      return ret2;
    };
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk2 = state.decoder.end();
        if (chunk2 && chunk2.length) {
          state.buffer.push(chunk2);
          state.length += state.objectMode ? 1 : chunk2.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) pna.nextTick(emitReadable_, stream);
        else emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) pna.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk2) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret2 = dest.write(chunk2);
        if (false === ret2 && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk2 = state.decoder.end();
          if (chunk2 && chunk2.length) _this.push(chunk2);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk2) {
        debug("wrapped data");
        if (state.decoder) chunk2 = state.decoder.write(chunk2);
        if (state.objectMode && (chunk2 === null || chunk2 === void 0)) return;
        else if (!state.objectMode && (!chunk2 || !chunk2.length)) return;
        var ret2 = _this.push(chunk2);
        if (!ret2) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ (function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          })(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret2;
      if (state.objectMode) ret2 = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret2 = state.buffer.join("");
        else if (state.buffer.length === 1) ret2 = state.buffer.head.data;
        else ret2 = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret2 = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret2;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret2;
      if (n < list.head.data.length) {
        ret2 = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret2 = list.shift();
      } else {
        ret2 = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret2;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret2 = p.data;
      n -= ret2.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret2 += str;
        else ret2 += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function copyFromBuffer(n, list) {
      var ret2 = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret2);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret2, ret2.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret2;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l2 = xs.length; i < l2; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb2 = ts.writecb;
      if (!cb2) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb2(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk2, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk2, encoding);
    };
    Transform.prototype._transform = function(chunk2, encoding, cb2) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk2, encoding, cb2) {
      var ts = this._transformState;
      ts.writecb = cb2;
      ts.writechunk = chunk2;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb2) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb2(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util2());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk2, encoding, cb2) {
      cb2(null, chunk2);
    };
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = __require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  }
});

// node_modules/jszip/lib/support.js
var require_support = __commonJS({
  "node_modules/jszip/lib/support.js"(exports2) {
    "use strict";
    exports2.base64 = true;
    exports2.array = true;
    exports2.string = true;
    exports2.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    exports2.nodebuffer = typeof Buffer !== "undefined";
    exports2.uint8array = typeof Uint8Array !== "undefined";
    if (typeof ArrayBuffer === "undefined") {
      exports2.blob = false;
    } else {
      buffer = new ArrayBuffer(0);
      try {
        exports2.blob = new Blob([buffer], {
          type: "application/zip"
        }).size === 0;
      } catch (e) {
        try {
          Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          builder = new Builder();
          builder.append(buffer);
          exports2.blob = builder.getBlob("application/zip").size === 0;
        } catch (e2) {
          exports2.blob = false;
        }
      }
    }
    var buffer;
    var Builder;
    var builder;
    try {
      exports2.nodestream = !!require_readable().Readable;
    } catch (e) {
      exports2.nodestream = false;
    }
  }
});

// node_modules/jszip/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/jszip/lib/base64.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    exports2.encode = function(input) {
      var output = [];
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      var i = 0, len = input.length, remainingBytes = len;
      var isArray = utils.getTypeOf(input) !== "string";
      while (i < input.length) {
        remainingBytes = len - i;
        if (!isArray) {
          chr1 = input.charCodeAt(i++);
          chr2 = i < len ? input.charCodeAt(i++) : 0;
          chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
          chr1 = input[i++];
          chr2 = i < len ? input[i++] : 0;
          chr3 = i < len ? input[i++] : 0;
        }
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
      }
      return output.join("");
    };
    exports2.decode = function(input) {
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0, resultIndex = 0;
      var dataUrlPrefix = "data:";
      if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        throw new Error("Invalid base64 input, it looks like a data url.");
      }
      input = input.replace(/[^A-Za-z0-9+/=]/g, "");
      var totalLength = input.length * 3 / 4;
      if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (totalLength % 1 !== 0) {
        throw new Error("Invalid base64 input, bad content length.");
      }
      var output;
      if (support.uint8array) {
        output = new Uint8Array(totalLength | 0);
      } else {
        output = new Array(totalLength | 0);
      }
      while (i < input.length) {
        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output[resultIndex++] = chr1;
        if (enc3 !== 64) {
          output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
          output[resultIndex++] = chr3;
        }
      }
      return output;
    };
  }
});

// node_modules/jszip/lib/nodejsUtils.js
var require_nodejsUtils = __commonJS({
  "node_modules/jszip/lib/nodejsUtils.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /**
       * True if this is running in Nodejs, will be undefined in a browser.
       * In a browser, browserify won't include this file and the whole module
       * will be resolved an empty object.
       */
      isNode: typeof Buffer !== "undefined",
      /**
       * Create a new nodejs Buffer from an existing content.
       * @param {Object} data the data to pass to the constructor.
       * @param {String} encoding the encoding to use.
       * @return {Buffer} a new Buffer.
       */
      newBufferFrom: function(data, encoding) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
          return Buffer.from(data, encoding);
        } else {
          if (typeof data === "number") {
            throw new Error('The "data" argument must not be a number');
          }
          return new Buffer(data, encoding);
        }
      },
      /**
       * Create a new nodejs Buffer with the specified size.
       * @param {Integer} size the size of the buffer.
       * @return {Buffer} a new Buffer.
       */
      allocBuffer: function(size2) {
        if (Buffer.alloc) {
          return Buffer.alloc(size2);
        } else {
          var buf = new Buffer(size2);
          buf.fill(0);
          return buf;
        }
      },
      /**
       * Find out if an object is a Buffer.
       * @param {Object} b the object to test.
       * @return {Boolean} true if the object is a Buffer, false otherwise.
       */
      isBuffer: function(b) {
        return Buffer.isBuffer(b);
      },
      isStream: function(obj2) {
        return obj2 && typeof obj2.on === "function" && typeof obj2.pause === "function" && typeof obj2.resume === "function";
      }
    };
  }
});

// node_modules/immediate/lib/index.js
var require_lib = __commonJS({
  "node_modules/immediate/lib/index.js"(exports2, module2) {
    "use strict";
    var Mutation = global.MutationObserver || global.WebKitMutationObserver;
    var scheduleDrain;
    if (process.browser) {
      if (Mutation) {
        called = 0;
        observer = new Mutation(nextTick);
        element = global.document.createTextNode("");
        observer.observe(element, {
          characterData: true
        });
        scheduleDrain = function() {
          element.data = called = ++called % 2;
        };
      } else if (!global.setImmediate && typeof global.MessageChannel !== "undefined") {
        channel = new global.MessageChannel();
        channel.port1.onmessage = nextTick;
        scheduleDrain = function() {
          channel.port2.postMessage(0);
        };
      } else if ("document" in global && "onreadystatechange" in global.document.createElement("script")) {
        scheduleDrain = function() {
          var scriptEl = global.document.createElement("script");
          scriptEl.onreadystatechange = function() {
            nextTick();
            scriptEl.onreadystatechange = null;
            scriptEl.parentNode.removeChild(scriptEl);
            scriptEl = null;
          };
          global.document.documentElement.appendChild(scriptEl);
        };
      } else {
        scheduleDrain = function() {
          setTimeout(nextTick, 0);
        };
      }
    } else {
      scheduleDrain = function() {
        process.nextTick(nextTick);
      };
    }
    var called;
    var observer;
    var element;
    var channel;
    var draining;
    var queue2 = [];
    function nextTick() {
      draining = true;
      var i, oldQueue;
      var len = queue2.length;
      while (len) {
        oldQueue = queue2;
        queue2 = [];
        i = -1;
        while (++i < len) {
          oldQueue[i]();
        }
        len = queue2.length;
      }
      draining = false;
    }
    module2.exports = immediate;
    function immediate(task) {
      if (queue2.push(task) === 1 && !draining) {
        scheduleDrain();
      }
    }
  }
});

// node_modules/lie/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/lie/lib/index.js"(exports2, module2) {
    "use strict";
    var immediate = require_lib();
    function INTERNAL2() {
    }
    var handlers = {};
    var REJECTED = ["REJECTED"];
    var FULFILLED = ["FULFILLED"];
    var PENDING = ["PENDING"];
    if (!process.browser) {
      UNHANDLED = ["UNHANDLED"];
    }
    var UNHANDLED;
    module2.exports = Promise2;
    function Promise2(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function");
      }
      this.state = PENDING;
      this.queue = [];
      this.outcome = void 0;
      if (!process.browser) {
        this.handled = UNHANDLED;
      }
      if (resolver !== INTERNAL2) {
        safelyResolveThenable(this, resolver);
      }
    }
    Promise2.prototype.finally = function(callback) {
      if (typeof callback !== "function") {
        return this;
      }
      var p = this.constructor;
      return this.then(resolve2, reject3);
      function resolve2(value) {
        function yes() {
          return value;
        }
        return p.resolve(callback()).then(yes);
      }
      function reject3(reason) {
        function no() {
          throw reason;
        }
        return p.resolve(callback()).then(no);
      }
    };
    Promise2.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    Promise2.prototype.then = function(onFulfilled, onRejected) {
      if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
        return this;
      }
      var promise = new this.constructor(INTERNAL2);
      if (!process.browser) {
        if (this.handled === UNHANDLED) {
          this.handled = null;
        }
      }
      if (this.state !== PENDING) {
        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
        unwrap(promise, resolver, this.outcome);
      } else {
        this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
      }
      return promise;
    };
    function QueueItem(promise, onFulfilled, onRejected) {
      this.promise = promise;
      if (typeof onFulfilled === "function") {
        this.onFulfilled = onFulfilled;
        this.callFulfilled = this.otherCallFulfilled;
      }
      if (typeof onRejected === "function") {
        this.onRejected = onRejected;
        this.callRejected = this.otherCallRejected;
      }
    }
    QueueItem.prototype.callFulfilled = function(value) {
      handlers.resolve(this.promise, value);
    };
    QueueItem.prototype.otherCallFulfilled = function(value) {
      unwrap(this.promise, this.onFulfilled, value);
    };
    QueueItem.prototype.callRejected = function(value) {
      handlers.reject(this.promise, value);
    };
    QueueItem.prototype.otherCallRejected = function(value) {
      unwrap(this.promise, this.onRejected, value);
    };
    function unwrap(promise, func, value) {
      immediate(function() {
        var returnValue;
        try {
          returnValue = func(value);
        } catch (e) {
          return handlers.reject(promise, e);
        }
        if (returnValue === promise) {
          handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
        } else {
          handlers.resolve(promise, returnValue);
        }
      });
    }
    handlers.resolve = function(self2, value) {
      var result2 = tryCatch2(getThen, value);
      if (result2.status === "error") {
        return handlers.reject(self2, result2.value);
      }
      var thenable = result2.value;
      if (thenable) {
        safelyResolveThenable(self2, thenable);
      } else {
        self2.state = FULFILLED;
        self2.outcome = value;
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callFulfilled(value);
        }
      }
      return self2;
    };
    handlers.reject = function(self2, error) {
      self2.state = REJECTED;
      self2.outcome = error;
      if (!process.browser) {
        if (self2.handled === UNHANDLED) {
          immediate(function() {
            if (self2.handled === UNHANDLED) {
              process.emit("unhandledRejection", error, self2);
            }
          });
        }
      }
      var i = -1;
      var len = self2.queue.length;
      while (++i < len) {
        self2.queue[i].callRejected(error);
      }
      return self2;
    };
    function getThen(obj2) {
      var then = obj2 && obj2.then;
      if (obj2 && (typeof obj2 === "object" || typeof obj2 === "function") && typeof then === "function") {
        return function appyThen() {
          then.apply(obj2, arguments);
        };
      }
    }
    function safelyResolveThenable(self2, thenable) {
      var called = false;
      function onError(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.reject(self2, value);
      }
      function onSuccess(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.resolve(self2, value);
      }
      function tryToUnwrap() {
        thenable(onSuccess, onError);
      }
      var result2 = tryCatch2(tryToUnwrap);
      if (result2.status === "error") {
        onError(result2.value);
      }
    }
    function tryCatch2(func, value) {
      var out = {};
      try {
        out.value = func(value);
        out.status = "success";
      } catch (e) {
        out.status = "error";
        out.value = e;
      }
      return out;
    }
    Promise2.resolve = resolve;
    function resolve(value) {
      if (value instanceof this) {
        return value;
      }
      return handlers.resolve(new this(INTERNAL2), value);
    }
    Promise2.reject = reject2;
    function reject2(reason) {
      var promise = new this(INTERNAL2);
      return handlers.reject(promise, reason);
    }
    Promise2.all = all;
    function all(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var values2 = new Array(len);
      var resolved = 0;
      var i = -1;
      var promise = new this(INTERNAL2);
      while (++i < len) {
        allResolver(iterable[i], i);
      }
      return promise;
      function allResolver(value, i2) {
        self2.resolve(value).then(resolveFromAll, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
        function resolveFromAll(outValue) {
          values2[i2] = outValue;
          if (++resolved === len && !called) {
            called = true;
            handlers.resolve(promise, values2);
          }
        }
      }
    }
    Promise2.race = race;
    function race(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var i = -1;
      var promise = new this(INTERNAL2);
      while (++i < len) {
        resolver(iterable[i]);
      }
      return promise;
      function resolver(value) {
        self2.resolve(value).then(function(response) {
          if (!called) {
            called = true;
            handlers.resolve(promise, response);
          }
        }, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
      }
    }
  }
});

// node_modules/jszip/lib/external.js
var require_external = __commonJS({
  "node_modules/jszip/lib/external.js"(exports2, module2) {
    "use strict";
    var ES6Promise = null;
    if (typeof Promise !== "undefined") {
      ES6Promise = Promise;
    } else {
      ES6Promise = require_lib2();
    }
    module2.exports = {
      Promise: ES6Promise
    };
  }
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/setimmediate/setImmediate.js"(exports2) {
    (function(global2, undefined2) {
      "use strict";
      if (global2.setImmediate) {
        return;
      }
      var nextHandle = 1;
      var tasksByHandle = {};
      var currentlyRunningATask = false;
      var doc = global2.document;
      var registerImmediate;
      function setImmediate2(callback) {
        if (typeof callback !== "function") {
          callback = new Function("" + callback);
        }
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
        }
        var task = { callback, args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
      }
      function clearImmediate(handle) {
        delete tasksByHandle[handle];
      }
      function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
          case 0:
            callback();
            break;
          case 1:
            callback(args[0]);
            break;
          case 2:
            callback(args[0], args[1]);
            break;
          case 3:
            callback(args[0], args[1], args[2]);
            break;
          default:
            callback.apply(undefined2, args);
            break;
        }
      }
      function runIfPresent(handle) {
        if (currentlyRunningATask) {
          setTimeout(runIfPresent, 0, handle);
        } else {
          var task = tasksByHandle[handle];
          if (task) {
            currentlyRunningATask = true;
            try {
              run(task);
            } finally {
              clearImmediate(handle);
              currentlyRunningATask = false;
            }
          }
        }
      }
      function installNextTickImplementation() {
        registerImmediate = function(handle) {
          process.nextTick(function() {
            runIfPresent(handle);
          });
        };
      }
      function canUsePostMessage() {
        if (global2.postMessage && !global2.importScripts) {
          var postMessageIsAsynchronous = true;
          var oldOnMessage = global2.onmessage;
          global2.onmessage = function() {
            postMessageIsAsynchronous = false;
          };
          global2.postMessage("", "*");
          global2.onmessage = oldOnMessage;
          return postMessageIsAsynchronous;
        }
      }
      function installPostMessageImplementation() {
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
          if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
            runIfPresent(+event.data.slice(messagePrefix.length));
          }
        };
        if (global2.addEventListener) {
          global2.addEventListener("message", onGlobalMessage, false);
        } else {
          global2.attachEvent("onmessage", onGlobalMessage);
        }
        registerImmediate = function(handle) {
          global2.postMessage(messagePrefix + handle, "*");
        };
      }
      function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
          var handle = event.data;
          runIfPresent(handle);
        };
        registerImmediate = function(handle) {
          channel.port2.postMessage(handle);
        };
      }
      function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
          var script = doc.createElement("script");
          script.onreadystatechange = function() {
            runIfPresent(handle);
            script.onreadystatechange = null;
            html.removeChild(script);
            script = null;
          };
          html.appendChild(script);
        };
      }
      function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
          setTimeout(runIfPresent, 0, handle);
        };
      }
      var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
      attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
      if ({}.toString.call(global2.process) === "[object process]") {
        installNextTickImplementation();
      } else if (canUsePostMessage()) {
        installPostMessageImplementation();
      } else if (global2.MessageChannel) {
        installMessageChannelImplementation();
      } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        installReadyStateChangeImplementation();
      } else {
        installSetTimeoutImplementation();
      }
      attachTo.setImmediate = setImmediate2;
      attachTo.clearImmediate = clearImmediate;
    })(typeof self === "undefined" ? typeof global === "undefined" ? exports2 : global : self);
  }
});

// node_modules/jszip/lib/utils.js
var require_utils = __commonJS({
  "node_modules/jszip/lib/utils.js"(exports2) {
    "use strict";
    var support = require_support();
    var base64 = require_base64();
    var nodejsUtils = require_nodejsUtils();
    var external = require_external();
    require_setImmediate();
    function string2binary(str) {
      var result2 = null;
      if (support.uint8array) {
        result2 = new Uint8Array(str.length);
      } else {
        result2 = new Array(str.length);
      }
      return stringToArrayLike(str, result2);
    }
    exports2.newBlob = function(part, type) {
      exports2.checkSupport("blob");
      try {
        return new Blob([part], {
          type
        });
      } catch (e) {
        try {
          var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          var builder = new Builder();
          builder.append(part);
          return builder.getBlob(type);
        } catch (e2) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };
    function identity2(input) {
      return input;
    }
    function stringToArrayLike(str, array) {
      for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 255;
      }
      return array;
    }
    var arrayToStringHelper = {
      /**
       * Transform an array of int into a string, chunk by chunk.
       * See the performances notes on arrayLikeToString.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @param {String} type the type of the array.
       * @param {Integer} chunk the chunk size.
       * @return {String} the resulting string.
       * @throws Error if the chunk is too big for the stack.
       */
      stringifyByChunk: function(array, type, chunk2) {
        var result2 = [], k = 0, len = array.length;
        if (len <= chunk2) {
          return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
          if (type === "array" || type === "nodebuffer") {
            result2.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk2, len))));
          } else {
            result2.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk2, len))));
          }
          k += chunk2;
        }
        return result2.join("");
      },
      /**
       * Call String.fromCharCode on every item in the array.
       * This is the naive implementation, which generate A LOT of intermediate string.
       * This should be used when everything else fail.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @return {String} the result.
       */
      stringifyByChar: function(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
          resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
      },
      applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: (function() {
          try {
            return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e) {
            return false;
          }
        })(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: (function() {
          try {
            return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
          } catch (e) {
            return false;
          }
        })()
      }
    };
    function arrayLikeToString(array) {
      var chunk2 = 65536, type = exports2.getTypeOf(array), canUseApply = true;
      if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
      } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
      }
      if (canUseApply) {
        while (chunk2 > 1) {
          try {
            return arrayToStringHelper.stringifyByChunk(array, type, chunk2);
          } catch (e) {
            chunk2 = Math.floor(chunk2 / 2);
          }
        }
      }
      return arrayToStringHelper.stringifyByChar(array);
    }
    exports2.applyFromCharCode = arrayLikeToString;
    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
      }
      return arrayTo;
    }
    var transform = {};
    transform["string"] = {
      "string": identity2,
      "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
      }
    };
    transform["array"] = {
      "string": arrayLikeToString,
      "array": identity2,
      "arraybuffer": function(input) {
        return new Uint8Array(input).buffer;
      },
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["arraybuffer"] = {
      "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      "arraybuffer": identity2,
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
      }
    };
    transform["uint8array"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return input.buffer;
      },
      "uint8array": identity2,
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["nodebuffer"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": identity2
    };
    exports2.transformTo = function(outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports2.checkSupport(outputType);
      var inputType = exports2.getTypeOf(input);
      var result2 = transform[inputType][outputType](input);
      return result2;
    };
    exports2.resolve = function(path) {
      var parts = path.split("/");
      var result2 = [];
      for (var index = 0; index < parts.length; index++) {
        var part = parts[index];
        if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
          continue;
        } else if (part === "..") {
          result2.pop();
        } else {
          result2.push(part);
        }
      }
      return result2.join("/");
    };
    exports2.getTypeOf = function(input) {
      if (typeof input === "string") {
        return "string";
      }
      if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
      }
      if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
      }
      if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
      }
      if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
      }
    };
    exports2.checkSupport = function(type) {
      var supported = support[type.toLowerCase()];
      if (!supported) {
        throw new Error(type + " is not supported by this platform");
      }
    };
    exports2.MAX_VALUE_16BITS = 65535;
    exports2.MAX_VALUE_32BITS = -1;
    exports2.pretty = function(str) {
      var res = "", code, i;
      for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
      }
      return res;
    };
    exports2.delay = function(callback, args, self2) {
      setImmediate(function() {
        callback.apply(self2 || null, args || []);
      });
    };
    exports2.inherits = function(ctor2, superCtor) {
      var Obj = function() {
      };
      Obj.prototype = superCtor.prototype;
      ctor2.prototype = new Obj();
    };
    exports2.extend = function() {
      var result2 = {}, i, attr;
      for (i = 0; i < arguments.length; i++) {
        for (attr in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result2[attr] === "undefined") {
            result2[attr] = arguments[i][attr];
          }
        }
      }
      return result2;
    };
    exports2.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
      var promise = external.Promise.resolve(inputData).then(function(data) {
        var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
        if (isBlob && typeof FileReader !== "undefined") {
          return new external.Promise(function(resolve, reject2) {
            var reader = new FileReader();
            reader.onload = function(e) {
              resolve(e.target.result);
            };
            reader.onerror = function(e) {
              reject2(e.target.error);
            };
            reader.readAsArrayBuffer(data);
          });
        } else {
          return data;
        }
      });
      return promise.then(function(data) {
        var dataType = exports2.getTypeOf(data);
        if (!dataType) {
          return external.Promise.reject(
            new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        }
        if (dataType === "arraybuffer") {
          data = exports2.transformTo("uint8array", data);
        } else if (dataType === "string") {
          if (isBase64) {
            data = base64.decode(data);
          } else if (isBinary) {
            if (isOptimizedBinaryString !== true) {
              data = string2binary(data);
            }
          }
        }
        return data;
      });
    };
  }
});

// node_modules/jszip/lib/stream/GenericWorker.js
var require_GenericWorker = __commonJS({
  "node_modules/jszip/lib/stream/GenericWorker.js"(exports2, module2) {
    "use strict";
    function GenericWorker(name) {
      this.name = name || "default";
      this.streamInfo = {};
      this.generatedError = null;
      this.extraStreamInfo = {};
      this.isPaused = true;
      this.isFinished = false;
      this.isLocked = false;
      this._listeners = {
        "data": [],
        "end": [],
        "error": []
      };
      this.previous = null;
    }
    GenericWorker.prototype = {
      /**
       * Push a chunk to the next workers.
       * @param {Object} chunk the chunk to push
       */
      push: function(chunk2) {
        this.emit("data", chunk2);
      },
      /**
       * End the stream.
       * @return {Boolean} true if this call ended the worker, false otherwise.
       */
      end: function() {
        if (this.isFinished) {
          return false;
        }
        this.flush();
        try {
          this.emit("end");
          this.cleanUp();
          this.isFinished = true;
        } catch (e) {
          this.emit("error", e);
        }
        return true;
      },
      /**
       * End the stream with an error.
       * @param {Error} e the error which caused the premature end.
       * @return {Boolean} true if this call ended the worker with an error, false otherwise.
       */
      error: function(e) {
        if (this.isFinished) {
          return false;
        }
        if (this.isPaused) {
          this.generatedError = e;
        } else {
          this.isFinished = true;
          this.emit("error", e);
          if (this.previous) {
            this.previous.error(e);
          }
          this.cleanUp();
        }
        return true;
      },
      /**
       * Add a callback on an event.
       * @param {String} name the name of the event (data, end, error)
       * @param {Function} listener the function to call when the event is triggered
       * @return {GenericWorker} the current object for chainability
       */
      on: function(name, listener) {
        this._listeners[name].push(listener);
        return this;
      },
      /**
       * Clean any references when a worker is ending.
       */
      cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
      },
      /**
       * Trigger an event. This will call registered callback with the provided arg.
       * @param {String} name the name of the event (data, end, error)
       * @param {Object} arg the argument to call the callback with.
       */
      emit: function(name, arg) {
        if (this._listeners[name]) {
          for (var i = 0; i < this._listeners[name].length; i++) {
            this._listeners[name][i].call(this, arg);
          }
        }
      },
      /**
       * Chain a worker with an other.
       * @param {Worker} next the worker receiving events from the current one.
       * @return {worker} the next worker for chainability
       */
      pipe: function(next) {
        return next.registerPrevious(this);
      },
      /**
       * Same as `pipe` in the other direction.
       * Using an API with `pipe(next)` is very easy.
       * Implementing the API with the point of view of the next one registering
       * a source is easier, see the ZipFileWorker.
       * @param {Worker} previous the previous worker, sending events to this one
       * @return {Worker} the current worker for chainability
       */
      registerPrevious: function(previous) {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.streamInfo = previous.streamInfo;
        this.mergeStreamInfo();
        this.previous = previous;
        var self2 = this;
        previous.on("data", function(chunk2) {
          self2.processChunk(chunk2);
        });
        previous.on("end", function() {
          self2.end();
        });
        previous.on("error", function(e) {
          self2.error(e);
        });
        return this;
      },
      /**
       * Pause the stream so it doesn't send events anymore.
       * @return {Boolean} true if this call paused the worker, false otherwise.
       */
      pause: function() {
        if (this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = true;
        if (this.previous) {
          this.previous.pause();
        }
        return true;
      },
      /**
       * Resume a paused stream.
       * @return {Boolean} true if this call resumed the worker, false otherwise.
       */
      resume: function() {
        if (!this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = false;
        var withError = false;
        if (this.generatedError) {
          this.error(this.generatedError);
          withError = true;
        }
        if (this.previous) {
          this.previous.resume();
        }
        return !withError;
      },
      /**
       * Flush any remaining bytes as the stream is ending.
       */
      flush: function() {
      },
      /**
       * Process a chunk. This is usually the method overridden.
       * @param {Object} chunk the chunk to process.
       */
      processChunk: function(chunk2) {
        this.push(chunk2);
      },
      /**
       * Add a key/value to be added in the workers chain streamInfo once activated.
       * @param {String} key the key to use
       * @param {Object} value the associated value
       * @return {Worker} the current worker for chainability
       */
      withStreamInfo: function(key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
      },
      /**
       * Merge this worker's streamInfo into the chain's streamInfo.
       */
      mergeStreamInfo: function() {
        for (var key in this.extraStreamInfo) {
          if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
            continue;
          }
          this.streamInfo[key] = this.extraStreamInfo[key];
        }
      },
      /**
       * Lock the stream to prevent further updates on the workers chain.
       * After calling this method, all calls to pipe will fail.
       */
      lock: function() {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
          this.previous.lock();
        }
      },
      /**
       *
       * Pretty print the workers chain.
       */
      toString: function() {
        var me = "Worker " + this.name;
        if (this.previous) {
          return this.previous + " -> " + me;
        } else {
          return me;
        }
      }
    };
    module2.exports = GenericWorker;
  }
});

// node_modules/jszip/lib/utf8.js
var require_utf8 = __commonJS({
  "node_modules/jszip/lib/utf8.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var nodejsUtils = require_nodejsUtils();
    var GenericWorker = require_GenericWorker();
    var _utf8len = new Array(256);
    for (i = 0; i < 256; i++) {
      _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
    }
    var i;
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      if (support.uint8array) {
        buf = new Uint8Array(buf_len);
      } else {
        buf = new Array(buf_len);
      }
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var utf8border = function(buf, max2) {
      var pos;
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    };
    var buf2string = function(buf) {
      var i2, out, c, c_len;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out);
        } else {
          utf16buf.length = out;
        }
      }
      return utils.applyFromCharCode(utf16buf);
    };
    exports2.utf8encode = function utf8encode(str) {
      if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
      }
      return string2buf(str);
    };
    exports2.utf8decode = function utf8decode(buf) {
      if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
      return buf2string(buf);
    };
    function Utf8DecodeWorker() {
      GenericWorker.call(this, "utf-8 decode");
      this.leftOver = null;
    }
    utils.inherits(Utf8DecodeWorker, GenericWorker);
    Utf8DecodeWorker.prototype.processChunk = function(chunk2) {
      var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk2.data);
      if (this.leftOver && this.leftOver.length) {
        if (support.uint8array) {
          var previousData = data;
          data = new Uint8Array(previousData.length + this.leftOver.length);
          data.set(this.leftOver, 0);
          data.set(previousData, this.leftOver.length);
        } else {
          data = this.leftOver.concat(data);
        }
        this.leftOver = null;
      }
      var nextBoundary = utf8border(data);
      var usableData = data;
      if (nextBoundary !== data.length) {
        if (support.uint8array) {
          usableData = data.subarray(0, nextBoundary);
          this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
          usableData = data.slice(0, nextBoundary);
          this.leftOver = data.slice(nextBoundary, data.length);
        }
      }
      this.push({
        data: exports2.utf8decode(usableData),
        meta: chunk2.meta
      });
    };
    Utf8DecodeWorker.prototype.flush = function() {
      if (this.leftOver && this.leftOver.length) {
        this.push({
          data: exports2.utf8decode(this.leftOver),
          meta: {}
        });
        this.leftOver = null;
      }
    };
    exports2.Utf8DecodeWorker = Utf8DecodeWorker;
    function Utf8EncodeWorker() {
      GenericWorker.call(this, "utf-8 encode");
    }
    utils.inherits(Utf8EncodeWorker, GenericWorker);
    Utf8EncodeWorker.prototype.processChunk = function(chunk2) {
      this.push({
        data: exports2.utf8encode(chunk2.data),
        meta: chunk2.meta
      });
    };
    exports2.Utf8EncodeWorker = Utf8EncodeWorker;
  }
});

// node_modules/jszip/lib/stream/ConvertWorker.js
var require_ConvertWorker = __commonJS({
  "node_modules/jszip/lib/stream/ConvertWorker.js"(exports2, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var utils = require_utils();
    function ConvertWorker(destType) {
      GenericWorker.call(this, "ConvertWorker to " + destType);
      this.destType = destType;
    }
    utils.inherits(ConvertWorker, GenericWorker);
    ConvertWorker.prototype.processChunk = function(chunk2) {
      this.push({
        data: utils.transformTo(this.destType, chunk2.data),
        meta: chunk2.meta
      });
    };
    module2.exports = ConvertWorker;
  }
});

// node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js
var require_NodejsStreamOutputAdapter = __commonJS({
  "node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js"(exports2, module2) {
    "use strict";
    var Readable = require_readable().Readable;
    var utils = require_utils();
    utils.inherits(NodejsStreamOutputAdapter, Readable);
    function NodejsStreamOutputAdapter(helper, options, updateCb) {
      Readable.call(this, options);
      this._helper = helper;
      var self2 = this;
      helper.on("data", function(data, meta) {
        if (!self2.push(data)) {
          self2._helper.pause();
        }
        if (updateCb) {
          updateCb(meta);
        }
      }).on("error", function(e) {
        self2.emit("error", e);
      }).on("end", function() {
        self2.push(null);
      });
    }
    NodejsStreamOutputAdapter.prototype._read = function() {
      this._helper.resume();
    };
    module2.exports = NodejsStreamOutputAdapter;
  }
});

// node_modules/jszip/lib/stream/StreamHelper.js
var require_StreamHelper = __commonJS({
  "node_modules/jszip/lib/stream/StreamHelper.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var ConvertWorker = require_ConvertWorker();
    var GenericWorker = require_GenericWorker();
    var base64 = require_base64();
    var support = require_support();
    var external = require_external();
    var NodejsStreamOutputAdapter = null;
    if (support.nodestream) {
      try {
        NodejsStreamOutputAdapter = require_NodejsStreamOutputAdapter();
      } catch (e) {
      }
    }
    function transformZipOutput(type, content, mimeType) {
      switch (type) {
        case "blob":
          return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64":
          return base64.encode(content);
        default:
          return utils.transformTo(type, content);
      }
    }
    function concat(type, dataArray) {
      var i, index = 0, res = null, totalLength = 0;
      for (i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
      }
      switch (type) {
        case "string":
          return dataArray.join("");
        case "array":
          return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
          res = new Uint8Array(totalLength);
          for (i = 0; i < dataArray.length; i++) {
            res.set(dataArray[i], index);
            index += dataArray[i].length;
          }
          return res;
        case "nodebuffer":
          return Buffer.concat(dataArray);
        default:
          throw new Error("concat : unsupported type '" + type + "'");
      }
    }
    function accumulate(helper, updateCallback) {
      return new external.Promise(function(resolve, reject2) {
        var dataArray = [];
        var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
        helper.on("data", function(data, meta) {
          dataArray.push(data);
          if (updateCallback) {
            updateCallback(meta);
          }
        }).on("error", function(err) {
          dataArray = [];
          reject2(err);
        }).on("end", function() {
          try {
            var result2 = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
            resolve(result2);
          } catch (e) {
            reject2(e);
          }
          dataArray = [];
        }).resume();
      });
    }
    function StreamHelper(worker, outputType, mimeType) {
      var internalType = outputType;
      switch (outputType) {
        case "blob":
        case "arraybuffer":
          internalType = "uint8array";
          break;
        case "base64":
          internalType = "string";
          break;
      }
      try {
        this._internalType = internalType;
        this._outputType = outputType;
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        worker.lock();
      } catch (e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
      }
    }
    StreamHelper.prototype = {
      /**
       * Listen a StreamHelper, accumulate its content and concatenate it into a
       * complete block.
       * @param {Function} updateCb the update callback.
       * @return Promise the promise for the accumulation.
       */
      accumulate: function(updateCb) {
        return accumulate(this, updateCb);
      },
      /**
       * Add a listener on an event triggered on a stream.
       * @param {String} evt the name of the event
       * @param {Function} fn the listener
       * @return {StreamHelper} the current helper.
       */
      on: function(evt, fn) {
        var self2 = this;
        if (evt === "data") {
          this._worker.on(evt, function(chunk2) {
            fn.call(self2, chunk2.data, chunk2.meta);
          });
        } else {
          this._worker.on(evt, function() {
            utils.delay(fn, arguments, self2);
          });
        }
        return this;
      },
      /**
       * Resume the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      resume: function() {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
      },
      /**
       * Pause the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      pause: function() {
        this._worker.pause();
        return this;
      },
      /**
       * Return a nodejs stream for this helper.
       * @param {Function} updateCb the update callback.
       * @return {NodejsStreamOutputAdapter} the nodejs stream.
       */
      toNodejsStream: function(updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
          throw new Error(this._outputType + " is not supported by this method");
        }
        return new NodejsStreamOutputAdapter(this, {
          objectMode: this._outputType !== "nodebuffer"
        }, updateCb);
      }
    };
    module2.exports = StreamHelper;
  }
});

// node_modules/jszip/lib/defaults.js
var require_defaults = __commonJS({
  "node_modules/jszip/lib/defaults.js"(exports2) {
    "use strict";
    exports2.base64 = false;
    exports2.binary = false;
    exports2.dir = false;
    exports2.createFolders = true;
    exports2.date = null;
    exports2.compression = null;
    exports2.compressionOptions = null;
    exports2.comment = null;
    exports2.unixPermissions = null;
    exports2.dosPermissions = null;
  }
});

// node_modules/jszip/lib/stream/DataWorker.js
var require_DataWorker = __commonJS({
  "node_modules/jszip/lib/stream/DataWorker.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var DEFAULT_BLOCK_SIZE = 16 * 1024;
    function DataWorker(dataP) {
      GenericWorker.call(this, "DataWorker");
      var self2 = this;
      this.dataIsReady = false;
      this.index = 0;
      this.max = 0;
      this.data = null;
      this.type = "";
      this._tickScheduled = false;
      dataP.then(function(data) {
        self2.dataIsReady = true;
        self2.data = data;
        self2.max = data && data.length || 0;
        self2.type = utils.getTypeOf(data);
        if (!self2.isPaused) {
          self2._tickAndRepeat();
        }
      }, function(e) {
        self2.error(e);
      });
    }
    utils.inherits(DataWorker, GenericWorker);
    DataWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this.data = null;
    };
    DataWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
      }
      return true;
    };
    DataWorker.prototype._tickAndRepeat = function() {
      this._tickScheduled = false;
      if (this.isPaused || this.isFinished) {
        return;
      }
      this._tick();
      if (!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
      }
    };
    DataWorker.prototype._tick = function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      var size2 = DEFAULT_BLOCK_SIZE;
      var data = null, nextIndex = Math.min(this.max, this.index + size2);
      if (this.index >= this.max) {
        return this.end();
      } else {
        switch (this.type) {
          case "string":
            data = this.data.substring(this.index, nextIndex);
            break;
          case "uint8array":
            data = this.data.subarray(this.index, nextIndex);
            break;
          case "array":
          case "nodebuffer":
            data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
          data,
          meta: {
            percent: this.max ? this.index / this.max * 100 : 0
          }
        });
      }
    };
    module2.exports = DataWorker;
  }
});

// node_modules/jszip/lib/crc32.js
var require_crc32 = __commonJS({
  "node_modules/jszip/lib/crc32.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    function crc32str(crc, str, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = function crc32wrapper(input, crc) {
      if (typeof input === "undefined" || !input.length) {
        return 0;
      }
      var isArray = utils.getTypeOf(input) !== "string";
      if (isArray) {
        return crc32(crc | 0, input, input.length, 0);
      } else {
        return crc32str(crc | 0, input, input.length, 0);
      }
    };
  }
});

// node_modules/jszip/lib/stream/Crc32Probe.js
var require_Crc32Probe = __commonJS({
  "node_modules/jszip/lib/stream/Crc32Probe.js"(exports2, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var crc32 = require_crc32();
    var utils = require_utils();
    function Crc32Probe() {
      GenericWorker.call(this, "Crc32Probe");
      this.withStreamInfo("crc32", 0);
    }
    utils.inherits(Crc32Probe, GenericWorker);
    Crc32Probe.prototype.processChunk = function(chunk2) {
      this.streamInfo.crc32 = crc32(chunk2.data, this.streamInfo.crc32 || 0);
      this.push(chunk2);
    };
    module2.exports = Crc32Probe;
  }
});

// node_modules/jszip/lib/stream/DataLengthProbe.js
var require_DataLengthProbe = __commonJS({
  "node_modules/jszip/lib/stream/DataLengthProbe.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    function DataLengthProbe(propName) {
      GenericWorker.call(this, "DataLengthProbe for " + propName);
      this.propName = propName;
      this.withStreamInfo(propName, 0);
    }
    utils.inherits(DataLengthProbe, GenericWorker);
    DataLengthProbe.prototype.processChunk = function(chunk2) {
      if (chunk2) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk2.data.length;
      }
      GenericWorker.prototype.processChunk.call(this, chunk2);
    };
    module2.exports = DataLengthProbe;
  }
});

// node_modules/jszip/lib/compressedObject.js
var require_compressedObject = __commonJS({
  "node_modules/jszip/lib/compressedObject.js"(exports2, module2) {
    "use strict";
    var external = require_external();
    var DataWorker = require_DataWorker();
    var Crc32Probe = require_Crc32Probe();
    var DataLengthProbe = require_DataLengthProbe();
    function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
      this.compressedSize = compressedSize;
      this.uncompressedSize = uncompressedSize;
      this.crc32 = crc32;
      this.compression = compression;
      this.compressedContent = data;
    }
    CompressedObject.prototype = {
      /**
       * Create a worker to get the uncompressed content.
       * @return {GenericWorker} the worker.
       */
      getContentWorker: function() {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
        var that = this;
        worker.on("end", function() {
          if (this.streamInfo["data_length"] !== that.uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
          }
        });
        return worker;
      },
      /**
       * Create a worker to get the compressed content.
       * @return {GenericWorker} the worker.
       */
      getCompressedWorker: function() {
        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      }
    };
    CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
      return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
    };
    module2.exports = CompressedObject;
  }
});

// node_modules/jszip/lib/zipObject.js
var require_zipObject = __commonJS({
  "node_modules/jszip/lib/zipObject.js"(exports2, module2) {
    "use strict";
    var StreamHelper = require_StreamHelper();
    var DataWorker = require_DataWorker();
    var utf8 = require_utf8();
    var CompressedObject = require_compressedObject();
    var GenericWorker = require_GenericWorker();
    var ZipObject = function(name, data, options) {
      this.name = name;
      this.dir = options.dir;
      this.date = options.date;
      this.comment = options.comment;
      this.unixPermissions = options.unixPermissions;
      this.dosPermissions = options.dosPermissions;
      this._data = data;
      this._dataBinary = options.binary;
      this.options = {
        compression: options.compression,
        compressionOptions: options.compressionOptions
      };
    };
    ZipObject.prototype = {
      /**
       * Create an internal stream for the content of this object.
       * @param {String} type the type of each chunk.
       * @return StreamHelper the stream.
       */
      internalStream: function(type) {
        var result2 = null, outputType = "string";
        try {
          if (!type) {
            throw new Error("No output type specified.");
          }
          outputType = type.toLowerCase();
          var askUnicodeString = outputType === "string" || outputType === "text";
          if (outputType === "binarystring" || outputType === "text") {
            outputType = "string";
          }
          result2 = this._decompressWorker();
          var isUnicodeString = !this._dataBinary;
          if (isUnicodeString && !askUnicodeString) {
            result2 = result2.pipe(new utf8.Utf8EncodeWorker());
          }
          if (!isUnicodeString && askUnicodeString) {
            result2 = result2.pipe(new utf8.Utf8DecodeWorker());
          }
        } catch (e) {
          result2 = new GenericWorker("error");
          result2.error(e);
        }
        return new StreamHelper(result2, outputType, "");
      },
      /**
       * Prepare the content in the asked type.
       * @param {String} type the type of the result.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Promise the promise of the result.
       */
      async: function(type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
      },
      /**
       * Prepare the content as a nodejs stream.
       * @param {String} type the type of each chunk.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Stream the stream.
       */
      nodeStream: function(type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
      },
      /**
       * Return a worker for the compressed content.
       * @private
       * @param {Object} compression the compression object to use.
       * @param {Object} compressionOptions the options to use when compressing.
       * @return Worker the worker.
       */
      _compressWorker: function(compression, compressionOptions) {
        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
          return this._data.getCompressedWorker();
        } else {
          var result2 = this._decompressWorker();
          if (!this._dataBinary) {
            result2 = result2.pipe(new utf8.Utf8EncodeWorker());
          }
          return CompressedObject.createWorkerFrom(result2, compression, compressionOptions);
        }
      },
      /**
       * Return a worker for the decompressed content.
       * @private
       * @return Worker the worker.
       */
      _decompressWorker: function() {
        if (this._data instanceof CompressedObject) {
          return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
          return this._data;
        } else {
          return new DataWorker(this._data);
        }
      }
    };
    var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
    var removedFn = function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    };
    for (i = 0; i < removedMethods.length; i++) {
      ZipObject.prototype[removedMethods[i]] = removedFn;
    }
    var i;
    module2.exports = ZipObject;
  }
});

// node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "node_modules/pako/lib/utils/common.js"(exports2) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj2, key) {
      return Object.prototype.hasOwnProperty.call(obj2, key);
    }
    exports2.assign = function(obj2) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj2[p] = source[p];
          }
        }
      }
      return obj2;
    };
    exports2.shrinkBuf = function(buf, size2) {
      if (buf.length === size2) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size2);
      }
      buf.length = size2;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l2, len, pos, chunk2, result2;
        len = 0;
        for (i = 0, l2 = chunks.length; i < l2; i++) {
          len += chunks[i].length;
        }
        result2 = new Uint8Array(len);
        pos = 0;
        for (i = 0, l2 = chunks.length; i < l2; i++) {
          chunk2 = chunks[i];
          result2.set(chunk2, pos);
          pos += chunk2.length;
        }
        return result2;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports2.setTyped = function(on) {
      if (on) {
        exports2.Buf8 = Uint8Array;
        exports2.Buf16 = Uint16Array;
        exports2.Buf32 = Int32Array;
        exports2.assign(exports2, fnTyped);
      } else {
        exports2.Buf8 = Array;
        exports2.Buf16 = Array;
        exports2.Buf32 = Array;
        exports2.assign(exports2, fnUntyped);
      }
    };
    exports2.setTyped(TYPED_OK);
  }
});

// node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "node_modules/pako/lib/zlib/trees.js"(exports2) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last2) {
      send_bits(s, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last2) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last2);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last2) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports2._tr_init = _tr_init;
    exports2._tr_stored_block = _tr_stored_block;
    exports2._tr_flush_block = _tr_flush_block;
    exports2._tr_tally = _tr_tally;
    exports2._tr_align = _tr_align;
  }
});

// node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "node_modules/pako/lib/zlib/adler32.js"(exports2, module2) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS({
  "node_modules/pako/lib/zlib/crc32.js"(exports2, module2) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "node_modules/pako/lib/zlib/messages.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "node_modules/pako/lib/zlib/deflate.js"(exports2) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last2) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size2) {
      var len = strm.avail_in;
      if (len > size2) {
        len = size2;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret2 = deflateResetKeep(strm);
      if (ret2 === Z_OK) {
        lm_init(strm.state);
      }
      return ret2;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap2 = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap2 = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap2 = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap2;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap2;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap2 = s.wrap;
      if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap2 === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap2 === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap2;
      return Z_OK;
    }
    exports2.deflateInit = deflateInit;
    exports2.deflateInit2 = deflateInit2;
    exports2.deflateReset = deflateReset;
    exports2.deflateResetKeep = deflateResetKeep;
    exports2.deflateSetHeader = deflateSetHeader;
    exports2.deflate = deflate;
    exports2.deflateEnd = deflateEnd;
    exports2.deflateSetDictionary = deflateSetDictionary;
    exports2.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "node_modules/pako/lib/utils/strings.js"(exports2) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports2.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result2 = "";
      for (var i = 0; i < len; i++) {
        result2 += String.fromCharCode(buf[i]);
      }
      return result2;
    }
    exports2.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports2.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports2.buf2string = function(buf, max2) {
      var i, out, c, c_len;
      var len = max2 || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports2.utf8border = function(buf, max2) {
      var pos;
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    };
  }
});

// node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "node_modules/pako/lib/zlib/zstream.js"(exports2, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "node_modules/pako/lib/deflate.js"(exports2) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString2 = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate)) return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk2) {
      this.chunks.push(chunk2);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports2.Deflate = Deflate;
    exports2.deflate = deflate;
    exports2.deflateRaw = deflateRaw;
    exports2.gzip = gzip;
  }
});

// node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "node_modules/pako/lib/zlib/inffast.js"(exports2, module2) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last2;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last2 = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last2 && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "node_modules/pako/lib/zlib/inftrees.js"(exports2, module2) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min2 = 0, max2 = 0;
      var root2 = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root2 = bits;
      for (max2 = MAXBITS; max2 >= 1; max2--) {
        if (count[max2] !== 0) {
          break;
        }
      }
      if (root2 > max2) {
        root2 = max2;
      }
      if (max2 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min2 = 1; min2 < max2; min2++) {
        if (count[min2] !== 0) {
          break;
        }
      }
      if (root2 < min2) {
        root2 = min2;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max2 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min2;
      next = table_index;
      curr = root2;
      drop = 0;
      low = -1;
      used = 1 << root2;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min2 = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max2) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root2 && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root2;
          }
          next += min2;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max2) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root2 << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root2;
      return 0;
    };
  }
});

// node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "node_modules/pako/lib/zlib/inflate.js"(exports2) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap2;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap2 = 0;
        windowBits = -windowBits;
      } else {
        wrap2 = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap2;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret2;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret2 = inflateReset2(strm, windowBits);
      if (ret2 !== Z_OK) {
        strm.state = null;
      }
      return ret2;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret2;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret2 = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            /* falls through */
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            /* falls through */
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            /* falls through */
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            /* falls through */
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            /* falls through */
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            /* falls through */
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            /* falls through */
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            /* falls through */
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            /* falls through */
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case COPY_:
              state.mode = COPY;
            /* falls through */
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            /* falls through */
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret2 = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret2) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            /* falls through */
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret2 = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret2) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret2 = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret2) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case LEN_:
              state.mode = LEN;
            /* falls through */
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            /* falls through */
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            /* falls through */
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            /* falls through */
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            /* falls through */
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            /* falls through */
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            /* falls through */
            case DONE:
              ret2 = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret2 = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            /* falls through */
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret2 === Z_OK) {
        ret2 = Z_BUF_ERROR;
      }
      return ret2;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret2;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret2 = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret2) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports2.inflateReset = inflateReset;
    exports2.inflateReset2 = inflateReset2;
    exports2.inflateResetKeep = inflateResetKeep;
    exports2.inflateInit = inflateInit;
    exports2.inflateInit2 = inflateInit2;
    exports2.inflate = inflate;
    exports2.inflateEnd = inflateEnd;
    exports2.inflateGetHeader = inflateGetHeader;
    exports2.inflateSetDictionary = inflateSetDictionary;
    exports2.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "node_modules/pako/lib/zlib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "node_modules/pako/lib/zlib/gzheader.js"(exports2, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "node_modules/pako/lib/inflate.js"(exports2) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString2 = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate)) return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk2) {
      this.chunks.push(chunk2);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports2.Inflate = Inflate;
    exports2.inflate = inflate;
    exports2.inflateRaw = inflateRaw;
    exports2.ungzip = inflate;
  }
});

// node_modules/pako/index.js
var require_pako = __commonJS({
  "node_modules/pako/index.js"(exports2, module2) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module2.exports = pako;
  }
});

// node_modules/jszip/lib/flate.js
var require_flate = __commonJS({
  "node_modules/jszip/lib/flate.js"(exports2) {
    "use strict";
    var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
    var pako = require_pako();
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
    exports2.magic = "\b\0";
    function FlateWorker(action, options) {
      GenericWorker.call(this, "FlateWorker/" + action);
      this._pako = null;
      this._pakoAction = action;
      this._pakoOptions = options;
      this.meta = {};
    }
    utils.inherits(FlateWorker, GenericWorker);
    FlateWorker.prototype.processChunk = function(chunk2) {
      this.meta = chunk2.meta;
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push(utils.transformTo(ARRAY_TYPE, chunk2.data), false);
    };
    FlateWorker.prototype.flush = function() {
      GenericWorker.prototype.flush.call(this);
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push([], true);
    };
    FlateWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this._pako = null;
    };
    FlateWorker.prototype._createPako = function() {
      this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1
        // default compression
      });
      var self2 = this;
      this._pako.onData = function(data) {
        self2.push({
          data,
          meta: self2.meta
        });
      };
    };
    exports2.compressWorker = function(compressionOptions) {
      return new FlateWorker("Deflate", compressionOptions);
    };
    exports2.uncompressWorker = function() {
      return new FlateWorker("Inflate", {});
    };
  }
});

// node_modules/jszip/lib/compressions.js
var require_compressions = __commonJS({
  "node_modules/jszip/lib/compressions.js"(exports2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    exports2.STORE = {
      magic: "\0\0",
      compressWorker: function() {
        return new GenericWorker("STORE compression");
      },
      uncompressWorker: function() {
        return new GenericWorker("STORE decompression");
      }
    };
    exports2.DEFLATE = require_flate();
  }
});

// node_modules/jszip/lib/signature.js
var require_signature = __commonJS({
  "node_modules/jszip/lib/signature.js"(exports2) {
    "use strict";
    exports2.LOCAL_FILE_HEADER = "PK";
    exports2.CENTRAL_FILE_HEADER = "PK";
    exports2.CENTRAL_DIRECTORY_END = "PK";
    exports2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
    exports2.ZIP64_CENTRAL_DIRECTORY_END = "PK";
    exports2.DATA_DESCRIPTOR = "PK\x07\b";
  }
});

// node_modules/jszip/lib/generate/ZipFileWorker.js
var require_ZipFileWorker = __commonJS({
  "node_modules/jszip/lib/generate/ZipFileWorker.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var utf8 = require_utf8();
    var crc32 = require_crc32();
    var signature = require_signature();
    var decToHex = function(dec, bytes) {
      var hex = "", i;
      for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 255);
        dec = dec >>> 8;
      }
      return hex;
    };
    var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
      var result2 = unixPermissions;
      if (!unixPermissions) {
        result2 = isDir ? 16893 : 33204;
      }
      return (result2 & 65535) << 16;
    };
    var generateDosExternalFileAttr = function(dosPermissions) {
      return (dosPermissions || 0) & 63;
    };
    var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
      var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
      var dataInfo = {
        crc32: 0,
        compressedSize: 0,
        uncompressedSize: 0
      };
      if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo["crc32"];
        dataInfo.compressedSize = streamInfo["compressedSize"];
        dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
      }
      var bitflag = 0;
      if (streamedContent) {
        bitflag |= 8;
      }
      if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        bitflag |= 2048;
      }
      var extFileAttr = 0;
      var versionMadeBy = 0;
      if (dir) {
        extFileAttr |= 16;
      }
      if (platform === "UNIX") {
        versionMadeBy = 798;
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
      } else {
        versionMadeBy = 20;
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
      }
      dosTime = date.getUTCHours();
      dosTime = dosTime << 6;
      dosTime = dosTime | date.getUTCMinutes();
      dosTime = dosTime << 5;
      dosTime = dosTime | date.getUTCSeconds() / 2;
      dosDate = date.getUTCFullYear() - 1980;
      dosDate = dosDate << 4;
      dosDate = dosDate | date.getUTCMonth() + 1;
      dosDate = dosDate << 5;
      dosDate = dosDate | date.getUTCDate();
      if (useUTF8ForFileName) {
        unicodePathExtraField = // Version
        decToHex(1, 1) + // NameCRC32
        decToHex(crc32(encodedFileName), 4) + // UnicodeName
        utfEncodedFileName;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        decToHex(unicodePathExtraField.length, 2) + // content
        unicodePathExtraField;
      }
      if (useUTF8ForComment) {
        unicodeCommentExtraField = // Version
        decToHex(1, 1) + // CommentCRC32
        decToHex(crc32(encodedComment), 4) + // UnicodeName
        utfEncodedComment;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        decToHex(unicodeCommentExtraField.length, 2) + // content
        unicodeCommentExtraField;
      }
      var header = "";
      header += "\n\0";
      header += decToHex(bitflag, 2);
      header += compression.magic;
      header += decToHex(dosTime, 2);
      header += decToHex(dosDate, 2);
      header += decToHex(dataInfo.crc32, 4);
      header += decToHex(dataInfo.compressedSize, 4);
      header += decToHex(dataInfo.uncompressedSize, 4);
      header += decToHex(encodedFileName.length, 2);
      header += decToHex(extraFields.length, 2);
      var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
      var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
      decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
      header + // file comment length
      decToHex(encodedComment.length, 2) + // disk number start
      "\0\0\0\0" + // external file attributes
      decToHex(extFileAttr, 4) + // relative offset of local header
      decToHex(offset, 4) + // file name
      encodedFileName + // extra field
      extraFields + // file comment
      encodedComment;
      return {
        fileRecord,
        dirRecord
      };
    };
    var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
      var dirEnd = "";
      var encodedComment = utils.transformTo("string", encodeFileName(comment));
      dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
      "\0\0\0\0" + // total number of entries in the central directory on this disk
      decToHex(entriesCount, 2) + // total number of entries in the central directory
      decToHex(entriesCount, 2) + // size of the central directory   4 bytes
      decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
      decToHex(localDirLength, 4) + // .ZIP file comment length
      decToHex(encodedComment.length, 2) + // .ZIP file comment
      encodedComment;
      return dirEnd;
    };
    var generateDataDescriptors = function(streamInfo) {
      var descriptor = "";
      descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes
      decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
      decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
      decToHex(streamInfo["uncompressedSize"], 4);
      return descriptor;
    };
    function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
      GenericWorker.call(this, "ZipFileWorker");
      this.bytesWritten = 0;
      this.zipComment = comment;
      this.zipPlatform = platform;
      this.encodeFileName = encodeFileName;
      this.streamFiles = streamFiles;
      this.accumulate = false;
      this.contentBuffer = [];
      this.dirRecords = [];
      this.currentSourceOffset = 0;
      this.entriesCount = 0;
      this.currentFile = null;
      this._sources = [];
    }
    utils.inherits(ZipFileWorker, GenericWorker);
    ZipFileWorker.prototype.push = function(chunk2) {
      var currentFilePercent = chunk2.meta.percent || 0;
      var entriesCount = this.entriesCount;
      var remainingFiles = this._sources.length;
      if (this.accumulate) {
        this.contentBuffer.push(chunk2);
      } else {
        this.bytesWritten += chunk2.data.length;
        GenericWorker.prototype.push.call(this, {
          data: chunk2.data,
          meta: {
            currentFile: this.currentFile,
            percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
          }
        });
      }
    };
    ZipFileWorker.prototype.openedSource = function(streamInfo) {
      this.currentSourceOffset = this.bytesWritten;
      this.currentFile = streamInfo["file"].name;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      if (streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
      } else {
        this.accumulate = true;
      }
    };
    ZipFileWorker.prototype.closedSource = function(streamInfo) {
      this.accumulate = false;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.dirRecords.push(record.dirRecord);
      if (streamedContent) {
        this.push({
          data: generateDataDescriptors(streamInfo),
          meta: { percent: 100 }
        });
      } else {
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
        while (this.contentBuffer.length) {
          this.push(this.contentBuffer.shift());
        }
      }
      this.currentFile = null;
    };
    ZipFileWorker.prototype.flush = function() {
      var localDirLength = this.bytesWritten;
      for (var i = 0; i < this.dirRecords.length; i++) {
        this.push({
          data: this.dirRecords[i],
          meta: { percent: 100 }
        });
      }
      var centralDirLength = this.bytesWritten - localDirLength;
      var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
      this.push({
        data: dirEnd,
        meta: { percent: 100 }
      });
    };
    ZipFileWorker.prototype.prepareNextSource = function() {
      this.previous = this._sources.shift();
      this.openedSource(this.previous.streamInfo);
      if (this.isPaused) {
        this.previous.pause();
      } else {
        this.previous.resume();
      }
    };
    ZipFileWorker.prototype.registerPrevious = function(previous) {
      this._sources.push(previous);
      var self2 = this;
      previous.on("data", function(chunk2) {
        self2.processChunk(chunk2);
      });
      previous.on("end", function() {
        self2.closedSource(self2.previous.streamInfo);
        if (self2._sources.length) {
          self2.prepareNextSource();
        } else {
          self2.end();
        }
      });
      previous.on("error", function(e) {
        self2.error(e);
      });
      return this;
    };
    ZipFileWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
      }
      if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
      }
    };
    ZipFileWorker.prototype.error = function(e) {
      var sources = this._sources;
      if (!GenericWorker.prototype.error.call(this, e)) {
        return false;
      }
      for (var i = 0; i < sources.length; i++) {
        try {
          sources[i].error(e);
        } catch (e2) {
        }
      }
      return true;
    };
    ZipFileWorker.prototype.lock = function() {
      GenericWorker.prototype.lock.call(this);
      var sources = this._sources;
      for (var i = 0; i < sources.length; i++) {
        sources[i].lock();
      }
    };
    module2.exports = ZipFileWorker;
  }
});

// node_modules/jszip/lib/generate/index.js
var require_generate = __commonJS({
  "node_modules/jszip/lib/generate/index.js"(exports2) {
    "use strict";
    var compressions = require_compressions();
    var ZipFileWorker = require_ZipFileWorker();
    var getCompression = function(fileCompression, zipCompression) {
      var compressionName = fileCompression || zipCompression;
      var compression = compressions[compressionName];
      if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
      }
      return compression;
    };
    exports2.generateWorker = function(zip, options, comment) {
      var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
      var entriesCount = 0;
      try {
        zip.forEach(function(relativePath, file) {
          entriesCount++;
          var compression = getCompression(file.options.compression, options.compression);
          var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
          var dir = file.dir, date = file.date;
          file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
            name: relativePath,
            dir,
            date,
            comment: file.comment || "",
            unixPermissions: file.unixPermissions,
            dosPermissions: file.dosPermissions
          }).pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
      } catch (e) {
        zipFileWorker.error(e);
      }
      return zipFileWorker;
    };
  }
});

// node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js
var require_NodejsStreamInputAdapter = __commonJS({
  "node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    function NodejsStreamInputAdapter(filename, stream) {
      GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
      this._upstreamEnded = false;
      this._bindStream(stream);
    }
    utils.inherits(NodejsStreamInputAdapter, GenericWorker);
    NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
      var self2 = this;
      this._stream = stream;
      stream.pause();
      stream.on("data", function(chunk2) {
        self2.push({
          data: chunk2,
          meta: {
            percent: 0
          }
        });
      }).on("error", function(e) {
        if (self2.isPaused) {
          this.generatedError = e;
        } else {
          self2.error(e);
        }
      }).on("end", function() {
        if (self2.isPaused) {
          self2._upstreamEnded = true;
        } else {
          self2.end();
        }
      });
    };
    NodejsStreamInputAdapter.prototype.pause = function() {
      if (!GenericWorker.prototype.pause.call(this)) {
        return false;
      }
      this._stream.pause();
      return true;
    };
    NodejsStreamInputAdapter.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (this._upstreamEnded) {
        this.end();
      } else {
        this._stream.resume();
      }
      return true;
    };
    module2.exports = NodejsStreamInputAdapter;
  }
});

// node_modules/jszip/lib/object.js
var require_object = __commonJS({
  "node_modules/jszip/lib/object.js"(exports2, module2) {
    "use strict";
    var utf8 = require_utf8();
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var StreamHelper = require_StreamHelper();
    var defaults = require_defaults();
    var CompressedObject = require_compressedObject();
    var ZipObject = require_zipObject();
    var generate = require_generate();
    var nodejsUtils = require_nodejsUtils();
    var NodejsStreamInputAdapter = require_NodejsStreamInputAdapter();
    var fileAdd = function(name, data, originalOptions) {
      var dataType = utils.getTypeOf(data), parent;
      var o = utils.extend(originalOptions || {}, defaults);
      o.date = o.date || /* @__PURE__ */ new Date();
      if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
      }
      if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
      }
      if (o.unixPermissions && o.unixPermissions & 16384) {
        o.dir = true;
      }
      if (o.dosPermissions && o.dosPermissions & 16) {
        o.dir = true;
      }
      if (o.dir) {
        name = forceTrailingSlash(name);
      }
      if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
      }
      var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
      if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
      }
      var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
      if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
      }
      var zipObjectContent = null;
      if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
      } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
      } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
      }
      var object2 = new ZipObject(name, zipObjectContent, o);
      this.files[name] = object2;
    };
    var parentFolder = function(path) {
      if (path.slice(-1) === "/") {
        path = path.substring(0, path.length - 1);
      }
      var lastSlash = path.lastIndexOf("/");
      return lastSlash > 0 ? path.substring(0, lastSlash) : "";
    };
    var forceTrailingSlash = function(path) {
      if (path.slice(-1) !== "/") {
        path += "/";
      }
      return path;
    };
    var folderAdd = function(name, createFolders) {
      createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
      name = forceTrailingSlash(name);
      if (!this.files[name]) {
        fileAdd.call(this, name, null, {
          dir: true,
          createFolders
        });
      }
      return this.files[name];
    };
    function isRegExp(object2) {
      return Object.prototype.toString.call(object2) === "[object RegExp]";
    }
    var out = {
      /**
       * @see loadAsync
       */
      load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Call a callback function for each entry at this folder level.
       * @param {Function} cb the callback function:
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       */
      forEach: function(cb2) {
        var filename, relativePath, file;
        for (filename in this.files) {
          file = this.files[filename];
          relativePath = filename.slice(this.root.length, filename.length);
          if (relativePath && filename.slice(0, this.root.length) === this.root) {
            cb2(relativePath, file);
          }
        }
      },
      /**
       * Filter nested files/folders with the specified function.
       * @param {Function} search the predicate to use :
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       * @return {Array} An array of matching elements.
       */
      filter: function(search) {
        var result2 = [];
        this.forEach(function(relativePath, entry) {
          if (search(relativePath, entry)) {
            result2.push(entry);
          }
        });
        return result2;
      },
      /**
       * Add a file to the zip file, or search a file.
       * @param   {string|RegExp} name The name of the file to add (if data is defined),
       * the name of the file to find (if no data) or a regex to match files.
       * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
       * @param   {Object} o     File options
       * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
       * a file (when searching by string) or an array of files (when searching by regex).
       */
      file: function(name, data, o) {
        if (arguments.length === 1) {
          if (isRegExp(name)) {
            var regexp = name;
            return this.filter(function(relativePath, file) {
              return !file.dir && regexp.test(relativePath);
            });
          } else {
            var obj2 = this.files[this.root + name];
            if (obj2 && !obj2.dir) {
              return obj2;
            } else {
              return null;
            }
          }
        } else {
          name = this.root + name;
          fileAdd.call(this, name, data, o);
        }
        return this;
      },
      /**
       * Add a directory to the zip file, or search.
       * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
       * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
       */
      folder: function(arg) {
        if (!arg) {
          return this;
        }
        if (isRegExp(arg)) {
          return this.filter(function(relativePath, file) {
            return file.dir && arg.test(relativePath);
          });
        }
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);
        var ret2 = this.clone();
        ret2.root = newFolder.name;
        return ret2;
      },
      /**
       * Delete a file, or a directory and all sub-files, from the zip
       * @param {string} name the name of the file to delete
       * @return {JSZip} this JSZip object
       */
      remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
          if (name.slice(-1) !== "/") {
            name += "/";
          }
          file = this.files[name];
        }
        if (file && !file.dir) {
          delete this.files[name];
        } else {
          var kids = this.filter(function(relativePath, file2) {
            return file2.name.slice(0, name.length) === name;
          });
          for (var i = 0; i < kids.length; i++) {
            delete this.files[kids[i].name];
          }
        }
        return this;
      },
      /**
       * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
       */
      generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Generate the complete zip file as an internal stream.
       * @param {Object} options the options to generate the zip file :
       * - compression, "STORE" by default.
       * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
       * @return {StreamHelper} the streamed zip file.
       */
      generateInternalStream: function(options) {
        var worker, opts = {};
        try {
          opts = utils.extend(options || {}, {
            streamFiles: false,
            compression: "STORE",
            compressionOptions: null,
            type: "",
            platform: "DOS",
            comment: null,
            mimeType: "application/zip",
            encodeFileName: utf8.utf8encode
          });
          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();
          if (opts.type === "binarystring") {
            opts.type = "string";
          }
          if (!opts.type) {
            throw new Error("No output type specified.");
          }
          utils.checkSupport(opts.type);
          if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
            opts.platform = "UNIX";
          }
          if (opts.platform === "win32") {
            opts.platform = "DOS";
          }
          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
        } catch (e) {
          worker = new GenericWorker("error");
          worker.error(e);
        }
        return new StreamHelper(worker, opts.type || "string", opts.mimeType);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
          options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
      }
    };
    module2.exports = out;
  }
});

// node_modules/jszip/lib/reader/DataReader.js
var require_DataReader = __commonJS({
  "node_modules/jszip/lib/reader/DataReader.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function DataReader(data) {
      this.data = data;
      this.length = data.length;
      this.index = 0;
      this.zero = 0;
    }
    DataReader.prototype = {
      /**
       * Check that the offset will not go too far.
       * @param {string} offset the additional offset to check.
       * @throws {Error} an Error if the offset is out of bounds.
       */
      checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
      },
      /**
       * Check that the specified index will not be too far.
       * @param {string} newIndex the index to check.
       * @throws {Error} an Error if the index is out of bounds.
       */
      checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
      },
      /**
       * Change the index.
       * @param {number} newIndex The new index.
       * @throws {Error} if the new index is out of the data.
       */
      setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
      },
      /**
       * Skip the next n bytes.
       * @param {number} n the number of bytes to skip.
       * @throws {Error} if the new index is out of the data.
       */
      skip: function(n) {
        this.setIndex(this.index + n);
      },
      /**
       * Get the byte at the specified index.
       * @param {number} i the index to use.
       * @return {number} a byte.
       */
      byteAt: function() {
      },
      /**
       * Get the next number with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {number} the corresponding number.
       */
      readInt: function(size2) {
        var result2 = 0, i;
        this.checkOffset(size2);
        for (i = this.index + size2 - 1; i >= this.index; i--) {
          result2 = (result2 << 8) + this.byteAt(i);
        }
        this.index += size2;
        return result2;
      },
      /**
       * Get the next string with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {string} the corresponding string.
       */
      readString: function(size2) {
        return utils.transformTo("string", this.readData(size2));
      },
      /**
       * Get raw data without conversion, <size> bytes.
       * @param {number} size the number of bytes to read.
       * @return {Object} the raw data, implementation specific.
       */
      readData: function() {
      },
      /**
       * Find the last occurrence of a zip signature (4 bytes).
       * @param {string} sig the signature to find.
       * @return {number} the index of the last occurrence, -1 if not found.
       */
      lastIndexOfSignature: function() {
      },
      /**
       * Read the signature (4 bytes) at the current position and compare it with sig.
       * @param {string} sig the expected signature
       * @return {boolean} true if the signature matches, false otherwise.
       */
      readAndCheckSignature: function() {
      },
      /**
       * Get the next date.
       * @return {Date} the date.
       */
      readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
          (dostime >> 25 & 127) + 1980,
          // year
          (dostime >> 21 & 15) - 1,
          // month
          dostime >> 16 & 31,
          // day
          dostime >> 11 & 31,
          // hour
          dostime >> 5 & 63,
          // minute
          (dostime & 31) << 1
        ));
      }
    };
    module2.exports = DataReader;
  }
});

// node_modules/jszip/lib/reader/ArrayReader.js
var require_ArrayReader = __commonJS({
  "node_modules/jszip/lib/reader/ArrayReader.js"(exports2, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils = require_utils();
    function ArrayReader(data) {
      DataReader.call(this, data);
      for (var i = 0; i < this.data.length; i++) {
        data[i] = data[i] & 255;
      }
    }
    utils.inherits(ArrayReader, DataReader);
    ArrayReader.prototype.byteAt = function(i) {
      return this.data[this.zero + i];
    };
    ArrayReader.prototype.lastIndexOfSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
      for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
          return i - this.zero;
        }
      }
      return -1;
    };
    ArrayReader.prototype.readAndCheckSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
      return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
    };
    ArrayReader.prototype.readData = function(size2) {
      this.checkOffset(size2);
      if (size2 === 0) {
        return [];
      }
      var result2 = this.data.slice(this.zero + this.index, this.zero + this.index + size2);
      this.index += size2;
      return result2;
    };
    module2.exports = ArrayReader;
  }
});

// node_modules/jszip/lib/reader/StringReader.js
var require_StringReader = __commonJS({
  "node_modules/jszip/lib/reader/StringReader.js"(exports2, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils = require_utils();
    function StringReader(data) {
      DataReader.call(this, data);
    }
    utils.inherits(StringReader, DataReader);
    StringReader.prototype.byteAt = function(i) {
      return this.data.charCodeAt(this.zero + i);
    };
    StringReader.prototype.lastIndexOfSignature = function(sig) {
      return this.data.lastIndexOf(sig) - this.zero;
    };
    StringReader.prototype.readAndCheckSignature = function(sig) {
      var data = this.readData(4);
      return sig === data;
    };
    StringReader.prototype.readData = function(size2) {
      this.checkOffset(size2);
      var result2 = this.data.slice(this.zero + this.index, this.zero + this.index + size2);
      this.index += size2;
      return result2;
    };
    module2.exports = StringReader;
  }
});

// node_modules/jszip/lib/reader/Uint8ArrayReader.js
var require_Uint8ArrayReader = __commonJS({
  "node_modules/jszip/lib/reader/Uint8ArrayReader.js"(exports2, module2) {
    "use strict";
    var ArrayReader = require_ArrayReader();
    var utils = require_utils();
    function Uint8ArrayReader(data) {
      ArrayReader.call(this, data);
    }
    utils.inherits(Uint8ArrayReader, ArrayReader);
    Uint8ArrayReader.prototype.readData = function(size2) {
      this.checkOffset(size2);
      if (size2 === 0) {
        return new Uint8Array(0);
      }
      var result2 = this.data.subarray(this.zero + this.index, this.zero + this.index + size2);
      this.index += size2;
      return result2;
    };
    module2.exports = Uint8ArrayReader;
  }
});

// node_modules/jszip/lib/reader/NodeBufferReader.js
var require_NodeBufferReader = __commonJS({
  "node_modules/jszip/lib/reader/NodeBufferReader.js"(exports2, module2) {
    "use strict";
    var Uint8ArrayReader = require_Uint8ArrayReader();
    var utils = require_utils();
    function NodeBufferReader(data) {
      Uint8ArrayReader.call(this, data);
    }
    utils.inherits(NodeBufferReader, Uint8ArrayReader);
    NodeBufferReader.prototype.readData = function(size2) {
      this.checkOffset(size2);
      var result2 = this.data.slice(this.zero + this.index, this.zero + this.index + size2);
      this.index += size2;
      return result2;
    };
    module2.exports = NodeBufferReader;
  }
});

// node_modules/jszip/lib/reader/readerFor.js
var require_readerFor = __commonJS({
  "node_modules/jszip/lib/reader/readerFor.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var ArrayReader = require_ArrayReader();
    var StringReader = require_StringReader();
    var NodeBufferReader = require_NodeBufferReader();
    var Uint8ArrayReader = require_Uint8ArrayReader();
    module2.exports = function(data) {
      var type = utils.getTypeOf(data);
      utils.checkSupport(type);
      if (type === "string" && !support.uint8array) {
        return new StringReader(data);
      }
      if (type === "nodebuffer") {
        return new NodeBufferReader(data);
      }
      if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
      }
      return new ArrayReader(utils.transformTo("array", data));
    };
  }
});

// node_modules/jszip/lib/zipEntry.js
var require_zipEntry = __commonJS({
  "node_modules/jszip/lib/zipEntry.js"(exports2, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils = require_utils();
    var CompressedObject = require_compressedObject();
    var crc32fn = require_crc32();
    var utf8 = require_utf8();
    var compressions = require_compressions();
    var support = require_support();
    var MADE_BY_DOS = 0;
    var MADE_BY_UNIX = 3;
    var findCompression = function(compressionMethod) {
      for (var method in compressions) {
        if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
          continue;
        }
        if (compressions[method].magic === compressionMethod) {
          return compressions[method];
        }
      }
      return null;
    };
    function ZipEntry(options, loadOptions) {
      this.options = options;
      this.loadOptions = loadOptions;
    }
    ZipEntry.prototype = {
      /**
       * say if the file is encrypted.
       * @return {boolean} true if the file is encrypted, false otherwise.
       */
      isEncrypted: function() {
        return (this.bitFlag & 1) === 1;
      },
      /**
       * say if the file has utf-8 filename/comment.
       * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
       */
      useUTF8: function() {
        return (this.bitFlag & 2048) === 2048;
      },
      /**
       * Read the local part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;
        reader.skip(22);
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2);
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);
        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        }
        compression = findCompression(this.compressionMethod);
        if (compression === null) {
          throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);
        if (this.isEncrypted()) {
          throw new Error("Encrypted zip are not supported");
        }
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
      },
      /**
       * Parse the external file attributes and get the unix/dos permissions.
       */
      processAttributes: function() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;
        this.dir = this.externalFileAttributes & 16 ? true : false;
        if (madeBy === MADE_BY_DOS) {
          this.dosPermissions = this.externalFileAttributes & 63;
        }
        if (madeBy === MADE_BY_UNIX) {
          this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
        }
        if (!this.dir && this.fileNameStr.slice(-1) === "/") {
          this.dir = true;
        }
      },
      /**
       * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
       * @param {DataReader} reader the reader to use.
       */
      parseZIP64ExtraField: function() {
        if (!this.extraFields[1]) {
          return;
        }
        var extraReader = readerFor(this.extraFields[1].value);
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
          this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
          this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
          this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
          this.diskNumberStart = extraReader.readInt(4);
        }
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
        if (!this.extraFields) {
          this.extraFields = {};
        }
        while (reader.index + 4 < end) {
          extraFieldId = reader.readInt(2);
          extraFieldLength = reader.readInt(2);
          extraFieldValue = reader.readData(extraFieldLength);
          this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
        reader.setIndex(end);
      },
      /**
       * Apply an UTF8 transformation if needed.
       */
      handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
          this.fileNameStr = utf8.utf8decode(this.fileName);
          this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
          var upath = this.findExtraFieldUnicodePath();
          if (upath !== null) {
            this.fileNameStr = upath;
          } else {
            var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
          }
          var ucomment = this.findExtraFieldUnicodeComment();
          if (ucomment !== null) {
            this.fileCommentStr = ucomment;
          } else {
            var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
          }
        }
      },
      /**
       * Find the unicode path declared in the extra field, if any.
       * @return {String} the unicode path, null otherwise.
       */
      findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[28789];
        if (upathField) {
          var extraReader = readerFor(upathField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
      },
      /**
       * Find the unicode comment declared in the extra field, if any.
       * @return {String} the unicode comment, null otherwise.
       */
      findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[25461];
        if (ucommentField) {
          var extraReader = readerFor(ucommentField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
      }
    };
    module2.exports = ZipEntry;
  }
});

// node_modules/jszip/lib/zipEntries.js
var require_zipEntries = __commonJS({
  "node_modules/jszip/lib/zipEntries.js"(exports2, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils = require_utils();
    var sig = require_signature();
    var ZipEntry = require_zipEntry();
    var support = require_support();
    function ZipEntries(loadOptions) {
      this.files = [];
      this.loadOptions = loadOptions;
    }
    ZipEntries.prototype = {
      /**
       * Check that the reader is on the specified signature.
       * @param {string} expectedSignature the expected signature.
       * @throws {Error} if it is an other signature.
       */
      checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
          this.reader.index -= 4;
          var signature = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
      },
      /**
       * Check if the given signature is at the given index.
       * @param {number} askedIndex the index to check.
       * @param {string} expectedSignature the signature to expect.
       * @return {boolean} true if the signature is here, false otherwise.
       */
      isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result2 = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result2;
      },
      /**
       * Read the end of the central directory.
       */
      readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);
        this.zipCommentLength = this.reader.readInt(2);
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
      },
      /**
       * Read the end of the Zip 64 central directory.
       * Not merged with the method readEndOfCentral :
       * The end of central can coexist with its Zip64 brother,
       * I don't want to read the wrong number of bytes !
       */
      readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);
        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
        while (index < extraDataSize) {
          extraFieldId = this.reader.readInt(2);
          extraFieldLength = this.reader.readInt(4);
          extraFieldValue = this.reader.readData(extraFieldLength);
          this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      /**
       * Read the end of the Zip 64 central directory locator.
       */
      readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
          throw new Error("Multi-volumes zip are not supported");
        }
      },
      /**
       * Read the local files, based on the offset read in the central part.
       */
      readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
          file = this.files[i];
          this.reader.setIndex(file.localHeaderOffset);
          this.checkSignature(sig.LOCAL_FILE_HEADER);
          file.readLocalPart(this.reader);
          file.handleUTF8();
          file.processAttributes();
        }
      },
      /**
       * Read the central directory.
       */
      readCentralDir: function() {
        var file;
        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
          file = new ZipEntry({
            zip64: this.zip64
          }, this.loadOptions);
          file.readCentralPart(this.reader);
          this.files.push(file);
        }
        if (this.centralDirRecords !== this.files.length) {
          if (this.centralDirRecords !== 0 && this.files.length === 0) {
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          } else {
          }
        }
      },
      /**
       * Read the end of central directory.
       */
      readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
          var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
          if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          } else {
            throw new Error("Corrupted zip: can't find end of central directory");
          }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
          this.zip64 = true;
          offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          if (offset < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          }
          this.reader.setIndex(offset);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          this.readBlockZip64EndOfCentralLocator();
          if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir < 0) {
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            }
          }
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          this.readBlockZip64EndOfCentral();
        }
        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
          expectedEndOfCentralDirOffset += 20;
          expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
        }
        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
        if (extraBytes > 0) {
          if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
          } else {
            this.reader.zero = extraBytes;
          }
        } else if (extraBytes < 0) {
          throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
      },
      prepareReader: function(data) {
        this.reader = readerFor(data);
      },
      /**
       * Read a zip file and create ZipEntries.
       * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
       */
      load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
      }
    };
    module2.exports = ZipEntries;
  }
});

// node_modules/jszip/lib/load.js
var require_load = __commonJS({
  "node_modules/jszip/lib/load.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var external = require_external();
    var utf8 = require_utf8();
    var ZipEntries = require_zipEntries();
    var Crc32Probe = require_Crc32Probe();
    var nodejsUtils = require_nodejsUtils();
    function checkEntryCRC32(zipEntry) {
      return new external.Promise(function(resolve, reject2) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function(e) {
          reject2(e);
        }).on("end", function() {
          if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
            reject2(new Error("Corrupted zip : CRC32 mismatch"));
          } else {
            resolve();
          }
        }).resume();
      });
    }
    module2.exports = function(data, options) {
      var zip = this;
      options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
      });
      if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
      }
      return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data2);
        return zipEntries;
      }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
          for (var i = 0; i < files.length; i++) {
            promises.push(checkEntryCRC32(files[i]));
          }
        }
        return external.Promise.all(promises);
      }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
          var input = files[i];
          var unsafeName = input.fileNameStr;
          var safeName = utils.resolve(input.fileNameStr);
          zip.file(safeName, input.decompressed, {
            binary: true,
            optimizedBinaryString: true,
            date: input.date,
            dir: input.dir,
            comment: input.fileCommentStr.length ? input.fileCommentStr : null,
            unixPermissions: input.unixPermissions,
            dosPermissions: input.dosPermissions,
            createFolders: options.createFolders
          });
          if (!input.dir) {
            zip.file(safeName).unsafeOriginalName = unsafeName;
          }
        }
        if (zipEntries.zipComment.length) {
          zip.comment = zipEntries.zipComment;
        }
        return zip;
      });
    };
  }
});

// node_modules/jszip/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/jszip/lib/index.js"(exports2, module2) {
    "use strict";
    function JSZip() {
      if (!(this instanceof JSZip)) {
        return new JSZip();
      }
      if (arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
      }
      this.files = /* @__PURE__ */ Object.create(null);
      this.comment = null;
      this.root = "";
      this.clone = function() {
        var newObj = new JSZip();
        for (var i in this) {
          if (typeof this[i] !== "function") {
            newObj[i] = this[i];
          }
        }
        return newObj;
      };
    }
    JSZip.prototype = require_object();
    JSZip.prototype.loadAsync = require_load();
    JSZip.support = require_support();
    JSZip.defaults = require_defaults();
    JSZip.version = "3.10.1";
    JSZip.loadAsync = function(content, options) {
      return new JSZip().loadAsync(content, options);
    };
    JSZip.external = require_external();
    module2.exports = JSZip;
  }
});

// node_modules/mammoth/lib/zipfile.js
var require_zipfile = __commonJS({
  "node_modules/mammoth/lib/zipfile.js"(exports2) {
    var base64js = require_base64_js();
    var JSZip = require_lib3();
    exports2.openArrayBuffer = openArrayBuffer;
    exports2.splitPath = splitPath;
    exports2.joinPath = joinPath;
    function openArrayBuffer(arrayBuffer) {
      return JSZip.loadAsync(arrayBuffer).then(function(zipFile) {
        function exists(name) {
          return zipFile.file(name) !== null;
        }
        function read(name, encoding) {
          return zipFile.file(name).async("uint8array").then(function(array) {
            if (encoding === "base64") {
              return base64js.fromByteArray(array);
            } else if (encoding) {
              var decoder = new TextDecoder(encoding);
              return decoder.decode(array);
            } else {
              return array;
            }
          });
        }
        function write(name, contents) {
          zipFile.file(name, contents);
        }
        function toArrayBuffer() {
          return zipFile.generateAsync({ type: "arraybuffer" });
        }
        return {
          exists,
          read,
          write,
          toArrayBuffer
        };
      });
    }
    function splitPath(path) {
      var lastIndex = path.lastIndexOf("/");
      if (lastIndex === -1) {
        return { dirname: "", basename: path };
      } else {
        return {
          dirname: path.substring(0, lastIndex),
          basename: path.substring(lastIndex + 1)
        };
      }
    }
    function joinPath() {
      var nonEmptyPaths = Array.prototype.filter.call(arguments, function(path) {
        return path;
      });
      var relevantPaths = [];
      nonEmptyPaths.forEach(function(path) {
        if (/^\//.test(path)) {
          relevantPaths = [path];
        } else {
          relevantPaths.push(path);
        }
      });
      return relevantPaths.join("/");
    }
  }
});

// node_modules/mammoth/lib/xml/nodes.js
var require_nodes = __commonJS({
  "node_modules/mammoth/lib/xml/nodes.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    exports2.Element = Element;
    exports2.element = function(name, attributes, children) {
      return new Element(name, attributes, children);
    };
    exports2.text = function(value) {
      return {
        type: "text",
        value
      };
    };
    var emptyElement = exports2.emptyElement = {
      first: function() {
        return null;
      },
      firstOrEmpty: function() {
        return emptyElement;
      },
      attributes: {},
      children: []
    };
    function Element(name, attributes, children) {
      this.type = "element";
      this.name = name;
      this.attributes = attributes || {};
      this.children = children || [];
    }
    Element.prototype.first = function(name) {
      return _3.find(this.children, function(child) {
        return child.name === name;
      });
    };
    Element.prototype.firstOrEmpty = function(name) {
      return this.first(name) || emptyElement;
    };
    Element.prototype.getElementsByTagName = function(name) {
      var elements = _3.filter(this.children, function(child) {
        return child.name === name;
      });
      return toElementList(elements);
    };
    Element.prototype.text = function() {
      if (this.children.length === 0) {
        return "";
      } else if (this.children.length !== 1 || this.children[0].type !== "text") {
        throw new Error("Not implemented");
      }
      return this.children[0].value;
    };
    var elementListPrototype = {
      getElementsByTagName: function(name) {
        return toElementList(_3.flatten(this.map(function(element) {
          return element.getElementsByTagName(name);
        }, true)));
      }
    };
    function toElementList(array) {
      return _3.extend(array, elementListPrototype);
    }
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports2) {
    "use strict";
    function find2(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i = 0; i < list.length; i++) {
        if (Object.prototype.hasOwnProperty.call(list, i)) {
          var item = list[i];
          if (predicate.call(void 0, item, i, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object2, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object2) : object2;
    }
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports2.assign = assign;
    exports2.find = find2;
    exports2.freeze = freeze;
    exports2.MIME_TYPE = MIME_TYPE;
    exports2.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports2) {
    var conventions = require_conventions();
    var find2 = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p in src) {
        if (Object.prototype.hasOwnProperty.call(src, p)) {
          dest[p] = src[p];
        }
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t2 = function() {
        };
        var t = t2;
        ;
        t2.prototype = Super.prototype;
        t2 = new t2();
        copy(pt, t2);
        Class.prototype = pt = t2;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message) this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i = ls.length; i in list; i++) {
            if (Object.prototype.hasOwnProperty.call(list, i)) {
              delete list[i];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i < lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i = this.length;
        while (i--) {
          var attr = this[i];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version2) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root2 = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root2);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node2() {
    }
    Node2.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version2) {
        return this.ownerDocument.implementation.hasFeature(feature, version2);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map2 = el._nsMap;
          if (map2) {
            for (var n in map2) {
              if (Object.prototype.hasOwnProperty.call(map2, n) && map2[n] === namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map2 = el._nsMap;
          if (map2) {
            if (Object.prototype.hasOwnProperty.call(map2, prefix)) {
              return map2[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node2);
    copy(NodeType, Node2.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node2.DOCUMENT_NODE || node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node2.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node2.COMMENT_NODE || node.nodeType === Node2.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node2.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node2.ELEMENT_NODE;
    }
    function isTextNode(node) {
      return node && node.nodeType === Node2.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find2(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find2(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find2(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find2(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node2.DOCUMENT_NODE
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find2(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find2(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find2(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node2.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find2(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find2(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find2(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node2.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
        var targetDoc = parent.ownerDocument || parent;
        _updateOwnerDocument(newFirst, targetDoc);
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    function _updateOwnerDocument(node, newOwnerDocument) {
      if (node.ownerDocument === newOwnerDocument) {
        return;
      }
      node.ownerDocument = newOwnerDocument;
      if (node.nodeType === ELEMENT_NODE && node.attributes) {
        for (var i = 0; i < node.attributes.length; i++) {
          var attr = node.attributes.item(i);
          if (attr) {
            attr.ownerDocument = newOwnerDocument;
          }
        }
      }
      var child = node.firstChild;
      while (child) {
        _updateOwnerDocument(child, newOwnerDocument);
        child = child.nextSibling;
      }
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      var targetDoc = parentNode.ownerDocument || parentNode;
      _updateOwnerDocument(newChild, targetDoc);
      return newChild;
    }
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        _updateOwnerDocument(newChild, this);
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        _updateOwnerDocument(newChild, this);
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment2();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node2);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node2);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node2);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node2);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment2() {
    }
    Comment2.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment2, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node2);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node2);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node2);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node2);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node2);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node2);
    function XMLSerializer() {
    }
    XMLSerializer.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node2.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(
            node.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        //case ENTITY_NODE:
        //case NOTATION_NODE:
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        //var attrs = node2.attributes;
        //var len = attrs.length;
        //for(var i=0;i<len;i++){
        //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
        //}
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        if (Object.prototype.hasOwnProperty.call(node, n)) {
          var v = node[n];
          if (typeof v != "object") {
            if (v != node2[n]) {
              node2[n] = v;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object2, key, value) {
      object2[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node2.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object2, key, value) {
          object2["$$" + key] = value;
        };
      }
    } catch (e) {
    }
    var getTextContent;
    exports2.DocumentType = DocumentType;
    exports2.DOMException = DOMException;
    exports2.DOMImplementation = DOMImplementation;
    exports2.Element = Element;
    exports2.Node = Node2;
    exports2.NodeList = NodeList;
    exports2.XMLSerializer = XMLSerializer;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports2) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports2.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports2.HTML_ENTITIES = freeze({
      Aacute: "\xC1",
      aacute: "\xE1",
      Abreve: "\u0102",
      abreve: "\u0103",
      ac: "\u223E",
      acd: "\u223F",
      acE: "\u223E\u0333",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      Acy: "\u0410",
      acy: "\u0430",
      AElig: "\xC6",
      aelig: "\xE6",
      af: "\u2061",
      Afr: "\u{1D504}",
      afr: "\u{1D51E}",
      Agrave: "\xC0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      Alpha: "\u0391",
      alpha: "\u03B1",
      Amacr: "\u0100",
      amacr: "\u0101",
      amalg: "\u2A3F",
      AMP: "&",
      amp: "&",
      And: "\u2A53",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      Aogon: "\u0104",
      aogon: "\u0105",
      Aopf: "\u{1D538}",
      aopf: "\u{1D552}",
      ap: "\u2248",
      apacir: "\u2A6F",
      apE: "\u2A70",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      ApplyFunction: "\u2061",
      approx: "\u2248",
      approxeq: "\u224A",
      Aring: "\xC5",
      aring: "\xE5",
      Ascr: "\u{1D49C}",
      ascr: "\u{1D4B6}",
      Assign: "\u2254",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      Atilde: "\xC3",
      atilde: "\xE3",
      Auml: "\xC4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      barvee: "\u22BD",
      Barwed: "\u2306",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      Bcy: "\u0411",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      Because: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      Bfr: "\u{1D505}",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bNot: "\u2AED",
      bnot: "\u2310",
      Bopf: "\u{1D539}",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxbox: "\u29C9",
      boxDL: "\u2557",
      boxDl: "\u2556",
      boxdL: "\u2555",
      boxdl: "\u2510",
      boxDR: "\u2554",
      boxDr: "\u2553",
      boxdR: "\u2552",
      boxdr: "\u250C",
      boxH: "\u2550",
      boxh: "\u2500",
      boxHD: "\u2566",
      boxHd: "\u2564",
      boxhD: "\u2565",
      boxhd: "\u252C",
      boxHU: "\u2569",
      boxHu: "\u2567",
      boxhU: "\u2568",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxUL: "\u255D",
      boxUl: "\u255C",
      boxuL: "\u255B",
      boxul: "\u2518",
      boxUR: "\u255A",
      boxUr: "\u2559",
      boxuR: "\u2558",
      boxur: "\u2514",
      boxV: "\u2551",
      boxv: "\u2502",
      boxVH: "\u256C",
      boxVh: "\u256B",
      boxvH: "\u256A",
      boxvh: "\u253C",
      boxVL: "\u2563",
      boxVl: "\u2562",
      boxvL: "\u2561",
      boxvl: "\u2524",
      boxVR: "\u2560",
      boxVr: "\u255F",
      boxvR: "\u255E",
      boxvr: "\u251C",
      bprime: "\u2035",
      Breve: "\u02D8",
      breve: "\u02D8",
      brvbar: "\xA6",
      Bscr: "\u212C",
      bscr: "\u{1D4B7}",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\\",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      Bumpeq: "\u224E",
      bumpeq: "\u224F",
      Cacute: "\u0106",
      cacute: "\u0107",
      Cap: "\u22D2",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      CapitalDifferentialD: "\u2145",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      Cayleys: "\u212D",
      ccaps: "\u2A4D",
      Ccaron: "\u010C",
      ccaron: "\u010D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      Ccirc: "\u0108",
      ccirc: "\u0109",
      Cconint: "\u2230",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      Cdot: "\u010A",
      cdot: "\u010B",
      cedil: "\xB8",
      Cedilla: "\xB8",
      cemptyv: "\u29B2",
      cent: "\xA2",
      CenterDot: "\xB7",
      centerdot: "\xB7",
      Cfr: "\u212D",
      cfr: "\u{1D520}",
      CHcy: "\u0427",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      Chi: "\u03A7",
      chi: "\u03C7",
      cir: "\u25CB",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      CircleDot: "\u2299",
      circledR: "\xAE",
      circledS: "\u24C8",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      cirE: "\u29C3",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      clubs: "\u2663",
      clubsuit: "\u2663",
      Colon: "\u2237",
      colon: ":",
      Colone: "\u2A74",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      Congruent: "\u2261",
      Conint: "\u222F",
      conint: "\u222E",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      copf: "\u{1D554}",
      coprod: "\u2210",
      Coproduct: "\u2210",
      COPY: "\xA9",
      copy: "\xA9",
      copysr: "\u2117",
      CounterClockwiseContourIntegral: "\u2233",
      crarr: "\u21B5",
      Cross: "\u2A2F",
      cross: "\u2717",
      Cscr: "\u{1D49E}",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      Cup: "\u22D3",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      CupCap: "\u224D",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      Dagger: "\u2021",
      dagger: "\u2020",
      daleth: "\u2138",
      Darr: "\u21A1",
      dArr: "\u21D3",
      darr: "\u2193",
      dash: "\u2010",
      Dashv: "\u2AE4",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      Dcaron: "\u010E",
      dcaron: "\u010F",
      Dcy: "\u0414",
      dcy: "\u0434",
      DD: "\u2145",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      DDotrahd: "\u2911",
      ddotseq: "\u2A77",
      deg: "\xB0",
      Del: "\u2207",
      Delta: "\u0394",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      Dfr: "\u{1D507}",
      dfr: "\u{1D521}",
      dHar: "\u2965",
      dharl: "\u21C3",
      dharr: "\u21C2",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      diam: "\u22C4",
      Diamond: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      DifferentialD: "\u2146",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      DJcy: "\u0402",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      Dopf: "\u{1D53B}",
      dopf: "\u{1D555}",
      Dot: "\xA8",
      dot: "\u02D9",
      DotDot: "\u20DC",
      doteq: "\u2250",
      doteqdot: "\u2251",
      DotEqual: "\u2250",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      Downarrow: "\u21D3",
      downarrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      Dscr: "\u{1D49F}",
      dscr: "\u{1D4B9}",
      DScy: "\u0405",
      dscy: "\u0455",
      dsol: "\u29F6",
      Dstrok: "\u0110",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      DZcy: "\u040F",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      Eacute: "\xC9",
      eacute: "\xE9",
      easter: "\u2A6E",
      Ecaron: "\u011A",
      ecaron: "\u011B",
      ecir: "\u2256",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      ecolon: "\u2255",
      Ecy: "\u042D",
      ecy: "\u044D",
      eDDot: "\u2A77",
      Edot: "\u0116",
      eDot: "\u2251",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      Efr: "\u{1D508}",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      Egrave: "\xC8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      Element: "\u2208",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      Emacr: "\u0112",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      EmptySmallSquare: "\u25FB",
      emptyv: "\u2205",
      EmptyVerySmallSquare: "\u25AB",
      emsp: "\u2003",
      emsp13: "\u2004",
      emsp14: "\u2005",
      ENG: "\u014A",
      eng: "\u014B",
      ensp: "\u2002",
      Eogon: "\u0118",
      eogon: "\u0119",
      Eopf: "\u{1D53C}",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      Epsilon: "\u0395",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      Equal: "\u2A75",
      equals: "=",
      EqualTilde: "\u2242",
      equest: "\u225F",
      Equilibrium: "\u21CC",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erarr: "\u2971",
      erDot: "\u2253",
      Escr: "\u2130",
      escr: "\u212F",
      esdot: "\u2250",
      Esim: "\u2A73",
      esim: "\u2242",
      Eta: "\u0397",
      eta: "\u03B7",
      ETH: "\xD0",
      eth: "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      Exists: "\u2203",
      expectation: "\u2130",
      ExponentialE: "\u2147",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      Fcy: "\u0424",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      Ffr: "\u{1D509}",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      Fopf: "\u{1D53D}",
      fopf: "\u{1D557}",
      ForAll: "\u2200",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      Fouriertrf: "\u2131",
      fpartint: "\u2A0D",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      Fscr: "\u2131",
      fscr: "\u{1D4BB}",
      gacute: "\u01F5",
      Gamma: "\u0393",
      gamma: "\u03B3",
      Gammad: "\u03DC",
      gammad: "\u03DD",
      gap: "\u2A86",
      Gbreve: "\u011E",
      gbreve: "\u011F",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      gcirc: "\u011D",
      Gcy: "\u0413",
      gcy: "\u0433",
      Gdot: "\u0120",
      gdot: "\u0121",
      gE: "\u2267",
      ge: "\u2265",
      gEl: "\u2A8C",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      Gfr: "\u{1D50A}",
      gfr: "\u{1D524}",
      Gg: "\u22D9",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      GJcy: "\u0403",
      gjcy: "\u0453",
      gl: "\u2277",
      gla: "\u2AA5",
      glE: "\u2A92",
      glj: "\u2AA4",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gnE: "\u2269",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      Gopf: "\u{1D53E}",
      gopf: "\u{1D558}",
      grave: "`",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      Gt: "\u226B",
      GT: ">",
      gt: ">",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      Hacek: "\u02C7",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      HARDcy: "\u042A",
      hardcy: "\u044A",
      hArr: "\u21D4",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      Hat: "^",
      hbar: "\u210F",
      Hcirc: "\u0124",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      Hfr: "\u210C",
      hfr: "\u{1D525}",
      HilbertSpace: "\u210B",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      Hopf: "\u210D",
      hopf: "\u{1D559}",
      horbar: "\u2015",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      hscr: "\u{1D4BD}",
      hslash: "\u210F",
      Hstrok: "\u0126",
      hstrok: "\u0127",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      hybull: "\u2043",
      hyphen: "\u2010",
      Iacute: "\xCD",
      iacute: "\xED",
      ic: "\u2063",
      Icirc: "\xCE",
      icirc: "\xEE",
      Icy: "\u0418",
      icy: "\u0438",
      Idot: "\u0130",
      IEcy: "\u0415",
      iecy: "\u0435",
      iexcl: "\xA1",
      iff: "\u21D4",
      Ifr: "\u2111",
      ifr: "\u{1D526}",
      Igrave: "\xCC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      IJlig: "\u0132",
      ijlig: "\u0133",
      Im: "\u2111",
      Imacr: "\u012A",
      imacr: "\u012B",
      image: "\u2111",
      ImaginaryI: "\u2148",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      Implies: "\u21D2",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      Int: "\u222C",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      Integral: "\u222B",
      intercal: "\u22BA",
      Intersection: "\u22C2",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      IOcy: "\u0401",
      iocy: "\u0451",
      Iogon: "\u012E",
      iogon: "\u012F",
      Iopf: "\u{1D540}",
      iopf: "\u{1D55A}",
      Iota: "\u0399",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iquest: "\xBF",
      Iscr: "\u2110",
      iscr: "\u{1D4BE}",
      isin: "\u2208",
      isindot: "\u22F5",
      isinE: "\u22F9",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      Itilde: "\u0128",
      itilde: "\u0129",
      Iukcy: "\u0406",
      iukcy: "\u0456",
      Iuml: "\xCF",
      iuml: "\xEF",
      Jcirc: "\u0134",
      jcirc: "\u0135",
      Jcy: "\u0419",
      jcy: "\u0439",
      Jfr: "\u{1D50D}",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      Jopf: "\u{1D541}",
      jopf: "\u{1D55B}",
      Jscr: "\u{1D4A5}",
      jscr: "\u{1D4BF}",
      Jsercy: "\u0408",
      jsercy: "\u0458",
      Jukcy: "\u0404",
      jukcy: "\u0454",
      Kappa: "\u039A",
      kappa: "\u03BA",
      kappav: "\u03F0",
      Kcedil: "\u0136",
      kcedil: "\u0137",
      Kcy: "\u041A",
      kcy: "\u043A",
      Kfr: "\u{1D50E}",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      KHcy: "\u0425",
      khcy: "\u0445",
      KJcy: "\u040C",
      kjcy: "\u045C",
      Kopf: "\u{1D542}",
      kopf: "\u{1D55C}",
      Kscr: "\u{1D4A6}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      Lacute: "\u0139",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      Lambda: "\u039B",
      lambda: "\u03BB",
      Lang: "\u27EA",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      Laplacetrf: "\u2112",
      laquo: "\xAB",
      Larr: "\u219E",
      lArr: "\u21D0",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      lAtail: "\u291B",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lBarr: "\u290E",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      Lcaron: "\u013D",
      lcaron: "\u013E",
      Lcedil: "\u013B",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      Lcy: "\u041B",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      lE: "\u2266",
      le: "\u2264",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      Leftarrow: "\u21D0",
      leftarrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      leftarrowtail: "\u21A2",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      LeftRightArrow: "\u2194",
      Leftrightarrow: "\u21D4",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      leftthreetimes: "\u22CB",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      lEg: "\u2A8B",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      lessgtr: "\u2276",
      LessLess: "\u2AA1",
      lesssim: "\u2272",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      Lfr: "\u{1D50F}",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lHar: "\u2962",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      LJcy: "\u0409",
      ljcy: "\u0459",
      Ll: "\u22D8",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      Lleftarrow: "\u21DA",
      llhard: "\u296B",
      lltri: "\u25FA",
      Lmidot: "\u013F",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lnE: "\u2268",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      LongLeftArrow: "\u27F5",
      Longleftarrow: "\u27F8",
      longleftarrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      Longleftrightarrow: "\u27FA",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      LongRightArrow: "\u27F6",
      Longrightarrow: "\u27F9",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      Lopf: "\u{1D543}",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      Lscr: "\u2112",
      lscr: "\u{1D4C1}",
      Lsh: "\u21B0",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      Lstrok: "\u0141",
      lstrok: "\u0142",
      Lt: "\u226A",
      LT: "<",
      lt: "<",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      ltrPar: "\u2996",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      Map: "\u2905",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      Mcy: "\u041C",
      mcy: "\u043C",
      mdash: "\u2014",
      mDDot: "\u223A",
      measuredangle: "\u2221",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micro: "\xB5",
      mid: "\u2223",
      midast: "*",
      midcir: "\u2AF0",
      middot: "\xB7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      MinusPlus: "\u2213",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      Mopf: "\u{1D544}",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      Mscr: "\u2133",
      mscr: "\u{1D4C2}",
      mstpos: "\u223E",
      Mu: "\u039C",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nabla: "\u2207",
      Nacute: "\u0143",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      Ncaron: "\u0147",
      ncaron: "\u0148",
      Ncedil: "\u0145",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      Ncy: "\u041D",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      nearhk: "\u2924",
      neArr: "\u21D7",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      nexist: "\u2204",
      nexists: "\u2204",
      Nfr: "\u{1D511}",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      nGg: "\u22D9\u0338",
      ngsim: "\u2275",
      nGt: "\u226B\u20D2",
      ngt: "\u226F",
      ngtr: "\u226F",
      nGtv: "\u226B\u0338",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      NJcy: "\u040A",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlarr: "\u219A",
      nldr: "\u2025",
      nlE: "\u2266\u0338",
      nle: "\u2270",
      nLeftarrow: "\u21CD",
      nleftarrow: "\u219A",
      nLeftrightarrow: "\u21CE",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nLl: "\u22D8\u0338",
      nlsim: "\u2274",
      nLt: "\u226A\u20D2",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nLtv: "\u226A\u0338",
      nmid: "\u2224",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      Nopf: "\u2115",
      nopf: "\u{1D55F}",
      Not: "\u2AEC",
      not: "\xAC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      notin: "\u2209",
      notindot: "\u22F5\u0338",
      notinE: "\u22F9\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nRightarrow: "\u21CF",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      Nscr: "\u{1D4A9}",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      Nu: "\u039D",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvap: "\u224D\u20D2",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nvDash: "\u22AD",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvHarr: "\u2904",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwarhk: "\u2923",
      nwArr: "\u21D6",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      Oacute: "\xD3",
      oacute: "\xF3",
      oast: "\u229B",
      ocir: "\u229A",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      Ocy: "\u041E",
      ocy: "\u043E",
      odash: "\u229D",
      Odblac: "\u0150",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      OElig: "\u0152",
      oelig: "\u0153",
      ofcir: "\u29BF",
      Ofr: "\u{1D512}",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      Ograve: "\xD2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      Omacr: "\u014C",
      omacr: "\u014D",
      Omega: "\u03A9",
      omega: "\u03C9",
      Omicron: "\u039F",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      Oopf: "\u{1D546}",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      operp: "\u29B9",
      oplus: "\u2295",
      Or: "\u2A54",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\u2A5D",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oS: "\u24C8",
      Oscr: "\u{1D4AA}",
      oscr: "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      osol: "\u2298",
      Otilde: "\xD5",
      otilde: "\xF5",
      Otimes: "\u2A37",
      otimes: "\u2297",
      otimesas: "\u2A36",
      Ouml: "\xD6",
      ouml: "\xF6",
      ovbar: "\u233D",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      par: "\u2225",
      para: "\xB6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      PartialD: "\u2202",
      Pcy: "\u041F",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      Pfr: "\u{1D513}",
      pfr: "\u{1D52D}",
      Phi: "\u03A6",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      Pi: "\u03A0",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "+",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      PlusMinus: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      Poincareplane: "\u210C",
      pointint: "\u2A15",
      Popf: "\u2119",
      popf: "\u{1D561}",
      pound: "\xA3",
      Pr: "\u2ABB",
      pr: "\u227A",
      prap: "\u2AB7",
      prcue: "\u227C",
      prE: "\u2AB3",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      Prime: "\u2033",
      prime: "\u2032",
      primes: "\u2119",
      prnap: "\u2AB9",
      prnE: "\u2AB5",
      prnsim: "\u22E8",
      prod: "\u220F",
      Product: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      Proportion: "\u2237",
      Proportional: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      Pscr: "\u{1D4AB}",
      pscr: "\u{1D4C5}",
      Psi: "\u03A8",
      psi: "\u03C8",
      puncsp: "\u2008",
      Qfr: "\u{1D514}",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      Qopf: "\u211A",
      qopf: "\u{1D562}",
      qprime: "\u2057",
      Qscr: "\u{1D4AC}",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      QUOT: '"',
      quot: '"',
      rAarr: "\u21DB",
      race: "\u223D\u0331",
      Racute: "\u0154",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      Rang: "\u27EB",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raquo: "\xBB",
      Rarr: "\u21A0",
      rArr: "\u21D2",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      Rarrtl: "\u2916",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      rAtail: "\u291C",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      RBarr: "\u2910",
      rBarr: "\u290F",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      Rcaron: "\u0158",
      rcaron: "\u0159",
      Rcedil: "\u0156",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      Rcy: "\u0420",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      Re: "\u211C",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      REG: "\xAE",
      reg: "\xAE",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      rfisht: "\u297D",
      rfloor: "\u230B",
      Rfr: "\u211C",
      rfr: "\u{1D52F}",
      rHar: "\u2964",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      Rho: "\u03A1",
      rho: "\u03C1",
      rhov: "\u03F1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      Rightarrow: "\u21D2",
      rightarrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      rightarrowtail: "\u21A3",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      rightthreetimes: "\u22CC",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      Ropf: "\u211D",
      ropf: "\u{1D563}",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      RoundImplies: "\u2970",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      Rrightarrow: "\u21DB",
      rsaquo: "\u203A",
      Rscr: "\u211B",
      rscr: "\u{1D4C7}",
      Rsh: "\u21B1",
      rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      RuleDelayed: "\u29F4",
      ruluhar: "\u2968",
      rx: "\u211E",
      Sacute: "\u015A",
      sacute: "\u015B",
      sbquo: "\u201A",
      Sc: "\u2ABC",
      sc: "\u227B",
      scap: "\u2AB8",
      Scaron: "\u0160",
      scaron: "\u0161",
      sccue: "\u227D",
      scE: "\u2AB4",
      sce: "\u2AB0",
      Scedil: "\u015E",
      scedil: "\u015F",
      Scirc: "\u015C",
      scirc: "\u015D",
      scnap: "\u2ABA",
      scnE: "\u2AB6",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      Scy: "\u0421",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      searhk: "\u2925",
      seArr: "\u21D8",
      searr: "\u2198",
      searrow: "\u2198",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      Sfr: "\u{1D516}",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      SHCHcy: "\u0429",
      shchcy: "\u0449",
      SHcy: "\u0428",
      shcy: "\u0448",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      shy: "\xAD",
      Sigma: "\u03A3",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      SmallCircle: "\u2218",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      SOFTcy: "\u042C",
      softcy: "\u044C",
      sol: "/",
      solb: "\u29C4",
      solbar: "\u233F",
      Sopf: "\u{1D54A}",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      Sqrt: "\u221A",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      Square: "\u25A1",
      square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      Sscr: "\u{1D4AE}",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      Star: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      Sub: "\u22D0",
      sub: "\u2282",
      subdot: "\u2ABD",
      subE: "\u2AC5",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      Subset: "\u22D0",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      SubsetEqual: "\u2286",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      sum: "\u2211",
      sung: "\u266A",
      Sup: "\u22D1",
      sup: "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supE: "\u2AC6",
      supe: "\u2287",
      supedot: "\u2AC4",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      Supset: "\u22D1",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swarhk: "\u2926",
      swArr: "\u21D9",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szlig: "\xDF",
      Tab: "	",
      target: "\u2316",
      Tau: "\u03A4",
      tau: "\u03C4",
      tbrk: "\u23B4",
      Tcaron: "\u0164",
      tcaron: "\u0165",
      Tcedil: "\u0162",
      tcedil: "\u0163",
      Tcy: "\u0422",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      Tfr: "\u{1D517}",
      tfr: "\u{1D531}",
      there4: "\u2234",
      Therefore: "\u2234",
      therefore: "\u2234",
      Theta: "\u0398",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      ThickSpace: "\u205F\u200A",
      thinsp: "\u2009",
      ThinSpace: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      THORN: "\xDE",
      thorn: "\xFE",
      Tilde: "\u223C",
      tilde: "\u02DC",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      times: "\xD7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      Topf: "\u{1D54B}",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      TRADE: "\u2122",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      TripleDot: "\u20DB",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      Tscr: "\u{1D4AF}",
      tscr: "\u{1D4C9}",
      TScy: "\u0426",
      tscy: "\u0446",
      TSHcy: "\u040B",
      tshcy: "\u045B",
      Tstrok: "\u0166",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      Uacute: "\xDA",
      uacute: "\xFA",
      Uarr: "\u219F",
      uArr: "\u21D1",
      uarr: "\u2191",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      ubrcy: "\u045E",
      Ubreve: "\u016C",
      ubreve: "\u016D",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      Ucy: "\u0423",
      ucy: "\u0443",
      udarr: "\u21C5",
      Udblac: "\u0170",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      Ufr: "\u{1D518}",
      ufr: "\u{1D532}",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      uHar: "\u2963",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      Umacr: "\u016A",
      umacr: "\u016B",
      uml: "\xA8",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      uogon: "\u0173",
      Uopf: "\u{1D54C}",
      uopf: "\u{1D566}",
      UpArrow: "\u2191",
      Uparrow: "\u21D1",
      uparrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      Updownarrow: "\u21D5",
      updownarrow: "\u2195",
      UpEquilibrium: "\u296E",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      upsi: "\u03C5",
      upsih: "\u03D2",
      Upsilon: "\u03A5",
      upsilon: "\u03C5",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      Uring: "\u016E",
      uring: "\u016F",
      urtri: "\u25F9",
      Uscr: "\u{1D4B0}",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      Utilde: "\u0168",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      Uuml: "\xDC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      vArr: "\u21D5",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      Vbar: "\u2AEB",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      Vcy: "\u0412",
      vcy: "\u0432",
      VDash: "\u22AB",
      Vdash: "\u22A9",
      vDash: "\u22A8",
      vdash: "\u22A2",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      Verbar: "\u2016",
      verbar: "|",
      Vert: "\u2016",
      vert: "|",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      Vopf: "\u{1D54D}",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      Vscr: "\u{1D4B1}",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      Vvdash: "\u22AA",
      vzigzag: "\u299A",
      Wcirc: "\u0174",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      Wedge: "\u22C0",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      Wfr: "\u{1D51A}",
      wfr: "\u{1D534}",
      Wopf: "\u{1D54E}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      Wscr: "\u{1D4B2}",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      Xfr: "\u{1D51B}",
      xfr: "\u{1D535}",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      Xi: "\u039E",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      Xopf: "\u{1D54F}",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      Xscr: "\u{1D4B3}",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      Yacute: "\xDD",
      yacute: "\xFD",
      YAcy: "\u042F",
      yacy: "\u044F",
      Ycirc: "\u0176",
      ycirc: "\u0177",
      Ycy: "\u042B",
      ycy: "\u044B",
      yen: "\xA5",
      Yfr: "\u{1D51C}",
      yfr: "\u{1D536}",
      YIcy: "\u0407",
      yicy: "\u0457",
      Yopf: "\u{1D550}",
      yopf: "\u{1D56A}",
      Yscr: "\u{1D4B4}",
      yscr: "\u{1D4CE}",
      YUcy: "\u042E",
      yucy: "\u044E",
      Yuml: "\u0178",
      yuml: "\xFF",
      Zacute: "\u0179",
      zacute: "\u017A",
      Zcaron: "\u017D",
      zcaron: "\u017E",
      Zcy: "\u0417",
      zcy: "\u0437",
      Zdot: "\u017B",
      zdot: "\u017C",
      zeetrf: "\u2128",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      zeta: "\u03B6",
      Zfr: "\u2128",
      zfr: "\u{1D537}",
      ZHcy: "\u0416",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      Zopf: "\u2124",
      zopf: "\u{1D56B}",
      Zscr: "\u{1D4B5}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    });
    exports2.entityMap = exports2.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports2) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse2(
          source,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse2(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var k = a2.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k)) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config2 = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config2.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config2.localNSMap;
              var endMatch = config2.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config2.tagName && config2.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config2.uri, config2.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config2.tagName);
                }
              } else {
                parseStack.push(config2);
              }
              end++;
              break;
            // end elment
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f, t) {
      t.lineNumber = f.lineNumber;
      t.columnNumber = f.columnNumber;
      return t;
    }
    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p = ++start;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p);
              }
              start = p + 1;
              p = source.indexOf(c, start);
              if (p > 0) {
                value = source.slice(start, p);
                addAttribute(attrName, value, start - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              //case S_EQ:
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              //normal
              case S_ATTR_NOQUOT_VALUE:
              //Compatible state
              case S_ATTR:
                value = source.slice(start, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p;
          /*xml space '\x20' | #x9 | #xD | #xA; */
          case "\x80":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                //case S_TAG:void();break;
                //case S_ATTR:void();break;
                //case S_ATTR_NOQUOT_VALUE:void();break;
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n in source) {
        if (Object.prototype.hasOwnProperty.call(source, n)) {
          target[n] = source[n];
        }
      }
    }
    function parseDCC(source, start, domBuilder, errorHandler) {
      var next = source.charAt(start + 2);
      switch (next) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1]) return buf;
      }
    }
    exports2.XMLReader = XMLReader;
    exports2.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports2) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser(options) {
      this.options = options || { locator: {} };
    }
    DOMParser.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax2.parse(
          normalize(source),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build2(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build2("warning");
      build2("error");
      build2("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l2) {
      if (l2) {
        return "\n@" + (l2.systemId || "") + "#[line:" + l2.lineNumber + ",col:" + l2.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports2.__DOMHandler = DOMHandler;
    exports2.normalizeLineEndings = normalizeLineEndings;
    exports2.DOMParser = DOMParser;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports2) {
    var dom = require_dom();
    exports2.DOMImplementation = dom.DOMImplementation;
    exports2.XMLSerializer = dom.XMLSerializer;
    exports2.DOMParser = require_dom_parser().DOMParser;
  }
});

// node_modules/mammoth/lib/xml/xmldom.js
var require_xmldom = __commonJS({
  "node_modules/mammoth/lib/xml/xmldom.js"(exports2) {
    var xmldom = require_lib4();
    var dom = require_dom();
    function parseFromString(string) {
      var error = null;
      var domParser = new xmldom.DOMParser({
        errorHandler: function(level, message) {
          error = { level, message };
        }
      });
      var document2 = domParser.parseFromString(string);
      if (error === null) {
        return document2;
      } else {
        throw new Error(error.level + ": " + error.message);
      }
    }
    exports2.parseFromString = parseFromString;
    exports2.Node = dom.Node;
  }
});

// node_modules/mammoth/lib/xml/reader.js
var require_reader = __commonJS({
  "node_modules/mammoth/lib/xml/reader.js"(exports2) {
    var promises = require_promises();
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var xmldom = require_xmldom();
    var nodes = require_nodes();
    var Element = nodes.Element;
    exports2.readString = readString;
    var Node2 = xmldom.Node;
    function readString(xmlString, namespaceMap) {
      namespaceMap = namespaceMap || {};
      try {
        var document2 = xmldom.parseFromString(xmlString, "text/xml");
      } catch (error) {
        return promises.reject(error);
      }
      if (document2.documentElement.tagName === "parsererror") {
        return promises.resolve(new Error(document2.documentElement.textContent));
      }
      function convertNode(node) {
        switch (node.nodeType) {
          case Node2.ELEMENT_NODE:
            return convertElement(node);
          case Node2.TEXT_NODE:
            return nodes.text(node.nodeValue);
        }
      }
      function convertElement(element) {
        var convertedName = convertName(element);
        var convertedChildren = [];
        _3.forEach(element.childNodes, function(childNode) {
          var convertedNode = convertNode(childNode);
          if (convertedNode) {
            convertedChildren.push(convertedNode);
          }
        });
        var convertedAttributes = {};
        _3.forEach(element.attributes, function(attribute) {
          convertedAttributes[convertName(attribute)] = attribute.value;
        });
        return new Element(convertedName, convertedAttributes, convertedChildren);
      }
      function convertName(node) {
        if (node.namespaceURI) {
          var mappedPrefix = namespaceMap[node.namespaceURI];
          var prefix;
          if (mappedPrefix) {
            prefix = mappedPrefix + ":";
          } else {
            prefix = "{" + node.namespaceURI + "}";
          }
          return prefix + node.localName;
        } else {
          return node.localName;
        }
      }
      return promises.resolve(convertNode(document2.documentElement));
    }
  }
});

// node_modules/xmlbuilder/lib/Utility.js
var require_Utility = __commonJS({
  "node_modules/xmlbuilder/lib/Utility.js"(exports2, module2) {
    (function() {
      var assign, getValue, isArray, isEmpty2, isFunction2, isObject3, isPlainObject, slice2 = [].slice, hasProp = {}.hasOwnProperty;
      assign = function() {
        var i, key, len, source, sources, target;
        target = arguments[0], sources = 2 <= arguments.length ? slice2.call(arguments, 1) : [];
        if (isFunction2(Object.assign)) {
          Object.assign.apply(null, arguments);
        } else {
          for (i = 0, len = sources.length; i < len; i++) {
            source = sources[i];
            if (source != null) {
              for (key in source) {
                if (!hasProp.call(source, key)) continue;
                target[key] = source[key];
              }
            }
          }
        }
        return target;
      };
      isFunction2 = function(val) {
        return !!val && Object.prototype.toString.call(val) === "[object Function]";
      };
      isObject3 = function(val) {
        var ref;
        return !!val && ((ref = typeof val) === "function" || ref === "object");
      };
      isArray = function(val) {
        if (isFunction2(Array.isArray)) {
          return Array.isArray(val);
        } else {
          return Object.prototype.toString.call(val) === "[object Array]";
        }
      };
      isEmpty2 = function(val) {
        var key;
        if (isArray(val)) {
          return !val.length;
        } else {
          for (key in val) {
            if (!hasProp.call(val, key)) continue;
            return false;
          }
          return true;
        }
      };
      isPlainObject = function(val) {
        var ctor2, proto;
        return isObject3(val) && (proto = Object.getPrototypeOf(val)) && (ctor2 = proto.constructor) && typeof ctor2 === "function" && ctor2 instanceof ctor2 && Function.prototype.toString.call(ctor2) === Function.prototype.toString.call(Object);
      };
      getValue = function(obj2) {
        if (isFunction2(obj2.valueOf)) {
          return obj2.valueOf();
        } else {
          return obj2;
        }
      };
      module2.exports.assign = assign;
      module2.exports.isFunction = isFunction2;
      module2.exports.isObject = isObject3;
      module2.exports.isArray = isArray;
      module2.exports.isEmpty = isEmpty2;
      module2.exports.isPlainObject = isPlainObject;
      module2.exports.getValue = getValue;
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLAttribute.js
var require_XMLAttribute = __commonJS({
  "node_modules/xmlbuilder/lib/XMLAttribute.js"(exports2, module2) {
    (function() {
      var XMLAttribute;
      module2.exports = XMLAttribute = (function() {
        function XMLAttribute2(parent, name, value) {
          this.options = parent.options;
          this.stringify = parent.stringify;
          this.parent = parent;
          if (name == null) {
            throw new Error("Missing attribute name. " + this.debugInfo(name));
          }
          if (value == null) {
            throw new Error("Missing attribute value. " + this.debugInfo(name));
          }
          this.name = this.stringify.attName(name);
          this.value = this.stringify.attValue(value);
        }
        XMLAttribute2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLAttribute2.prototype.toString = function(options) {
          return this.options.writer.set(options).attribute(this);
        };
        XMLAttribute2.prototype.debugInfo = function(name) {
          name = name || this.name;
          if (name == null) {
            return "parent: <" + this.parent.name + ">";
          } else {
            return "attribute: {" + name + "}, parent: <" + this.parent.name + ">";
          }
        };
        return XMLAttribute2;
      })();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLElement.js
var require_XMLElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLElement.js"(exports2, module2) {
    (function() {
      var XMLAttribute, XMLElement, XMLNode, getValue, isFunction2, isObject3, ref, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject3 = ref.isObject, isFunction2 = ref.isFunction, getValue = ref.getValue;
      XMLNode = require_XMLNode();
      XMLAttribute = require_XMLAttribute();
      module2.exports = XMLElement = (function(superClass) {
        extend(XMLElement2, superClass);
        function XMLElement2(parent, name, attributes) {
          XMLElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing element name. " + this.debugInfo());
          }
          this.name = this.stringify.eleName(name);
          this.attributes = {};
          if (attributes != null) {
            this.attribute(attributes);
          }
          if (parent.isDocument) {
            this.isRoot = true;
            this.documentObject = parent;
            parent.rootObject = this;
          }
        }
        XMLElement2.prototype.clone = function() {
          var att, attName, clonedSelf, ref1;
          clonedSelf = Object.create(this);
          if (clonedSelf.isRoot) {
            clonedSelf.documentObject = null;
          }
          clonedSelf.attributes = {};
          ref1 = this.attributes;
          for (attName in ref1) {
            if (!hasProp.call(ref1, attName)) continue;
            att = ref1[attName];
            clonedSelf.attributes[attName] = att.clone();
          }
          clonedSelf.children = [];
          this.children.forEach(function(child) {
            var clonedChild;
            clonedChild = child.clone();
            clonedChild.parent = clonedSelf;
            return clonedSelf.children.push(clonedChild);
          });
          return clonedSelf;
        };
        XMLElement2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (name != null) {
            name = getValue(name);
          }
          if (isObject3(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName)) continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction2(value)) {
              value = value.apply();
            }
            if (!this.options.skipNullAttributes || value != null) {
              this.attributes[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLElement2.prototype.removeAttribute = function(name) {
          var attName, i, len;
          if (name == null) {
            throw new Error("Missing attribute name. " + this.debugInfo());
          }
          name = getValue(name);
          if (Array.isArray(name)) {
            for (i = 0, len = name.length; i < len; i++) {
              attName = name[i];
              delete this.attributes[attName];
            }
          } else {
            delete this.attributes[name];
          }
          return this;
        };
        XMLElement2.prototype.toString = function(options) {
          return this.options.writer.set(options).element(this);
        };
        XMLElement2.prototype.att = function(name, value) {
          return this.attribute(name, value);
        };
        XMLElement2.prototype.a = function(name, value) {
          return this.attribute(name, value);
        };
        return XMLElement2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLCData.js
var require_XMLCData = __commonJS({
  "node_modules/xmlbuilder/lib/XMLCData.js"(exports2, module2) {
    (function() {
      var XMLCData, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLCData = (function(superClass) {
        extend(XMLCData2, superClass);
        function XMLCData2(parent, text) {
          XMLCData2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing CDATA text. " + this.debugInfo());
          }
          this.text = this.stringify.cdata(text);
        }
        XMLCData2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLCData2.prototype.toString = function(options) {
          return this.options.writer.set(options).cdata(this);
        };
        return XMLCData2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLComment.js
var require_XMLComment = __commonJS({
  "node_modules/xmlbuilder/lib/XMLComment.js"(exports2, module2) {
    (function() {
      var XMLComment, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLComment = (function(superClass) {
        extend(XMLComment2, superClass);
        function XMLComment2(parent, text) {
          XMLComment2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing comment text. " + this.debugInfo());
          }
          this.text = this.stringify.comment(text);
        }
        XMLComment2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLComment2.prototype.toString = function(options) {
          return this.options.writer.set(options).comment(this);
        };
        return XMLComment2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDeclaration.js
var require_XMLDeclaration = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDeclaration.js"(exports2, module2) {
    (function() {
      var XMLDeclaration, XMLNode, isObject3, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject3 = require_Utility().isObject;
      XMLNode = require_XMLNode();
      module2.exports = XMLDeclaration = (function(superClass) {
        extend(XMLDeclaration2, superClass);
        function XMLDeclaration2(parent, version2, encoding, standalone) {
          var ref;
          XMLDeclaration2.__super__.constructor.call(this, parent);
          if (isObject3(version2)) {
            ref = version2, version2 = ref.version, encoding = ref.encoding, standalone = ref.standalone;
          }
          if (!version2) {
            version2 = "1.0";
          }
          this.version = this.stringify.xmlVersion(version2);
          if (encoding != null) {
            this.encoding = this.stringify.xmlEncoding(encoding);
          }
          if (standalone != null) {
            this.standalone = this.stringify.xmlStandalone(standalone);
          }
        }
        XMLDeclaration2.prototype.toString = function(options) {
          return this.options.writer.set(options).declaration(this);
        };
        return XMLDeclaration2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDAttList.js
var require_XMLDTDAttList = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDAttList.js"(exports2, module2) {
    (function() {
      var XMLDTDAttList, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDAttList = (function(superClass) {
        extend(XMLDTDAttList2, superClass);
        function XMLDTDAttList2(parent, elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          XMLDTDAttList2.__super__.constructor.call(this, parent);
          if (elementName == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (attributeName == null) {
            throw new Error("Missing DTD attribute name. " + this.debugInfo(elementName));
          }
          if (!attributeType) {
            throw new Error("Missing DTD attribute type. " + this.debugInfo(elementName));
          }
          if (!defaultValueType) {
            throw new Error("Missing DTD attribute default. " + this.debugInfo(elementName));
          }
          if (defaultValueType.indexOf("#") !== 0) {
            defaultValueType = "#" + defaultValueType;
          }
          if (!defaultValueType.match(/^(#REQUIRED|#IMPLIED|#FIXED|#DEFAULT)$/)) {
            throw new Error("Invalid default value type; expected: #REQUIRED, #IMPLIED, #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          if (defaultValue && !defaultValueType.match(/^(#FIXED|#DEFAULT)$/)) {
            throw new Error("Default value only applies to #FIXED or #DEFAULT. " + this.debugInfo(elementName));
          }
          this.elementName = this.stringify.eleName(elementName);
          this.attributeName = this.stringify.attName(attributeName);
          this.attributeType = this.stringify.dtdAttType(attributeType);
          this.defaultValue = this.stringify.dtdAttDefault(defaultValue);
          this.defaultValueType = defaultValueType;
        }
        XMLDTDAttList2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdAttList(this);
        };
        return XMLDTDAttList2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDEntity.js
var require_XMLDTDEntity = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDEntity.js"(exports2, module2) {
    (function() {
      var XMLDTDEntity, XMLNode, isObject3, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject3 = require_Utility().isObject;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDEntity = (function(superClass) {
        extend(XMLDTDEntity2, superClass);
        function XMLDTDEntity2(parent, pe, name, value) {
          XMLDTDEntity2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD entity name. " + this.debugInfo(name));
          }
          if (value == null) {
            throw new Error("Missing DTD entity value. " + this.debugInfo(name));
          }
          this.pe = !!pe;
          this.name = this.stringify.eleName(name);
          if (!isObject3(value)) {
            this.value = this.stringify.dtdEntityValue(value);
          } else {
            if (!value.pubID && !value.sysID) {
              throw new Error("Public and/or system identifiers are required for an external entity. " + this.debugInfo(name));
            }
            if (value.pubID && !value.sysID) {
              throw new Error("System identifier is required for a public external entity. " + this.debugInfo(name));
            }
            if (value.pubID != null) {
              this.pubID = this.stringify.dtdPubID(value.pubID);
            }
            if (value.sysID != null) {
              this.sysID = this.stringify.dtdSysID(value.sysID);
            }
            if (value.nData != null) {
              this.nData = this.stringify.dtdNData(value.nData);
            }
            if (this.pe && this.nData) {
              throw new Error("Notation declaration is not allowed in a parameter entity. " + this.debugInfo(name));
            }
          }
        }
        XMLDTDEntity2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdEntity(this);
        };
        return XMLDTDEntity2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDElement.js
var require_XMLDTDElement = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDElement.js"(exports2, module2) {
    (function() {
      var XMLDTDElement, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDElement = (function(superClass) {
        extend(XMLDTDElement2, superClass);
        function XMLDTDElement2(parent, name, value) {
          XMLDTDElement2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD element name. " + this.debugInfo());
          }
          if (!value) {
            value = "(#PCDATA)";
          }
          if (Array.isArray(value)) {
            value = "(" + value.join(",") + ")";
          }
          this.name = this.stringify.eleName(name);
          this.value = this.stringify.dtdElementValue(value);
        }
        XMLDTDElement2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdElement(this);
        };
        return XMLDTDElement2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDTDNotation.js
var require_XMLDTDNotation = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDTDNotation.js"(exports2, module2) {
    (function() {
      var XMLDTDNotation, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDTDNotation = (function(superClass) {
        extend(XMLDTDNotation2, superClass);
        function XMLDTDNotation2(parent, name, value) {
          XMLDTDNotation2.__super__.constructor.call(this, parent);
          if (name == null) {
            throw new Error("Missing DTD notation name. " + this.debugInfo(name));
          }
          if (!value.pubID && !value.sysID) {
            throw new Error("Public or system identifiers are required for an external entity. " + this.debugInfo(name));
          }
          this.name = this.stringify.eleName(name);
          if (value.pubID != null) {
            this.pubID = this.stringify.dtdPubID(value.pubID);
          }
          if (value.sysID != null) {
            this.sysID = this.stringify.dtdSysID(value.sysID);
          }
        }
        XMLDTDNotation2.prototype.toString = function(options) {
          return this.options.writer.set(options).dtdNotation(this);
        };
        return XMLDTDNotation2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocType.js
var require_XMLDocType = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocType.js"(exports2, module2) {
    (function() {
      var XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDocType, XMLNode, isObject3, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isObject3 = require_Utility().isObject;
      XMLNode = require_XMLNode();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      module2.exports = XMLDocType = (function(superClass) {
        extend(XMLDocType2, superClass);
        function XMLDocType2(parent, pubID, sysID) {
          var ref, ref1;
          XMLDocType2.__super__.constructor.call(this, parent);
          this.name = "!DOCTYPE";
          this.documentObject = parent;
          if (isObject3(pubID)) {
            ref = pubID, pubID = ref.pubID, sysID = ref.sysID;
          }
          if (sysID == null) {
            ref1 = [pubID, sysID], sysID = ref1[0], pubID = ref1[1];
          }
          if (pubID != null) {
            this.pubID = this.stringify.dtdPubID(pubID);
          }
          if (sysID != null) {
            this.sysID = this.stringify.dtdSysID(sysID);
          }
        }
        XMLDocType2.prototype.element = function(name, value) {
          var child;
          child = new XMLDTDElement(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var child;
          child = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.entity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, false, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.pEntity = function(name, value) {
          var child;
          child = new XMLDTDEntity(this, true, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.notation = function(name, value) {
          var child;
          child = new XMLDTDNotation(this, name, value);
          this.children.push(child);
          return this;
        };
        XMLDocType2.prototype.toString = function(options) {
          return this.options.writer.set(options).docType(this);
        };
        XMLDocType2.prototype.ele = function(name, value) {
          return this.element(name, value);
        };
        XMLDocType2.prototype.att = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          return this.attList(elementName, attributeName, attributeType, defaultValueType, defaultValue);
        };
        XMLDocType2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocType2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocType2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        XMLDocType2.prototype.up = function() {
          return this.root() || this.documentObject;
        };
        return XMLDocType2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLRaw.js
var require_XMLRaw = __commonJS({
  "node_modules/xmlbuilder/lib/XMLRaw.js"(exports2, module2) {
    (function() {
      var XMLNode, XMLRaw, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLRaw = (function(superClass) {
        extend(XMLRaw2, superClass);
        function XMLRaw2(parent, text) {
          XMLRaw2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing raw text. " + this.debugInfo());
          }
          this.value = this.stringify.raw(text);
        }
        XMLRaw2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLRaw2.prototype.toString = function(options) {
          return this.options.writer.set(options).raw(this);
        };
        return XMLRaw2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLText.js
var require_XMLText = __commonJS({
  "node_modules/xmlbuilder/lib/XMLText.js"(exports2, module2) {
    (function() {
      var XMLNode, XMLText, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLText = (function(superClass) {
        extend(XMLText2, superClass);
        function XMLText2(parent, text) {
          XMLText2.__super__.constructor.call(this, parent);
          if (text == null) {
            throw new Error("Missing element text. " + this.debugInfo());
          }
          this.value = this.stringify.eleText(text);
        }
        XMLText2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLText2.prototype.toString = function(options) {
          return this.options.writer.set(options).text(this);
        };
        return XMLText2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLProcessingInstruction.js
var require_XMLProcessingInstruction = __commonJS({
  "node_modules/xmlbuilder/lib/XMLProcessingInstruction.js"(exports2, module2) {
    (function() {
      var XMLNode, XMLProcessingInstruction, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLProcessingInstruction = (function(superClass) {
        extend(XMLProcessingInstruction2, superClass);
        function XMLProcessingInstruction2(parent, target, value) {
          XMLProcessingInstruction2.__super__.constructor.call(this, parent);
          if (target == null) {
            throw new Error("Missing instruction target. " + this.debugInfo());
          }
          this.target = this.stringify.insTarget(target);
          if (value) {
            this.value = this.stringify.insValue(value);
          }
        }
        XMLProcessingInstruction2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLProcessingInstruction2.prototype.toString = function(options) {
          return this.options.writer.set(options).processingInstruction(this);
        };
        return XMLProcessingInstruction2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDummy.js
var require_XMLDummy = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDummy.js"(exports2, module2) {
    (function() {
      var XMLDummy, XMLNode, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLNode = require_XMLNode();
      module2.exports = XMLDummy = (function(superClass) {
        extend(XMLDummy2, superClass);
        function XMLDummy2(parent) {
          XMLDummy2.__super__.constructor.call(this, parent);
          this.isDummy = true;
        }
        XMLDummy2.prototype.clone = function() {
          return Object.create(this);
        };
        XMLDummy2.prototype.toString = function(options) {
          return "";
        };
        return XMLDummy2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLNode.js
var require_XMLNode = __commonJS({
  "node_modules/xmlbuilder/lib/XMLNode.js"(exports2, module2) {
    (function() {
      var XMLCData, XMLComment, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLNode, XMLProcessingInstruction, XMLRaw, XMLText, getValue, isEmpty2, isFunction2, isObject3, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject3 = ref.isObject, isFunction2 = ref.isFunction, isEmpty2 = ref.isEmpty, getValue = ref.getValue;
      XMLElement = null;
      XMLCData = null;
      XMLComment = null;
      XMLDeclaration = null;
      XMLDocType = null;
      XMLRaw = null;
      XMLText = null;
      XMLProcessingInstruction = null;
      XMLDummy = null;
      module2.exports = XMLNode = (function() {
        function XMLNode2(parent) {
          this.parent = parent;
          if (this.parent) {
            this.options = this.parent.options;
            this.stringify = this.parent.stringify;
          }
          this.children = [];
          if (!XMLElement) {
            XMLElement = require_XMLElement();
            XMLCData = require_XMLCData();
            XMLComment = require_XMLComment();
            XMLDeclaration = require_XMLDeclaration();
            XMLDocType = require_XMLDocType();
            XMLRaw = require_XMLRaw();
            XMLText = require_XMLText();
            XMLProcessingInstruction = require_XMLProcessingInstruction();
            XMLDummy = require_XMLDummy();
          }
        }
        XMLNode2.prototype.element = function(name, attributes, text) {
          var childNode, item, j, k, key, lastChild, len, len1, ref1, ref2, val;
          lastChild = null;
          if (attributes === null && text == null) {
            ref1 = [{}, null], attributes = ref1[0], text = ref1[1];
          }
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject3(attributes)) {
            ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
          }
          if (name != null) {
            name = getValue(name);
          }
          if (Array.isArray(name)) {
            for (j = 0, len = name.length; j < len; j++) {
              item = name[j];
              lastChild = this.element(item);
            }
          } else if (isFunction2(name)) {
            lastChild = this.element(name.apply());
          } else if (isObject3(name)) {
            for (key in name) {
              if (!hasProp.call(name, key)) continue;
              val = name[key];
              if (isFunction2(val)) {
                val = val.apply();
              }
              if (isObject3(val) && isEmpty2(val)) {
                val = null;
              }
              if (!this.options.ignoreDecorators && this.stringify.convertAttKey && key.indexOf(this.stringify.convertAttKey) === 0) {
                lastChild = this.attribute(key.substr(this.stringify.convertAttKey.length), val);
              } else if (!this.options.separateArrayItems && Array.isArray(val)) {
                for (k = 0, len1 = val.length; k < len1; k++) {
                  item = val[k];
                  childNode = {};
                  childNode[key] = item;
                  lastChild = this.element(childNode);
                }
              } else if (isObject3(val)) {
                lastChild = this.element(key);
                lastChild.element(val);
              } else {
                lastChild = this.element(key, val);
              }
            }
          } else if (this.options.skipNullNodes && text === null) {
            lastChild = this.dummy();
          } else {
            if (!this.options.ignoreDecorators && this.stringify.convertTextKey && name.indexOf(this.stringify.convertTextKey) === 0) {
              lastChild = this.text(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCDataKey && name.indexOf(this.stringify.convertCDataKey) === 0) {
              lastChild = this.cdata(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertCommentKey && name.indexOf(this.stringify.convertCommentKey) === 0) {
              lastChild = this.comment(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertRawKey && name.indexOf(this.stringify.convertRawKey) === 0) {
              lastChild = this.raw(text);
            } else if (!this.options.ignoreDecorators && this.stringify.convertPIKey && name.indexOf(this.stringify.convertPIKey) === 0) {
              lastChild = this.instruction(name.substr(this.stringify.convertPIKey.length), text);
            } else {
              lastChild = this.node(name, attributes, text);
            }
          }
          if (lastChild == null) {
            throw new Error("Could not create any elements with: " + name + ". " + this.debugInfo());
          }
          return lastChild;
        };
        XMLNode2.prototype.insertBefore = function(name, attributes, text) {
          var child, i, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.insertAfter = function(name, attributes, text) {
          var child, i, removed;
          if (this.isRoot) {
            throw new Error("Cannot insert elements at root level. " + this.debugInfo(name));
          }
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.element(name, attributes, text);
          Array.prototype.push.apply(this.parent.children, removed);
          return child;
        };
        XMLNode2.prototype.remove = function() {
          var i, ref1;
          if (this.isRoot) {
            throw new Error("Cannot remove the root element. " + this.debugInfo());
          }
          i = this.parent.children.indexOf(this);
          [].splice.apply(this.parent.children, [i, i - i + 1].concat(ref1 = [])), ref1;
          return this.parent;
        };
        XMLNode2.prototype.node = function(name, attributes, text) {
          var child, ref1;
          if (name != null) {
            name = getValue(name);
          }
          attributes || (attributes = {});
          attributes = getValue(attributes);
          if (!isObject3(attributes)) {
            ref1 = [attributes, text], text = ref1[0], attributes = ref1[1];
          }
          child = new XMLElement(this, name, attributes);
          if (text != null) {
            child.text(text);
          }
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.text = function(value) {
          var child;
          child = new XMLText(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.cdata = function(value) {
          var child;
          child = new XMLCData(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.comment = function(value) {
          var child;
          child = new XMLComment(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.commentBefore = function(value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.commentAfter = function(value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.comment(value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.raw = function(value) {
          var child;
          child = new XMLRaw(this, value);
          this.children.push(child);
          return this;
        };
        XMLNode2.prototype.dummy = function() {
          var child;
          child = new XMLDummy(this);
          this.children.push(child);
          return child;
        };
        XMLNode2.prototype.instruction = function(target, value) {
          var insTarget, insValue, instruction, j, len;
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (j = 0, len = target.length; j < len; j++) {
              insTarget = target[j];
              this.instruction(insTarget);
            }
          } else if (isObject3(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget)) continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction2(value)) {
              value = value.apply();
            }
            instruction = new XMLProcessingInstruction(this, target, value);
            this.children.push(instruction);
          }
          return this;
        };
        XMLNode2.prototype.instructionBefore = function(target, value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.instructionAfter = function(target, value) {
          var child, i, removed;
          i = this.parent.children.indexOf(this);
          removed = this.parent.children.splice(i + 1);
          child = this.parent.instruction(target, value);
          Array.prototype.push.apply(this.parent.children, removed);
          return this;
        };
        XMLNode2.prototype.declaration = function(version2, encoding, standalone) {
          var doc, xmldec;
          doc = this.document();
          xmldec = new XMLDeclaration(doc, version2, encoding, standalone);
          if (doc.children[0] instanceof XMLDeclaration) {
            doc.children[0] = xmldec;
          } else {
            doc.children.unshift(xmldec);
          }
          return doc.root() || doc;
        };
        XMLNode2.prototype.doctype = function(pubID, sysID) {
          var child, doc, doctype, i, j, k, len, len1, ref1, ref2;
          doc = this.document();
          doctype = new XMLDocType(doc, pubID, sysID);
          ref1 = doc.children;
          for (i = j = 0, len = ref1.length; j < len; i = ++j) {
            child = ref1[i];
            if (child instanceof XMLDocType) {
              doc.children[i] = doctype;
              return doctype;
            }
          }
          ref2 = doc.children;
          for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
            child = ref2[i];
            if (child.isRoot) {
              doc.children.splice(i, 0, doctype);
              return doctype;
            }
          }
          doc.children.push(doctype);
          return doctype;
        };
        XMLNode2.prototype.up = function() {
          if (this.isRoot) {
            throw new Error("The root node has no parent. Use doc() if you need to get the document object.");
          }
          return this.parent;
        };
        XMLNode2.prototype.root = function() {
          var node;
          node = this;
          while (node) {
            if (node.isDocument) {
              return node.rootObject;
            } else if (node.isRoot) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.document = function() {
          var node;
          node = this;
          while (node) {
            if (node.isDocument) {
              return node;
            } else {
              node = node.parent;
            }
          }
        };
        XMLNode2.prototype.end = function(options) {
          return this.document().end(options);
        };
        XMLNode2.prototype.prev = function() {
          var i;
          i = this.parent.children.indexOf(this);
          while (i > 0 && this.parent.children[i - 1].isDummy) {
            i = i - 1;
          }
          if (i < 1) {
            throw new Error("Already at the first node. " + this.debugInfo());
          }
          return this.parent.children[i - 1];
        };
        XMLNode2.prototype.next = function() {
          var i;
          i = this.parent.children.indexOf(this);
          while (i < this.parent.children.length - 1 && this.parent.children[i + 1].isDummy) {
            i = i + 1;
          }
          if (i === -1 || i === this.parent.children.length - 1) {
            throw new Error("Already at the last node. " + this.debugInfo());
          }
          return this.parent.children[i + 1];
        };
        XMLNode2.prototype.importDocument = function(doc) {
          var clonedRoot;
          clonedRoot = doc.root().clone();
          clonedRoot.parent = this;
          clonedRoot.isRoot = false;
          this.children.push(clonedRoot);
          return this;
        };
        XMLNode2.prototype.debugInfo = function(name) {
          var ref1, ref2;
          name = name || this.name;
          if (name == null && !((ref1 = this.parent) != null ? ref1.name : void 0)) {
            return "";
          } else if (name == null) {
            return "parent: <" + this.parent.name + ">";
          } else if (!((ref2 = this.parent) != null ? ref2.name : void 0)) {
            return "node: <" + name + ">";
          } else {
            return "node: <" + name + ">, parent: <" + this.parent.name + ">";
          }
        };
        XMLNode2.prototype.ele = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.doc = function() {
          return this.document();
        };
        XMLNode2.prototype.dec = function(version2, encoding, standalone) {
          return this.declaration(version2, encoding, standalone);
        };
        XMLNode2.prototype.dtd = function(pubID, sysID) {
          return this.doctype(pubID, sysID);
        };
        XMLNode2.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLNode2.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLNode2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLNode2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLNode2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLNode2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLNode2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLNode2.prototype.u = function() {
          return this.up();
        };
        XMLNode2.prototype.importXMLBuilder = function(doc) {
          return this.importDocument(doc);
        };
        return XMLNode2;
      })();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStringifier.js
var require_XMLStringifier = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringifier.js"(exports2, module2) {
    (function() {
      var XMLStringifier, bind = function(fn, me) {
        return function() {
          return fn.apply(me, arguments);
        };
      }, hasProp = {}.hasOwnProperty;
      module2.exports = XMLStringifier = (function() {
        function XMLStringifier2(options) {
          this.assertLegalChar = bind(this.assertLegalChar, this);
          var key, ref, value;
          options || (options = {});
          this.noDoubleEncoding = options.noDoubleEncoding;
          ref = options.stringify || {};
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this[key] = value;
          }
        }
        XMLStringifier2.prototype.eleName = function(val) {
          val = "" + val || "";
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.eleText = function(val) {
          val = "" + val || "";
          return this.assertLegalChar(this.elEscape(val));
        };
        XMLStringifier2.prototype.cdata = function(val) {
          val = "" + val || "";
          val = val.replace("]]>", "]]]]><![CDATA[>");
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.comment = function(val) {
          val = "" + val || "";
          if (val.match(/--/)) {
            throw new Error("Comment text cannot contain double-hypen: " + val);
          }
          return this.assertLegalChar(val);
        };
        XMLStringifier2.prototype.raw = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.attName = function(val) {
          return val = "" + val || "";
        };
        XMLStringifier2.prototype.attValue = function(val) {
          val = "" + val || "";
          return this.attEscape(val);
        };
        XMLStringifier2.prototype.insTarget = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.insValue = function(val) {
          val = "" + val || "";
          if (val.match(/\?>/)) {
            throw new Error("Invalid processing instruction value: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlVersion = function(val) {
          val = "" + val || "";
          if (!val.match(/1\.[0-9]+/)) {
            throw new Error("Invalid version number: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlEncoding = function(val) {
          val = "" + val || "";
          if (!val.match(/^[A-Za-z](?:[A-Za-z0-9._-])*$/)) {
            throw new Error("Invalid encoding: " + val);
          }
          return val;
        };
        XMLStringifier2.prototype.xmlStandalone = function(val) {
          if (val) {
            return "yes";
          } else {
            return "no";
          }
        };
        XMLStringifier2.prototype.dtdPubID = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdSysID = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdElementValue = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdAttType = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdAttDefault = function(val) {
          if (val != null) {
            return "" + val || "";
          } else {
            return val;
          }
        };
        XMLStringifier2.prototype.dtdEntityValue = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.dtdNData = function(val) {
          return "" + val || "";
        };
        XMLStringifier2.prototype.convertAttKey = "@";
        XMLStringifier2.prototype.convertPIKey = "?";
        XMLStringifier2.prototype.convertTextKey = "#text";
        XMLStringifier2.prototype.convertCDataKey = "#cdata";
        XMLStringifier2.prototype.convertCommentKey = "#comment";
        XMLStringifier2.prototype.convertRawKey = "#raw";
        XMLStringifier2.prototype.assertLegalChar = function(str) {
          var res;
          res = str.match(/[\0\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/);
          if (res) {
            throw new Error("Invalid character in string: " + str + " at index " + res.index);
          }
          return str;
        };
        XMLStringifier2.prototype.elEscape = function(str) {
          var ampregex;
          ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#xD;");
        };
        XMLStringifier2.prototype.attEscape = function(str) {
          var ampregex;
          ampregex = this.noDoubleEncoding ? /(?!&\S+;)&/g : /&/g;
          return str.replace(ampregex, "&amp;").replace(/</g, "&lt;").replace(/"/g, "&quot;").replace(/\t/g, "&#x9;").replace(/\n/g, "&#xA;").replace(/\r/g, "&#xD;");
        };
        return XMLStringifier2;
      })();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLWriterBase.js
var require_XMLWriterBase = __commonJS({
  "node_modules/xmlbuilder/lib/XMLWriterBase.js"(exports2, module2) {
    (function() {
      var XMLWriterBase, hasProp = {}.hasOwnProperty;
      module2.exports = XMLWriterBase = (function() {
        function XMLWriterBase2(options) {
          var key, ref, ref1, ref2, ref3, ref4, ref5, ref6, value;
          options || (options = {});
          this.pretty = options.pretty || false;
          this.allowEmpty = (ref = options.allowEmpty) != null ? ref : false;
          if (this.pretty) {
            this.indent = (ref1 = options.indent) != null ? ref1 : "  ";
            this.newline = (ref2 = options.newline) != null ? ref2 : "\n";
            this.offset = (ref3 = options.offset) != null ? ref3 : 0;
            this.dontprettytextnodes = (ref4 = options.dontprettytextnodes) != null ? ref4 : 0;
          } else {
            this.indent = "";
            this.newline = "";
            this.offset = 0;
            this.dontprettytextnodes = 0;
          }
          this.spacebeforeslash = (ref5 = options.spacebeforeslash) != null ? ref5 : "";
          if (this.spacebeforeslash === true) {
            this.spacebeforeslash = " ";
          }
          this.newlinedefault = this.newline;
          this.prettydefault = this.pretty;
          ref6 = options.writer || {};
          for (key in ref6) {
            if (!hasProp.call(ref6, key)) continue;
            value = ref6[key];
            this[key] = value;
          }
        }
        XMLWriterBase2.prototype.set = function(options) {
          var key, ref, value;
          options || (options = {});
          if ("pretty" in options) {
            this.pretty = options.pretty;
          }
          if ("allowEmpty" in options) {
            this.allowEmpty = options.allowEmpty;
          }
          if (this.pretty) {
            this.indent = "indent" in options ? options.indent : "  ";
            this.newline = "newline" in options ? options.newline : "\n";
            this.offset = "offset" in options ? options.offset : 0;
            this.dontprettytextnodes = "dontprettytextnodes" in options ? options.dontprettytextnodes : 0;
          } else {
            this.indent = "";
            this.newline = "";
            this.offset = 0;
            this.dontprettytextnodes = 0;
          }
          this.spacebeforeslash = "spacebeforeslash" in options ? options.spacebeforeslash : "";
          if (this.spacebeforeslash === true) {
            this.spacebeforeslash = " ";
          }
          this.newlinedefault = this.newline;
          this.prettydefault = this.pretty;
          ref = options.writer || {};
          for (key in ref) {
            if (!hasProp.call(ref, key)) continue;
            value = ref[key];
            this[key] = value;
          }
          return this;
        };
        XMLWriterBase2.prototype.space = function(level) {
          var indent;
          if (this.pretty) {
            indent = (level || 0) + this.offset + 1;
            if (indent > 0) {
              return new Array(indent).join(this.indent);
            } else {
              return "";
            }
          } else {
            return "";
          }
        };
        return XMLWriterBase2;
      })();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStringWriter.js
var require_XMLStringWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStringWriter.js"(exports2, module2) {
    (function() {
      var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLText, XMLWriterBase, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDummy = require_XMLDummy();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStringWriter = (function(superClass) {
        extend(XMLStringWriter2, superClass);
        function XMLStringWriter2(options) {
          XMLStringWriter2.__super__.constructor.call(this, options);
        }
        XMLStringWriter2.prototype.document = function(doc) {
          var child, i, len, r, ref;
          this.textispresent = false;
          r = "";
          ref = doc.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            if (child instanceof XMLDummy) {
              continue;
            }
            r += (function() {
              switch (false) {
                case !(child instanceof XMLDeclaration):
                  return this.declaration(child);
                case !(child instanceof XMLDocType):
                  return this.docType(child);
                case !(child instanceof XMLComment):
                  return this.comment(child);
                case !(child instanceof XMLProcessingInstruction):
                  return this.processingInstruction(child);
                default:
                  return this.element(child, 0);
              }
            }).call(this);
          }
          if (this.pretty && r.slice(-this.newline.length) === this.newline) {
            r = r.slice(0, -this.newline.length);
          }
          return r;
        };
        XMLStringWriter2.prototype.attribute = function(att) {
          return " " + att.name + '="' + att.value + '"';
        };
        XMLStringWriter2.prototype.cdata = function(node, level) {
          return this.space(level) + "<![CDATA[" + node.text + "]]>" + this.newline;
        };
        XMLStringWriter2.prototype.comment = function(node, level) {
          return this.space(level) + "<!-- " + node.text + " -->" + this.newline;
        };
        XMLStringWriter2.prototype.declaration = function(node, level) {
          var r;
          r = this.space(level);
          r += '<?xml version="' + node.version + '"';
          if (node.encoding != null) {
            r += ' encoding="' + node.encoding + '"';
          }
          if (node.standalone != null) {
            r += ' standalone="' + node.standalone + '"';
          }
          r += this.spacebeforeslash + "?>";
          r += this.newline;
          return r;
        };
        XMLStringWriter2.prototype.docType = function(node, level) {
          var child, i, len, r, ref;
          level || (level = 0);
          r = this.space(level);
          r += "<!DOCTYPE " + node.root().name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          if (node.children.length > 0) {
            r += " [";
            r += this.newline;
            ref = node.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              r += (function() {
                switch (false) {
                  case !(child instanceof XMLDTDAttList):
                    return this.dtdAttList(child, level + 1);
                  case !(child instanceof XMLDTDElement):
                    return this.dtdElement(child, level + 1);
                  case !(child instanceof XMLDTDEntity):
                    return this.dtdEntity(child, level + 1);
                  case !(child instanceof XMLDTDNotation):
                    return this.dtdNotation(child, level + 1);
                  case !(child instanceof XMLCData):
                    return this.cdata(child, level + 1);
                  case !(child instanceof XMLComment):
                    return this.comment(child, level + 1);
                  case !(child instanceof XMLProcessingInstruction):
                    return this.processingInstruction(child, level + 1);
                  default:
                    throw new Error("Unknown DTD node type: " + child.constructor.name);
                }
              }).call(this);
            }
            r += "]";
          }
          r += this.spacebeforeslash + ">";
          r += this.newline;
          return r;
        };
        XMLStringWriter2.prototype.element = function(node, level) {
          var att, child, i, j, len, len1, name, r, ref, ref1, ref2, space, textispresentwasset;
          level || (level = 0);
          textispresentwasset = false;
          if (this.textispresent) {
            this.newline = "";
            this.pretty = false;
          } else {
            this.newline = this.newlinedefault;
            this.pretty = this.prettydefault;
          }
          space = this.space(level);
          r = "";
          r += space + "<" + node.name;
          ref = node.attributes;
          for (name in ref) {
            if (!hasProp.call(ref, name)) continue;
            att = ref[name];
            r += this.attribute(att);
          }
          if (node.children.length === 0 || node.children.every(function(e) {
            return e.value === "";
          })) {
            if (this.allowEmpty) {
              r += "></" + node.name + ">" + this.newline;
            } else {
              r += this.spacebeforeslash + "/>" + this.newline;
            }
          } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
            r += ">";
            r += node.children[0].value;
            r += "</" + node.name + ">" + this.newline;
          } else {
            if (this.dontprettytextnodes) {
              ref1 = node.children;
              for (i = 0, len = ref1.length; i < len; i++) {
                child = ref1[i];
                if (child.value != null) {
                  this.textispresent++;
                  textispresentwasset = true;
                  break;
                }
              }
            }
            if (this.textispresent) {
              this.newline = "";
              this.pretty = false;
              space = this.space(level);
            }
            r += ">" + this.newline;
            ref2 = node.children;
            for (j = 0, len1 = ref2.length; j < len1; j++) {
              child = ref2[j];
              r += (function() {
                switch (false) {
                  case !(child instanceof XMLCData):
                    return this.cdata(child, level + 1);
                  case !(child instanceof XMLComment):
                    return this.comment(child, level + 1);
                  case !(child instanceof XMLElement):
                    return this.element(child, level + 1);
                  case !(child instanceof XMLRaw):
                    return this.raw(child, level + 1);
                  case !(child instanceof XMLText):
                    return this.text(child, level + 1);
                  case !(child instanceof XMLProcessingInstruction):
                    return this.processingInstruction(child, level + 1);
                  case !(child instanceof XMLDummy):
                    return "";
                  default:
                    throw new Error("Unknown XML node type: " + child.constructor.name);
                }
              }).call(this);
            }
            if (textispresentwasset) {
              this.textispresent--;
            }
            if (!this.textispresent) {
              this.newline = this.newlinedefault;
              this.pretty = this.prettydefault;
            }
            r += space + "</" + node.name + ">" + this.newline;
          }
          return r;
        };
        XMLStringWriter2.prototype.processingInstruction = function(node, level) {
          var r;
          r = this.space(level) + "<?" + node.target;
          if (node.value) {
            r += " " + node.value;
          }
          r += this.spacebeforeslash + "?>" + this.newline;
          return r;
        };
        XMLStringWriter2.prototype.raw = function(node, level) {
          return this.space(level) + node.value + this.newline;
        };
        XMLStringWriter2.prototype.text = function(node, level) {
          return this.space(level) + node.value + this.newline;
        };
        XMLStringWriter2.prototype.dtdAttList = function(node, level) {
          var r;
          r = this.space(level) + "<!ATTLIST " + node.elementName + " " + node.attributeName + " " + node.attributeType;
          if (node.defaultValueType !== "#DEFAULT") {
            r += " " + node.defaultValueType;
          }
          if (node.defaultValue) {
            r += ' "' + node.defaultValue + '"';
          }
          r += this.spacebeforeslash + ">" + this.newline;
          return r;
        };
        XMLStringWriter2.prototype.dtdElement = function(node, level) {
          return this.space(level) + "<!ELEMENT " + node.name + " " + node.value + this.spacebeforeslash + ">" + this.newline;
        };
        XMLStringWriter2.prototype.dtdEntity = function(node, level) {
          var r;
          r = this.space(level) + "<!ENTITY";
          if (node.pe) {
            r += " %";
          }
          r += " " + node.name;
          if (node.value) {
            r += ' "' + node.value + '"';
          } else {
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            if (node.nData) {
              r += " NDATA " + node.nData;
            }
          }
          r += this.spacebeforeslash + ">" + this.newline;
          return r;
        };
        XMLStringWriter2.prototype.dtdNotation = function(node, level) {
          var r;
          r = this.space(level) + "<!NOTATION " + node.name;
          if (node.pubID && node.sysID) {
            r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
          } else if (node.pubID) {
            r += ' PUBLIC "' + node.pubID + '"';
          } else if (node.sysID) {
            r += ' SYSTEM "' + node.sysID + '"';
          }
          r += this.spacebeforeslash + ">" + this.newline;
          return r;
        };
        XMLStringWriter2.prototype.openNode = function(node, level) {
          var att, name, r, ref;
          level || (level = 0);
          if (node instanceof XMLElement) {
            r = this.space(level) + "<" + node.name;
            ref = node.attributes;
            for (name in ref) {
              if (!hasProp.call(ref, name)) continue;
              att = ref[name];
              r += this.attribute(att);
            }
            r += (node.children ? ">" : "/>") + this.newline;
            return r;
          } else {
            r = this.space(level) + "<!DOCTYPE " + node.rootNodeName;
            if (node.pubID && node.sysID) {
              r += ' PUBLIC "' + node.pubID + '" "' + node.sysID + '"';
            } else if (node.sysID) {
              r += ' SYSTEM "' + node.sysID + '"';
            }
            r += (node.children ? " [" : ">") + this.newline;
            return r;
          }
        };
        XMLStringWriter2.prototype.closeNode = function(node, level) {
          level || (level = 0);
          switch (false) {
            case !(node instanceof XMLElement):
              return this.space(level) + "</" + node.name + ">" + this.newline;
            case !(node instanceof XMLDocType):
              return this.space(level) + "]>" + this.newline;
          }
        };
        return XMLStringWriter2;
      })(XMLWriterBase);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocument.js
var require_XMLDocument = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocument.js"(exports2, module2) {
    (function() {
      var XMLDocument, XMLNode, XMLStringWriter, XMLStringifier, isPlainObject, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      isPlainObject = require_Utility().isPlainObject;
      XMLNode = require_XMLNode();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocument = (function(superClass) {
        extend(XMLDocument2, superClass);
        function XMLDocument2(options) {
          XMLDocument2.__super__.constructor.call(this, null);
          this.name = "?xml";
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter();
          }
          this.options = options;
          this.stringify = new XMLStringifier(options);
          this.isDocument = true;
        }
        XMLDocument2.prototype.end = function(writer) {
          var writerOptions;
          if (!writer) {
            writer = this.options.writer;
          } else if (isPlainObject(writer)) {
            writerOptions = writer;
            writer = this.options.writer.set(writerOptions);
          }
          return writer.document(this);
        };
        XMLDocument2.prototype.toString = function(options) {
          return this.options.writer.set(options).document(this);
        };
        return XMLDocument2;
      })(XMLNode);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLDocumentCB.js
var require_XMLDocumentCB = __commonJS({
  "node_modules/xmlbuilder/lib/XMLDocumentCB.js"(exports2, module2) {
    (function() {
      var XMLAttribute, XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDocumentCB, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStringWriter, XMLStringifier, XMLText, getValue, isFunction2, isObject3, isPlainObject, ref, hasProp = {}.hasOwnProperty;
      ref = require_Utility(), isObject3 = ref.isObject, isFunction2 = ref.isFunction, isPlainObject = ref.isPlainObject, getValue = ref.getValue;
      XMLElement = require_XMLElement();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLAttribute = require_XMLAttribute();
      XMLStringifier = require_XMLStringifier();
      XMLStringWriter = require_XMLStringWriter();
      module2.exports = XMLDocumentCB = (function() {
        function XMLDocumentCB2(options, onData, onEnd) {
          var writerOptions;
          this.name = "?xml";
          options || (options = {});
          if (!options.writer) {
            options.writer = new XMLStringWriter(options);
          } else if (isPlainObject(options.writer)) {
            writerOptions = options.writer;
            options.writer = new XMLStringWriter(writerOptions);
          }
          this.options = options;
          this.writer = options.writer;
          this.stringify = new XMLStringifier(options);
          this.onDataCallback = onData || function() {
          };
          this.onEndCallback = onEnd || function() {
          };
          this.currentNode = null;
          this.currentLevel = -1;
          this.openTags = {};
          this.documentStarted = false;
          this.documentCompleted = false;
          this.root = null;
        }
        XMLDocumentCB2.prototype.node = function(name, attributes, text) {
          var ref1, ref2;
          if (name == null) {
            throw new Error("Missing node name.");
          }
          if (this.root && this.currentLevel === -1) {
            throw new Error("Document can only have one root node. " + this.debugInfo(name));
          }
          this.openCurrent();
          name = getValue(name);
          if (attributes === null && text == null) {
            ref1 = [{}, null], attributes = ref1[0], text = ref1[1];
          }
          if (attributes == null) {
            attributes = {};
          }
          attributes = getValue(attributes);
          if (!isObject3(attributes)) {
            ref2 = [attributes, text], text = ref2[0], attributes = ref2[1];
          }
          this.currentNode = new XMLElement(this, name, attributes);
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          if (text != null) {
            this.text(text);
          }
          return this;
        };
        XMLDocumentCB2.prototype.element = function(name, attributes, text) {
          if (this.currentNode && this.currentNode instanceof XMLDocType) {
            return this.dtdElement.apply(this, arguments);
          } else {
            return this.node(name, attributes, text);
          }
        };
        XMLDocumentCB2.prototype.attribute = function(name, value) {
          var attName, attValue;
          if (!this.currentNode || this.currentNode.children) {
            throw new Error("att() can only be used immediately after an ele() call in callback mode. " + this.debugInfo(name));
          }
          if (name != null) {
            name = getValue(name);
          }
          if (isObject3(name)) {
            for (attName in name) {
              if (!hasProp.call(name, attName)) continue;
              attValue = name[attName];
              this.attribute(attName, attValue);
            }
          } else {
            if (isFunction2(value)) {
              value = value.apply();
            }
            if (!this.options.skipNullAttributes || value != null) {
              this.currentNode.attributes[name] = new XMLAttribute(this, name, value);
            }
          }
          return this;
        };
        XMLDocumentCB2.prototype.text = function(value) {
          var node;
          this.openCurrent();
          node = new XMLText(this, value);
          this.onData(this.writer.text(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.cdata = function(value) {
          var node;
          this.openCurrent();
          node = new XMLCData(this, value);
          this.onData(this.writer.cdata(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.comment = function(value) {
          var node;
          this.openCurrent();
          node = new XMLComment(this, value);
          this.onData(this.writer.comment(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.raw = function(value) {
          var node;
          this.openCurrent();
          node = new XMLRaw(this, value);
          this.onData(this.writer.raw(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.instruction = function(target, value) {
          var i, insTarget, insValue, len, node;
          this.openCurrent();
          if (target != null) {
            target = getValue(target);
          }
          if (value != null) {
            value = getValue(value);
          }
          if (Array.isArray(target)) {
            for (i = 0, len = target.length; i < len; i++) {
              insTarget = target[i];
              this.instruction(insTarget);
            }
          } else if (isObject3(target)) {
            for (insTarget in target) {
              if (!hasProp.call(target, insTarget)) continue;
              insValue = target[insTarget];
              this.instruction(insTarget, insValue);
            }
          } else {
            if (isFunction2(value)) {
              value = value.apply();
            }
            node = new XMLProcessingInstruction(this, target, value);
            this.onData(this.writer.processingInstruction(node, this.currentLevel + 1), this.currentLevel + 1);
          }
          return this;
        };
        XMLDocumentCB2.prototype.declaration = function(version2, encoding, standalone) {
          var node;
          this.openCurrent();
          if (this.documentStarted) {
            throw new Error("declaration() must be the first node.");
          }
          node = new XMLDeclaration(this, version2, encoding, standalone);
          this.onData(this.writer.declaration(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.doctype = function(root2, pubID, sysID) {
          this.openCurrent();
          if (root2 == null) {
            throw new Error("Missing root node name.");
          }
          if (this.root) {
            throw new Error("dtd() must come before the root node.");
          }
          this.currentNode = new XMLDocType(this, pubID, sysID);
          this.currentNode.rootNodeName = root2;
          this.currentNode.children = false;
          this.currentLevel++;
          this.openTags[this.currentLevel] = this.currentNode;
          return this;
        };
        XMLDocumentCB2.prototype.dtdElement = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDElement(this, name, value);
          this.onData(this.writer.dtdElement(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.attList = function(elementName, attributeName, attributeType, defaultValueType, defaultValue) {
          var node;
          this.openCurrent();
          node = new XMLDTDAttList(this, elementName, attributeName, attributeType, defaultValueType, defaultValue);
          this.onData(this.writer.dtdAttList(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.entity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, false, name, value);
          this.onData(this.writer.dtdEntity(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.pEntity = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDEntity(this, true, name, value);
          this.onData(this.writer.dtdEntity(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.notation = function(name, value) {
          var node;
          this.openCurrent();
          node = new XMLDTDNotation(this, name, value);
          this.onData(this.writer.dtdNotation(node, this.currentLevel + 1), this.currentLevel + 1);
          return this;
        };
        XMLDocumentCB2.prototype.up = function() {
          if (this.currentLevel < 0) {
            throw new Error("The document node has no parent.");
          }
          if (this.currentNode) {
            if (this.currentNode.children) {
              this.closeNode(this.currentNode);
            } else {
              this.openNode(this.currentNode);
            }
            this.currentNode = null;
          } else {
            this.closeNode(this.openTags[this.currentLevel]);
          }
          delete this.openTags[this.currentLevel];
          this.currentLevel--;
          return this;
        };
        XMLDocumentCB2.prototype.end = function() {
          while (this.currentLevel >= 0) {
            this.up();
          }
          return this.onEnd();
        };
        XMLDocumentCB2.prototype.openCurrent = function() {
          if (this.currentNode) {
            this.currentNode.children = true;
            return this.openNode(this.currentNode);
          }
        };
        XMLDocumentCB2.prototype.openNode = function(node) {
          if (!node.isOpen) {
            if (!this.root && this.currentLevel === 0 && node instanceof XMLElement) {
              this.root = node;
            }
            this.onData(this.writer.openNode(node, this.currentLevel), this.currentLevel);
            return node.isOpen = true;
          }
        };
        XMLDocumentCB2.prototype.closeNode = function(node) {
          if (!node.isClosed) {
            this.onData(this.writer.closeNode(node, this.currentLevel), this.currentLevel);
            return node.isClosed = true;
          }
        };
        XMLDocumentCB2.prototype.onData = function(chunk2, level) {
          this.documentStarted = true;
          return this.onDataCallback(chunk2, level + 1);
        };
        XMLDocumentCB2.prototype.onEnd = function() {
          this.documentCompleted = true;
          return this.onEndCallback();
        };
        XMLDocumentCB2.prototype.debugInfo = function(name) {
          if (name == null) {
            return "";
          } else {
            return "node: <" + name + ">";
          }
        };
        XMLDocumentCB2.prototype.ele = function() {
          return this.element.apply(this, arguments);
        };
        XMLDocumentCB2.prototype.nod = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.txt = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.dat = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.com = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.ins = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.dec = function(version2, encoding, standalone) {
          return this.declaration(version2, encoding, standalone);
        };
        XMLDocumentCB2.prototype.dtd = function(root2, pubID, sysID) {
          return this.doctype(root2, pubID, sysID);
        };
        XMLDocumentCB2.prototype.e = function(name, attributes, text) {
          return this.element(name, attributes, text);
        };
        XMLDocumentCB2.prototype.n = function(name, attributes, text) {
          return this.node(name, attributes, text);
        };
        XMLDocumentCB2.prototype.t = function(value) {
          return this.text(value);
        };
        XMLDocumentCB2.prototype.d = function(value) {
          return this.cdata(value);
        };
        XMLDocumentCB2.prototype.c = function(value) {
          return this.comment(value);
        };
        XMLDocumentCB2.prototype.r = function(value) {
          return this.raw(value);
        };
        XMLDocumentCB2.prototype.i = function(target, value) {
          return this.instruction(target, value);
        };
        XMLDocumentCB2.prototype.att = function() {
          if (this.currentNode && this.currentNode instanceof XMLDocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.a = function() {
          if (this.currentNode && this.currentNode instanceof XMLDocType) {
            return this.attList.apply(this, arguments);
          } else {
            return this.attribute.apply(this, arguments);
          }
        };
        XMLDocumentCB2.prototype.ent = function(name, value) {
          return this.entity(name, value);
        };
        XMLDocumentCB2.prototype.pent = function(name, value) {
          return this.pEntity(name, value);
        };
        XMLDocumentCB2.prototype.not = function(name, value) {
          return this.notation(name, value);
        };
        return XMLDocumentCB2;
      })();
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/XMLStreamWriter.js
var require_XMLStreamWriter = __commonJS({
  "node_modules/xmlbuilder/lib/XMLStreamWriter.js"(exports2, module2) {
    (function() {
      var XMLCData, XMLComment, XMLDTDAttList, XMLDTDElement, XMLDTDEntity, XMLDTDNotation, XMLDeclaration, XMLDocType, XMLDummy, XMLElement, XMLProcessingInstruction, XMLRaw, XMLStreamWriter, XMLText, XMLWriterBase, extend = function(child, parent) {
        for (var key in parent) {
          if (hasProp.call(parent, key)) child[key] = parent[key];
        }
        function ctor2() {
          this.constructor = child;
        }
        ctor2.prototype = parent.prototype;
        child.prototype = new ctor2();
        child.__super__ = parent.prototype;
        return child;
      }, hasProp = {}.hasOwnProperty;
      XMLDeclaration = require_XMLDeclaration();
      XMLDocType = require_XMLDocType();
      XMLCData = require_XMLCData();
      XMLComment = require_XMLComment();
      XMLElement = require_XMLElement();
      XMLRaw = require_XMLRaw();
      XMLText = require_XMLText();
      XMLProcessingInstruction = require_XMLProcessingInstruction();
      XMLDummy = require_XMLDummy();
      XMLDTDAttList = require_XMLDTDAttList();
      XMLDTDElement = require_XMLDTDElement();
      XMLDTDEntity = require_XMLDTDEntity();
      XMLDTDNotation = require_XMLDTDNotation();
      XMLWriterBase = require_XMLWriterBase();
      module2.exports = XMLStreamWriter = (function(superClass) {
        extend(XMLStreamWriter2, superClass);
        function XMLStreamWriter2(stream, options) {
          XMLStreamWriter2.__super__.constructor.call(this, options);
          this.stream = stream;
        }
        XMLStreamWriter2.prototype.document = function(doc) {
          var child, i, j, len, len1, ref, ref1, results;
          ref = doc.children;
          for (i = 0, len = ref.length; i < len; i++) {
            child = ref[i];
            child.isLastRootNode = false;
          }
          doc.children[doc.children.length - 1].isLastRootNode = true;
          ref1 = doc.children;
          results = [];
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            child = ref1[j];
            if (child instanceof XMLDummy) {
              continue;
            }
            switch (false) {
              case !(child instanceof XMLDeclaration):
                results.push(this.declaration(child));
                break;
              case !(child instanceof XMLDocType):
                results.push(this.docType(child));
                break;
              case !(child instanceof XMLComment):
                results.push(this.comment(child));
                break;
              case !(child instanceof XMLProcessingInstruction):
                results.push(this.processingInstruction(child));
                break;
              default:
                results.push(this.element(child));
            }
          }
          return results;
        };
        XMLStreamWriter2.prototype.attribute = function(att) {
          return this.stream.write(" " + att.name + '="' + att.value + '"');
        };
        XMLStreamWriter2.prototype.cdata = function(node, level) {
          return this.stream.write(this.space(level) + "<![CDATA[" + node.text + "]]>" + this.endline(node));
        };
        XMLStreamWriter2.prototype.comment = function(node, level) {
          return this.stream.write(this.space(level) + "<!-- " + node.text + " -->" + this.endline(node));
        };
        XMLStreamWriter2.prototype.declaration = function(node, level) {
          this.stream.write(this.space(level));
          this.stream.write('<?xml version="' + node.version + '"');
          if (node.encoding != null) {
            this.stream.write(' encoding="' + node.encoding + '"');
          }
          if (node.standalone != null) {
            this.stream.write(' standalone="' + node.standalone + '"');
          }
          this.stream.write(this.spacebeforeslash + "?>");
          return this.stream.write(this.endline(node));
        };
        XMLStreamWriter2.prototype.docType = function(node, level) {
          var child, i, len, ref;
          level || (level = 0);
          this.stream.write(this.space(level));
          this.stream.write("<!DOCTYPE " + node.root().name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          if (node.children.length > 0) {
            this.stream.write(" [");
            this.stream.write(this.endline(node));
            ref = node.children;
            for (i = 0, len = ref.length; i < len; i++) {
              child = ref[i];
              switch (false) {
                case !(child instanceof XMLDTDAttList):
                  this.dtdAttList(child, level + 1);
                  break;
                case !(child instanceof XMLDTDElement):
                  this.dtdElement(child, level + 1);
                  break;
                case !(child instanceof XMLDTDEntity):
                  this.dtdEntity(child, level + 1);
                  break;
                case !(child instanceof XMLDTDNotation):
                  this.dtdNotation(child, level + 1);
                  break;
                case !(child instanceof XMLCData):
                  this.cdata(child, level + 1);
                  break;
                case !(child instanceof XMLComment):
                  this.comment(child, level + 1);
                  break;
                case !(child instanceof XMLProcessingInstruction):
                  this.processingInstruction(child, level + 1);
                  break;
                default:
                  throw new Error("Unknown DTD node type: " + child.constructor.name);
              }
            }
            this.stream.write("]");
          }
          this.stream.write(this.spacebeforeslash + ">");
          return this.stream.write(this.endline(node));
        };
        XMLStreamWriter2.prototype.element = function(node, level) {
          var att, child, i, len, name, ref, ref1, space;
          level || (level = 0);
          space = this.space(level);
          this.stream.write(space + "<" + node.name);
          ref = node.attributes;
          for (name in ref) {
            if (!hasProp.call(ref, name)) continue;
            att = ref[name];
            this.attribute(att);
          }
          if (node.children.length === 0 || node.children.every(function(e) {
            return e.value === "";
          })) {
            if (this.allowEmpty) {
              this.stream.write("></" + node.name + ">");
            } else {
              this.stream.write(this.spacebeforeslash + "/>");
            }
          } else if (this.pretty && node.children.length === 1 && node.children[0].value != null) {
            this.stream.write(">");
            this.stream.write(node.children[0].value);
            this.stream.write("</" + node.name + ">");
          } else {
            this.stream.write(">" + this.newline);
            ref1 = node.children;
            for (i = 0, len = ref1.length; i < len; i++) {
              child = ref1[i];
              switch (false) {
                case !(child instanceof XMLCData):
                  this.cdata(child, level + 1);
                  break;
                case !(child instanceof XMLComment):
                  this.comment(child, level + 1);
                  break;
                case !(child instanceof XMLElement):
                  this.element(child, level + 1);
                  break;
                case !(child instanceof XMLRaw):
                  this.raw(child, level + 1);
                  break;
                case !(child instanceof XMLText):
                  this.text(child, level + 1);
                  break;
                case !(child instanceof XMLProcessingInstruction):
                  this.processingInstruction(child, level + 1);
                  break;
                case !(child instanceof XMLDummy):
                  "";
                  break;
                default:
                  throw new Error("Unknown XML node type: " + child.constructor.name);
              }
            }
            this.stream.write(space + "</" + node.name + ">");
          }
          return this.stream.write(this.endline(node));
        };
        XMLStreamWriter2.prototype.processingInstruction = function(node, level) {
          this.stream.write(this.space(level) + "<?" + node.target);
          if (node.value) {
            this.stream.write(" " + node.value);
          }
          return this.stream.write(this.spacebeforeslash + "?>" + this.endline(node));
        };
        XMLStreamWriter2.prototype.raw = function(node, level) {
          return this.stream.write(this.space(level) + node.value + this.endline(node));
        };
        XMLStreamWriter2.prototype.text = function(node, level) {
          return this.stream.write(this.space(level) + node.value + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdAttList = function(node, level) {
          this.stream.write(this.space(level) + "<!ATTLIST " + node.elementName + " " + node.attributeName + " " + node.attributeType);
          if (node.defaultValueType !== "#DEFAULT") {
            this.stream.write(" " + node.defaultValueType);
          }
          if (node.defaultValue) {
            this.stream.write(' "' + node.defaultValue + '"');
          }
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdElement = function(node, level) {
          this.stream.write(this.space(level) + "<!ELEMENT " + node.name + " " + node.value);
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdEntity = function(node, level) {
          this.stream.write(this.space(level) + "<!ENTITY");
          if (node.pe) {
            this.stream.write(" %");
          }
          this.stream.write(" " + node.name);
          if (node.value) {
            this.stream.write(' "' + node.value + '"');
          } else {
            if (node.pubID && node.sysID) {
              this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
            } else if (node.sysID) {
              this.stream.write(' SYSTEM "' + node.sysID + '"');
            }
            if (node.nData) {
              this.stream.write(" NDATA " + node.nData);
            }
          }
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.dtdNotation = function(node, level) {
          this.stream.write(this.space(level) + "<!NOTATION " + node.name);
          if (node.pubID && node.sysID) {
            this.stream.write(' PUBLIC "' + node.pubID + '" "' + node.sysID + '"');
          } else if (node.pubID) {
            this.stream.write(' PUBLIC "' + node.pubID + '"');
          } else if (node.sysID) {
            this.stream.write(' SYSTEM "' + node.sysID + '"');
          }
          return this.stream.write(this.spacebeforeslash + ">" + this.endline(node));
        };
        XMLStreamWriter2.prototype.endline = function(node) {
          if (!node.isLastRootNode) {
            return this.newline;
          } else {
            return "";
          }
        };
        return XMLStreamWriter2;
      })(XMLWriterBase);
    }).call(exports2);
  }
});

// node_modules/xmlbuilder/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/xmlbuilder/lib/index.js"(exports2, module2) {
    (function() {
      var XMLDocument, XMLDocumentCB, XMLStreamWriter, XMLStringWriter, assign, isFunction2, ref;
      ref = require_Utility(), assign = ref.assign, isFunction2 = ref.isFunction;
      XMLDocument = require_XMLDocument();
      XMLDocumentCB = require_XMLDocumentCB();
      XMLStringWriter = require_XMLStringWriter();
      XMLStreamWriter = require_XMLStreamWriter();
      module2.exports.create = function(name, xmldec, doctype, options) {
        var doc, root2;
        if (name == null) {
          throw new Error("Root element needs a name.");
        }
        options = assign({}, xmldec, doctype, options);
        doc = new XMLDocument(options);
        root2 = doc.element(name);
        if (!options.headless) {
          doc.declaration(options);
          if (options.pubID != null || options.sysID != null) {
            doc.doctype(options);
          }
        }
        return root2;
      };
      module2.exports.begin = function(options, onData, onEnd) {
        var ref1;
        if (isFunction2(options)) {
          ref1 = [options, onData], onData = ref1[0], onEnd = ref1[1];
          options = {};
        }
        if (onData) {
          return new XMLDocumentCB(options, onData, onEnd);
        } else {
          return new XMLDocument(options);
        }
      };
      module2.exports.stringWriter = function(options) {
        return new XMLStringWriter(options);
      };
      module2.exports.streamWriter = function(stream, options) {
        return new XMLStreamWriter(stream, options);
      };
    }).call(exports2);
  }
});

// node_modules/mammoth/lib/xml/writer.js
var require_writer = __commonJS({
  "node_modules/mammoth/lib/xml/writer.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var xmlbuilder = require_lib5();
    exports2.writeString = writeString;
    function writeString(root2, namespaces) {
      var uriToPrefix = _3.invert(namespaces);
      var nodeWriters = {
        element: writeElement,
        text: writeTextNode
      };
      function writeNode(builder, node) {
        return nodeWriters[node.type](builder, node);
      }
      function writeElement(builder, element) {
        var elementBuilder = builder.element(mapElementName(element.name), element.attributes);
        element.children.forEach(function(child) {
          writeNode(elementBuilder, child);
        });
      }
      function mapElementName(name) {
        var longFormMatch = /^\{(.*)\}(.*)$/.exec(name);
        if (longFormMatch) {
          var prefix = uriToPrefix[longFormMatch[1]];
          return prefix + (prefix === "" ? "" : ":") + longFormMatch[2];
        } else {
          return name;
        }
      }
      function writeDocument(root3) {
        var builder = xmlbuilder.create(mapElementName(root3.name), {
          version: "1.0",
          encoding: "UTF-8",
          standalone: true
        });
        _3.forEach(namespaces, function(uri, prefix) {
          var key = "xmlns" + (prefix === "" ? "" : ":" + prefix);
          builder.attribute(key, uri);
        });
        root3.children.forEach(function(child) {
          writeNode(builder, child);
        });
        return builder.end();
      }
      return writeDocument(root2);
    }
    function writeTextNode(builder, node) {
      builder.text(node.value);
    }
  }
});

// node_modules/mammoth/lib/xml/index.js
var require_xml = __commonJS({
  "node_modules/mammoth/lib/xml/index.js"(exports2) {
    var nodes = require_nodes();
    exports2.Element = nodes.Element;
    exports2.element = nodes.element;
    exports2.emptyElement = nodes.emptyElement;
    exports2.text = nodes.text;
    exports2.readString = require_reader().readString;
    exports2.writeString = require_writer().writeString;
  }
});

// node_modules/mammoth/lib/docx/office-xml-reader.js
var require_office_xml_reader = __commonJS({
  "node_modules/mammoth/lib/docx/office-xml-reader.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var promises = require_promises();
    var xml = require_xml();
    exports2.read = read;
    exports2.readXmlFromZipFile = readXmlFromZipFile;
    var xmlNamespaceMap = {
      // Transitional format
      "http://schemas.openxmlformats.org/wordprocessingml/2006/main": "w",
      "http://schemas.openxmlformats.org/officeDocument/2006/relationships": "r",
      "http://schemas.openxmlformats.org/drawingml/2006/wordprocessingDrawing": "wp",
      "http://schemas.openxmlformats.org/drawingml/2006/main": "a",
      "http://schemas.openxmlformats.org/drawingml/2006/picture": "pic",
      // Strict format
      "http://purl.oclc.org/ooxml/wordprocessingml/main": "w",
      "http://purl.oclc.org/ooxml/officeDocument/relationships": "r",
      "http://purl.oclc.org/ooxml/drawingml/wordprocessingDrawing": "wp",
      "http://purl.oclc.org/ooxml/drawingml/main": "a",
      "http://purl.oclc.org/ooxml/drawingml/picture": "pic",
      // Common
      "http://schemas.openxmlformats.org/package/2006/content-types": "content-types",
      "http://schemas.openxmlformats.org/package/2006/relationships": "relationships",
      "http://schemas.openxmlformats.org/markup-compatibility/2006": "mc",
      "urn:schemas-microsoft-com:vml": "v",
      "urn:schemas-microsoft-com:office:word": "office-word",
      // [MS-DOCX]: Word Extensions to the Office Open XML (.docx) File Format
      // https://learn.microsoft.com/en-us/openspecs/office_standards/ms-docx/b839fe1f-e1ca-4fa6-8c26-5954d0abbccd
      "http://schemas.microsoft.com/office/word/2010/wordml": "wordml"
    };
    function read(xmlString) {
      return xml.readString(xmlString, xmlNamespaceMap).then(function(document2) {
        return collapseAlternateContent(document2)[0];
      });
    }
    function readXmlFromZipFile(docxFile, path) {
      if (docxFile.exists(path)) {
        return docxFile.read(path, "utf-8").then(stripUtf8Bom).then(read);
      } else {
        return promises.resolve(null);
      }
    }
    function stripUtf8Bom(xmlString) {
      return xmlString.replace(/^\uFEFF/g, "");
    }
    function collapseAlternateContent(node) {
      if (node.type === "element") {
        if (node.name === "mc:AlternateContent") {
          return node.firstOrEmpty("mc:Fallback").children;
        } else {
          node.children = _3.flatten(node.children.map(collapseAlternateContent, true));
          return [node];
        }
      } else {
        return [node];
      }
    }
  }
});

// node_modules/dingbat-to-unicode/dist/dingbats.js
var require_dingbats = __commonJS({
  "node_modules/dingbat-to-unicode/dist/dingbats.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var dingbats = [
      { "Typeface name": "Symbol", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
      { "Typeface name": "Symbol", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "33", "Unicode hex": "21" },
      { "Typeface name": "Symbol", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "8704", "Unicode hex": "2200" },
      { "Typeface name": "Symbol", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "35", "Unicode hex": "23" },
      { "Typeface name": "Symbol", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "8707", "Unicode hex": "2203" },
      { "Typeface name": "Symbol", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "37", "Unicode hex": "25" },
      { "Typeface name": "Symbol", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "38", "Unicode hex": "26" },
      { "Typeface name": "Symbol", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "8717", "Unicode hex": "220D" },
      { "Typeface name": "Symbol", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "40", "Unicode hex": "28" },
      { "Typeface name": "Symbol", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "41", "Unicode hex": "29" },
      { "Typeface name": "Symbol", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "42", "Unicode hex": "2A" },
      { "Typeface name": "Symbol", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "43", "Unicode hex": "2B" },
      { "Typeface name": "Symbol", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "44", "Unicode hex": "2C" },
      { "Typeface name": "Symbol", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "8722", "Unicode hex": "2212" },
      { "Typeface name": "Symbol", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "46", "Unicode hex": "2E" },
      { "Typeface name": "Symbol", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "47", "Unicode hex": "2F" },
      { "Typeface name": "Symbol", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "48", "Unicode hex": "30" },
      { "Typeface name": "Symbol", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "49", "Unicode hex": "31" },
      { "Typeface name": "Symbol", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "50", "Unicode hex": "32" },
      { "Typeface name": "Symbol", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "51", "Unicode hex": "33" },
      { "Typeface name": "Symbol", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "52", "Unicode hex": "34" },
      { "Typeface name": "Symbol", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "53", "Unicode hex": "35" },
      { "Typeface name": "Symbol", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "54", "Unicode hex": "36" },
      { "Typeface name": "Symbol", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "55", "Unicode hex": "37" },
      { "Typeface name": "Symbol", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "56", "Unicode hex": "38" },
      { "Typeface name": "Symbol", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "57", "Unicode hex": "39" },
      { "Typeface name": "Symbol", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "58", "Unicode hex": "3A" },
      { "Typeface name": "Symbol", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "59", "Unicode hex": "3B" },
      { "Typeface name": "Symbol", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "60", "Unicode hex": "3C" },
      { "Typeface name": "Symbol", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "61", "Unicode hex": "3D" },
      { "Typeface name": "Symbol", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "62", "Unicode hex": "3E" },
      { "Typeface name": "Symbol", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "63", "Unicode hex": "3F" },
      { "Typeface name": "Symbol", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "8773", "Unicode hex": "2245" },
      { "Typeface name": "Symbol", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "913", "Unicode hex": "391" },
      { "Typeface name": "Symbol", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "914", "Unicode hex": "392" },
      { "Typeface name": "Symbol", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "935", "Unicode hex": "3A7" },
      { "Typeface name": "Symbol", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "916", "Unicode hex": "394" },
      { "Typeface name": "Symbol", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "917", "Unicode hex": "395" },
      { "Typeface name": "Symbol", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "934", "Unicode hex": "3A6" },
      { "Typeface name": "Symbol", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "915", "Unicode hex": "393" },
      { "Typeface name": "Symbol", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "919", "Unicode hex": "397" },
      { "Typeface name": "Symbol", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "921", "Unicode hex": "399" },
      { "Typeface name": "Symbol", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "977", "Unicode hex": "3D1" },
      { "Typeface name": "Symbol", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "922", "Unicode hex": "39A" },
      { "Typeface name": "Symbol", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "923", "Unicode hex": "39B" },
      { "Typeface name": "Symbol", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "924", "Unicode hex": "39C" },
      { "Typeface name": "Symbol", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "925", "Unicode hex": "39D" },
      { "Typeface name": "Symbol", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "927", "Unicode hex": "39F" },
      { "Typeface name": "Symbol", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "928", "Unicode hex": "3A0" },
      { "Typeface name": "Symbol", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "920", "Unicode hex": "398" },
      { "Typeface name": "Symbol", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "929", "Unicode hex": "3A1" },
      { "Typeface name": "Symbol", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "931", "Unicode hex": "3A3" },
      { "Typeface name": "Symbol", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "932", "Unicode hex": "3A4" },
      { "Typeface name": "Symbol", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "933", "Unicode hex": "3A5" },
      { "Typeface name": "Symbol", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "962", "Unicode hex": "3C2" },
      { "Typeface name": "Symbol", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "937", "Unicode hex": "3A9" },
      { "Typeface name": "Symbol", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "926", "Unicode hex": "39E" },
      { "Typeface name": "Symbol", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "936", "Unicode hex": "3A8" },
      { "Typeface name": "Symbol", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "918", "Unicode hex": "396" },
      { "Typeface name": "Symbol", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "91", "Unicode hex": "5B" },
      { "Typeface name": "Symbol", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "8756", "Unicode hex": "2234" },
      { "Typeface name": "Symbol", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "93", "Unicode hex": "5D" },
      { "Typeface name": "Symbol", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "8869", "Unicode hex": "22A5" },
      { "Typeface name": "Symbol", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "95", "Unicode hex": "5F" },
      { "Typeface name": "Symbol", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "8254", "Unicode hex": "203E" },
      { "Typeface name": "Symbol", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "945", "Unicode hex": "3B1" },
      { "Typeface name": "Symbol", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "946", "Unicode hex": "3B2" },
      { "Typeface name": "Symbol", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "967", "Unicode hex": "3C7" },
      { "Typeface name": "Symbol", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "948", "Unicode hex": "3B4" },
      { "Typeface name": "Symbol", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "949", "Unicode hex": "3B5" },
      { "Typeface name": "Symbol", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "966", "Unicode hex": "3C6" },
      { "Typeface name": "Symbol", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "947", "Unicode hex": "3B3" },
      { "Typeface name": "Symbol", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "951", "Unicode hex": "3B7" },
      { "Typeface name": "Symbol", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "953", "Unicode hex": "3B9" },
      { "Typeface name": "Symbol", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "981", "Unicode hex": "3D5" },
      { "Typeface name": "Symbol", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "954", "Unicode hex": "3BA" },
      { "Typeface name": "Symbol", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "955", "Unicode hex": "3BB" },
      { "Typeface name": "Symbol", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "956", "Unicode hex": "3BC" },
      { "Typeface name": "Symbol", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "957", "Unicode hex": "3BD" },
      { "Typeface name": "Symbol", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "959", "Unicode hex": "3BF" },
      { "Typeface name": "Symbol", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "960", "Unicode hex": "3C0" },
      { "Typeface name": "Symbol", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "952", "Unicode hex": "3B8" },
      { "Typeface name": "Symbol", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "961", "Unicode hex": "3C1" },
      { "Typeface name": "Symbol", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "963", "Unicode hex": "3C3" },
      { "Typeface name": "Symbol", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "964", "Unicode hex": "3C4" },
      { "Typeface name": "Symbol", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "965", "Unicode hex": "3C5" },
      { "Typeface name": "Symbol", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "982", "Unicode hex": "3D6" },
      { "Typeface name": "Symbol", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "969", "Unicode hex": "3C9" },
      { "Typeface name": "Symbol", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "958", "Unicode hex": "3BE" },
      { "Typeface name": "Symbol", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "968", "Unicode hex": "3C8" },
      { "Typeface name": "Symbol", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "950", "Unicode hex": "3B6" },
      { "Typeface name": "Symbol", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "123", "Unicode hex": "7B" },
      { "Typeface name": "Symbol", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "124", "Unicode hex": "7C" },
      { "Typeface name": "Symbol", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "125", "Unicode hex": "7D" },
      { "Typeface name": "Symbol", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "126", "Unicode hex": "7E" },
      { "Typeface name": "Symbol", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "8364", "Unicode hex": "20AC" },
      { "Typeface name": "Symbol", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "978", "Unicode hex": "3D2" },
      { "Typeface name": "Symbol", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "8242", "Unicode hex": "2032" },
      { "Typeface name": "Symbol", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "8804", "Unicode hex": "2264" },
      { "Typeface name": "Symbol", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "8260", "Unicode hex": "2044" },
      { "Typeface name": "Symbol", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "8734", "Unicode hex": "221E" },
      { "Typeface name": "Symbol", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "402", "Unicode hex": "192" },
      { "Typeface name": "Symbol", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9827", "Unicode hex": "2663" },
      { "Typeface name": "Symbol", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9830", "Unicode hex": "2666" },
      { "Typeface name": "Symbol", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "9829", "Unicode hex": "2665" },
      { "Typeface name": "Symbol", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "9824", "Unicode hex": "2660" },
      { "Typeface name": "Symbol", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "8596", "Unicode hex": "2194" },
      { "Typeface name": "Symbol", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "8592", "Unicode hex": "2190" },
      { "Typeface name": "Symbol", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "8593", "Unicode hex": "2191" },
      { "Typeface name": "Symbol", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "8594", "Unicode hex": "2192" },
      { "Typeface name": "Symbol", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "8595", "Unicode hex": "2193" },
      { "Typeface name": "Symbol", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "176", "Unicode hex": "B0" },
      { "Typeface name": "Symbol", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "177", "Unicode hex": "B1" },
      { "Typeface name": "Symbol", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "8243", "Unicode hex": "2033" },
      { "Typeface name": "Symbol", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "8805", "Unicode hex": "2265" },
      { "Typeface name": "Symbol", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "215", "Unicode hex": "D7" },
      { "Typeface name": "Symbol", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "8733", "Unicode hex": "221D" },
      { "Typeface name": "Symbol", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "8706", "Unicode hex": "2202" },
      { "Typeface name": "Symbol", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "8226", "Unicode hex": "2022" },
      { "Typeface name": "Symbol", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "247", "Unicode hex": "F7" },
      { "Typeface name": "Symbol", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "8800", "Unicode hex": "2260" },
      { "Typeface name": "Symbol", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "8801", "Unicode hex": "2261" },
      { "Typeface name": "Symbol", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "8776", "Unicode hex": "2248" },
      { "Typeface name": "Symbol", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "8230", "Unicode hex": "2026" },
      { "Typeface name": "Symbol", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "9168", "Unicode hex": "23D0" },
      { "Typeface name": "Symbol", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "9135", "Unicode hex": "23AF" },
      { "Typeface name": "Symbol", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "8629", "Unicode hex": "21B5" },
      { "Typeface name": "Symbol", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "8501", "Unicode hex": "2135" },
      { "Typeface name": "Symbol", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "8465", "Unicode hex": "2111" },
      { "Typeface name": "Symbol", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "8476", "Unicode hex": "211C" },
      { "Typeface name": "Symbol", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "8472", "Unicode hex": "2118" },
      { "Typeface name": "Symbol", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "8855", "Unicode hex": "2297" },
      { "Typeface name": "Symbol", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "8853", "Unicode hex": "2295" },
      { "Typeface name": "Symbol", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "8709", "Unicode hex": "2205" },
      { "Typeface name": "Symbol", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "8745", "Unicode hex": "2229" },
      { "Typeface name": "Symbol", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "8746", "Unicode hex": "222A" },
      { "Typeface name": "Symbol", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "8835", "Unicode hex": "2283" },
      { "Typeface name": "Symbol", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "8839", "Unicode hex": "2287" },
      { "Typeface name": "Symbol", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "8836", "Unicode hex": "2284" },
      { "Typeface name": "Symbol", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "8834", "Unicode hex": "2282" },
      { "Typeface name": "Symbol", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "8838", "Unicode hex": "2286" },
      { "Typeface name": "Symbol", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "8712", "Unicode hex": "2208" },
      { "Typeface name": "Symbol", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "8713", "Unicode hex": "2209" },
      { "Typeface name": "Symbol", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "8736", "Unicode hex": "2220" },
      { "Typeface name": "Symbol", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "8711", "Unicode hex": "2207" },
      { "Typeface name": "Symbol", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "174", "Unicode hex": "AE" },
      { "Typeface name": "Symbol", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "169", "Unicode hex": "A9" },
      { "Typeface name": "Symbol", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "8482", "Unicode hex": "2122" },
      { "Typeface name": "Symbol", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "8719", "Unicode hex": "220F" },
      { "Typeface name": "Symbol", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8730", "Unicode hex": "221A" },
      { "Typeface name": "Symbol", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "8901", "Unicode hex": "22C5" },
      { "Typeface name": "Symbol", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "172", "Unicode hex": "AC" },
      { "Typeface name": "Symbol", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "8743", "Unicode hex": "2227" },
      { "Typeface name": "Symbol", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "8744", "Unicode hex": "2228" },
      { "Typeface name": "Symbol", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "8660", "Unicode hex": "21D4" },
      { "Typeface name": "Symbol", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "8656", "Unicode hex": "21D0" },
      { "Typeface name": "Symbol", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "8657", "Unicode hex": "21D1" },
      { "Typeface name": "Symbol", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "8658", "Unicode hex": "21D2" },
      { "Typeface name": "Symbol", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "8659", "Unicode hex": "21D3" },
      { "Typeface name": "Symbol", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "9674", "Unicode hex": "25CA" },
      { "Typeface name": "Symbol", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "12296", "Unicode hex": "3008" },
      { "Typeface name": "Symbol", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "174", "Unicode hex": "AE" },
      { "Typeface name": "Symbol", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "169", "Unicode hex": "A9" },
      { "Typeface name": "Symbol", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "8482", "Unicode hex": "2122" },
      { "Typeface name": "Symbol", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "8721", "Unicode hex": "2211" },
      { "Typeface name": "Symbol", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "9115", "Unicode hex": "239B" },
      { "Typeface name": "Symbol", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "9116", "Unicode hex": "239C" },
      { "Typeface name": "Symbol", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9117", "Unicode hex": "239D" },
      { "Typeface name": "Symbol", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9121", "Unicode hex": "23A1" },
      { "Typeface name": "Symbol", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "9122", "Unicode hex": "23A2" },
      { "Typeface name": "Symbol", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "9123", "Unicode hex": "23A3" },
      { "Typeface name": "Symbol", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "9127", "Unicode hex": "23A7" },
      { "Typeface name": "Symbol", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "9128", "Unicode hex": "23A8" },
      { "Typeface name": "Symbol", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "9129", "Unicode hex": "23A9" },
      { "Typeface name": "Symbol", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "9130", "Unicode hex": "23AA" },
      { "Typeface name": "Symbol", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "63743", "Unicode hex": "F8FF" },
      { "Typeface name": "Symbol", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "12297", "Unicode hex": "3009" },
      { "Typeface name": "Symbol", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8747", "Unicode hex": "222B" },
      { "Typeface name": "Symbol", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "8992", "Unicode hex": "2320" },
      { "Typeface name": "Symbol", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "9134", "Unicode hex": "23AE" },
      { "Typeface name": "Symbol", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "8993", "Unicode hex": "2321" },
      { "Typeface name": "Symbol", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "9118", "Unicode hex": "239E" },
      { "Typeface name": "Symbol", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "9119", "Unicode hex": "239F" },
      { "Typeface name": "Symbol", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "9120", "Unicode hex": "23A0" },
      { "Typeface name": "Symbol", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "9124", "Unicode hex": "23A4" },
      { "Typeface name": "Symbol", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "9125", "Unicode hex": "23A5" },
      { "Typeface name": "Symbol", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "9126", "Unicode hex": "23A6" },
      { "Typeface name": "Symbol", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "9131", "Unicode hex": "23AB" },
      { "Typeface name": "Symbol", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "9132", "Unicode hex": "23AC" },
      { "Typeface name": "Symbol", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "9133", "Unicode hex": "23AD" },
      { "Typeface name": "Webdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
      { "Typeface name": "Webdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128375", "Unicode hex": "1F577" },
      { "Typeface name": "Webdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128376", "Unicode hex": "1F578" },
      { "Typeface name": "Webdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128370", "Unicode hex": "1F572" },
      { "Typeface name": "Webdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128374", "Unicode hex": "1F576" },
      { "Typeface name": "Webdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "127942", "Unicode hex": "1F3C6" },
      { "Typeface name": "Webdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "127894", "Unicode hex": "1F396" },
      { "Typeface name": "Webdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128391", "Unicode hex": "1F587" },
      { "Typeface name": "Webdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128488", "Unicode hex": "1F5E8" },
      { "Typeface name": "Webdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128489", "Unicode hex": "1F5E9" },
      { "Typeface name": "Webdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128496", "Unicode hex": "1F5F0" },
      { "Typeface name": "Webdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128497", "Unicode hex": "1F5F1" },
      { "Typeface name": "Webdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "127798", "Unicode hex": "1F336" },
      { "Typeface name": "Webdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "127895", "Unicode hex": "1F397" },
      { "Typeface name": "Webdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128638", "Unicode hex": "1F67E" },
      { "Typeface name": "Webdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128636", "Unicode hex": "1F67C" },
      { "Typeface name": "Webdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128469", "Unicode hex": "1F5D5" },
      { "Typeface name": "Webdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128470", "Unicode hex": "1F5D6" },
      { "Typeface name": "Webdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128471", "Unicode hex": "1F5D7" },
      { "Typeface name": "Webdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "9204", "Unicode hex": "23F4" },
      { "Typeface name": "Webdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "9205", "Unicode hex": "23F5" },
      { "Typeface name": "Webdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "9206", "Unicode hex": "23F6" },
      { "Typeface name": "Webdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "9207", "Unicode hex": "23F7" },
      { "Typeface name": "Webdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "9194", "Unicode hex": "23EA" },
      { "Typeface name": "Webdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "9193", "Unicode hex": "23E9" },
      { "Typeface name": "Webdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "9198", "Unicode hex": "23EE" },
      { "Typeface name": "Webdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "9197", "Unicode hex": "23ED" },
      { "Typeface name": "Webdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "9208", "Unicode hex": "23F8" },
      { "Typeface name": "Webdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "9209", "Unicode hex": "23F9" },
      { "Typeface name": "Webdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "9210", "Unicode hex": "23FA" },
      { "Typeface name": "Webdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128474", "Unicode hex": "1F5DA" },
      { "Typeface name": "Webdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128499", "Unicode hex": "1F5F3" },
      { "Typeface name": "Webdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128736", "Unicode hex": "1F6E0" },
      { "Typeface name": "Webdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "127959", "Unicode hex": "1F3D7" },
      { "Typeface name": "Webdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "127960", "Unicode hex": "1F3D8" },
      { "Typeface name": "Webdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "127961", "Unicode hex": "1F3D9" },
      { "Typeface name": "Webdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "127962", "Unicode hex": "1F3DA" },
      { "Typeface name": "Webdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "127964", "Unicode hex": "1F3DC" },
      { "Typeface name": "Webdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "127981", "Unicode hex": "1F3ED" },
      { "Typeface name": "Webdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "127963", "Unicode hex": "1F3DB" },
      { "Typeface name": "Webdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "127968", "Unicode hex": "1F3E0" },
      { "Typeface name": "Webdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "127958", "Unicode hex": "1F3D6" },
      { "Typeface name": "Webdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "127965", "Unicode hex": "1F3DD" },
      { "Typeface name": "Webdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128739", "Unicode hex": "1F6E3" },
      { "Typeface name": "Webdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128269", "Unicode hex": "1F50D" },
      { "Typeface name": "Webdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "127956", "Unicode hex": "1F3D4" },
      { "Typeface name": "Webdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128065", "Unicode hex": "1F441" },
      { "Typeface name": "Webdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128066", "Unicode hex": "1F442" },
      { "Typeface name": "Webdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127966", "Unicode hex": "1F3DE" },
      { "Typeface name": "Webdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "127957", "Unicode hex": "1F3D5" },
      { "Typeface name": "Webdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "128740", "Unicode hex": "1F6E4" },
      { "Typeface name": "Webdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127967", "Unicode hex": "1F3DF" },
      { "Typeface name": "Webdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "128755", "Unicode hex": "1F6F3" },
      { "Typeface name": "Webdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128364", "Unicode hex": "1F56C" },
      { "Typeface name": "Webdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "128363", "Unicode hex": "1F56B" },
      { "Typeface name": "Webdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128360", "Unicode hex": "1F568" },
      { "Typeface name": "Webdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "128264", "Unicode hex": "1F508" },
      { "Typeface name": "Webdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "127892", "Unicode hex": "1F394" },
      { "Typeface name": "Webdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "127893", "Unicode hex": "1F395" },
      { "Typeface name": "Webdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128492", "Unicode hex": "1F5EC" },
      { "Typeface name": "Webdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128637", "Unicode hex": "1F67D" },
      { "Typeface name": "Webdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "128493", "Unicode hex": "1F5ED" },
      { "Typeface name": "Webdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128490", "Unicode hex": "1F5EA" },
      { "Typeface name": "Webdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128491", "Unicode hex": "1F5EB" },
      { "Typeface name": "Webdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "11156", "Unicode hex": "2B94" },
      { "Typeface name": "Webdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "10004", "Unicode hex": "2714" },
      { "Typeface name": "Webdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128690", "Unicode hex": "1F6B2" },
      { "Typeface name": "Webdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "11036", "Unicode hex": "2B1C" },
      { "Typeface name": "Webdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128737", "Unicode hex": "1F6E1" },
      { "Typeface name": "Webdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128230", "Unicode hex": "1F4E6" },
      { "Typeface name": "Webdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128753", "Unicode hex": "1F6F1" },
      { "Typeface name": "Webdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "11035", "Unicode hex": "2B1B" },
      { "Typeface name": "Webdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128657", "Unicode hex": "1F691" },
      { "Typeface name": "Webdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "128712", "Unicode hex": "1F6C8" },
      { "Typeface name": "Webdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128745", "Unicode hex": "1F6E9" },
      { "Typeface name": "Webdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128752", "Unicode hex": "1F6F0" },
      { "Typeface name": "Webdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "128968", "Unicode hex": "1F7C8" },
      { "Typeface name": "Webdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128372", "Unicode hex": "1F574" },
      { "Typeface name": "Webdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "11044", "Unicode hex": "2B24" },
      { "Typeface name": "Webdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128741", "Unicode hex": "1F6E5" },
      { "Typeface name": "Webdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128660", "Unicode hex": "1F694" },
      { "Typeface name": "Webdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "128472", "Unicode hex": "1F5D8" },
      { "Typeface name": "Webdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "128473", "Unicode hex": "1F5D9" },
      { "Typeface name": "Webdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "10067", "Unicode hex": "2753" },
      { "Typeface name": "Webdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "128754", "Unicode hex": "1F6F2" },
      { "Typeface name": "Webdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "128647", "Unicode hex": "1F687" },
      { "Typeface name": "Webdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "128653", "Unicode hex": "1F68D" },
      { "Typeface name": "Webdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9971", "Unicode hex": "26F3" },
      { "Typeface name": "Webdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10680", "Unicode hex": "29B8" },
      { "Typeface name": "Webdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "8854", "Unicode hex": "2296" },
      { "Typeface name": "Webdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "128685", "Unicode hex": "1F6AD" },
      { "Typeface name": "Webdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "128494", "Unicode hex": "1F5EE" },
      { "Typeface name": "Webdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "9168", "Unicode hex": "23D0" },
      { "Typeface name": "Webdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128495", "Unicode hex": "1F5EF" },
      { "Typeface name": "Webdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128498", "Unicode hex": "1F5F2" },
      { "Typeface name": "Webdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128697", "Unicode hex": "1F6B9" },
      { "Typeface name": "Webdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "128698", "Unicode hex": "1F6BA" },
      { "Typeface name": "Webdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "128713", "Unicode hex": "1F6C9" },
      { "Typeface name": "Webdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "128714", "Unicode hex": "1F6CA" },
      { "Typeface name": "Webdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "128700", "Unicode hex": "1F6BC" },
      { "Typeface name": "Webdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "128125", "Unicode hex": "1F47D" },
      { "Typeface name": "Webdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "127947", "Unicode hex": "1F3CB" },
      { "Typeface name": "Webdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "9975", "Unicode hex": "26F7" },
      { "Typeface name": "Webdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "127938", "Unicode hex": "1F3C2" },
      { "Typeface name": "Webdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "127948", "Unicode hex": "1F3CC" },
      { "Typeface name": "Webdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "127946", "Unicode hex": "1F3CA" },
      { "Typeface name": "Webdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127940", "Unicode hex": "1F3C4" },
      { "Typeface name": "Webdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "127949", "Unicode hex": "1F3CD" },
      { "Typeface name": "Webdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "127950", "Unicode hex": "1F3CE" },
      { "Typeface name": "Webdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128664", "Unicode hex": "1F698" },
      { "Typeface name": "Webdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128480", "Unicode hex": "1F5E0" },
      { "Typeface name": "Webdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128738", "Unicode hex": "1F6E2" },
      { "Typeface name": "Webdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128176", "Unicode hex": "1F4B0" },
      { "Typeface name": "Webdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "127991", "Unicode hex": "1F3F7" },
      { "Typeface name": "Webdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128179", "Unicode hex": "1F4B3" },
      { "Typeface name": "Webdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128106", "Unicode hex": "1F46A" },
      { "Typeface name": "Webdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "128481", "Unicode hex": "1F5E1" },
      { "Typeface name": "Webdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128482", "Unicode hex": "1F5E2" },
      { "Typeface name": "Webdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128483", "Unicode hex": "1F5E3" },
      { "Typeface name": "Webdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "10031", "Unicode hex": "272F" },
      { "Typeface name": "Webdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128388", "Unicode hex": "1F584" },
      { "Typeface name": "Webdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128389", "Unicode hex": "1F585" },
      { "Typeface name": "Webdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128387", "Unicode hex": "1F583" },
      { "Typeface name": "Webdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128390", "Unicode hex": "1F586" },
      { "Typeface name": "Webdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128441", "Unicode hex": "1F5B9" },
      { "Typeface name": "Webdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "128442", "Unicode hex": "1F5BA" },
      { "Typeface name": "Webdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128443", "Unicode hex": "1F5BB" },
      { "Typeface name": "Webdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128373", "Unicode hex": "1F575" },
      { "Typeface name": "Webdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "128368", "Unicode hex": "1F570" },
      { "Typeface name": "Webdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128445", "Unicode hex": "1F5BD" },
      { "Typeface name": "Webdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128446", "Unicode hex": "1F5BE" },
      { "Typeface name": "Webdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
      { "Typeface name": "Webdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128466", "Unicode hex": "1F5D2" },
      { "Typeface name": "Webdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128467", "Unicode hex": "1F5D3" },
      { "Typeface name": "Webdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128366", "Unicode hex": "1F56E" },
      { "Typeface name": "Webdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128218", "Unicode hex": "1F4DA" },
      { "Typeface name": "Webdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128478", "Unicode hex": "1F5DE" },
      { "Typeface name": "Webdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128479", "Unicode hex": "1F5DF" },
      { "Typeface name": "Webdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128451", "Unicode hex": "1F5C3" },
      { "Typeface name": "Webdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128450", "Unicode hex": "1F5C2" },
      { "Typeface name": "Webdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128444", "Unicode hex": "1F5BC" },
      { "Typeface name": "Webdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "127917", "Unicode hex": "1F3AD" },
      { "Typeface name": "Webdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "127900", "Unicode hex": "1F39C" },
      { "Typeface name": "Webdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "127896", "Unicode hex": "1F398" },
      { "Typeface name": "Webdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "127897", "Unicode hex": "1F399" },
      { "Typeface name": "Webdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "127911", "Unicode hex": "1F3A7" },
      { "Typeface name": "Webdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128191", "Unicode hex": "1F4BF" },
      { "Typeface name": "Webdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "127902", "Unicode hex": "1F39E" },
      { "Typeface name": "Webdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128247", "Unicode hex": "1F4F7" },
      { "Typeface name": "Webdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "127903", "Unicode hex": "1F39F" },
      { "Typeface name": "Webdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "127916", "Unicode hex": "1F3AC" },
      { "Typeface name": "Webdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128253", "Unicode hex": "1F4FD" },
      { "Typeface name": "Webdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128249", "Unicode hex": "1F4F9" },
      { "Typeface name": "Webdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128254", "Unicode hex": "1F4FE" },
      { "Typeface name": "Webdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128251", "Unicode hex": "1F4FB" },
      { "Typeface name": "Webdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "127898", "Unicode hex": "1F39A" },
      { "Typeface name": "Webdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "127899", "Unicode hex": "1F39B" },
      { "Typeface name": "Webdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128250", "Unicode hex": "1F4FA" },
      { "Typeface name": "Webdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128187", "Unicode hex": "1F4BB" },
      { "Typeface name": "Webdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128421", "Unicode hex": "1F5A5" },
      { "Typeface name": "Webdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128422", "Unicode hex": "1F5A6" },
      { "Typeface name": "Webdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128423", "Unicode hex": "1F5A7" },
      { "Typeface name": "Webdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "128377", "Unicode hex": "1F579" },
      { "Typeface name": "Webdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "127918", "Unicode hex": "1F3AE" },
      { "Typeface name": "Webdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "128379", "Unicode hex": "1F57B" },
      { "Typeface name": "Webdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128380", "Unicode hex": "1F57C" },
      { "Typeface name": "Webdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128223", "Unicode hex": "1F4DF" },
      { "Typeface name": "Webdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128385", "Unicode hex": "1F581" },
      { "Typeface name": "Webdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128384", "Unicode hex": "1F580" },
      { "Typeface name": "Webdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128424", "Unicode hex": "1F5A8" },
      { "Typeface name": "Webdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128425", "Unicode hex": "1F5A9" },
      { "Typeface name": "Webdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128447", "Unicode hex": "1F5BF" },
      { "Typeface name": "Webdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128426", "Unicode hex": "1F5AA" },
      { "Typeface name": "Webdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128476", "Unicode hex": "1F5DC" },
      { "Typeface name": "Webdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128274", "Unicode hex": "1F512" },
      { "Typeface name": "Webdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128275", "Unicode hex": "1F513" },
      { "Typeface name": "Webdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128477", "Unicode hex": "1F5DD" },
      { "Typeface name": "Webdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128229", "Unicode hex": "1F4E5" },
      { "Typeface name": "Webdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128228", "Unicode hex": "1F4E4" },
      { "Typeface name": "Webdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128371", "Unicode hex": "1F573" },
      { "Typeface name": "Webdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "127779", "Unicode hex": "1F323" },
      { "Typeface name": "Webdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "127780", "Unicode hex": "1F324" },
      { "Typeface name": "Webdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "127781", "Unicode hex": "1F325" },
      { "Typeface name": "Webdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "127782", "Unicode hex": "1F326" },
      { "Typeface name": "Webdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "9729", "Unicode hex": "2601" },
      { "Typeface name": "Webdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "127784", "Unicode hex": "1F328" },
      { "Typeface name": "Webdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "127783", "Unicode hex": "1F327" },
      { "Typeface name": "Webdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "127785", "Unicode hex": "1F329" },
      { "Typeface name": "Webdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "127786", "Unicode hex": "1F32A" },
      { "Typeface name": "Webdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "127788", "Unicode hex": "1F32C" },
      { "Typeface name": "Webdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "127787", "Unicode hex": "1F32B" },
      { "Typeface name": "Webdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "127772", "Unicode hex": "1F31C" },
      { "Typeface name": "Webdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "127777", "Unicode hex": "1F321" },
      { "Typeface name": "Webdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128715", "Unicode hex": "1F6CB" },
      { "Typeface name": "Webdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128719", "Unicode hex": "1F6CF" },
      { "Typeface name": "Webdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "127869", "Unicode hex": "1F37D" },
      { "Typeface name": "Webdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "127864", "Unicode hex": "1F378" },
      { "Typeface name": "Webdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128718", "Unicode hex": "1F6CE" },
      { "Typeface name": "Webdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128717", "Unicode hex": "1F6CD" },
      { "Typeface name": "Webdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "9413", "Unicode hex": "24C5" },
      { "Typeface name": "Webdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "9855", "Unicode hex": "267F" },
      { "Typeface name": "Webdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128710", "Unicode hex": "1F6C6" },
      { "Typeface name": "Webdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "128392", "Unicode hex": "1F588" },
      { "Typeface name": "Webdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "127891", "Unicode hex": "1F393" },
      { "Typeface name": "Webdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128484", "Unicode hex": "1F5E4" },
      { "Typeface name": "Webdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128485", "Unicode hex": "1F5E5" },
      { "Typeface name": "Webdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128486", "Unicode hex": "1F5E6" },
      { "Typeface name": "Webdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "128487", "Unicode hex": "1F5E7" },
      { "Typeface name": "Webdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128746", "Unicode hex": "1F6EA" },
      { "Typeface name": "Webdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128063", "Unicode hex": "1F43F" },
      { "Typeface name": "Webdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "128038", "Unicode hex": "1F426" },
      { "Typeface name": "Webdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128031", "Unicode hex": "1F41F" },
      { "Typeface name": "Webdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128021", "Unicode hex": "1F415" },
      { "Typeface name": "Webdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "128008", "Unicode hex": "1F408" },
      { "Typeface name": "Webdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "128620", "Unicode hex": "1F66C" },
      { "Typeface name": "Webdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "128622", "Unicode hex": "1F66E" },
      { "Typeface name": "Webdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "128621", "Unicode hex": "1F66D" },
      { "Typeface name": "Webdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "128623", "Unicode hex": "1F66F" },
      { "Typeface name": "Webdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128506", "Unicode hex": "1F5FA" },
      { "Typeface name": "Webdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "127757", "Unicode hex": "1F30D" },
      { "Typeface name": "Webdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "127759", "Unicode hex": "1F30F" },
      { "Typeface name": "Webdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "127758", "Unicode hex": "1F30E" },
      { "Typeface name": "Webdings", "Dingbat dec": "255", "Dingbat hex": "FF", "Unicode dec": "128330", "Unicode hex": "1F54A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
      { "Typeface name": "Wingdings", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128393", "Unicode hex": "1F589" },
      { "Typeface name": "Wingdings", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "9986", "Unicode hex": "2702" },
      { "Typeface name": "Wingdings", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "9985", "Unicode hex": "2701" },
      { "Typeface name": "Wingdings", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128083", "Unicode hex": "1F453" },
      { "Typeface name": "Wingdings", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "128365", "Unicode hex": "1F56D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "128366", "Unicode hex": "1F56E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128367", "Unicode hex": "1F56F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128383", "Unicode hex": "1F57F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "9990", "Unicode hex": "2706" },
      { "Typeface name": "Wingdings", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128386", "Unicode hex": "1F582" },
      { "Typeface name": "Wingdings", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128387", "Unicode hex": "1F583" },
      { "Typeface name": "Wingdings", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128234", "Unicode hex": "1F4EA" },
      { "Typeface name": "Wingdings", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128235", "Unicode hex": "1F4EB" },
      { "Typeface name": "Wingdings", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128236", "Unicode hex": "1F4EC" },
      { "Typeface name": "Wingdings", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128237", "Unicode hex": "1F4ED" },
      { "Typeface name": "Wingdings", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128448", "Unicode hex": "1F5C0" },
      { "Typeface name": "Wingdings", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128449", "Unicode hex": "1F5C1" },
      { "Typeface name": "Wingdings", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128462", "Unicode hex": "1F5CE" },
      { "Typeface name": "Wingdings", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128463", "Unicode hex": "1F5CF" },
      { "Typeface name": "Wingdings", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128464", "Unicode hex": "1F5D0" },
      { "Typeface name": "Wingdings", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128452", "Unicode hex": "1F5C4" },
      { "Typeface name": "Wingdings", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "8987", "Unicode hex": "231B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128430", "Unicode hex": "1F5AE" },
      { "Typeface name": "Wingdings", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128432", "Unicode hex": "1F5B0" },
      { "Typeface name": "Wingdings", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128434", "Unicode hex": "1F5B2" },
      { "Typeface name": "Wingdings", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128435", "Unicode hex": "1F5B3" },
      { "Typeface name": "Wingdings", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128436", "Unicode hex": "1F5B4" },
      { "Typeface name": "Wingdings", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128427", "Unicode hex": "1F5AB" },
      { "Typeface name": "Wingdings", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128428", "Unicode hex": "1F5AC" },
      { "Typeface name": "Wingdings", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "9991", "Unicode hex": "2707" },
      { "Typeface name": "Wingdings", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "9997", "Unicode hex": "270D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128398", "Unicode hex": "1F58E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "9996", "Unicode hex": "270C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128399", "Unicode hex": "1F58F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128077", "Unicode hex": "1F44D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128078", "Unicode hex": "1F44E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "9756", "Unicode hex": "261C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "9758", "Unicode hex": "261E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "9757", "Unicode hex": "261D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "9759", "Unicode hex": "261F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128400", "Unicode hex": "1F590" },
      { "Typeface name": "Wingdings", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "9786", "Unicode hex": "263A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128528", "Unicode hex": "1F610" },
      { "Typeface name": "Wingdings", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "9785", "Unicode hex": "2639" },
      { "Typeface name": "Wingdings", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128163", "Unicode hex": "1F4A3" },
      { "Typeface name": "Wingdings", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128369", "Unicode hex": "1F571" },
      { "Typeface name": "Wingdings", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "127987", "Unicode hex": "1F3F3" },
      { "Typeface name": "Wingdings", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "127985", "Unicode hex": "1F3F1" },
      { "Typeface name": "Wingdings", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "9992", "Unicode hex": "2708" },
      { "Typeface name": "Wingdings", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9788", "Unicode hex": "263C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "127778", "Unicode hex": "1F322" },
      { "Typeface name": "Wingdings", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "10052", "Unicode hex": "2744" },
      { "Typeface name": "Wingdings", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "128326", "Unicode hex": "1F546" },
      { "Typeface name": "Wingdings", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "10014", "Unicode hex": "271E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128328", "Unicode hex": "1F548" },
      { "Typeface name": "Wingdings", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10016", "Unicode hex": "2720" },
      { "Typeface name": "Wingdings", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "10017", "Unicode hex": "2721" },
      { "Typeface name": "Wingdings", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "9770", "Unicode hex": "262A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "9775", "Unicode hex": "262F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128329", "Unicode hex": "1F549" },
      { "Typeface name": "Wingdings", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "9784", "Unicode hex": "2638" },
      { "Typeface name": "Wingdings", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "9800", "Unicode hex": "2648" },
      { "Typeface name": "Wingdings", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "9801", "Unicode hex": "2649" },
      { "Typeface name": "Wingdings", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "9802", "Unicode hex": "264A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "9803", "Unicode hex": "264B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "9804", "Unicode hex": "264C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "9805", "Unicode hex": "264D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "9806", "Unicode hex": "264E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "9807", "Unicode hex": "264F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "9808", "Unicode hex": "2650" },
      { "Typeface name": "Wingdings", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "9809", "Unicode hex": "2651" },
      { "Typeface name": "Wingdings", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "9810", "Unicode hex": "2652" },
      { "Typeface name": "Wingdings", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9811", "Unicode hex": "2653" },
      { "Typeface name": "Wingdings", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "128624", "Unicode hex": "1F670" },
      { "Typeface name": "Wingdings", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "128629", "Unicode hex": "1F675" },
      { "Typeface name": "Wingdings", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9899", "Unicode hex": "26AB" },
      { "Typeface name": "Wingdings", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "128318", "Unicode hex": "1F53E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9724", "Unicode hex": "25FC" },
      { "Typeface name": "Wingdings", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "128911", "Unicode hex": "1F78F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "128912", "Unicode hex": "1F790" },
      { "Typeface name": "Wingdings", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "10065", "Unicode hex": "2751" },
      { "Typeface name": "Wingdings", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "10066", "Unicode hex": "2752" },
      { "Typeface name": "Wingdings", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "128927", "Unicode hex": "1F79F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "10731", "Unicode hex": "29EB" },
      { "Typeface name": "Wingdings", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9670", "Unicode hex": "25C6" },
      { "Typeface name": "Wingdings", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10070", "Unicode hex": "2756" },
      { "Typeface name": "Wingdings", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "11049", "Unicode hex": "2B29" },
      { "Typeface name": "Wingdings", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "8999", "Unicode hex": "2327" },
      { "Typeface name": "Wingdings", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "11193", "Unicode hex": "2BB9" },
      { "Typeface name": "Wingdings", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "8984", "Unicode hex": "2318" },
      { "Typeface name": "Wingdings", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "127989", "Unicode hex": "1F3F5" },
      { "Typeface name": "Wingdings", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "127990", "Unicode hex": "1F3F6" },
      { "Typeface name": "Wingdings", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128630", "Unicode hex": "1F676" },
      { "Typeface name": "Wingdings", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128631", "Unicode hex": "1F677" },
      { "Typeface name": "Wingdings", "Dingbat dec": "127", "Dingbat hex": "7F", "Unicode dec": "9647", "Unicode hex": "25AF" },
      { "Typeface name": "Wingdings", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "127243", "Unicode hex": "1F10B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "10112", "Unicode hex": "2780" },
      { "Typeface name": "Wingdings", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "10113", "Unicode hex": "2781" },
      { "Typeface name": "Wingdings", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "10114", "Unicode hex": "2782" },
      { "Typeface name": "Wingdings", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "10115", "Unicode hex": "2783" },
      { "Typeface name": "Wingdings", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10116", "Unicode hex": "2784" },
      { "Typeface name": "Wingdings", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "10117", "Unicode hex": "2785" },
      { "Typeface name": "Wingdings", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "10118", "Unicode hex": "2786" },
      { "Typeface name": "Wingdings", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "10119", "Unicode hex": "2787" },
      { "Typeface name": "Wingdings", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "10120", "Unicode hex": "2788" },
      { "Typeface name": "Wingdings", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "10121", "Unicode hex": "2789" },
      { "Typeface name": "Wingdings", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "127244", "Unicode hex": "1F10C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "10122", "Unicode hex": "278A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "10123", "Unicode hex": "278B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "10124", "Unicode hex": "278C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "10125", "Unicode hex": "278D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "10126", "Unicode hex": "278E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "10127", "Unicode hex": "278F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "10128", "Unicode hex": "2790" },
      { "Typeface name": "Wingdings", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "10129", "Unicode hex": "2791" },
      { "Typeface name": "Wingdings", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "10130", "Unicode hex": "2792" },
      { "Typeface name": "Wingdings", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "10131", "Unicode hex": "2793" },
      { "Typeface name": "Wingdings", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128610", "Unicode hex": "1F662" },
      { "Typeface name": "Wingdings", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "128608", "Unicode hex": "1F660" },
      { "Typeface name": "Wingdings", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "128609", "Unicode hex": "1F661" },
      { "Typeface name": "Wingdings", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "128611", "Unicode hex": "1F663" },
      { "Typeface name": "Wingdings", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128606", "Unicode hex": "1F65E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128604", "Unicode hex": "1F65C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128605", "Unicode hex": "1F65D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "128607", "Unicode hex": "1F65F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "8729", "Unicode hex": "2219" },
      { "Typeface name": "Wingdings", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "8226", "Unicode hex": "2022" },
      { "Typeface name": "Wingdings", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "11037", "Unicode hex": "2B1D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "11096", "Unicode hex": "2B58" },
      { "Typeface name": "Wingdings", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "128902", "Unicode hex": "1F786" },
      { "Typeface name": "Wingdings", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "128904", "Unicode hex": "1F788" },
      { "Typeface name": "Wingdings", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128906", "Unicode hex": "1F78A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128907", "Unicode hex": "1F78B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128319", "Unicode hex": "1F53F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "9642", "Unicode hex": "25AA" },
      { "Typeface name": "Wingdings", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "128910", "Unicode hex": "1F78E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128961", "Unicode hex": "1F7C1" },
      { "Typeface name": "Wingdings", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128965", "Unicode hex": "1F7C5" },
      { "Typeface name": "Wingdings", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "9733", "Unicode hex": "2605" },
      { "Typeface name": "Wingdings", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128971", "Unicode hex": "1F7CB" },
      { "Typeface name": "Wingdings", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "128975", "Unicode hex": "1F7CF" },
      { "Typeface name": "Wingdings", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "128979", "Unicode hex": "1F7D3" },
      { "Typeface name": "Wingdings", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "128977", "Unicode hex": "1F7D1" },
      { "Typeface name": "Wingdings", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "11216", "Unicode hex": "2BD0" },
      { "Typeface name": "Wingdings", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "8982", "Unicode hex": "2316" },
      { "Typeface name": "Wingdings", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "11214", "Unicode hex": "2BCE" },
      { "Typeface name": "Wingdings", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "11215", "Unicode hex": "2BCF" },
      { "Typeface name": "Wingdings", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "11217", "Unicode hex": "2BD1" },
      { "Typeface name": "Wingdings", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "10026", "Unicode hex": "272A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "10032", "Unicode hex": "2730" },
      { "Typeface name": "Wingdings", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "128336", "Unicode hex": "1F550" },
      { "Typeface name": "Wingdings", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "128337", "Unicode hex": "1F551" },
      { "Typeface name": "Wingdings", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128338", "Unicode hex": "1F552" },
      { "Typeface name": "Wingdings", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "128339", "Unicode hex": "1F553" },
      { "Typeface name": "Wingdings", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "128340", "Unicode hex": "1F554" },
      { "Typeface name": "Wingdings", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "128341", "Unicode hex": "1F555" },
      { "Typeface name": "Wingdings", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "128342", "Unicode hex": "1F556" },
      { "Typeface name": "Wingdings", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "128343", "Unicode hex": "1F557" },
      { "Typeface name": "Wingdings", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "128344", "Unicode hex": "1F558" },
      { "Typeface name": "Wingdings", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "128345", "Unicode hex": "1F559" },
      { "Typeface name": "Wingdings", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "128346", "Unicode hex": "1F55A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "128347", "Unicode hex": "1F55B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11184", "Unicode hex": "2BB0" },
      { "Typeface name": "Wingdings", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11185", "Unicode hex": "2BB1" },
      { "Typeface name": "Wingdings", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11186", "Unicode hex": "2BB2" },
      { "Typeface name": "Wingdings", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "11187", "Unicode hex": "2BB3" },
      { "Typeface name": "Wingdings", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "11188", "Unicode hex": "2BB4" },
      { "Typeface name": "Wingdings", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "11189", "Unicode hex": "2BB5" },
      { "Typeface name": "Wingdings", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11190", "Unicode hex": "2BB6" },
      { "Typeface name": "Wingdings", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11191", "Unicode hex": "2BB7" },
      { "Typeface name": "Wingdings", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128618", "Unicode hex": "1F66A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128619", "Unicode hex": "1F66B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128597", "Unicode hex": "1F655" },
      { "Typeface name": "Wingdings", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128596", "Unicode hex": "1F654" },
      { "Typeface name": "Wingdings", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128599", "Unicode hex": "1F657" },
      { "Typeface name": "Wingdings", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128598", "Unicode hex": "1F656" },
      { "Typeface name": "Wingdings", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128592", "Unicode hex": "1F650" },
      { "Typeface name": "Wingdings", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128593", "Unicode hex": "1F651" },
      { "Typeface name": "Wingdings", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128594", "Unicode hex": "1F652" },
      { "Typeface name": "Wingdings", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128595", "Unicode hex": "1F653" },
      { "Typeface name": "Wingdings", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "9003", "Unicode hex": "232B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "8998", "Unicode hex": "2326" },
      { "Typeface name": "Wingdings", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "11160", "Unicode hex": "2B98" },
      { "Typeface name": "Wingdings", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "11162", "Unicode hex": "2B9A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "11161", "Unicode hex": "2B99" },
      { "Typeface name": "Wingdings", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "11163", "Unicode hex": "2B9B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "11144", "Unicode hex": "2B88" },
      { "Typeface name": "Wingdings", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "11146", "Unicode hex": "2B8A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "11145", "Unicode hex": "2B89" },
      { "Typeface name": "Wingdings", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "11147", "Unicode hex": "2B8B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129128", "Unicode hex": "1F868" },
      { "Typeface name": "Wingdings", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129130", "Unicode hex": "1F86A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129129", "Unicode hex": "1F869" },
      { "Typeface name": "Wingdings", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129131", "Unicode hex": "1F86B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129132", "Unicode hex": "1F86C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129133", "Unicode hex": "1F86D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129135", "Unicode hex": "1F86F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129134", "Unicode hex": "1F86E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129144", "Unicode hex": "1F878" },
      { "Typeface name": "Wingdings", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129146", "Unicode hex": "1F87A" },
      { "Typeface name": "Wingdings", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129145", "Unicode hex": "1F879" },
      { "Typeface name": "Wingdings", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129147", "Unicode hex": "1F87B" },
      { "Typeface name": "Wingdings", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129148", "Unicode hex": "1F87C" },
      { "Typeface name": "Wingdings", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129149", "Unicode hex": "1F87D" },
      { "Typeface name": "Wingdings", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129151", "Unicode hex": "1F87F" },
      { "Typeface name": "Wingdings", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129150", "Unicode hex": "1F87E" },
      { "Typeface name": "Wingdings", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "8678", "Unicode hex": "21E6" },
      { "Typeface name": "Wingdings", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "8680", "Unicode hex": "21E8" },
      { "Typeface name": "Wingdings", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "8679", "Unicode hex": "21E7" },
      { "Typeface name": "Wingdings", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "8681", "Unicode hex": "21E9" },
      { "Typeface name": "Wingdings", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "11012", "Unicode hex": "2B04" },
      { "Typeface name": "Wingdings", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "8691", "Unicode hex": "21F3" },
      { "Typeface name": "Wingdings", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "11009", "Unicode hex": "2B01" },
      { "Typeface name": "Wingdings", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11008", "Unicode hex": "2B00" },
      { "Typeface name": "Wingdings", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11011", "Unicode hex": "2B03" },
      { "Typeface name": "Wingdings", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "11010", "Unicode hex": "2B02" },
      { "Typeface name": "Wingdings", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "129196", "Unicode hex": "1F8AC" },
      { "Typeface name": "Wingdings", "Dingbat dec": "250", "Dingbat hex": "FA", "Unicode dec": "129197", "Unicode hex": "1F8AD" },
      { "Typeface name": "Wingdings", "Dingbat dec": "251", "Dingbat hex": "FB", "Unicode dec": "128502", "Unicode hex": "1F5F6" },
      { "Typeface name": "Wingdings", "Dingbat dec": "252", "Dingbat hex": "FC", "Unicode dec": "10003", "Unicode hex": "2713" },
      { "Typeface name": "Wingdings", "Dingbat dec": "253", "Dingbat hex": "FD", "Unicode dec": "128503", "Unicode hex": "1F5F7" },
      { "Typeface name": "Wingdings", "Dingbat dec": "254", "Dingbat hex": "FE", "Unicode dec": "128505", "Unicode hex": "1F5F9" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "128394", "Unicode hex": "1F58A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "128395", "Unicode hex": "1F58B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "128396", "Unicode hex": "1F58C" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "128397", "Unicode hex": "1F58D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "9988", "Unicode hex": "2704" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "9984", "Unicode hex": "2700" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "128382", "Unicode hex": "1F57E" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "128381", "Unicode hex": "1F57D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "128453", "Unicode hex": "1F5C5" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "128454", "Unicode hex": "1F5C6" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "128455", "Unicode hex": "1F5C7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "128456", "Unicode hex": "1F5C8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "128457", "Unicode hex": "1F5C9" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "128458", "Unicode hex": "1F5CA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "128459", "Unicode hex": "1F5CB" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "128460", "Unicode hex": "1F5CC" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "128461", "Unicode hex": "1F5CD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "128203", "Unicode hex": "1F4CB" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "128465", "Unicode hex": "1F5D1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "128468", "Unicode hex": "1F5D4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "128437", "Unicode hex": "1F5B5" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "128438", "Unicode hex": "1F5B6" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "128439", "Unicode hex": "1F5B7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "128440", "Unicode hex": "1F5B8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "128429", "Unicode hex": "1F5AD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "128431", "Unicode hex": "1F5AF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "128433", "Unicode hex": "1F5B1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "128402", "Unicode hex": "1F592" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "128403", "Unicode hex": "1F593" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "128408", "Unicode hex": "1F598" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "128409", "Unicode hex": "1F599" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "128410", "Unicode hex": "1F59A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "128411", "Unicode hex": "1F59B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "128072", "Unicode hex": "1F448" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "128073", "Unicode hex": "1F449" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "128412", "Unicode hex": "1F59C" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "128413", "Unicode hex": "1F59D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "128414", "Unicode hex": "1F59E" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "128415", "Unicode hex": "1F59F" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "128416", "Unicode hex": "1F5A0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "128417", "Unicode hex": "1F5A1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "128070", "Unicode hex": "1F446" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "128071", "Unicode hex": "1F447" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "128418", "Unicode hex": "1F5A2" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "128419", "Unicode hex": "1F5A3" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "128401", "Unicode hex": "1F591" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "128500", "Unicode hex": "1F5F4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "128504", "Unicode hex": "1F5F8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "128501", "Unicode hex": "1F5F5" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9745", "Unicode hex": "2611" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "11197", "Unicode hex": "2BBD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "9746", "Unicode hex": "2612" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "11198", "Unicode hex": "2BBE" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "11199", "Unicode hex": "2BBF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "128711", "Unicode hex": "1F6C7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "10680", "Unicode hex": "29B8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "128625", "Unicode hex": "1F671" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "128628", "Unicode hex": "1F674" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "128626", "Unicode hex": "1F672" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "128627", "Unicode hex": "1F673" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "8253", "Unicode hex": "203D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "128633", "Unicode hex": "1F679" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "128634", "Unicode hex": "1F67A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "128635", "Unicode hex": "1F67B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "128614", "Unicode hex": "1F666" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "128612", "Unicode hex": "1F664" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "128613", "Unicode hex": "1F665" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "128615", "Unicode hex": "1F667" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "128602", "Unicode hex": "1F65A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "128600", "Unicode hex": "1F658" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "128601", "Unicode hex": "1F659" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "128603", "Unicode hex": "1F65B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "9450", "Unicode hex": "24EA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "9312", "Unicode hex": "2460" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "9313", "Unicode hex": "2461" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "9314", "Unicode hex": "2462" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "9315", "Unicode hex": "2463" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "9316", "Unicode hex": "2464" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "9317", "Unicode hex": "2465" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9318", "Unicode hex": "2466" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9319", "Unicode hex": "2467" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9320", "Unicode hex": "2468" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9321", "Unicode hex": "2469" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9471", "Unicode hex": "24FF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "10102", "Unicode hex": "2776" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "10103", "Unicode hex": "2777" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "10104", "Unicode hex": "2778" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "10105", "Unicode hex": "2779" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "10106", "Unicode hex": "277A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "10107", "Unicode hex": "277B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "10108", "Unicode hex": "277C" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "10109", "Unicode hex": "277D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "10110", "Unicode hex": "277E" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "10111", "Unicode hex": "277F" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "9737", "Unicode hex": "2609" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "127765", "Unicode hex": "1F315" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "9789", "Unicode hex": "263D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "9790", "Unicode hex": "263E" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11839", "Unicode hex": "2E3F" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "10013", "Unicode hex": "271D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "128327", "Unicode hex": "1F547" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "128348", "Unicode hex": "1F55C" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "128349", "Unicode hex": "1F55D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "128350", "Unicode hex": "1F55E" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "128351", "Unicode hex": "1F55F" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "128352", "Unicode hex": "1F560" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "128353", "Unicode hex": "1F561" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "128354", "Unicode hex": "1F562" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "128355", "Unicode hex": "1F563" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "128356", "Unicode hex": "1F564" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "128357", "Unicode hex": "1F565" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "128358", "Unicode hex": "1F566" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "128359", "Unicode hex": "1F567" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "128616", "Unicode hex": "1F668" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "128617", "Unicode hex": "1F669" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "8901", "Unicode hex": "22C5" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "128900", "Unicode hex": "1F784" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "10625", "Unicode hex": "2981" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "9679", "Unicode hex": "25CF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "9675", "Unicode hex": "25CB" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "128901", "Unicode hex": "1F785" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "128903", "Unicode hex": "1F787" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "128905", "Unicode hex": "1F789" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "8857", "Unicode hex": "2299" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "10687", "Unicode hex": "29BF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "128908", "Unicode hex": "1F78C" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "128909", "Unicode hex": "1F78D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "9726", "Unicode hex": "25FE" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "9632", "Unicode hex": "25A0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "9633", "Unicode hex": "25A1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "128913", "Unicode hex": "1F791" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "128914", "Unicode hex": "1F792" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "128915", "Unicode hex": "1F793" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "128916", "Unicode hex": "1F794" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "9635", "Unicode hex": "25A3" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "128917", "Unicode hex": "1F795" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "128918", "Unicode hex": "1F796" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "128919", "Unicode hex": "1F797" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "128920", "Unicode hex": "1F798" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "11049", "Unicode hex": "2B29" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "11045", "Unicode hex": "2B25" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "9671", "Unicode hex": "25C7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "128922", "Unicode hex": "1F79A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "9672", "Unicode hex": "25C8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "128923", "Unicode hex": "1F79B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "128924", "Unicode hex": "1F79C" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "128925", "Unicode hex": "1F79D" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "128926", "Unicode hex": "1F79E" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "11050", "Unicode hex": "2B2A" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "11047", "Unicode hex": "2B27" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "9674", "Unicode hex": "25CA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "128928", "Unicode hex": "1F7A0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "9686", "Unicode hex": "25D6" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "9687", "Unicode hex": "25D7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "11210", "Unicode hex": "2BCA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "11211", "Unicode hex": "2BCB" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "11200", "Unicode hex": "2BC0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "11201", "Unicode hex": "2BC1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "11039", "Unicode hex": "2B1F" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "11202", "Unicode hex": "2BC2" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "11043", "Unicode hex": "2B23" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "11042", "Unicode hex": "2B22" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "11203", "Unicode hex": "2BC3" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "11204", "Unicode hex": "2BC4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "128929", "Unicode hex": "1F7A1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "128930", "Unicode hex": "1F7A2" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "128931", "Unicode hex": "1F7A3" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "128932", "Unicode hex": "1F7A4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "128933", "Unicode hex": "1F7A5" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "128934", "Unicode hex": "1F7A6" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "128935", "Unicode hex": "1F7A7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "128936", "Unicode hex": "1F7A8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "128937", "Unicode hex": "1F7A9" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "128938", "Unicode hex": "1F7AA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "128939", "Unicode hex": "1F7AB" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "128940", "Unicode hex": "1F7AC" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "128941", "Unicode hex": "1F7AD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "128942", "Unicode hex": "1F7AE" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "128943", "Unicode hex": "1F7AF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "128944", "Unicode hex": "1F7B0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "128945", "Unicode hex": "1F7B1" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "128946", "Unicode hex": "1F7B2" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "128947", "Unicode hex": "1F7B3" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "128948", "Unicode hex": "1F7B4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "128949", "Unicode hex": "1F7B5" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "128950", "Unicode hex": "1F7B6" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "128951", "Unicode hex": "1F7B7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "128952", "Unicode hex": "1F7B8" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "128953", "Unicode hex": "1F7B9" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "128954", "Unicode hex": "1F7BA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "128955", "Unicode hex": "1F7BB" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "128956", "Unicode hex": "1F7BC" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "128957", "Unicode hex": "1F7BD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "128958", "Unicode hex": "1F7BE" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "128959", "Unicode hex": "1F7BF" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "128960", "Unicode hex": "1F7C0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "128962", "Unicode hex": "1F7C2" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "128964", "Unicode hex": "1F7C4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "128966", "Unicode hex": "1F7C6" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "128969", "Unicode hex": "1F7C9" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "128970", "Unicode hex": "1F7CA" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "10038", "Unicode hex": "2736" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "128972", "Unicode hex": "1F7CC" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "128974", "Unicode hex": "1F7CE" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "128976", "Unicode hex": "1F7D0" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "128978", "Unicode hex": "1F7D2" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "10041", "Unicode hex": "2739" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "241", "Dingbat hex": "F1", "Unicode dec": "128963", "Unicode hex": "1F7C3" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "242", "Dingbat hex": "F2", "Unicode dec": "128967", "Unicode hex": "1F7C7" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "243", "Dingbat hex": "F3", "Unicode dec": "10031", "Unicode hex": "272F" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "244", "Dingbat hex": "F4", "Unicode dec": "128973", "Unicode hex": "1F7CD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "245", "Dingbat hex": "F5", "Unicode dec": "128980", "Unicode hex": "1F7D4" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "246", "Dingbat hex": "F6", "Unicode dec": "11212", "Unicode hex": "2BCC" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "247", "Dingbat hex": "F7", "Unicode dec": "11213", "Unicode hex": "2BCD" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "248", "Dingbat hex": "F8", "Unicode dec": "8251", "Unicode hex": "203B" },
      { "Typeface name": "Wingdings 2", "Dingbat dec": "249", "Dingbat hex": "F9", "Unicode dec": "8258", "Unicode hex": "2042" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "32", "Dingbat hex": "20", "Unicode dec": "32", "Unicode hex": "20" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "33", "Dingbat hex": "21", "Unicode dec": "11104", "Unicode hex": "2B60" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "34", "Dingbat hex": "22", "Unicode dec": "11106", "Unicode hex": "2B62" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "35", "Dingbat hex": "23", "Unicode dec": "11105", "Unicode hex": "2B61" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "36", "Dingbat hex": "24", "Unicode dec": "11107", "Unicode hex": "2B63" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "37", "Dingbat hex": "25", "Unicode dec": "11110", "Unicode hex": "2B66" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "38", "Dingbat hex": "26", "Unicode dec": "11111", "Unicode hex": "2B67" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "39", "Dingbat hex": "27", "Unicode dec": "11113", "Unicode hex": "2B69" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "40", "Dingbat hex": "28", "Unicode dec": "11112", "Unicode hex": "2B68" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "41", "Dingbat hex": "29", "Unicode dec": "11120", "Unicode hex": "2B70" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "42", "Dingbat hex": "2A", "Unicode dec": "11122", "Unicode hex": "2B72" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "43", "Dingbat hex": "2B", "Unicode dec": "11121", "Unicode hex": "2B71" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "44", "Dingbat hex": "2C", "Unicode dec": "11123", "Unicode hex": "2B73" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "45", "Dingbat hex": "2D", "Unicode dec": "11126", "Unicode hex": "2B76" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "46", "Dingbat hex": "2E", "Unicode dec": "11128", "Unicode hex": "2B78" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "47", "Dingbat hex": "2F", "Unicode dec": "11131", "Unicode hex": "2B7B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "48", "Dingbat hex": "30", "Unicode dec": "11133", "Unicode hex": "2B7D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "49", "Dingbat hex": "31", "Unicode dec": "11108", "Unicode hex": "2B64" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "50", "Dingbat hex": "32", "Unicode dec": "11109", "Unicode hex": "2B65" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "51", "Dingbat hex": "33", "Unicode dec": "11114", "Unicode hex": "2B6A" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "52", "Dingbat hex": "34", "Unicode dec": "11116", "Unicode hex": "2B6C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "53", "Dingbat hex": "35", "Unicode dec": "11115", "Unicode hex": "2B6B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "54", "Dingbat hex": "36", "Unicode dec": "11117", "Unicode hex": "2B6D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "55", "Dingbat hex": "37", "Unicode dec": "11085", "Unicode hex": "2B4D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "56", "Dingbat hex": "38", "Unicode dec": "11168", "Unicode hex": "2BA0" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "57", "Dingbat hex": "39", "Unicode dec": "11169", "Unicode hex": "2BA1" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "58", "Dingbat hex": "3A", "Unicode dec": "11170", "Unicode hex": "2BA2" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "59", "Dingbat hex": "3B", "Unicode dec": "11171", "Unicode hex": "2BA3" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "60", "Dingbat hex": "3C", "Unicode dec": "11172", "Unicode hex": "2BA4" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "61", "Dingbat hex": "3D", "Unicode dec": "11173", "Unicode hex": "2BA5" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "62", "Dingbat hex": "3E", "Unicode dec": "11174", "Unicode hex": "2BA6" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "63", "Dingbat hex": "3F", "Unicode dec": "11175", "Unicode hex": "2BA7" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "64", "Dingbat hex": "40", "Unicode dec": "11152", "Unicode hex": "2B90" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "65", "Dingbat hex": "41", "Unicode dec": "11153", "Unicode hex": "2B91" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "66", "Dingbat hex": "42", "Unicode dec": "11154", "Unicode hex": "2B92" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "67", "Dingbat hex": "43", "Unicode dec": "11155", "Unicode hex": "2B93" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "68", "Dingbat hex": "44", "Unicode dec": "11136", "Unicode hex": "2B80" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "69", "Dingbat hex": "45", "Unicode dec": "11139", "Unicode hex": "2B83" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "70", "Dingbat hex": "46", "Unicode dec": "11134", "Unicode hex": "2B7E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "71", "Dingbat hex": "47", "Unicode dec": "11135", "Unicode hex": "2B7F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "72", "Dingbat hex": "48", "Unicode dec": "11140", "Unicode hex": "2B84" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "73", "Dingbat hex": "49", "Unicode dec": "11142", "Unicode hex": "2B86" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "74", "Dingbat hex": "4A", "Unicode dec": "11141", "Unicode hex": "2B85" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "75", "Dingbat hex": "4B", "Unicode dec": "11143", "Unicode hex": "2B87" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "76", "Dingbat hex": "4C", "Unicode dec": "11151", "Unicode hex": "2B8F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "77", "Dingbat hex": "4D", "Unicode dec": "11149", "Unicode hex": "2B8D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "78", "Dingbat hex": "4E", "Unicode dec": "11150", "Unicode hex": "2B8E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "79", "Dingbat hex": "4F", "Unicode dec": "11148", "Unicode hex": "2B8C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "80", "Dingbat hex": "50", "Unicode dec": "11118", "Unicode hex": "2B6E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "81", "Dingbat hex": "51", "Unicode dec": "11119", "Unicode hex": "2B6F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "82", "Dingbat hex": "52", "Unicode dec": "9099", "Unicode hex": "238B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "83", "Dingbat hex": "53", "Unicode dec": "8996", "Unicode hex": "2324" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "84", "Dingbat hex": "54", "Unicode dec": "8963", "Unicode hex": "2303" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "85", "Dingbat hex": "55", "Unicode dec": "8997", "Unicode hex": "2325" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "86", "Dingbat hex": "56", "Unicode dec": "9251", "Unicode hex": "2423" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "87", "Dingbat hex": "57", "Unicode dec": "9085", "Unicode hex": "237D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "88", "Dingbat hex": "58", "Unicode dec": "8682", "Unicode hex": "21EA" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "89", "Dingbat hex": "59", "Unicode dec": "11192", "Unicode hex": "2BB8" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "90", "Dingbat hex": "5A", "Unicode dec": "129184", "Unicode hex": "1F8A0" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "91", "Dingbat hex": "5B", "Unicode dec": "129185", "Unicode hex": "1F8A1" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "92", "Dingbat hex": "5C", "Unicode dec": "129186", "Unicode hex": "1F8A2" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "93", "Dingbat hex": "5D", "Unicode dec": "129187", "Unicode hex": "1F8A3" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "94", "Dingbat hex": "5E", "Unicode dec": "129188", "Unicode hex": "1F8A4" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "95", "Dingbat hex": "5F", "Unicode dec": "129189", "Unicode hex": "1F8A5" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "96", "Dingbat hex": "60", "Unicode dec": "129190", "Unicode hex": "1F8A6" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "97", "Dingbat hex": "61", "Unicode dec": "129191", "Unicode hex": "1F8A7" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "98", "Dingbat hex": "62", "Unicode dec": "129192", "Unicode hex": "1F8A8" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "99", "Dingbat hex": "63", "Unicode dec": "129193", "Unicode hex": "1F8A9" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "100", "Dingbat hex": "64", "Unicode dec": "129194", "Unicode hex": "1F8AA" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "101", "Dingbat hex": "65", "Unicode dec": "129195", "Unicode hex": "1F8AB" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "102", "Dingbat hex": "66", "Unicode dec": "129104", "Unicode hex": "1F850" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "103", "Dingbat hex": "67", "Unicode dec": "129106", "Unicode hex": "1F852" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "104", "Dingbat hex": "68", "Unicode dec": "129105", "Unicode hex": "1F851" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "105", "Dingbat hex": "69", "Unicode dec": "129107", "Unicode hex": "1F853" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "106", "Dingbat hex": "6A", "Unicode dec": "129108", "Unicode hex": "1F854" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "107", "Dingbat hex": "6B", "Unicode dec": "129109", "Unicode hex": "1F855" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "108", "Dingbat hex": "6C", "Unicode dec": "129111", "Unicode hex": "1F857" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "109", "Dingbat hex": "6D", "Unicode dec": "129110", "Unicode hex": "1F856" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "110", "Dingbat hex": "6E", "Unicode dec": "129112", "Unicode hex": "1F858" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "111", "Dingbat hex": "6F", "Unicode dec": "129113", "Unicode hex": "1F859" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "112", "Dingbat hex": "70", "Unicode dec": "9650", "Unicode hex": "25B2" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "113", "Dingbat hex": "71", "Unicode dec": "9660", "Unicode hex": "25BC" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "114", "Dingbat hex": "72", "Unicode dec": "9651", "Unicode hex": "25B3" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "115", "Dingbat hex": "73", "Unicode dec": "9661", "Unicode hex": "25BD" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "116", "Dingbat hex": "74", "Unicode dec": "9664", "Unicode hex": "25C0" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "117", "Dingbat hex": "75", "Unicode dec": "9654", "Unicode hex": "25B6" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "118", "Dingbat hex": "76", "Unicode dec": "9665", "Unicode hex": "25C1" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "119", "Dingbat hex": "77", "Unicode dec": "9655", "Unicode hex": "25B7" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "120", "Dingbat hex": "78", "Unicode dec": "9699", "Unicode hex": "25E3" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "121", "Dingbat hex": "79", "Unicode dec": "9698", "Unicode hex": "25E2" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "122", "Dingbat hex": "7A", "Unicode dec": "9700", "Unicode hex": "25E4" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "123", "Dingbat hex": "7B", "Unicode dec": "9701", "Unicode hex": "25E5" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "124", "Dingbat hex": "7C", "Unicode dec": "128896", "Unicode hex": "1F780" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "125", "Dingbat hex": "7D", "Unicode dec": "128898", "Unicode hex": "1F782" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "126", "Dingbat hex": "7E", "Unicode dec": "128897", "Unicode hex": "1F781" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "128", "Dingbat hex": "80", "Unicode dec": "128899", "Unicode hex": "1F783" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "129", "Dingbat hex": "81", "Unicode dec": "11205", "Unicode hex": "2BC5" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "130", "Dingbat hex": "82", "Unicode dec": "11206", "Unicode hex": "2BC6" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "131", "Dingbat hex": "83", "Unicode dec": "11207", "Unicode hex": "2BC7" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "132", "Dingbat hex": "84", "Unicode dec": "11208", "Unicode hex": "2BC8" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "133", "Dingbat hex": "85", "Unicode dec": "11164", "Unicode hex": "2B9C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "134", "Dingbat hex": "86", "Unicode dec": "11166", "Unicode hex": "2B9E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "135", "Dingbat hex": "87", "Unicode dec": "11165", "Unicode hex": "2B9D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "136", "Dingbat hex": "88", "Unicode dec": "11167", "Unicode hex": "2B9F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "137", "Dingbat hex": "89", "Unicode dec": "129040", "Unicode hex": "1F810" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "138", "Dingbat hex": "8A", "Unicode dec": "129042", "Unicode hex": "1F812" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "139", "Dingbat hex": "8B", "Unicode dec": "129041", "Unicode hex": "1F811" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "140", "Dingbat hex": "8C", "Unicode dec": "129043", "Unicode hex": "1F813" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "141", "Dingbat hex": "8D", "Unicode dec": "129044", "Unicode hex": "1F814" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "142", "Dingbat hex": "8E", "Unicode dec": "129046", "Unicode hex": "1F816" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "143", "Dingbat hex": "8F", "Unicode dec": "129045", "Unicode hex": "1F815" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "144", "Dingbat hex": "90", "Unicode dec": "129047", "Unicode hex": "1F817" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "145", "Dingbat hex": "91", "Unicode dec": "129048", "Unicode hex": "1F818" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "146", "Dingbat hex": "92", "Unicode dec": "129050", "Unicode hex": "1F81A" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "147", "Dingbat hex": "93", "Unicode dec": "129049", "Unicode hex": "1F819" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "148", "Dingbat hex": "94", "Unicode dec": "129051", "Unicode hex": "1F81B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "149", "Dingbat hex": "95", "Unicode dec": "129052", "Unicode hex": "1F81C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "150", "Dingbat hex": "96", "Unicode dec": "129054", "Unicode hex": "1F81E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "151", "Dingbat hex": "97", "Unicode dec": "129053", "Unicode hex": "1F81D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "152", "Dingbat hex": "98", "Unicode dec": "129055", "Unicode hex": "1F81F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "153", "Dingbat hex": "99", "Unicode dec": "129024", "Unicode hex": "1F800" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "154", "Dingbat hex": "9A", "Unicode dec": "129026", "Unicode hex": "1F802" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "155", "Dingbat hex": "9B", "Unicode dec": "129025", "Unicode hex": "1F801" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "156", "Dingbat hex": "9C", "Unicode dec": "129027", "Unicode hex": "1F803" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "157", "Dingbat hex": "9D", "Unicode dec": "129028", "Unicode hex": "1F804" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "158", "Dingbat hex": "9E", "Unicode dec": "129030", "Unicode hex": "1F806" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "159", "Dingbat hex": "9F", "Unicode dec": "129029", "Unicode hex": "1F805" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "160", "Dingbat hex": "A0", "Unicode dec": "129031", "Unicode hex": "1F807" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "161", "Dingbat hex": "A1", "Unicode dec": "129032", "Unicode hex": "1F808" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "162", "Dingbat hex": "A2", "Unicode dec": "129034", "Unicode hex": "1F80A" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "163", "Dingbat hex": "A3", "Unicode dec": "129033", "Unicode hex": "1F809" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "164", "Dingbat hex": "A4", "Unicode dec": "129035", "Unicode hex": "1F80B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "165", "Dingbat hex": "A5", "Unicode dec": "129056", "Unicode hex": "1F820" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "166", "Dingbat hex": "A6", "Unicode dec": "129058", "Unicode hex": "1F822" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "167", "Dingbat hex": "A7", "Unicode dec": "129060", "Unicode hex": "1F824" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "168", "Dingbat hex": "A8", "Unicode dec": "129062", "Unicode hex": "1F826" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "169", "Dingbat hex": "A9", "Unicode dec": "129064", "Unicode hex": "1F828" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "170", "Dingbat hex": "AA", "Unicode dec": "129066", "Unicode hex": "1F82A" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "171", "Dingbat hex": "AB", "Unicode dec": "129068", "Unicode hex": "1F82C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "172", "Dingbat hex": "AC", "Unicode dec": "129180", "Unicode hex": "1F89C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "173", "Dingbat hex": "AD", "Unicode dec": "129181", "Unicode hex": "1F89D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "174", "Dingbat hex": "AE", "Unicode dec": "129182", "Unicode hex": "1F89E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "175", "Dingbat hex": "AF", "Unicode dec": "129183", "Unicode hex": "1F89F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "176", "Dingbat hex": "B0", "Unicode dec": "129070", "Unicode hex": "1F82E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "177", "Dingbat hex": "B1", "Unicode dec": "129072", "Unicode hex": "1F830" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "178", "Dingbat hex": "B2", "Unicode dec": "129074", "Unicode hex": "1F832" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "179", "Dingbat hex": "B3", "Unicode dec": "129076", "Unicode hex": "1F834" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "180", "Dingbat hex": "B4", "Unicode dec": "129078", "Unicode hex": "1F836" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "181", "Dingbat hex": "B5", "Unicode dec": "129080", "Unicode hex": "1F838" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "182", "Dingbat hex": "B6", "Unicode dec": "129082", "Unicode hex": "1F83A" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "183", "Dingbat hex": "B7", "Unicode dec": "129081", "Unicode hex": "1F839" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "184", "Dingbat hex": "B8", "Unicode dec": "129083", "Unicode hex": "1F83B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "185", "Dingbat hex": "B9", "Unicode dec": "129176", "Unicode hex": "1F898" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "186", "Dingbat hex": "BA", "Unicode dec": "129178", "Unicode hex": "1F89A" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "187", "Dingbat hex": "BB", "Unicode dec": "129177", "Unicode hex": "1F899" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "188", "Dingbat hex": "BC", "Unicode dec": "129179", "Unicode hex": "1F89B" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "189", "Dingbat hex": "BD", "Unicode dec": "129084", "Unicode hex": "1F83C" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "190", "Dingbat hex": "BE", "Unicode dec": "129086", "Unicode hex": "1F83E" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "191", "Dingbat hex": "BF", "Unicode dec": "129085", "Unicode hex": "1F83D" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "192", "Dingbat hex": "C0", "Unicode dec": "129087", "Unicode hex": "1F83F" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "193", "Dingbat hex": "C1", "Unicode dec": "129088", "Unicode hex": "1F840" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "194", "Dingbat hex": "C2", "Unicode dec": "129090", "Unicode hex": "1F842" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "195", "Dingbat hex": "C3", "Unicode dec": "129089", "Unicode hex": "1F841" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "196", "Dingbat hex": "C4", "Unicode dec": "129091", "Unicode hex": "1F843" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "197", "Dingbat hex": "C5", "Unicode dec": "129092", "Unicode hex": "1F844" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "198", "Dingbat hex": "C6", "Unicode dec": "129094", "Unicode hex": "1F846" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "199", "Dingbat hex": "C7", "Unicode dec": "129093", "Unicode hex": "1F845" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "200", "Dingbat hex": "C8", "Unicode dec": "129095", "Unicode hex": "1F847" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "201", "Dingbat hex": "C9", "Unicode dec": "11176", "Unicode hex": "2BA8" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "202", "Dingbat hex": "CA", "Unicode dec": "11177", "Unicode hex": "2BA9" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "203", "Dingbat hex": "CB", "Unicode dec": "11178", "Unicode hex": "2BAA" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "204", "Dingbat hex": "CC", "Unicode dec": "11179", "Unicode hex": "2BAB" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "205", "Dingbat hex": "CD", "Unicode dec": "11180", "Unicode hex": "2BAC" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "206", "Dingbat hex": "CE", "Unicode dec": "11181", "Unicode hex": "2BAD" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "207", "Dingbat hex": "CF", "Unicode dec": "11182", "Unicode hex": "2BAE" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "208", "Dingbat hex": "D0", "Unicode dec": "11183", "Unicode hex": "2BAF" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "209", "Dingbat hex": "D1", "Unicode dec": "129120", "Unicode hex": "1F860" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "210", "Dingbat hex": "D2", "Unicode dec": "129122", "Unicode hex": "1F862" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "211", "Dingbat hex": "D3", "Unicode dec": "129121", "Unicode hex": "1F861" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "212", "Dingbat hex": "D4", "Unicode dec": "129123", "Unicode hex": "1F863" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "213", "Dingbat hex": "D5", "Unicode dec": "129124", "Unicode hex": "1F864" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "214", "Dingbat hex": "D6", "Unicode dec": "129125", "Unicode hex": "1F865" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "215", "Dingbat hex": "D7", "Unicode dec": "129127", "Unicode hex": "1F867" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "216", "Dingbat hex": "D8", "Unicode dec": "129126", "Unicode hex": "1F866" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "217", "Dingbat hex": "D9", "Unicode dec": "129136", "Unicode hex": "1F870" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "218", "Dingbat hex": "DA", "Unicode dec": "129138", "Unicode hex": "1F872" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "219", "Dingbat hex": "DB", "Unicode dec": "129137", "Unicode hex": "1F871" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "220", "Dingbat hex": "DC", "Unicode dec": "129139", "Unicode hex": "1F873" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "221", "Dingbat hex": "DD", "Unicode dec": "129140", "Unicode hex": "1F874" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "222", "Dingbat hex": "DE", "Unicode dec": "129141", "Unicode hex": "1F875" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "223", "Dingbat hex": "DF", "Unicode dec": "129143", "Unicode hex": "1F877" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "224", "Dingbat hex": "E0", "Unicode dec": "129142", "Unicode hex": "1F876" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "225", "Dingbat hex": "E1", "Unicode dec": "129152", "Unicode hex": "1F880" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "226", "Dingbat hex": "E2", "Unicode dec": "129154", "Unicode hex": "1F882" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "227", "Dingbat hex": "E3", "Unicode dec": "129153", "Unicode hex": "1F881" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "228", "Dingbat hex": "E4", "Unicode dec": "129155", "Unicode hex": "1F883" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "229", "Dingbat hex": "E5", "Unicode dec": "129156", "Unicode hex": "1F884" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "230", "Dingbat hex": "E6", "Unicode dec": "129157", "Unicode hex": "1F885" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "231", "Dingbat hex": "E7", "Unicode dec": "129159", "Unicode hex": "1F887" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "232", "Dingbat hex": "E8", "Unicode dec": "129158", "Unicode hex": "1F886" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "233", "Dingbat hex": "E9", "Unicode dec": "129168", "Unicode hex": "1F890" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "234", "Dingbat hex": "EA", "Unicode dec": "129170", "Unicode hex": "1F892" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "235", "Dingbat hex": "EB", "Unicode dec": "129169", "Unicode hex": "1F891" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "236", "Dingbat hex": "EC", "Unicode dec": "129171", "Unicode hex": "1F893" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "237", "Dingbat hex": "ED", "Unicode dec": "129172", "Unicode hex": "1F894" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "238", "Dingbat hex": "EE", "Unicode dec": "129174", "Unicode hex": "1F896" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "239", "Dingbat hex": "EF", "Unicode dec": "129173", "Unicode hex": "1F895" },
      { "Typeface name": "Wingdings 3", "Dingbat dec": "240", "Dingbat hex": "F0", "Unicode dec": "129175", "Unicode hex": "1F897" }
    ];
    exports2.default = dingbats;
  }
});

// node_modules/dingbat-to-unicode/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/dingbat-to-unicode/dist/index.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hex = exports2.dec = exports2.codePoint = void 0;
    var dingbats_1 = __importDefault(require_dingbats());
    var dingbatsByCodePoint = {};
    var fromCodePoint = String.fromCodePoint ? String.fromCodePoint : fromCodePointPolyfill;
    for (_i = 0, dingbats_2 = dingbats_1.default; _i < dingbats_2.length; _i++) {
      dingbat = dingbats_2[_i];
      codePoint_1 = parseInt(dingbat["Unicode dec"], 10);
      scalarValue = {
        codePoint: codePoint_1,
        string: fromCodePoint(codePoint_1)
      };
      dingbatsByCodePoint[dingbat["Typeface name"].toUpperCase() + "_" + dingbat["Dingbat dec"]] = scalarValue;
    }
    var dingbat;
    var codePoint_1;
    var scalarValue;
    var _i;
    var dingbats_2;
    function codePoint(typeface, codePoint2) {
      return dingbatsByCodePoint[typeface.toUpperCase() + "_" + codePoint2];
    }
    exports2.codePoint = codePoint;
    function dec(typeface, dec2) {
      return codePoint(typeface, parseInt(dec2, 10));
    }
    exports2.dec = dec;
    function hex(typeface, hex2) {
      return codePoint(typeface, parseInt(hex2, 16));
    }
    exports2.hex = hex;
    function fromCodePointPolyfill(codePoint2) {
      if (codePoint2 <= 65535) {
        return String.fromCharCode(codePoint2);
      } else {
        var highSurrogate = Math.floor((codePoint2 - 65536) / 1024) + 55296;
        var lowSurrogate = (codePoint2 - 65536) % 1024 + 56320;
        return String.fromCharCode(highSurrogate, lowSurrogate);
      }
    }
  }
});

// node_modules/mammoth/lib/transforms.js
var require_transforms = __commonJS({
  "node_modules/mammoth/lib/transforms.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    exports2.paragraph = paragraph;
    exports2.run = run;
    exports2._elements = elements;
    exports2._elementsOfType = elementsOfType;
    exports2.getDescendantsOfType = getDescendantsOfType;
    exports2.getDescendants = getDescendants;
    function paragraph(transform) {
      return elementsOfType("paragraph", transform);
    }
    function run(transform) {
      return elementsOfType("run", transform);
    }
    function elementsOfType(elementType, transform) {
      return elements(function(element) {
        if (element.type === elementType) {
          return transform(element);
        } else {
          return element;
        }
      });
    }
    function elements(transform) {
      return function transformElement(element) {
        if (element.children) {
          var children = _3.map(element.children, transformElement);
          element = _3.extend(element, { children });
        }
        return transform(element);
      };
    }
    function getDescendantsOfType(element, type) {
      return getDescendants(element).filter(function(descendant) {
        return descendant.type === type;
      });
    }
    function getDescendants(element) {
      var descendants = [];
      visitDescendants(element, function(descendant) {
        descendants.push(descendant);
      });
      return descendants;
    }
    function visitDescendants(element, visit) {
      if (element.children) {
        element.children.forEach(function(child) {
          visitDescendants(child, visit);
          visit(child);
        });
      }
    }
  }
});

// node_modules/mammoth/lib/docx/uris.js
var require_uris = __commonJS({
  "node_modules/mammoth/lib/docx/uris.js"(exports2) {
    exports2.uriToZipEntryName = uriToZipEntryName;
    exports2.replaceFragment = replaceFragment;
    function uriToZipEntryName(base, uri) {
      if (uri.charAt(0) === "/") {
        return uri.substr(1);
      } else {
        return base + "/" + uri;
      }
    }
    function replaceFragment(uri, fragment) {
      var hashIndex = uri.indexOf("#");
      if (hashIndex !== -1) {
        uri = uri.substring(0, hashIndex);
      }
      return uri + "#" + fragment;
    }
  }
});

// node_modules/mammoth/lib/docx/body-reader.js
var require_body_reader = __commonJS({
  "node_modules/mammoth/lib/docx/body-reader.js"(exports2) {
    exports2.createBodyReader = createBodyReader;
    exports2._readNumberingProperties = readNumberingProperties;
    var dingbatToUnicode = require_dist2();
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var documents = require_documents();
    var Result = require_results().Result;
    var warning = require_results().warning;
    var xml = require_xml();
    var transforms = require_transforms();
    var uris = require_uris();
    function createBodyReader(options) {
      return {
        readXmlElement: function(element) {
          return new BodyReader(options).readXmlElement(element);
        },
        readXmlElements: function(elements) {
          return new BodyReader(options).readXmlElements(elements);
        }
      };
    }
    function BodyReader(options) {
      var complexFieldStack = [];
      var currentInstrText = [];
      var deletedParagraphContents = [];
      var relationships = options.relationships;
      var contentTypes = options.contentTypes;
      var docxFile = options.docxFile;
      var files = options.files;
      var numbering = options.numbering;
      var styles = options.styles;
      function readXmlElements(elements) {
        var results = elements.map(readXmlElement);
        return combineResults(results);
      }
      function readXmlElement(element) {
        if (element.type === "element") {
          var handler2 = xmlElementReaders[element.name];
          if (handler2) {
            return handler2(element);
          } else if (!Object.prototype.hasOwnProperty.call(ignoreElements, element.name)) {
            var message = warning("An unrecognised element was ignored: " + element.name);
            return emptyResultWithMessages([message]);
          }
        }
        return emptyResult();
      }
      function readParagraphProperties(element) {
        return readParagraphStyle(element).map(function(style) {
          return {
            type: "paragraphProperties",
            styleId: style.styleId,
            styleName: style.name,
            alignment: element.firstOrEmpty("w:jc").attributes["w:val"],
            numbering: readNumberingProperties(style.styleId, element.firstOrEmpty("w:numPr"), numbering),
            indent: readParagraphIndent(element.firstOrEmpty("w:ind"))
          };
        });
      }
      function readParagraphIndent(element) {
        return {
          start: element.attributes["w:start"] || element.attributes["w:left"],
          end: element.attributes["w:end"] || element.attributes["w:right"],
          firstLine: element.attributes["w:firstLine"],
          hanging: element.attributes["w:hanging"]
        };
      }
      function readRunProperties(element) {
        return readRunStyle(element).map(function(style) {
          var fontSizeString = element.firstOrEmpty("w:sz").attributes["w:val"];
          var fontSize = /^[0-9]+$/.test(fontSizeString) ? parseInt(fontSizeString, 10) / 2 : null;
          return {
            type: "runProperties",
            styleId: style.styleId,
            styleName: style.name,
            verticalAlignment: element.firstOrEmpty("w:vertAlign").attributes["w:val"],
            font: element.firstOrEmpty("w:rFonts").attributes["w:ascii"],
            fontSize,
            isBold: readBooleanElement(element.first("w:b")),
            isUnderline: readUnderline(element.first("w:u")),
            isItalic: readBooleanElement(element.first("w:i")),
            isStrikethrough: readBooleanElement(element.first("w:strike")),
            isAllCaps: readBooleanElement(element.first("w:caps")),
            isSmallCaps: readBooleanElement(element.first("w:smallCaps")),
            highlight: readHighlightValue(element.firstOrEmpty("w:highlight").attributes["w:val"])
          };
        });
      }
      function readUnderline(element) {
        if (element) {
          var value = element.attributes["w:val"];
          return value !== void 0 && value !== "false" && value !== "0" && value !== "none";
        } else {
          return false;
        }
      }
      function readBooleanElement(element) {
        if (element) {
          var value = element.attributes["w:val"];
          return value !== "false" && value !== "0";
        } else {
          return false;
        }
      }
      function readBooleanAttributeValue(value) {
        return value !== "false" && value !== "0";
      }
      function readHighlightValue(value) {
        if (!value || value === "none") {
          return null;
        } else {
          return value;
        }
      }
      function readParagraphStyle(element) {
        return readStyle(element, "w:pStyle", "Paragraph", styles.findParagraphStyleById);
      }
      function readRunStyle(element) {
        return readStyle(element, "w:rStyle", "Run", styles.findCharacterStyleById);
      }
      function readTableStyle(element) {
        return readStyle(element, "w:tblStyle", "Table", styles.findTableStyleById);
      }
      function readStyle(element, styleTagName, styleType, findStyleById) {
        var messages = [];
        var styleElement = element.first(styleTagName);
        var styleId = null;
        var name = null;
        if (styleElement) {
          styleId = styleElement.attributes["w:val"];
          if (styleId) {
            var style = findStyleById(styleId);
            if (style) {
              name = style.name;
            } else {
              messages.push(undefinedStyleWarning(styleType, styleId));
            }
          }
        }
        return elementResultWithMessages({ styleId, name }, messages);
      }
      function readFldChar(element) {
        var type = element.attributes["w:fldCharType"];
        if (type === "begin") {
          complexFieldStack.push({ type: "begin", fldChar: element });
          currentInstrText = [];
        } else if (type === "end") {
          var complexFieldEnd = complexFieldStack.pop();
          if (complexFieldEnd.type === "begin") {
            complexFieldEnd = parseCurrentInstrText(complexFieldEnd);
          }
          if (complexFieldEnd.type === "checkbox") {
            return elementResult(documents.checkbox({
              checked: complexFieldEnd.checked
            }));
          }
        } else if (type === "separate") {
          var complexFieldSeparate = complexFieldStack.pop();
          var complexField = parseCurrentInstrText(complexFieldSeparate);
          complexFieldStack.push(complexField);
        }
        return emptyResult();
      }
      function currentHyperlinkOptions() {
        var topHyperlink = _3.last(complexFieldStack.filter(function(complexField) {
          return complexField.type === "hyperlink";
        }));
        return topHyperlink ? topHyperlink.options : null;
      }
      function parseCurrentInstrText(complexField) {
        return parseInstrText(
          currentInstrText.join(""),
          complexField.type === "begin" ? complexField.fldChar : xml.emptyElement
        );
      }
      function parseInstrText(instrText, fldChar) {
        var externalLinkResult = /\s*HYPERLINK "(.*)"/.exec(instrText);
        if (externalLinkResult) {
          return { type: "hyperlink", options: { href: externalLinkResult[1] } };
        }
        var internalLinkResult = /\s*HYPERLINK\s+\\l\s+"(.*)"/.exec(instrText);
        if (internalLinkResult) {
          return { type: "hyperlink", options: { anchor: internalLinkResult[1] } };
        }
        var checkboxResult = /\s*FORMCHECKBOX\s*/.exec(instrText);
        if (checkboxResult) {
          var checkboxElement = fldChar.firstOrEmpty("w:ffData").firstOrEmpty("w:checkBox");
          var checkedElement = checkboxElement.first("w:checked");
          var checked = checkedElement == null ? readBooleanElement(checkboxElement.first("w:default")) : readBooleanElement(checkedElement);
          return { type: "checkbox", checked };
        }
        return { type: "unknown" };
      }
      function readInstrText(element) {
        currentInstrText.push(element.text());
        return emptyResult();
      }
      function readSymbol(element) {
        var font = element.attributes["w:font"];
        var char = element.attributes["w:char"];
        var unicodeCharacter = dingbatToUnicode.hex(font, char);
        if (unicodeCharacter == null && /^F0..$/.test(char)) {
          unicodeCharacter = dingbatToUnicode.hex(font, char.substring(2));
        }
        if (unicodeCharacter == null) {
          return emptyResultWithMessages([warning(
            "A w:sym element with an unsupported character was ignored: char " + char + " in font " + font
          )]);
        } else {
          return elementResult(new documents.Text(unicodeCharacter.string));
        }
      }
      function noteReferenceReader(noteType) {
        return function(element) {
          var noteId = element.attributes["w:id"];
          return elementResult(new documents.NoteReference({
            noteType,
            noteId
          }));
        };
      }
      function readCommentReference(element) {
        return elementResult(documents.commentReference({
          commentId: element.attributes["w:id"]
        }));
      }
      function readChildElements(element) {
        return readXmlElements(element.children);
      }
      var xmlElementReaders = {
        "w:p": function(element) {
          var paragraphPropertiesElement = element.firstOrEmpty("w:pPr");
          var isDeleted = !!paragraphPropertiesElement.firstOrEmpty("w:rPr").first("w:del");
          if (isDeleted) {
            element.children.forEach(function(child) {
              deletedParagraphContents.push(child);
            });
            return emptyResult();
          } else {
            var childrenXml = element.children;
            if (deletedParagraphContents.length > 0) {
              childrenXml = deletedParagraphContents.concat(childrenXml);
              deletedParagraphContents = [];
            }
            return ReadResult.map(
              readParagraphProperties(paragraphPropertiesElement),
              readXmlElements(childrenXml),
              function(properties, children) {
                return new documents.Paragraph(children, properties);
              }
            ).insertExtra();
          }
        },
        "w:r": function(element) {
          return ReadResult.map(
            readRunProperties(element.firstOrEmpty("w:rPr")),
            readXmlElements(element.children),
            function(properties, children) {
              var hyperlinkOptions = currentHyperlinkOptions();
              if (hyperlinkOptions !== null) {
                children = [new documents.Hyperlink(children, hyperlinkOptions)];
              }
              return new documents.Run(children, properties);
            }
          );
        },
        "w:fldChar": readFldChar,
        "w:instrText": readInstrText,
        "w:t": function(element) {
          return elementResult(new documents.Text(element.text()));
        },
        "w:tab": function(element) {
          return elementResult(new documents.Tab());
        },
        "w:noBreakHyphen": function() {
          return elementResult(new documents.Text("\u2011"));
        },
        "w:softHyphen": function(element) {
          return elementResult(new documents.Text("\xAD"));
        },
        "w:sym": readSymbol,
        "w:hyperlink": function(element) {
          var relationshipId = element.attributes["r:id"];
          var anchor = element.attributes["w:anchor"];
          return readXmlElements(element.children).map(function(children) {
            function create2(options2) {
              var targetFrame = element.attributes["w:tgtFrame"] || null;
              return new documents.Hyperlink(
                children,
                _3.extend({ targetFrame }, options2)
              );
            }
            if (relationshipId) {
              var href = relationships.findTargetByRelationshipId(relationshipId);
              if (anchor) {
                href = uris.replaceFragment(href, anchor);
              }
              return create2({ href });
            } else if (anchor) {
              return create2({ anchor });
            } else {
              return children;
            }
          });
        },
        "w:tbl": readTable,
        "w:tr": readTableRow,
        "w:tc": readTableCell,
        "w:footnoteReference": noteReferenceReader("footnote"),
        "w:endnoteReference": noteReferenceReader("endnote"),
        "w:commentReference": readCommentReference,
        "w:br": function(element) {
          var breakType = element.attributes["w:type"];
          if (breakType == null || breakType === "textWrapping") {
            return elementResult(documents.lineBreak);
          } else if (breakType === "page") {
            return elementResult(documents.pageBreak);
          } else if (breakType === "column") {
            return elementResult(documents.columnBreak);
          } else {
            return emptyResultWithMessages([warning("Unsupported break type: " + breakType)]);
          }
        },
        "w:bookmarkStart": function(element) {
          var name = element.attributes["w:name"];
          if (name === "_GoBack") {
            return emptyResult();
          } else {
            return elementResult(new documents.BookmarkStart({ name }));
          }
        },
        "mc:AlternateContent": function(element) {
          return readChildElements(element.firstOrEmpty("mc:Fallback"));
        },
        "w:sdt": function(element) {
          var contentResult = readXmlElements(element.firstOrEmpty("w:sdtContent").children);
          return contentResult.map(function(content) {
            var checkbox = element.firstOrEmpty("w:sdtPr").first("wordml:checkbox");
            if (checkbox) {
              var checkedElement = checkbox.first("wordml:checked");
              var isChecked = !!checkedElement && readBooleanAttributeValue(
                checkedElement.attributes["wordml:val"]
              );
              var documentCheckbox = documents.checkbox({
                checked: isChecked
              });
              var hasCheckbox = false;
              var replacedContent = content.map(transforms._elementsOfType(
                documents.types.text,
                function(text) {
                  if (text.value.length > 0 && !hasCheckbox) {
                    hasCheckbox = true;
                    return documentCheckbox;
                  } else {
                    return text;
                  }
                }
              ));
              if (hasCheckbox) {
                return replacedContent;
              } else {
                return documentCheckbox;
              }
            } else {
              return content;
            }
          });
        },
        "w:ins": readChildElements,
        "w:object": readChildElements,
        "w:smartTag": readChildElements,
        "w:drawing": readChildElements,
        "w:pict": function(element) {
          return readChildElements(element).toExtra();
        },
        "v:roundrect": readChildElements,
        "v:shape": readChildElements,
        "v:textbox": readChildElements,
        "w:txbxContent": readChildElements,
        "wp:inline": readDrawingElement,
        "wp:anchor": readDrawingElement,
        "v:imagedata": readImageData,
        "v:group": readChildElements,
        "v:rect": readChildElements
      };
      return {
        readXmlElement,
        readXmlElements
      };
      function readTable(element) {
        var propertiesResult = readTableProperties(element.firstOrEmpty("w:tblPr"));
        return readXmlElements(element.children).flatMap(calculateRowSpans).flatMap(function(children) {
          return propertiesResult.map(function(properties) {
            return documents.Table(children, properties);
          });
        });
      }
      function readTableProperties(element) {
        return readTableStyle(element).map(function(style) {
          return {
            styleId: style.styleId,
            styleName: style.name
          };
        });
      }
      function readTableRow(element) {
        var properties = element.firstOrEmpty("w:trPr");
        var isDeleted = !!properties.first("w:del");
        if (isDeleted) {
          return emptyResult();
        }
        var isHeader = !!properties.first("w:tblHeader");
        return readXmlElements(element.children).map(function(children) {
          return documents.TableRow(children, { isHeader });
        });
      }
      function readTableCell(element) {
        return readXmlElements(element.children).map(function(children) {
          var properties = element.firstOrEmpty("w:tcPr");
          var gridSpan = properties.firstOrEmpty("w:gridSpan").attributes["w:val"];
          var colSpan = gridSpan ? parseInt(gridSpan, 10) : 1;
          var cell = documents.TableCell(children, { colSpan });
          cell._vMerge = readVMerge(properties);
          return cell;
        });
      }
      function readVMerge(properties) {
        var element = properties.first("w:vMerge");
        if (element) {
          var val = element.attributes["w:val"];
          return val === "continue" || !val;
        } else {
          return null;
        }
      }
      function calculateRowSpans(rows) {
        var unexpectedNonRows = _3.any(rows, function(row) {
          return row.type !== documents.types.tableRow;
        });
        if (unexpectedNonRows) {
          removeVMergeProperties(rows);
          return elementResultWithMessages(rows, [warning(
            "unexpected non-row element in table, cell merging may be incorrect"
          )]);
        }
        var unexpectedNonCells = _3.any(rows, function(row) {
          return _3.any(row.children, function(cell) {
            return cell.type !== documents.types.tableCell;
          });
        });
        if (unexpectedNonCells) {
          removeVMergeProperties(rows);
          return elementResultWithMessages(rows, [warning(
            "unexpected non-cell element in table row, cell merging may be incorrect"
          )]);
        }
        var columns = {};
        rows.forEach(function(row) {
          var cellIndex = 0;
          row.children.forEach(function(cell) {
            if (cell._vMerge && columns[cellIndex]) {
              columns[cellIndex].rowSpan++;
            } else {
              columns[cellIndex] = cell;
              cell._vMerge = false;
            }
            cellIndex += cell.colSpan;
          });
        });
        rows.forEach(function(row) {
          row.children = row.children.filter(function(cell) {
            return !cell._vMerge;
          });
          row.children.forEach(function(cell) {
            delete cell._vMerge;
          });
        });
        return elementResult(rows);
      }
      function removeVMergeProperties(rows) {
        rows.forEach(function(row) {
          var cells = transforms.getDescendantsOfType(row, documents.types.tableCell);
          cells.forEach(function(cell) {
            delete cell._vMerge;
          });
        });
      }
      function readDrawingElement(element) {
        var blips = element.getElementsByTagName("a:graphic").getElementsByTagName("a:graphicData").getElementsByTagName("pic:pic").getElementsByTagName("pic:blipFill").getElementsByTagName("a:blip");
        return combineResults(blips.map(readBlip.bind(null, element)));
      }
      function readBlip(element, blip) {
        var properties = element.first("wp:docPr").attributes;
        var altText = isBlank(properties.descr) ? properties.title : properties.descr;
        var blipImageFile = findBlipImageFile(blip);
        if (blipImageFile === null) {
          return emptyResultWithMessages([warning("Could not find image file for a:blip element")]);
        } else {
          return readImage(blipImageFile, altText);
        }
      }
      function isBlank(value) {
        return value == null || /^\s*$/.test(value);
      }
      function findBlipImageFile(blip) {
        var embedRelationshipId = blip.attributes["r:embed"];
        var linkRelationshipId = blip.attributes["r:link"];
        if (embedRelationshipId) {
          return findEmbeddedImageFile(embedRelationshipId);
        } else if (linkRelationshipId) {
          var imagePath = relationships.findTargetByRelationshipId(linkRelationshipId);
          return {
            path: imagePath,
            read: files.read.bind(files, imagePath)
          };
        } else {
          return null;
        }
      }
      function readImageData(element) {
        var relationshipId = element.attributes["r:id"];
        if (relationshipId) {
          return readImage(
            findEmbeddedImageFile(relationshipId),
            element.attributes["o:title"]
          );
        } else {
          return emptyResultWithMessages([warning("A v:imagedata element without a relationship ID was ignored")]);
        }
      }
      function findEmbeddedImageFile(relationshipId) {
        var path = uris.uriToZipEntryName("word", relationships.findTargetByRelationshipId(relationshipId));
        return {
          path,
          read: docxFile.read.bind(docxFile, path)
        };
      }
      function readImage(imageFile, altText) {
        var contentType = contentTypes.findContentType(imageFile.path);
        var image = documents.Image({
          readImage: imageFile.read,
          altText,
          contentType
        });
        var warnings = supportedImageTypes[contentType] ? [] : warning("Image of type " + contentType + " is unlikely to display in web browsers");
        return elementResultWithMessages(image, warnings);
      }
      function undefinedStyleWarning(type, styleId) {
        return warning(
          type + " style with ID " + styleId + " was referenced but not defined in the document"
        );
      }
    }
    function readNumberingProperties(styleId, element, numbering) {
      var level = element.firstOrEmpty("w:ilvl").attributes["w:val"];
      var numId = element.firstOrEmpty("w:numId").attributes["w:val"];
      if (level !== void 0 && numId !== void 0) {
        return numbering.findLevel(numId, level);
      }
      if (styleId != null) {
        var levelByStyleId = numbering.findLevelByParagraphStyleId(styleId);
        if (levelByStyleId != null) {
          return levelByStyleId;
        }
      }
      if (numId !== void 0) {
        return numbering.findLevel(numId, "0");
      }
      return null;
    }
    var supportedImageTypes = {
      "image/png": true,
      "image/gif": true,
      "image/jpeg": true,
      "image/svg+xml": true,
      "image/tiff": true
    };
    var ignoreElements = {
      "office-word:wrap": true,
      "v:shadow": true,
      "v:shapetype": true,
      "w:annotationRef": true,
      "w:bookmarkEnd": true,
      "w:sectPr": true,
      "w:proofErr": true,
      "w:lastRenderedPageBreak": true,
      "w:commentRangeStart": true,
      "w:commentRangeEnd": true,
      "w:del": true,
      "w:footnoteRef": true,
      "w:endnoteRef": true,
      "w:pPr": true,
      "w:rPr": true,
      "w:tblPr": true,
      "w:tblGrid": true,
      "w:trPr": true,
      "w:tcPr": true
    };
    function emptyResultWithMessages(messages) {
      return new ReadResult(null, null, messages);
    }
    function emptyResult() {
      return new ReadResult(null);
    }
    function elementResult(element) {
      return new ReadResult(element);
    }
    function elementResultWithMessages(element, messages) {
      return new ReadResult(element, null, messages);
    }
    function ReadResult(element, extra, messages) {
      this.value = element || [];
      this.extra = extra || [];
      this._result = new Result({
        element: this.value,
        extra
      }, messages);
      this.messages = this._result.messages;
    }
    ReadResult.prototype.toExtra = function() {
      return new ReadResult(null, joinElements(this.extra, this.value), this.messages);
    };
    ReadResult.prototype.insertExtra = function() {
      var extra = this.extra;
      if (extra && extra.length) {
        return new ReadResult(joinElements(this.value, extra), null, this.messages);
      } else {
        return this;
      }
    };
    ReadResult.prototype.map = function(func) {
      var result2 = this._result.map(function(value) {
        return func(value.element);
      });
      return new ReadResult(result2.value, this.extra, result2.messages);
    };
    ReadResult.prototype.flatMap = function(func) {
      var result2 = this._result.flatMap(function(value) {
        return func(value.element)._result;
      });
      return new ReadResult(result2.value.element, joinElements(this.extra, result2.value.extra), result2.messages);
    };
    ReadResult.map = function(first2, second, func) {
      return new ReadResult(
        func(first2.value, second.value),
        joinElements(first2.extra, second.extra),
        first2.messages.concat(second.messages)
      );
    };
    function combineResults(results) {
      var result2 = Result.combine(_3.pluck(results, "_result"));
      return new ReadResult(
        _3.flatten(_3.pluck(result2.value, "element")),
        _3.filter(_3.flatten(_3.pluck(result2.value, "extra")), identity2),
        result2.messages
      );
    }
    function joinElements(first2, second) {
      return _3.flatten([first2, second]);
    }
    function identity2(value) {
      return value;
    }
  }
});

// node_modules/mammoth/lib/docx/document-xml-reader.js
var require_document_xml_reader = __commonJS({
  "node_modules/mammoth/lib/docx/document-xml-reader.js"(exports2) {
    exports2.DocumentXmlReader = DocumentXmlReader;
    var documents = require_documents();
    var Result = require_results().Result;
    function DocumentXmlReader(options) {
      var bodyReader = options.bodyReader;
      function convertXmlToDocument(element) {
        var body = element.first("w:body");
        if (body == null) {
          throw new Error("Could not find the body element: are you sure this is a docx file?");
        }
        var result2 = bodyReader.readXmlElements(body.children).map(function(children) {
          return new documents.Document(children, {
            notes: options.notes,
            comments: options.comments
          });
        });
        return new Result(result2.value, result2.messages);
      }
      return {
        convertXmlToDocument
      };
    }
  }
});

// node_modules/mammoth/lib/docx/relationships-reader.js
var require_relationships_reader = __commonJS({
  "node_modules/mammoth/lib/docx/relationships-reader.js"(exports2) {
    exports2.readRelationships = readRelationships;
    exports2.defaultValue = new Relationships([]);
    exports2.Relationships = Relationships;
    function readRelationships(element) {
      var relationships = [];
      element.children.forEach(function(child) {
        if (child.name === "relationships:Relationship") {
          var relationship = {
            relationshipId: child.attributes.Id,
            target: child.attributes.Target,
            type: child.attributes.Type
          };
          relationships.push(relationship);
        }
      });
      return new Relationships(relationships);
    }
    function Relationships(relationships) {
      var targetsByRelationshipId = {};
      relationships.forEach(function(relationship) {
        targetsByRelationshipId[relationship.relationshipId] = relationship.target;
      });
      var targetsByType = {};
      relationships.forEach(function(relationship) {
        if (!targetsByType[relationship.type]) {
          targetsByType[relationship.type] = [];
        }
        targetsByType[relationship.type].push(relationship.target);
      });
      return {
        findTargetByRelationshipId: function(relationshipId) {
          return targetsByRelationshipId[relationshipId];
        },
        findTargetsByType: function(type) {
          return targetsByType[type] || [];
        }
      };
    }
  }
});

// node_modules/mammoth/lib/docx/content-types-reader.js
var require_content_types_reader = __commonJS({
  "node_modules/mammoth/lib/docx/content-types-reader.js"(exports2) {
    exports2.readContentTypesFromXml = readContentTypesFromXml;
    var fallbackContentTypes = {
      "png": "png",
      "gif": "gif",
      "jpeg": "jpeg",
      "jpg": "jpeg",
      "tif": "tiff",
      "tiff": "tiff",
      "bmp": "bmp"
    };
    exports2.defaultContentTypes = contentTypes({}, {});
    function readContentTypesFromXml(element) {
      var extensionDefaults = {};
      var overrides = {};
      element.children.forEach(function(child) {
        if (child.name === "content-types:Default") {
          extensionDefaults[child.attributes.Extension] = child.attributes.ContentType;
        }
        if (child.name === "content-types:Override") {
          var name = child.attributes.PartName;
          if (name.charAt(0) === "/") {
            name = name.substring(1);
          }
          overrides[name] = child.attributes.ContentType;
        }
      });
      return contentTypes(overrides, extensionDefaults);
    }
    function contentTypes(overrides, extensionDefaults) {
      return {
        findContentType: function(path) {
          var overrideContentType = overrides[path];
          if (overrideContentType) {
            return overrideContentType;
          } else {
            var pathParts = path.split(".");
            var extension = pathParts[pathParts.length - 1];
            if (extensionDefaults.hasOwnProperty(extension)) {
              return extensionDefaults[extension];
            } else {
              var fallback = fallbackContentTypes[extension.toLowerCase()];
              if (fallback) {
                return "image/" + fallback;
              } else {
                return null;
              }
            }
          }
        }
      };
    }
  }
});

// node_modules/mammoth/lib/docx/numbering-xml.js
var require_numbering_xml = __commonJS({
  "node_modules/mammoth/lib/docx/numbering-xml.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    exports2.readNumberingXml = readNumberingXml;
    exports2.Numbering = Numbering;
    exports2.defaultNumbering = new Numbering({}, {});
    function Numbering(nums, abstractNums, styles) {
      var allLevels = _3.flatten(_3.values(abstractNums).map(function(abstractNum) {
        return _3.values(abstractNum.levels);
      }));
      var levelsByParagraphStyleId = _3.indexBy(
        allLevels.filter(function(level) {
          return level.paragraphStyleId != null;
        }),
        "paragraphStyleId"
      );
      function findLevel(numId, level) {
        var num = nums[numId];
        if (num) {
          var abstractNum = abstractNums[num.abstractNumId];
          if (!abstractNum) {
            return null;
          } else if (abstractNum.numStyleLink == null) {
            return abstractNums[num.abstractNumId].levels[level];
          } else {
            var style = styles.findNumberingStyleById(abstractNum.numStyleLink);
            return findLevel(style.numId, level);
          }
        } else {
          return null;
        }
      }
      function findLevelByParagraphStyleId(styleId) {
        return levelsByParagraphStyleId[styleId] || null;
      }
      return {
        findLevel,
        findLevelByParagraphStyleId
      };
    }
    function readNumberingXml(root2, options) {
      if (!options || !options.styles) {
        throw new Error("styles is missing");
      }
      var abstractNums = readAbstractNums(root2);
      var nums = readNums(root2, abstractNums);
      return new Numbering(nums, abstractNums, options.styles);
    }
    function readAbstractNums(root2) {
      var abstractNums = {};
      root2.getElementsByTagName("w:abstractNum").forEach(function(element) {
        var id = element.attributes["w:abstractNumId"];
        abstractNums[id] = readAbstractNum(element);
      });
      return abstractNums;
    }
    function readAbstractNum(element) {
      var levels = {};
      var levelWithoutIndex = null;
      element.getElementsByTagName("w:lvl").forEach(function(levelElement) {
        var levelIndex = levelElement.attributes["w:ilvl"];
        var numFmt = levelElement.firstOrEmpty("w:numFmt").attributes["w:val"];
        var isOrdered = numFmt !== "bullet";
        var paragraphStyleId = levelElement.firstOrEmpty("w:pStyle").attributes["w:val"];
        if (levelIndex === void 0) {
          levelWithoutIndex = {
            isOrdered,
            level: "0",
            paragraphStyleId
          };
        } else {
          levels[levelIndex] = {
            isOrdered,
            level: levelIndex,
            paragraphStyleId
          };
        }
      });
      if (levelWithoutIndex !== null && levels[levelWithoutIndex.level] === void 0) {
        levels[levelWithoutIndex.level] = levelWithoutIndex;
      }
      var numStyleLink = element.firstOrEmpty("w:numStyleLink").attributes["w:val"];
      return { levels, numStyleLink };
    }
    function readNums(root2) {
      var nums = {};
      root2.getElementsByTagName("w:num").forEach(function(element) {
        var numId = element.attributes["w:numId"];
        var abstractNumId = element.first("w:abstractNumId").attributes["w:val"];
        nums[numId] = { abstractNumId };
      });
      return nums;
    }
  }
});

// node_modules/mammoth/lib/docx/styles-reader.js
var require_styles_reader = __commonJS({
  "node_modules/mammoth/lib/docx/styles-reader.js"(exports2) {
    exports2.readStylesXml = readStylesXml;
    exports2.Styles = Styles;
    exports2.defaultStyles = new Styles({}, {});
    function Styles(paragraphStyles, characterStyles, tableStyles, numberingStyles) {
      return {
        findParagraphStyleById: function(styleId) {
          return paragraphStyles[styleId];
        },
        findCharacterStyleById: function(styleId) {
          return characterStyles[styleId];
        },
        findTableStyleById: function(styleId) {
          return tableStyles[styleId];
        },
        findNumberingStyleById: function(styleId) {
          return numberingStyles[styleId];
        }
      };
    }
    Styles.EMPTY = new Styles({}, {}, {}, {});
    function readStylesXml(root2) {
      var paragraphStyles = {};
      var characterStyles = {};
      var tableStyles = {};
      var numberingStyles = {};
      var styles = {
        "paragraph": paragraphStyles,
        "character": characterStyles,
        "table": tableStyles,
        "numbering": numberingStyles
      };
      root2.getElementsByTagName("w:style").forEach(function(styleElement) {
        var style = readStyleElement(styleElement);
        var styleSet = styles[style.type];
        if (styleSet && styleSet[style.styleId] === void 0) {
          styleSet[style.styleId] = style;
        }
      });
      return new Styles(paragraphStyles, characterStyles, tableStyles, numberingStyles);
    }
    function readStyleElement(styleElement) {
      var type = styleElement.attributes["w:type"];
      if (type === "numbering") {
        return readNumberingStyleElement(type, styleElement);
      } else {
        var styleId = readStyleId(styleElement);
        var name = styleName(styleElement);
        return { type, styleId, name };
      }
    }
    function styleName(styleElement) {
      var nameElement = styleElement.first("w:name");
      return nameElement ? nameElement.attributes["w:val"] : null;
    }
    function readNumberingStyleElement(type, styleElement) {
      var styleId = readStyleId(styleElement);
      var numId = styleElement.firstOrEmpty("w:pPr").firstOrEmpty("w:numPr").firstOrEmpty("w:numId").attributes["w:val"];
      return { type, numId, styleId };
    }
    function readStyleId(styleElement) {
      return styleElement.attributes["w:styleId"];
    }
  }
});

// node_modules/mammoth/lib/docx/notes-reader.js
var require_notes_reader = __commonJS({
  "node_modules/mammoth/lib/docx/notes-reader.js"(exports2) {
    var documents = require_documents();
    var Result = require_results().Result;
    exports2.createFootnotesReader = createReader.bind(exports2, "footnote");
    exports2.createEndnotesReader = createReader.bind(exports2, "endnote");
    function createReader(noteType, bodyReader) {
      function readNotesXml(element) {
        return Result.combine(element.getElementsByTagName("w:" + noteType).filter(isFootnoteElement).map(readFootnoteElement));
      }
      function isFootnoteElement(element) {
        var type = element.attributes["w:type"];
        return type !== "continuationSeparator" && type !== "separator";
      }
      function readFootnoteElement(footnoteElement) {
        var id = footnoteElement.attributes["w:id"];
        return bodyReader.readXmlElements(footnoteElement.children).map(function(body) {
          return documents.Note({ noteType, noteId: id, body });
        });
      }
      return readNotesXml;
    }
  }
});

// node_modules/mammoth/lib/docx/comments-reader.js
var require_comments_reader = __commonJS({
  "node_modules/mammoth/lib/docx/comments-reader.js"(exports2) {
    var documents = require_documents();
    var Result = require_results().Result;
    function createCommentsReader(bodyReader) {
      function readCommentsXml(element) {
        return Result.combine(element.getElementsByTagName("w:comment").map(readCommentElement));
      }
      function readCommentElement(element) {
        var id = element.attributes["w:id"];
        function readOptionalAttribute(name) {
          return (element.attributes[name] || "").trim() || null;
        }
        return bodyReader.readXmlElements(element.children).map(function(body) {
          return documents.comment({
            commentId: id,
            body,
            authorName: readOptionalAttribute("w:author"),
            authorInitials: readOptionalAttribute("w:initials")
          });
        });
      }
      return readCommentsXml;
    }
    exports2.createCommentsReader = createCommentsReader;
  }
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS({
  "node_modules/path-is-absolute/index.js"(exports2, module2) {
    "use strict";
    function posix(path) {
      return path.charAt(0) === "/";
    }
    function win32(path) {
      var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
      var result2 = splitDeviceRe.exec(path);
      var device = result2[1] || "";
      var isUnc = Boolean(device && device.charAt(1) !== ":");
      return Boolean(result2[2] || isUnc);
    }
    module2.exports = process.platform === "win32" ? win32 : posix;
    module2.exports.posix = posix;
    module2.exports.win32 = win32;
  }
});

// node_modules/mammoth/lib/docx/files.js
var require_files = __commonJS({
  "node_modules/mammoth/lib/docx/files.js"(exports2) {
    var fs2 = __require("fs");
    var url = __require("url");
    var os = __require("os");
    var dirname = __require("path").dirname;
    var resolvePath = __require("path").resolve;
    var isAbsolutePath = require_path_is_absolute();
    var promises = require_promises();
    exports2.Files = Files;
    exports2.uriToPath = uriToPath;
    function Files(options) {
      options = options || {};
      if (!options.externalFileAccess) {
        return {
          read: function(uri) {
            return promises.reject(new Error("could not read external image '" + uri + "', external file access is disabled"));
          }
        };
      }
      var base = options.relativeToFile ? dirname(options.relativeToFile) : null;
      function read(uri, encoding) {
        return resolveUri(uri).then(function(path) {
          return readFile(path, encoding).caught(function(error) {
            var message = "could not open external image: '" + uri + "' (document directory: '" + base + "')\n" + error.message;
            return promises.reject(new Error(message));
          });
        });
      }
      function resolveUri(uri) {
        var path = uriToPath(uri);
        if (isAbsolutePath(path)) {
          return promises.resolve(path);
        } else if (base) {
          return promises.resolve(resolvePath(base, path));
        } else {
          return promises.reject(new Error("could not find external image '" + uri + "', path of input document is unknown"));
        }
      }
      return {
        read
      };
    }
    var readFile = promises.promisify(fs2.readFile.bind(fs2));
    function uriToPath(uriString, platform) {
      if (!platform) {
        platform = os.platform();
      }
      var uri = url.parse(uriString);
      if (isLocalFileUri(uri) || isRelativeUri(uri)) {
        var path = decodeURIComponent(uri.path);
        if (platform === "win32" && /^\/[a-z]:/i.test(path)) {
          return path.slice(1);
        } else {
          return path;
        }
      } else {
        throw new Error("Could not convert URI to path: " + uriString);
      }
    }
    function isLocalFileUri(uri) {
      return uri.protocol === "file:" && (!uri.host || uri.host === "localhost");
    }
    function isRelativeUri(uri) {
      return !uri.protocol && !uri.host;
    }
  }
});

// node_modules/mammoth/lib/docx/docx-reader.js
var require_docx_reader = __commonJS({
  "node_modules/mammoth/lib/docx/docx-reader.js"(exports2) {
    exports2.read = read;
    exports2._findPartPaths = findPartPaths;
    var promises = require_promises();
    var documents = require_documents();
    var Result = require_results().Result;
    var zipfile = require_zipfile();
    var readXmlFromZipFile = require_office_xml_reader().readXmlFromZipFile;
    var createBodyReader = require_body_reader().createBodyReader;
    var DocumentXmlReader = require_document_xml_reader().DocumentXmlReader;
    var relationshipsReader = require_relationships_reader();
    var contentTypesReader = require_content_types_reader();
    var numberingXml = require_numbering_xml();
    var stylesReader = require_styles_reader();
    var notesReader = require_notes_reader();
    var commentsReader = require_comments_reader();
    var Files = require_files().Files;
    function read(docxFile, input, options) {
      input = input || {};
      options = options || {};
      var files = new Files({
        externalFileAccess: options.externalFileAccess,
        relativeToFile: input.path
      });
      return promises.props({
        contentTypes: readContentTypesFromZipFile(docxFile),
        partPaths: findPartPaths(docxFile),
        docxFile,
        files
      }).also(function(result2) {
        return {
          styles: readStylesFromZipFile(docxFile, result2.partPaths.styles)
        };
      }).also(function(result2) {
        return {
          numbering: readNumberingFromZipFile(docxFile, result2.partPaths.numbering, result2.styles)
        };
      }).also(function(result2) {
        return {
          footnotes: readXmlFileWithBody(result2.partPaths.footnotes, result2, function(bodyReader, xml) {
            if (xml) {
              return notesReader.createFootnotesReader(bodyReader)(xml);
            } else {
              return new Result([]);
            }
          }),
          endnotes: readXmlFileWithBody(result2.partPaths.endnotes, result2, function(bodyReader, xml) {
            if (xml) {
              return notesReader.createEndnotesReader(bodyReader)(xml);
            } else {
              return new Result([]);
            }
          }),
          comments: readXmlFileWithBody(result2.partPaths.comments, result2, function(bodyReader, xml) {
            if (xml) {
              return commentsReader.createCommentsReader(bodyReader)(xml);
            } else {
              return new Result([]);
            }
          })
        };
      }).also(function(result2) {
        return {
          notes: result2.footnotes.flatMap(function(footnotes) {
            return result2.endnotes.map(function(endnotes) {
              return new documents.Notes(footnotes.concat(endnotes));
            });
          })
        };
      }).then(function(result2) {
        return readXmlFileWithBody(result2.partPaths.mainDocument, result2, function(bodyReader, xml) {
          return result2.notes.flatMap(function(notes) {
            return result2.comments.flatMap(function(comments) {
              var reader = new DocumentXmlReader({
                bodyReader,
                notes,
                comments
              });
              return reader.convertXmlToDocument(xml);
            });
          });
        });
      });
    }
    function findPartPaths(docxFile) {
      return readPackageRelationships(docxFile).then(function(packageRelationships) {
        var mainDocumentPath = findPartPath({
          docxFile,
          relationships: packageRelationships,
          relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument",
          basePath: "",
          fallbackPath: "word/document.xml"
        });
        if (!docxFile.exists(mainDocumentPath)) {
          throw new Error("Could not find main document part. Are you sure this is a valid .docx file?");
        }
        return xmlFileReader({
          filename: relationshipsFilename(mainDocumentPath),
          readElement: relationshipsReader.readRelationships,
          defaultValue: relationshipsReader.defaultValue
        })(docxFile).then(function(documentRelationships) {
          function findPartRelatedToMainDocument(name) {
            return findPartPath({
              docxFile,
              relationships: documentRelationships,
              relationshipType: "http://schemas.openxmlformats.org/officeDocument/2006/relationships/" + name,
              basePath: zipfile.splitPath(mainDocumentPath).dirname,
              fallbackPath: "word/" + name + ".xml"
            });
          }
          return {
            mainDocument: mainDocumentPath,
            comments: findPartRelatedToMainDocument("comments"),
            endnotes: findPartRelatedToMainDocument("endnotes"),
            footnotes: findPartRelatedToMainDocument("footnotes"),
            numbering: findPartRelatedToMainDocument("numbering"),
            styles: findPartRelatedToMainDocument("styles")
          };
        });
      });
    }
    function findPartPath(options) {
      var docxFile = options.docxFile;
      var relationships = options.relationships;
      var relationshipType = options.relationshipType;
      var basePath = options.basePath;
      var fallbackPath = options.fallbackPath;
      var targets = relationships.findTargetsByType(relationshipType);
      var normalisedTargets = targets.map(function(target) {
        return stripPrefix(zipfile.joinPath(basePath, target), "/");
      });
      var validTargets = normalisedTargets.filter(function(target) {
        return docxFile.exists(target);
      });
      if (validTargets.length === 0) {
        return fallbackPath;
      } else {
        return validTargets[0];
      }
    }
    function stripPrefix(value, prefix) {
      if (value.substring(0, prefix.length) === prefix) {
        return value.substring(prefix.length);
      } else {
        return value;
      }
    }
    function xmlFileReader(options) {
      return function(zipFile) {
        return readXmlFromZipFile(zipFile, options.filename).then(function(element) {
          return element ? options.readElement(element) : options.defaultValue;
        });
      };
    }
    function readXmlFileWithBody(filename, options, func) {
      var readRelationshipsFromZipFile = xmlFileReader({
        filename: relationshipsFilename(filename),
        readElement: relationshipsReader.readRelationships,
        defaultValue: relationshipsReader.defaultValue
      });
      return readRelationshipsFromZipFile(options.docxFile).then(function(relationships) {
        var bodyReader = new createBodyReader({
          relationships,
          contentTypes: options.contentTypes,
          docxFile: options.docxFile,
          numbering: options.numbering,
          styles: options.styles,
          files: options.files
        });
        return readXmlFromZipFile(options.docxFile, filename).then(function(xml) {
          return func(bodyReader, xml);
        });
      });
    }
    function relationshipsFilename(filename) {
      var split = zipfile.splitPath(filename);
      return zipfile.joinPath(split.dirname, "_rels", split.basename + ".rels");
    }
    var readContentTypesFromZipFile = xmlFileReader({
      filename: "[Content_Types].xml",
      readElement: contentTypesReader.readContentTypesFromXml,
      defaultValue: contentTypesReader.defaultContentTypes
    });
    function readNumberingFromZipFile(zipFile, path, styles) {
      return xmlFileReader({
        filename: path,
        readElement: function(element) {
          return numberingXml.readNumberingXml(element, { styles });
        },
        defaultValue: numberingXml.defaultNumbering
      })(zipFile);
    }
    function readStylesFromZipFile(zipFile, path) {
      return xmlFileReader({
        filename: path,
        readElement: stylesReader.readStylesXml,
        defaultValue: stylesReader.defaultStyles
      })(zipFile);
    }
    var readPackageRelationships = xmlFileReader({
      filename: "_rels/.rels",
      readElement: relationshipsReader.readRelationships,
      defaultValue: relationshipsReader.defaultValue
    });
  }
});

// node_modules/mammoth/lib/docx/style-map.js
var require_style_map = __commonJS({
  "node_modules/mammoth/lib/docx/style-map.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var promises = require_promises();
    var xml = require_xml();
    exports2.writeStyleMap = writeStyleMap;
    exports2.readStyleMap = readStyleMap;
    var schema = "http://schemas.zwobble.org/mammoth/style-map";
    var styleMapPath = "mammoth/style-map";
    var styleMapAbsolutePath = "/" + styleMapPath;
    function writeStyleMap(docxFile, styleMap) {
      docxFile.write(styleMapPath, styleMap);
      return updateRelationships(docxFile).then(function() {
        return updateContentTypes(docxFile);
      });
    }
    function updateRelationships(docxFile) {
      var path = "word/_rels/document.xml.rels";
      var relationshipsUri = "http://schemas.openxmlformats.org/package/2006/relationships";
      var relationshipElementName = "{" + relationshipsUri + "}Relationship";
      return docxFile.read(path, "utf8").then(xml.readString).then(function(relationshipsContainer) {
        var relationships = relationshipsContainer.children;
        addOrUpdateElement(relationships, relationshipElementName, "Id", {
          "Id": "rMammothStyleMap",
          "Type": schema,
          "Target": styleMapAbsolutePath
        });
        var namespaces = { "": relationshipsUri };
        return docxFile.write(path, xml.writeString(relationshipsContainer, namespaces));
      });
    }
    function updateContentTypes(docxFile) {
      var path = "[Content_Types].xml";
      var contentTypesUri = "http://schemas.openxmlformats.org/package/2006/content-types";
      var overrideName = "{" + contentTypesUri + "}Override";
      return docxFile.read(path, "utf8").then(xml.readString).then(function(typesElement) {
        var children = typesElement.children;
        addOrUpdateElement(children, overrideName, "PartName", {
          "PartName": styleMapAbsolutePath,
          "ContentType": "text/prs.mammoth.style-map"
        });
        var namespaces = { "": contentTypesUri };
        return docxFile.write(path, xml.writeString(typesElement, namespaces));
      });
    }
    function addOrUpdateElement(elements, name, identifyingAttribute, attributes) {
      var existingElement = _3.find(elements, function(element) {
        return element.name === name && element.attributes[identifyingAttribute] === attributes[identifyingAttribute];
      });
      if (existingElement) {
        existingElement.attributes = attributes;
      } else {
        elements.push(xml.element(name, attributes));
      }
    }
    function readStyleMap(docxFile) {
      if (docxFile.exists(styleMapPath)) {
        return docxFile.read(styleMapPath, "utf8");
      } else {
        return promises.resolve(null);
      }
    }
  }
});

// node_modules/mammoth/lib/html/ast.js
var require_ast = __commonJS({
  "node_modules/mammoth/lib/html/ast.js"(exports2) {
    var htmlPaths = require_html_paths();
    function nonFreshElement(tagName, attributes, children) {
      return elementWithTag(
        htmlPaths.element(tagName, attributes, { fresh: false }),
        children
      );
    }
    function freshElement(tagName, attributes, children) {
      var tag = htmlPaths.element(tagName, attributes, { fresh: true });
      return elementWithTag(tag, children);
    }
    function elementWithTag(tag, children) {
      return {
        type: "element",
        tag,
        children: children || []
      };
    }
    function text(value) {
      return {
        type: "text",
        value
      };
    }
    var forceWrite = {
      type: "forceWrite"
    };
    exports2.freshElement = freshElement;
    exports2.nonFreshElement = nonFreshElement;
    exports2.elementWithTag = elementWithTag;
    exports2.text = text;
    exports2.forceWrite = forceWrite;
    var voidTagNames = {
      "br": true,
      "hr": true,
      "img": true,
      "input": true
    };
    function isVoidElement(node) {
      return node.children.length === 0 && voidTagNames[node.tag.tagName];
    }
    exports2.isVoidElement = isVoidElement;
  }
});

// node_modules/mammoth/lib/html/simplify.js
var require_simplify = __commonJS({
  "node_modules/mammoth/lib/html/simplify.js"(exports2, module2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var ast = require_ast();
    function simplify(nodes) {
      return collapse(removeEmpty(nodes));
    }
    function collapse(nodes) {
      var children = [];
      nodes.map(collapseNode).forEach(function(child) {
        appendChild(children, child);
      });
      return children;
    }
    function collapseNode(node) {
      return collapsers[node.type](node);
    }
    var collapsers = {
      element: collapseElement,
      text: identity2,
      forceWrite: identity2
    };
    function collapseElement(node) {
      return ast.elementWithTag(node.tag, collapse(node.children));
    }
    function identity2(value) {
      return value;
    }
    function appendChild(children, child) {
      var lastChild = children[children.length - 1];
      if (child.type === "element" && !child.tag.fresh && lastChild && lastChild.type === "element" && child.tag.matchesElement(lastChild.tag)) {
        if (child.tag.separator) {
          appendChild(lastChild.children, ast.text(child.tag.separator));
        }
        child.children.forEach(function(grandChild) {
          appendChild(lastChild.children, grandChild);
        });
      } else {
        children.push(child);
      }
    }
    function removeEmpty(nodes) {
      return flatMap(nodes, function(node) {
        return emptiers[node.type](node);
      });
    }
    function flatMap(values2, func) {
      return _3.flatten(_3.map(values2, func), true);
    }
    var emptiers = {
      element: elementEmptier,
      text: textEmptier,
      forceWrite: neverEmpty
    };
    function neverEmpty(node) {
      return [node];
    }
    function elementEmptier(element) {
      var children = removeEmpty(element.children);
      if (children.length === 0 && !ast.isVoidElement(element)) {
        return [];
      } else {
        return [ast.elementWithTag(element.tag, children)];
      }
    }
    function textEmptier(node) {
      if (node.value.length === 0) {
        return [];
      } else {
        return [node];
      }
    }
    module2.exports = simplify;
  }
});

// node_modules/mammoth/lib/html/index.js
var require_html = __commonJS({
  "node_modules/mammoth/lib/html/index.js"(exports2) {
    var ast = require_ast();
    exports2.freshElement = ast.freshElement;
    exports2.nonFreshElement = ast.nonFreshElement;
    exports2.elementWithTag = ast.elementWithTag;
    exports2.text = ast.text;
    exports2.forceWrite = ast.forceWrite;
    exports2.simplify = require_simplify();
    function write(writer, nodes) {
      nodes.forEach(function(node) {
        writeNode(writer, node);
      });
    }
    function writeNode(writer, node) {
      toStrings[node.type](writer, node);
    }
    var toStrings = {
      element: generateElementString,
      text: generateTextString,
      forceWrite: function() {
      }
    };
    function generateElementString(writer, node) {
      if (ast.isVoidElement(node)) {
        writer.selfClosing(node.tag.tagName, node.tag.attributes);
      } else {
        writer.open(node.tag.tagName, node.tag.attributes);
        write(writer, node.children);
        writer.close(node.tag.tagName);
      }
    }
    function generateTextString(writer, node) {
      writer.text(node.value);
    }
    exports2.write = write;
  }
});

// node_modules/mammoth/lib/styles/html-paths.js
var require_html_paths = __commonJS({
  "node_modules/mammoth/lib/styles/html-paths.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var html = require_html();
    exports2.topLevelElement = topLevelElement;
    exports2.elements = elements;
    exports2.element = element;
    function topLevelElement(tagName, attributes) {
      return elements([element(tagName, attributes, { fresh: true })]);
    }
    function elements(elementStyles) {
      return new HtmlPath(elementStyles.map(function(elementStyle) {
        if (_3.isString(elementStyle)) {
          return element(elementStyle);
        } else {
          return elementStyle;
        }
      }));
    }
    function HtmlPath(elements2) {
      this._elements = elements2;
    }
    HtmlPath.prototype.wrap = function wrap2(children) {
      var result2 = children();
      for (var index = this._elements.length - 1; index >= 0; index--) {
        result2 = this._elements[index].wrapNodes(result2);
      }
      return result2;
    };
    function element(tagName, attributes, options) {
      options = options || {};
      return new Element(tagName, attributes, options);
    }
    function Element(tagName, attributes, options) {
      var tagNames = {};
      if (_3.isArray(tagName)) {
        tagName.forEach(function(tagName2) {
          tagNames[tagName2] = true;
        });
        tagName = tagName[0];
      } else {
        tagNames[tagName] = true;
      }
      this.tagName = tagName;
      this.tagNames = tagNames;
      this.attributes = attributes || {};
      this.fresh = options.fresh;
      this.separator = options.separator;
    }
    Element.prototype.matchesElement = function(element2) {
      return this.tagNames[element2.tagName] && _3.isEqual(this.attributes || {}, element2.attributes || {});
    };
    Element.prototype.wrap = function wrap2(generateNodes) {
      return this.wrapNodes(generateNodes());
    };
    Element.prototype.wrapNodes = function wrapNodes(nodes) {
      return [html.elementWithTag(this, nodes)];
    };
    exports2.empty = elements([]);
    exports2.ignore = {
      wrap: function() {
        return [];
      }
    };
  }
});

// node_modules/mammoth/lib/images.js
var require_images = __commonJS({
  "node_modules/mammoth/lib/images.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var promises = require_promises();
    var Html = require_html();
    exports2.imgElement = imgElement;
    function imgElement(func) {
      return function(element, messages) {
        return promises.when(func(element)).then(function(result2) {
          var attributes = {};
          if (element.altText) {
            attributes.alt = element.altText;
          }
          _3.extend(attributes, result2);
          return [Html.freshElement("img", attributes)];
        });
      };
    }
    exports2.inline = exports2.imgElement;
    exports2.dataUri = imgElement(function(element) {
      return element.readAsBase64String().then(function(imageBuffer) {
        return {
          src: "data:" + element.contentType + ";base64," + imageBuffer
        };
      });
    });
  }
});

// node_modules/mammoth/lib/writers/html-writer.js
var require_html_writer = __commonJS({
  "node_modules/mammoth/lib/writers/html-writer.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    exports2.writer = writer;
    function writer(options) {
      options = options || {};
      if (options.prettyPrint) {
        return prettyWriter();
      } else {
        return simpleWriter();
      }
    }
    var indentedElements = {
      div: true,
      p: true,
      ul: true,
      li: true
    };
    function prettyWriter() {
      var indentationLevel = 0;
      var indentation = "  ";
      var stack = [];
      var start = true;
      var inText = false;
      var writer2 = simpleWriter();
      function open(tagName, attributes) {
        if (indentedElements[tagName]) {
          indent();
        }
        stack.push(tagName);
        writer2.open(tagName, attributes);
        if (indentedElements[tagName]) {
          indentationLevel++;
        }
        start = false;
      }
      function close(tagName) {
        if (indentedElements[tagName]) {
          indentationLevel--;
          indent();
        }
        stack.pop();
        writer2.close(tagName);
      }
      function text(value) {
        startText();
        var text2 = isInPre() ? value : value.replace("\n", "\n" + indentation);
        writer2.text(text2);
      }
      function selfClosing(tagName, attributes) {
        indent();
        writer2.selfClosing(tagName, attributes);
      }
      function insideIndentedElement() {
        return stack.length === 0 || indentedElements[stack[stack.length - 1]];
      }
      function startText() {
        if (!inText) {
          indent();
          inText = true;
        }
      }
      function indent() {
        inText = false;
        if (!start && insideIndentedElement() && !isInPre()) {
          writer2._append("\n");
          for (var i = 0; i < indentationLevel; i++) {
            writer2._append(indentation);
          }
        }
      }
      function isInPre() {
        return _3.some(stack, function(tagName) {
          return tagName === "pre";
        });
      }
      return {
        asString: writer2.asString,
        open,
        close,
        text,
        selfClosing
      };
    }
    function simpleWriter() {
      var fragments = [];
      function open(tagName, attributes) {
        var attributeString = generateAttributeString(attributes);
        fragments.push("<" + tagName + attributeString + ">");
      }
      function close(tagName) {
        fragments.push("</" + tagName + ">");
      }
      function selfClosing(tagName, attributes) {
        var attributeString = generateAttributeString(attributes);
        fragments.push("<" + tagName + attributeString + " />");
      }
      function generateAttributeString(attributes) {
        return _3.map(attributes, function(value, key) {
          return " " + key + '="' + escapeHtmlAttribute(value) + '"';
        }).join("");
      }
      function text(value) {
        fragments.push(escapeHtmlText(value));
      }
      function append(html) {
        fragments.push(html);
      }
      function asString() {
        return fragments.join("");
      }
      return {
        asString,
        open,
        close,
        text,
        selfClosing,
        _append: append
      };
    }
    function escapeHtmlText(value) {
      return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
    function escapeHtmlAttribute(value) {
      return value.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
    }
  }
});

// node_modules/mammoth/lib/writers/markdown-writer.js
var require_markdown_writer = __commonJS({
  "node_modules/mammoth/lib/writers/markdown-writer.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    function symmetricMarkdownElement(end) {
      return markdownElement(end, end);
    }
    function markdownElement(start, end) {
      return function() {
        return { start, end };
      };
    }
    function markdownLink(attributes) {
      var href = attributes.href || "";
      if (href) {
        return {
          start: "[",
          end: "](" + href + ")",
          anchorPosition: "before"
        };
      } else {
        return {};
      }
    }
    function markdownImage(attributes) {
      var src = attributes.src || "";
      var altText = attributes.alt || "";
      if (src || altText) {
        return { start: "![" + altText + "](" + src + ")" };
      } else {
        return {};
      }
    }
    function markdownList(options) {
      return function(attributes, list) {
        return {
          start: list ? "\n" : "",
          end: list ? "" : "\n",
          list: {
            isOrdered: options.isOrdered,
            indent: list ? list.indent + 1 : 0,
            count: 0
          }
        };
      };
    }
    function markdownListItem(attributes, list, listItem) {
      list = list || { indent: 0, isOrdered: false, count: 0 };
      list.count++;
      listItem.hasClosed = false;
      var bullet = list.isOrdered ? list.count + "." : "-";
      var start = repeatString("	", list.indent) + bullet + " ";
      return {
        start,
        end: function() {
          if (!listItem.hasClosed) {
            listItem.hasClosed = true;
            return "\n";
          }
        }
      };
    }
    var htmlToMarkdown = {
      "p": markdownElement("", "\n\n"),
      "br": markdownElement("", "  \n"),
      "ul": markdownList({ isOrdered: false }),
      "ol": markdownList({ isOrdered: true }),
      "li": markdownListItem,
      "strong": symmetricMarkdownElement("__"),
      "em": symmetricMarkdownElement("*"),
      "a": markdownLink,
      "img": markdownImage
    };
    (function() {
      for (var i = 1; i <= 6; i++) {
        htmlToMarkdown["h" + i] = markdownElement(repeatString("#", i) + " ", "\n\n");
      }
    })();
    function repeatString(value, count) {
      return new Array(count + 1).join(value);
    }
    function markdownWriter() {
      var fragments = [];
      var elementStack = [];
      var list = null;
      var listItem = {};
      function open(tagName, attributes) {
        attributes = attributes || {};
        var createElement = htmlToMarkdown[tagName] || function() {
          return {};
        };
        var element = createElement(attributes, list, listItem);
        elementStack.push({ end: element.end, list });
        if (element.list) {
          list = element.list;
        }
        var anchorBeforeStart = element.anchorPosition === "before";
        if (anchorBeforeStart) {
          writeAnchor(attributes);
        }
        fragments.push(element.start || "");
        if (!anchorBeforeStart) {
          writeAnchor(attributes);
        }
      }
      function writeAnchor(attributes) {
        if (attributes.id) {
          fragments.push('<a id="' + attributes.id + '"></a>');
        }
      }
      function close(tagName) {
        var element = elementStack.pop();
        list = element.list;
        var end = _3.isFunction(element.end) ? element.end() : element.end;
        fragments.push(end || "");
      }
      function selfClosing(tagName, attributes) {
        open(tagName, attributes);
        close(tagName);
      }
      function text(value) {
        fragments.push(escapeMarkdown(value));
      }
      function asString() {
        return fragments.join("");
      }
      return {
        asString,
        open,
        close,
        text,
        selfClosing
      };
    }
    exports2.writer = markdownWriter;
    function escapeMarkdown(value) {
      return value.replace(/\\/g, "\\\\").replace(/([\`\*_\{\}\[\]\(\)\#\+\-\.\!])/g, "\\$1");
    }
  }
});

// node_modules/mammoth/lib/writers/index.js
var require_writers = __commonJS({
  "node_modules/mammoth/lib/writers/index.js"(exports2) {
    var htmlWriter = require_html_writer();
    var markdownWriter = require_markdown_writer();
    exports2.writer = writer;
    function writer(options) {
      options = options || {};
      if (options.outputFormat === "markdown") {
        return markdownWriter.writer();
      } else {
        return htmlWriter.writer(options);
      }
    }
  }
});

// node_modules/mammoth/lib/document-to-html.js
var require_document_to_html = __commonJS({
  "node_modules/mammoth/lib/document-to-html.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var promises = require_promises();
    var documents = require_documents();
    var htmlPaths = require_html_paths();
    var results = require_results();
    var images = require_images();
    var Html = require_html();
    var writers = require_writers();
    exports2.DocumentConverter = DocumentConverter;
    function DocumentConverter(options) {
      return {
        convertToHtml: function(element) {
          var comments = _3.indexBy(
            element.type === documents.types.document ? element.comments : [],
            "commentId"
          );
          var conversion = new DocumentConversion(options, comments);
          return conversion.convertToHtml(element);
        }
      };
    }
    function DocumentConversion(options, comments) {
      var noteNumber = 1;
      var noteReferences = [];
      var referencedComments = [];
      options = _3.extend({ ignoreEmptyParagraphs: true }, options);
      var idPrefix = options.idPrefix === void 0 ? "" : options.idPrefix;
      var ignoreEmptyParagraphs = options.ignoreEmptyParagraphs;
      var defaultParagraphStyle = htmlPaths.topLevelElement("p");
      var styleMap = options.styleMap || [];
      function convertToHtml(document2) {
        var messages = [];
        var html = elementToHtml(document2, messages, {});
        var deferredNodes = [];
        walkHtml(html, function(node) {
          if (node.type === "deferred") {
            deferredNodes.push(node);
          }
        });
        var deferredValues = {};
        return promises.mapSeries(deferredNodes, function(deferred) {
          return deferred.value().then(function(value) {
            deferredValues[deferred.id] = value;
          });
        }).then(function() {
          function replaceDeferred(nodes) {
            return flatMap(nodes, function(node) {
              if (node.type === "deferred") {
                return deferredValues[node.id];
              } else if (node.children) {
                return [
                  _3.extend({}, node, {
                    children: replaceDeferred(node.children)
                  })
                ];
              } else {
                return [node];
              }
            });
          }
          var writer = writers.writer({
            prettyPrint: options.prettyPrint,
            outputFormat: options.outputFormat
          });
          Html.write(writer, Html.simplify(replaceDeferred(html)));
          return new results.Result(writer.asString(), messages);
        });
      }
      function convertElements(elements, messages, options2) {
        return flatMap(elements, function(element) {
          return elementToHtml(element, messages, options2);
        });
      }
      function elementToHtml(element, messages, options2) {
        if (!options2) {
          throw new Error("options not set");
        }
        var handler2 = elementConverters[element.type];
        if (handler2) {
          return handler2(element, messages, options2);
        } else {
          return [];
        }
      }
      function convertParagraph(element, messages, options2) {
        return htmlPathForParagraph(element, messages).wrap(function() {
          var content = convertElements(element.children, messages, options2);
          if (ignoreEmptyParagraphs) {
            return content;
          } else {
            return [Html.forceWrite].concat(content);
          }
        });
      }
      function htmlPathForParagraph(element, messages) {
        var style = findStyle(element);
        if (style) {
          return style.to;
        } else {
          if (element.styleId) {
            messages.push(unrecognisedStyleWarning("paragraph", element));
          }
          return defaultParagraphStyle;
        }
      }
      function convertRun(run, messages, options2) {
        var nodes = function() {
          return convertElements(run.children, messages, options2);
        };
        var paths = [];
        if (run.highlight !== null) {
          var path = findHtmlPath({ type: "highlight", color: run.highlight });
          if (path) {
            paths.push(path);
          }
        }
        if (run.isSmallCaps) {
          paths.push(findHtmlPathForRunProperty("smallCaps"));
        }
        if (run.isAllCaps) {
          paths.push(findHtmlPathForRunProperty("allCaps"));
        }
        if (run.isStrikethrough) {
          paths.push(findHtmlPathForRunProperty("strikethrough", "s"));
        }
        if (run.isUnderline) {
          paths.push(findHtmlPathForRunProperty("underline"));
        }
        if (run.verticalAlignment === documents.verticalAlignment.subscript) {
          paths.push(htmlPaths.element("sub", {}, { fresh: false }));
        }
        if (run.verticalAlignment === documents.verticalAlignment.superscript) {
          paths.push(htmlPaths.element("sup", {}, { fresh: false }));
        }
        if (run.isItalic) {
          paths.push(findHtmlPathForRunProperty("italic", "em"));
        }
        if (run.isBold) {
          paths.push(findHtmlPathForRunProperty("bold", "strong"));
        }
        var stylePath = htmlPaths.empty;
        var style = findStyle(run);
        if (style) {
          stylePath = style.to;
        } else if (run.styleId) {
          messages.push(unrecognisedStyleWarning("run", run));
        }
        paths.push(stylePath);
        paths.forEach(function(path2) {
          nodes = path2.wrap.bind(path2, nodes);
        });
        return nodes();
      }
      function findHtmlPathForRunProperty(elementType, defaultTagName) {
        var path = findHtmlPath({ type: elementType });
        if (path) {
          return path;
        } else if (defaultTagName) {
          return htmlPaths.element(defaultTagName, {}, { fresh: false });
        } else {
          return htmlPaths.empty;
        }
      }
      function findHtmlPath(element, defaultPath) {
        var style = findStyle(element);
        return style ? style.to : defaultPath;
      }
      function findStyle(element) {
        for (var i = 0; i < styleMap.length; i++) {
          if (styleMap[i].from.matches(element)) {
            return styleMap[i];
          }
        }
      }
      function recoveringConvertImage(convertImage) {
        return function(image, messages) {
          return promises.attempt(function() {
            return convertImage(image, messages);
          }).caught(function(error) {
            messages.push(results.error(error));
            return [];
          });
        };
      }
      function noteHtmlId(note) {
        return referentHtmlId(note.noteType, note.noteId);
      }
      function noteRefHtmlId(note) {
        return referenceHtmlId(note.noteType, note.noteId);
      }
      function referentHtmlId(referenceType, referenceId) {
        return htmlId(referenceType + "-" + referenceId);
      }
      function referenceHtmlId(referenceType, referenceId) {
        return htmlId(referenceType + "-ref-" + referenceId);
      }
      function htmlId(suffix) {
        return idPrefix + suffix;
      }
      var defaultTablePath = htmlPaths.elements([
        htmlPaths.element("table", {}, { fresh: true })
      ]);
      function convertTable(element, messages, options2) {
        return findHtmlPath(element, defaultTablePath).wrap(function() {
          return convertTableChildren(element, messages, options2);
        });
      }
      function convertTableChildren(element, messages, options2) {
        var bodyIndex = _3.findIndex(element.children, function(child) {
          return !child.type === documents.types.tableRow || !child.isHeader;
        });
        if (bodyIndex === -1) {
          bodyIndex = element.children.length;
        }
        var children;
        if (bodyIndex === 0) {
          children = convertElements(
            element.children,
            messages,
            _3.extend({}, options2, { isTableHeader: false })
          );
        } else {
          var headRows = convertElements(
            element.children.slice(0, bodyIndex),
            messages,
            _3.extend({}, options2, { isTableHeader: true })
          );
          var bodyRows = convertElements(
            element.children.slice(bodyIndex),
            messages,
            _3.extend({}, options2, { isTableHeader: false })
          );
          children = [
            Html.freshElement("thead", {}, headRows),
            Html.freshElement("tbody", {}, bodyRows)
          ];
        }
        return [Html.forceWrite].concat(children);
      }
      function convertTableRow(element, messages, options2) {
        var children = convertElements(element.children, messages, options2);
        return [
          Html.freshElement("tr", {}, [Html.forceWrite].concat(children))
        ];
      }
      function convertTableCell(element, messages, options2) {
        var tagName = options2.isTableHeader ? "th" : "td";
        var children = convertElements(element.children, messages, options2);
        var attributes = {};
        if (element.colSpan !== 1) {
          attributes.colspan = element.colSpan.toString();
        }
        if (element.rowSpan !== 1) {
          attributes.rowspan = element.rowSpan.toString();
        }
        return [
          Html.freshElement(tagName, attributes, [Html.forceWrite].concat(children))
        ];
      }
      function convertCommentReference(reference, messages, options2) {
        return findHtmlPath(reference, htmlPaths.ignore).wrap(function() {
          var comment = comments[reference.commentId];
          var count = referencedComments.length + 1;
          var label = "[" + commentAuthorLabel(comment) + count + "]";
          referencedComments.push({ label, comment });
          return [
            Html.freshElement("a", {
              href: "#" + referentHtmlId("comment", reference.commentId),
              id: referenceHtmlId("comment", reference.commentId)
            }, [Html.text(label)])
          ];
        });
      }
      function convertComment(referencedComment, messages, options2) {
        var label = referencedComment.label;
        var comment = referencedComment.comment;
        var body = convertElements(comment.body, messages, options2).concat([
          Html.nonFreshElement("p", {}, [
            Html.text(" "),
            Html.freshElement("a", { "href": "#" + referenceHtmlId("comment", comment.commentId) }, [
              Html.text("\u2191")
            ])
          ])
        ]);
        return [
          Html.freshElement(
            "dt",
            { "id": referentHtmlId("comment", comment.commentId) },
            [Html.text("Comment " + label)]
          ),
          Html.freshElement("dd", {}, body)
        ];
      }
      function convertBreak(element, messages, options2) {
        return htmlPathForBreak(element).wrap(function() {
          return [];
        });
      }
      function htmlPathForBreak(element) {
        var style = findStyle(element);
        if (style) {
          return style.to;
        } else if (element.breakType === "line") {
          return htmlPaths.topLevelElement("br");
        } else {
          return htmlPaths.empty;
        }
      }
      var elementConverters = {
        "document": function(document2, messages, options2) {
          var children = convertElements(document2.children, messages, options2);
          var notes = noteReferences.map(function(noteReference) {
            return document2.notes.resolve(noteReference);
          });
          var notesNodes = convertElements(notes, messages, options2);
          return children.concat([
            Html.freshElement("ol", {}, notesNodes),
            Html.freshElement("dl", {}, flatMap(referencedComments, function(referencedComment) {
              return convertComment(referencedComment, messages, options2);
            }))
          ]);
        },
        "paragraph": convertParagraph,
        "run": convertRun,
        "text": function(element, messages, options2) {
          return [Html.text(element.value)];
        },
        "tab": function(element, messages, options2) {
          return [Html.text("	")];
        },
        "hyperlink": function(element, messages, options2) {
          var href = element.anchor ? "#" + htmlId(element.anchor) : element.href;
          var attributes = { href };
          if (element.targetFrame != null) {
            attributes.target = element.targetFrame;
          }
          var children = convertElements(element.children, messages, options2);
          return [Html.nonFreshElement("a", attributes, children)];
        },
        "checkbox": function(element) {
          var attributes = { type: "checkbox" };
          if (element.checked) {
            attributes["checked"] = "checked";
          }
          return [Html.freshElement("input", attributes)];
        },
        "bookmarkStart": function(element, messages, options2) {
          var anchor = Html.freshElement("a", {
            id: htmlId(element.name)
          }, [Html.forceWrite]);
          return [anchor];
        },
        "noteReference": function(element, messages, options2) {
          noteReferences.push(element);
          var anchor = Html.freshElement("a", {
            href: "#" + noteHtmlId(element),
            id: noteRefHtmlId(element)
          }, [Html.text("[" + noteNumber++ + "]")]);
          return [Html.freshElement("sup", {}, [anchor])];
        },
        "note": function(element, messages, options2) {
          var children = convertElements(element.body, messages, options2);
          var backLink = Html.elementWithTag(htmlPaths.element("p", {}, { fresh: false }), [
            Html.text(" "),
            Html.freshElement("a", { href: "#" + noteRefHtmlId(element) }, [Html.text("\u2191")])
          ]);
          var body = children.concat([backLink]);
          return Html.freshElement("li", { id: noteHtmlId(element) }, body);
        },
        "commentReference": convertCommentReference,
        "comment": convertComment,
        "image": deferredConversion(recoveringConvertImage(options.convertImage || images.dataUri)),
        "table": convertTable,
        "tableRow": convertTableRow,
        "tableCell": convertTableCell,
        "break": convertBreak
      };
      return {
        convertToHtml
      };
    }
    var deferredId = 1;
    function deferredConversion(func) {
      return function(element, messages, options) {
        return [
          {
            type: "deferred",
            id: deferredId++,
            value: function() {
              return func(element, messages, options);
            }
          }
        ];
      };
    }
    function unrecognisedStyleWarning(type, element) {
      return results.warning(
        "Unrecognised " + type + " style: '" + element.styleName + "' (Style ID: " + element.styleId + ")"
      );
    }
    function flatMap(values2, func) {
      return _3.flatten(values2.map(func), true);
    }
    function walkHtml(nodes, callback) {
      nodes.forEach(function(node) {
        callback(node);
        if (node.children) {
          walkHtml(node.children, callback);
        }
      });
    }
    var commentAuthorLabel = exports2.commentAuthorLabel = function commentAuthorLabel2(comment) {
      return comment.authorInitials || "";
    };
  }
});

// node_modules/mammoth/lib/raw-text.js
var require_raw_text = __commonJS({
  "node_modules/mammoth/lib/raw-text.js"(exports2) {
    var documents = require_documents();
    function convertElementToRawText(element) {
      if (element.type === "text") {
        return element.value;
      } else if (element.type === documents.types.tab) {
        return "	";
      } else {
        var tail = element.type === "paragraph" ? "\n\n" : "";
        return (element.children || []).map(convertElementToRawText).join("") + tail;
      }
    }
    exports2.convertElementToRawText = convertElementToRawText;
  }
});

// node_modules/lop/lib/TokenIterator.js
var require_TokenIterator = __commonJS({
  "node_modules/lop/lib/TokenIterator.js"(exports2, module2) {
    var TokenIterator = module2.exports = function(tokens, startIndex) {
      this._tokens = tokens;
      this._startIndex = startIndex || 0;
    };
    TokenIterator.prototype.head = function() {
      return this._tokens[this._startIndex];
    };
    TokenIterator.prototype.tail = function(startIndex) {
      return new TokenIterator(this._tokens, this._startIndex + 1);
    };
    TokenIterator.prototype.toArray = function() {
      return this._tokens.slice(this._startIndex);
    };
    TokenIterator.prototype.end = function() {
      return this._tokens[this._tokens.length - 1];
    };
    TokenIterator.prototype.to = function(end) {
      var start = this.head().source;
      var endToken = end.head() || end.end();
      return start.to(endToken.source);
    };
  }
});

// node_modules/lop/lib/parser.js
var require_parser = __commonJS({
  "node_modules/lop/lib/parser.js"(exports2) {
    var TokenIterator = require_TokenIterator();
    exports2.Parser = function(options) {
      var parseTokens = function(parser, tokens) {
        return parser(new TokenIterator(tokens));
      };
      return {
        parseTokens
      };
    };
  }
});

// node_modules/option/index.js
var require_option = __commonJS({
  "node_modules/option/index.js"(exports2) {
    exports2.none = /* @__PURE__ */ Object.create({
      value: function() {
        throw new Error("Called value on none");
      },
      isNone: function() {
        return true;
      },
      isSome: function() {
        return false;
      },
      map: function() {
        return exports2.none;
      },
      flatMap: function() {
        return exports2.none;
      },
      filter: function() {
        return exports2.none;
      },
      toArray: function() {
        return [];
      },
      orElse: callOrReturn,
      valueOrElse: callOrReturn
    });
    function callOrReturn(value) {
      if (typeof value == "function") {
        return value();
      } else {
        return value;
      }
    }
    exports2.some = function(value) {
      return new Some(value);
    };
    var Some = function(value) {
      this._value = value;
    };
    Some.prototype.value = function() {
      return this._value;
    };
    Some.prototype.isNone = function() {
      return false;
    };
    Some.prototype.isSome = function() {
      return true;
    };
    Some.prototype.map = function(func) {
      return new Some(func(this._value));
    };
    Some.prototype.flatMap = function(func) {
      return func(this._value);
    };
    Some.prototype.filter = function(predicate) {
      return predicate(this._value) ? this : exports2.none;
    };
    Some.prototype.toArray = function() {
      return [this._value];
    };
    Some.prototype.orElse = function(value) {
      return this;
    };
    Some.prototype.valueOrElse = function(value) {
      return this._value;
    };
    exports2.isOption = function(value) {
      return value === exports2.none || value instanceof Some;
    };
    exports2.fromNullable = function(value) {
      if (value == null) {
        return exports2.none;
      }
      return new Some(value);
    };
  }
});

// node_modules/lop/lib/parsing-results.js
var require_parsing_results = __commonJS({
  "node_modules/lop/lib/parsing-results.js"(exports2, module2) {
    module2.exports = {
      failure: function(errors, remaining) {
        if (errors.length < 1) {
          throw new Error("Failure must have errors");
        }
        return new Result({
          status: "failure",
          remaining,
          errors
        });
      },
      error: function(errors, remaining) {
        if (errors.length < 1) {
          throw new Error("Failure must have errors");
        }
        return new Result({
          status: "error",
          remaining,
          errors
        });
      },
      success: function(value, remaining, source) {
        return new Result({
          status: "success",
          value,
          source,
          remaining,
          errors: []
        });
      },
      cut: function(remaining) {
        return new Result({
          status: "cut",
          remaining,
          errors: []
        });
      }
    };
    var Result = function(options) {
      this._value = options.value;
      this._status = options.status;
      this._hasValue = options.value !== void 0;
      this._remaining = options.remaining;
      this._source = options.source;
      this._errors = options.errors;
    };
    Result.prototype.map = function(func) {
      if (this._hasValue) {
        return new Result({
          value: func(this._value, this._source),
          status: this._status,
          remaining: this._remaining,
          source: this._source,
          errors: this._errors
        });
      } else {
        return this;
      }
    };
    Result.prototype.changeRemaining = function(remaining) {
      return new Result({
        value: this._value,
        status: this._status,
        remaining,
        source: this._source,
        errors: this._errors
      });
    };
    Result.prototype.isSuccess = function() {
      return this._status === "success" || this._status === "cut";
    };
    Result.prototype.isFailure = function() {
      return this._status === "failure";
    };
    Result.prototype.isError = function() {
      return this._status === "error";
    };
    Result.prototype.isCut = function() {
      return this._status === "cut";
    };
    Result.prototype.value = function() {
      return this._value;
    };
    Result.prototype.remaining = function() {
      return this._remaining;
    };
    Result.prototype.source = function() {
      return this._source;
    };
    Result.prototype.errors = function() {
      return this._errors;
    };
  }
});

// node_modules/lop/lib/errors.js
var require_errors2 = __commonJS({
  "node_modules/lop/lib/errors.js"(exports2) {
    exports2.error = function(options) {
      return new Error2(options);
    };
    var Error2 = function(options) {
      this.expected = options.expected;
      this.actual = options.actual;
      this._location = options.location;
    };
    Error2.prototype.describe = function() {
      var locationDescription = this._location ? this._location.describe() + ":\n" : "";
      return locationDescription + "Expected " + this.expected + "\nbut got " + this.actual;
    };
    Error2.prototype.lineNumber = function() {
      return this._location.lineNumber();
    };
    Error2.prototype.characterNumber = function() {
      return this._location.characterNumber();
    };
  }
});

// node_modules/lop/lib/lazy-iterators.js
var require_lazy_iterators = __commonJS({
  "node_modules/lop/lib/lazy-iterators.js"(exports2) {
    var fromArray = exports2.fromArray = function(array) {
      var index = 0;
      var hasNext = function() {
        return index < array.length;
      };
      return new LazyIterator({
        hasNext,
        next: function() {
          if (!hasNext()) {
            throw new Error("No more elements");
          } else {
            return array[index++];
          }
        }
      });
    };
    var LazyIterator = function(iterator) {
      this._iterator = iterator;
    };
    LazyIterator.prototype.map = function(func) {
      var iterator = this._iterator;
      return new LazyIterator({
        hasNext: function() {
          return iterator.hasNext();
        },
        next: function() {
          return func(iterator.next());
        }
      });
    };
    LazyIterator.prototype.filter = function(condition) {
      var iterator = this._iterator;
      var moved = false;
      var hasNext = false;
      var next;
      var moveIfNecessary = function() {
        if (moved) {
          return;
        }
        moved = true;
        hasNext = false;
        while (iterator.hasNext() && !hasNext) {
          next = iterator.next();
          hasNext = condition(next);
        }
      };
      return new LazyIterator({
        hasNext: function() {
          moveIfNecessary();
          return hasNext;
        },
        next: function() {
          moveIfNecessary();
          var toReturn = next;
          moved = false;
          return toReturn;
        }
      });
    };
    LazyIterator.prototype.first = function() {
      var iterator = this._iterator;
      if (this._iterator.hasNext()) {
        return iterator.next();
      } else {
        return null;
      }
    };
    LazyIterator.prototype.toArray = function() {
      var result2 = [];
      while (this._iterator.hasNext()) {
        result2.push(this._iterator.next());
      }
      return result2;
    };
  }
});

// node_modules/lop/lib/rules.js
var require_rules = __commonJS({
  "node_modules/lop/lib/rules.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var options = require_option();
    var results = require_parsing_results();
    var errors = require_errors2();
    var lazyIterators = require_lazy_iterators();
    exports2.token = function(tokenType, value) {
      var matchValue = value !== void 0;
      return function(input) {
        var token = input.head();
        if (token && token.name === tokenType && (!matchValue || token.value === value)) {
          return results.success(token.value, input.tail(), token.source);
        } else {
          var expected = describeToken({ name: tokenType, value });
          return describeTokenMismatch(input, expected);
        }
      };
    };
    exports2.tokenOfType = function(tokenType) {
      return exports2.token(tokenType);
    };
    exports2.firstOf = function(name, parsers) {
      if (!_3.isArray(parsers)) {
        parsers = Array.prototype.slice.call(arguments, 1);
      }
      return function(input) {
        return lazyIterators.fromArray(parsers).map(function(parser) {
          return parser(input);
        }).filter(function(result2) {
          return result2.isSuccess() || result2.isError();
        }).first() || describeTokenMismatch(input, name);
      };
    };
    exports2.then = function(parser, func) {
      return function(input) {
        var result2 = parser(input);
        if (!result2.map) {
          console.log(result2);
        }
        return result2.map(func);
      };
    };
    exports2.sequence = function() {
      var parsers = Array.prototype.slice.call(arguments, 0);
      var rule = function(input) {
        var result2 = _3.foldl(parsers, function(memo, parser) {
          var result3 = memo.result;
          var hasCut = memo.hasCut;
          if (!result3.isSuccess()) {
            return { result: result3, hasCut };
          }
          var subResult = parser(result3.remaining());
          if (subResult.isCut()) {
            return { result: result3, hasCut: true };
          } else if (subResult.isSuccess()) {
            var values2;
            if (parser.isCaptured) {
              values2 = result3.value().withValue(parser, subResult.value());
            } else {
              values2 = result3.value();
            }
            var remaining = subResult.remaining();
            var source2 = input.to(remaining);
            return {
              result: results.success(values2, remaining, source2),
              hasCut
            };
          } else if (hasCut) {
            return { result: results.error(subResult.errors(), subResult.remaining()), hasCut };
          } else {
            return { result: subResult, hasCut };
          }
        }, { result: results.success(new SequenceValues(), input), hasCut: false }).result;
        var source = input.to(result2.remaining());
        return result2.map(function(values2) {
          return values2.withValue(exports2.sequence.source, source);
        });
      };
      rule.head = function() {
        var firstCapture = _3.find(parsers, isCapturedRule);
        return exports2.then(
          rule,
          exports2.sequence.extract(firstCapture)
        );
      };
      rule.map = function(func) {
        return exports2.then(
          rule,
          function(result2) {
            return func.apply(this, result2.toArray());
          }
        );
      };
      function isCapturedRule(subRule) {
        return subRule.isCaptured;
      }
      return rule;
    };
    var SequenceValues = function(values2, valuesArray) {
      this._values = values2 || {};
      this._valuesArray = valuesArray || [];
    };
    SequenceValues.prototype.withValue = function(rule, value) {
      if (rule.captureName && rule.captureName in this._values) {
        throw new Error('Cannot add second value for capture "' + rule.captureName + '"');
      } else {
        var newValues = _3.clone(this._values);
        newValues[rule.captureName] = value;
        var newValuesArray = this._valuesArray.concat([value]);
        return new SequenceValues(newValues, newValuesArray);
      }
    };
    SequenceValues.prototype.get = function(rule) {
      if (rule.captureName in this._values) {
        return this._values[rule.captureName];
      } else {
        throw new Error('No value for capture "' + rule.captureName + '"');
      }
    };
    SequenceValues.prototype.toArray = function() {
      return this._valuesArray;
    };
    exports2.sequence.capture = function(rule, name) {
      var captureRule = function() {
        return rule.apply(this, arguments);
      };
      captureRule.captureName = name;
      captureRule.isCaptured = true;
      return captureRule;
    };
    exports2.sequence.extract = function(rule) {
      return function(result2) {
        return result2.get(rule);
      };
    };
    exports2.sequence.applyValues = function(func) {
      var rules = Array.prototype.slice.call(arguments, 1);
      return function(result2) {
        var values2 = rules.map(function(rule) {
          return result2.get(rule);
        });
        return func.apply(this, values2);
      };
    };
    exports2.sequence.source = {
      captureName: "\u2603source\u2603"
    };
    exports2.sequence.cut = function() {
      return function(input) {
        return results.cut(input);
      };
    };
    exports2.optional = function(rule) {
      return function(input) {
        var result2 = rule(input);
        if (result2.isSuccess()) {
          return result2.map(options.some);
        } else if (result2.isFailure()) {
          return results.success(options.none, input);
        } else {
          return result2;
        }
      };
    };
    exports2.zeroOrMoreWithSeparator = function(rule, separator) {
      return repeatedWithSeparator(rule, separator, false);
    };
    exports2.oneOrMoreWithSeparator = function(rule, separator) {
      return repeatedWithSeparator(rule, separator, true);
    };
    var zeroOrMore = exports2.zeroOrMore = function(rule) {
      return function(input) {
        var values2 = [];
        var result2;
        while ((result2 = rule(input)) && result2.isSuccess()) {
          input = result2.remaining();
          values2.push(result2.value());
        }
        if (result2.isError()) {
          return result2;
        } else {
          return results.success(values2, input);
        }
      };
    };
    exports2.oneOrMore = function(rule) {
      return exports2.oneOrMoreWithSeparator(rule, noOpRule);
    };
    function noOpRule(input) {
      return results.success(null, input);
    }
    var repeatedWithSeparator = function(rule, separator, isOneOrMore) {
      return function(input) {
        var result2 = rule(input);
        if (result2.isSuccess()) {
          var mainRule = exports2.sequence.capture(rule, "main");
          var remainingRule = zeroOrMore(exports2.then(
            exports2.sequence(separator, mainRule),
            exports2.sequence.extract(mainRule)
          ));
          var remainingResult = remainingRule(result2.remaining());
          return results.success([result2.value()].concat(remainingResult.value()), remainingResult.remaining());
        } else if (isOneOrMore || result2.isError()) {
          return result2;
        } else {
          return results.success([], input);
        }
      };
    };
    exports2.leftAssociative = function(leftRule, rightRule, func) {
      var rights;
      if (func) {
        rights = [{ func, rule: rightRule }];
      } else {
        rights = rightRule;
      }
      rights = rights.map(function(right) {
        return exports2.then(right.rule, function(rightValue) {
          return function(leftValue, source) {
            return right.func(leftValue, rightValue, source);
          };
        });
      });
      var repeatedRule = exports2.firstOf.apply(null, ["rules"].concat(rights));
      return function(input) {
        var start = input;
        var leftResult = leftRule(input);
        if (!leftResult.isSuccess()) {
          return leftResult;
        }
        var repeatedResult = repeatedRule(leftResult.remaining());
        while (repeatedResult.isSuccess()) {
          var remaining = repeatedResult.remaining();
          var source = start.to(repeatedResult.remaining());
          var right = repeatedResult.value();
          leftResult = results.success(
            right(leftResult.value(), source),
            remaining,
            source
          );
          repeatedResult = repeatedRule(leftResult.remaining());
        }
        if (repeatedResult.isError()) {
          return repeatedResult;
        }
        return leftResult;
      };
    };
    exports2.leftAssociative.firstOf = function() {
      return Array.prototype.slice.call(arguments, 0);
    };
    exports2.nonConsuming = function(rule) {
      return function(input) {
        return rule(input).changeRemaining(input);
      };
    };
    var describeToken = function(token) {
      if (token.value) {
        return token.name + ' "' + token.value + '"';
      } else {
        return token.name;
      }
    };
    function describeTokenMismatch(input, expected) {
      var error;
      var token = input.head();
      if (token) {
        error = errors.error({
          expected,
          actual: describeToken(token),
          location: token.source
        });
      } else {
        error = errors.error({
          expected,
          actual: "end of tokens"
        });
      }
      return results.failure([error], input);
    }
  }
});

// node_modules/lop/lib/StringSource.js
var require_StringSource = __commonJS({
  "node_modules/lop/lib/StringSource.js"(exports2, module2) {
    var StringSource = module2.exports = function(string, description) {
      var self2 = {
        asString: function() {
          return string;
        },
        range: function(startIndex, endIndex) {
          return new StringSourceRange(string, description, startIndex, endIndex);
        }
      };
      return self2;
    };
    var StringSourceRange = function(string, description, startIndex, endIndex) {
      this._string = string;
      this._description = description;
      this._startIndex = startIndex;
      this._endIndex = endIndex;
    };
    StringSourceRange.prototype.to = function(otherRange) {
      return new StringSourceRange(this._string, this._description, this._startIndex, otherRange._endIndex);
    };
    StringSourceRange.prototype.describe = function() {
      var position = this._position();
      var description = this._description ? this._description + "\n" : "";
      return description + "Line number: " + position.lineNumber + "\nCharacter number: " + position.characterNumber;
    };
    StringSourceRange.prototype.lineNumber = function() {
      return this._position().lineNumber;
    };
    StringSourceRange.prototype.characterNumber = function() {
      return this._position().characterNumber;
    };
    StringSourceRange.prototype._position = function() {
      var self2 = this;
      var index = 0;
      var nextNewLine = function() {
        return self2._string.indexOf("\n", index);
      };
      var lineNumber = 1;
      while (nextNewLine() !== -1 && nextNewLine() < this._startIndex) {
        index = nextNewLine() + 1;
        lineNumber += 1;
      }
      var characterNumber = this._startIndex - index + 1;
      return { lineNumber, characterNumber };
    };
  }
});

// node_modules/lop/lib/Token.js
var require_Token = __commonJS({
  "node_modules/lop/lib/Token.js"(exports2, module2) {
    module2.exports = function(name, value, source) {
      this.name = name;
      this.value = value;
      if (source) {
        this.source = source;
      }
    };
  }
});

// node_modules/lop/lib/bottom-up.js
var require_bottom_up = __commonJS({
  "node_modules/lop/lib/bottom-up.js"(exports2) {
    var rules = require_rules();
    var results = require_parsing_results();
    exports2.parser = function(name, prefixRules, infixRuleBuilders) {
      var self2 = {
        rule,
        leftAssociative,
        rightAssociative
      };
      var infixRules = new InfixRules(infixRuleBuilders.map(createInfixRule));
      var prefixRule = rules.firstOf(name, prefixRules);
      function createInfixRule(infixRuleBuilder) {
        return {
          name: infixRuleBuilder.name,
          rule: lazyRule(infixRuleBuilder.ruleBuilder.bind(null, self2))
        };
      }
      function rule() {
        return createRule(infixRules);
      }
      function leftAssociative(name2) {
        return createRule(infixRules.untilExclusive(name2));
      }
      function rightAssociative(name2) {
        return createRule(infixRules.untilInclusive(name2));
      }
      function createRule(infixRules2) {
        return apply.bind(null, infixRules2);
      }
      function apply(infixRules2, tokens) {
        var leftResult = prefixRule(tokens);
        if (leftResult.isSuccess()) {
          return infixRules2.apply(leftResult);
        } else {
          return leftResult;
        }
      }
      return self2;
    };
    function InfixRules(infixRules) {
      function untilExclusive(name) {
        return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name)));
      }
      function untilInclusive(name) {
        return new InfixRules(infixRules.slice(0, ruleNames().indexOf(name) + 1));
      }
      function ruleNames() {
        return infixRules.map(function(rule) {
          return rule.name;
        });
      }
      function apply(leftResult) {
        var currentResult;
        var source;
        while (true) {
          currentResult = applyToTokens(leftResult.remaining());
          if (currentResult.isSuccess()) {
            source = leftResult.source().to(currentResult.source());
            leftResult = results.success(
              currentResult.value()(leftResult.value(), source),
              currentResult.remaining(),
              source
            );
          } else if (currentResult.isFailure()) {
            return leftResult;
          } else {
            return currentResult;
          }
        }
      }
      function applyToTokens(tokens) {
        return rules.firstOf("infix", infixRules.map(function(infix) {
          return infix.rule;
        }))(tokens);
      }
      return {
        apply,
        untilExclusive,
        untilInclusive
      };
    }
    exports2.infix = function(name, ruleBuilder) {
      function map2(func) {
        return exports2.infix(name, function(parser) {
          var rule = ruleBuilder(parser);
          return function(tokens) {
            var result2 = rule(tokens);
            return result2.map(function(right) {
              return function(left, source) {
                return func(left, right, source);
              };
            });
          };
        });
      }
      return {
        name,
        ruleBuilder,
        map: map2
      };
    };
    var lazyRule = function(ruleBuilder) {
      var rule;
      return function(input) {
        if (!rule) {
          rule = ruleBuilder();
        }
        return rule(input);
      };
    };
  }
});

// node_modules/lop/lib/regex-tokeniser.js
var require_regex_tokeniser = __commonJS({
  "node_modules/lop/lib/regex-tokeniser.js"(exports2) {
    var Token = require_Token();
    var StringSource = require_StringSource();
    exports2.RegexTokeniser = RegexTokeniser;
    function RegexTokeniser(rules) {
      rules = rules.map(function(rule) {
        return {
          name: rule.name,
          regex: new RegExp(rule.regex.source, "g")
        };
      });
      function tokenise(input, description) {
        var source = new StringSource(input, description);
        var index = 0;
        var tokens = [];
        while (index < input.length) {
          var result2 = readNextToken(input, index, source);
          index = result2.endIndex;
          tokens.push(result2.token);
        }
        tokens.push(endToken(input, source));
        return tokens;
      }
      function readNextToken(string, startIndex, source) {
        for (var i = 0; i < rules.length; i++) {
          var regex = rules[i].regex;
          regex.lastIndex = startIndex;
          var result2 = regex.exec(string);
          if (result2) {
            var endIndex = startIndex + result2[0].length;
            if (result2.index === startIndex && endIndex > startIndex) {
              var value = result2[1];
              var token = new Token(
                rules[i].name,
                value,
                source.range(startIndex, endIndex)
              );
              return { token, endIndex };
            }
          }
        }
        var endIndex = startIndex + 1;
        var token = new Token(
          "unrecognisedCharacter",
          string.substring(startIndex, endIndex),
          source.range(startIndex, endIndex)
        );
        return { token, endIndex };
      }
      function endToken(input, source) {
        return new Token(
          "end",
          null,
          source.range(input.length, input.length)
        );
      }
      return {
        tokenise
      };
    }
  }
});

// node_modules/lop/index.js
var require_lop = __commonJS({
  "node_modules/lop/index.js"(exports2) {
    exports2.Parser = require_parser().Parser;
    exports2.rules = require_rules();
    exports2.errors = require_errors2();
    exports2.results = require_parsing_results();
    exports2.StringSource = require_StringSource();
    exports2.Token = require_Token();
    exports2.bottomUp = require_bottom_up();
    exports2.RegexTokeniser = require_regex_tokeniser().RegexTokeniser;
    exports2.rule = function(ruleBuilder) {
      var rule;
      return function(input) {
        if (!rule) {
          rule = ruleBuilder();
        }
        return rule(input);
      };
    };
  }
});

// node_modules/mammoth/lib/styles/document-matchers.js
var require_document_matchers = __commonJS({
  "node_modules/mammoth/lib/styles/document-matchers.js"(exports2) {
    exports2.paragraph = paragraph;
    exports2.run = run;
    exports2.table = table;
    exports2.bold = new Matcher("bold");
    exports2.italic = new Matcher("italic");
    exports2.underline = new Matcher("underline");
    exports2.strikethrough = new Matcher("strikethrough");
    exports2.allCaps = new Matcher("allCaps");
    exports2.smallCaps = new Matcher("smallCaps");
    exports2.highlight = highlight;
    exports2.commentReference = new Matcher("commentReference");
    exports2.lineBreak = new BreakMatcher({ breakType: "line" });
    exports2.pageBreak = new BreakMatcher({ breakType: "page" });
    exports2.columnBreak = new BreakMatcher({ breakType: "column" });
    exports2.equalTo = equalTo;
    exports2.startsWith = startsWith;
    function paragraph(options) {
      return new Matcher("paragraph", options);
    }
    function run(options) {
      return new Matcher("run", options);
    }
    function table(options) {
      return new Matcher("table", options);
    }
    function highlight(options) {
      return new HighlightMatcher(options);
    }
    function Matcher(elementType, options) {
      options = options || {};
      this._elementType = elementType;
      this._styleId = options.styleId;
      this._styleName = options.styleName;
      if (options.list) {
        this._listIndex = options.list.levelIndex;
        this._listIsOrdered = options.list.isOrdered;
      }
    }
    Matcher.prototype.matches = function(element) {
      return element.type === this._elementType && (this._styleId === void 0 || element.styleId === this._styleId) && (this._styleName === void 0 || element.styleName && this._styleName.operator(this._styleName.operand, element.styleName)) && (this._listIndex === void 0 || isList(element, this._listIndex, this._listIsOrdered)) && (this._breakType === void 0 || this._breakType === element.breakType);
    };
    function HighlightMatcher(options) {
      options = options || {};
      this._color = options.color;
    }
    HighlightMatcher.prototype.matches = function(element) {
      return element.type === "highlight" && (this._color === void 0 || element.color === this._color);
    };
    function BreakMatcher(options) {
      options = options || {};
      this._breakType = options.breakType;
    }
    BreakMatcher.prototype.matches = function(element) {
      return element.type === "break" && (this._breakType === void 0 || element.breakType === this._breakType);
    };
    function isList(element, levelIndex, isOrdered) {
      return element.numbering && element.numbering.level == levelIndex && element.numbering.isOrdered == isOrdered;
    }
    function equalTo(value) {
      return {
        operator: operatorEqualTo,
        operand: value
      };
    }
    function startsWith(value) {
      return {
        operator: operatorStartsWith,
        operand: value
      };
    }
    function operatorEqualTo(first2, second) {
      return first2.toUpperCase() === second.toUpperCase();
    }
    function operatorStartsWith(first2, second) {
      return second.toUpperCase().indexOf(first2.toUpperCase()) === 0;
    }
  }
});

// node_modules/mammoth/lib/styles/parser/tokeniser.js
var require_tokeniser = __commonJS({
  "node_modules/mammoth/lib/styles/parser/tokeniser.js"(exports2) {
    var lop = require_lop();
    var RegexTokeniser = lop.RegexTokeniser;
    exports2.tokenise = tokenise;
    var stringPrefix = "'((?:\\\\.|[^'])*)";
    function tokenise(string) {
      var identifierCharacter = "(?:[a-zA-Z\\-_]|\\\\.)";
      var tokeniser = new RegexTokeniser([
        { name: "identifier", regex: new RegExp("(" + identifierCharacter + "(?:" + identifierCharacter + "|[0-9])*)") },
        { name: "dot", regex: /\./ },
        { name: "colon", regex: /:/ },
        { name: "gt", regex: />/ },
        { name: "whitespace", regex: /\s+/ },
        { name: "arrow", regex: /=>/ },
        { name: "equals", regex: /=/ },
        { name: "startsWith", regex: /\^=/ },
        { name: "open-paren", regex: /\(/ },
        { name: "close-paren", regex: /\)/ },
        { name: "open-square-bracket", regex: /\[/ },
        { name: "close-square-bracket", regex: /\]/ },
        { name: "string", regex: new RegExp(stringPrefix + "'") },
        { name: "unterminated-string", regex: new RegExp(stringPrefix) },
        { name: "integer", regex: /([0-9]+)/ },
        { name: "choice", regex: /\|/ },
        { name: "bang", regex: /(!)/ }
      ]);
      return tokeniser.tokenise(string);
    }
  }
});

// node_modules/mammoth/lib/style-reader.js
var require_style_reader = __commonJS({
  "node_modules/mammoth/lib/style-reader.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var lop = require_lop();
    var documentMatchers = require_document_matchers();
    var htmlPaths = require_html_paths();
    var tokenise = require_tokeniser().tokenise;
    var results = require_results();
    exports2.readHtmlPath = readHtmlPath;
    exports2.readDocumentMatcher = readDocumentMatcher;
    exports2.readStyle = readStyle;
    function readStyle(string) {
      return parseString(styleRule, string);
    }
    function createStyleRule() {
      return lop.rules.sequence(
        lop.rules.sequence.capture(documentMatcherRule()),
        lop.rules.tokenOfType("whitespace"),
        lop.rules.tokenOfType("arrow"),
        lop.rules.sequence.capture(lop.rules.optional(lop.rules.sequence(
          lop.rules.tokenOfType("whitespace"),
          lop.rules.sequence.capture(htmlPathRule())
        ).head())),
        lop.rules.tokenOfType("end")
      ).map(function(documentMatcher, htmlPath) {
        return {
          from: documentMatcher,
          to: htmlPath.valueOrElse(htmlPaths.empty)
        };
      });
    }
    function readDocumentMatcher(string) {
      return parseString(documentMatcherRule(), string);
    }
    function documentMatcherRule() {
      var sequence = lop.rules.sequence;
      var identifierToConstant = function(identifier, constant2) {
        return lop.rules.then(
          lop.rules.token("identifier", identifier),
          function() {
            return constant2;
          }
        );
      };
      var paragraphRule = identifierToConstant("p", documentMatchers.paragraph);
      var runRule = identifierToConstant("r", documentMatchers.run);
      var elementTypeRule = lop.rules.firstOf(
        "p or r or table",
        paragraphRule,
        runRule
      );
      var styleIdRule = lop.rules.sequence(
        lop.rules.tokenOfType("dot"),
        lop.rules.sequence.cut(),
        lop.rules.sequence.capture(identifierRule)
      ).map(function(styleId) {
        return { styleId };
      });
      var styleNameMatcherRule = lop.rules.firstOf(
        "style name matcher",
        lop.rules.then(
          lop.rules.sequence(
            lop.rules.tokenOfType("equals"),
            lop.rules.sequence.cut(),
            lop.rules.sequence.capture(stringRule)
          ).head(),
          function(styleName) {
            return { styleName: documentMatchers.equalTo(styleName) };
          }
        ),
        lop.rules.then(
          lop.rules.sequence(
            lop.rules.tokenOfType("startsWith"),
            lop.rules.sequence.cut(),
            lop.rules.sequence.capture(stringRule)
          ).head(),
          function(styleName) {
            return { styleName: documentMatchers.startsWith(styleName) };
          }
        )
      );
      var styleNameRule = lop.rules.sequence(
        lop.rules.tokenOfType("open-square-bracket"),
        lop.rules.sequence.cut(),
        lop.rules.token("identifier", "style-name"),
        lop.rules.sequence.capture(styleNameMatcherRule),
        lop.rules.tokenOfType("close-square-bracket")
      ).head();
      var listTypeRule = lop.rules.firstOf(
        "list type",
        identifierToConstant("ordered-list", { isOrdered: true }),
        identifierToConstant("unordered-list", { isOrdered: false })
      );
      var listRule = sequence(
        lop.rules.tokenOfType("colon"),
        sequence.capture(listTypeRule),
        sequence.cut(),
        lop.rules.tokenOfType("open-paren"),
        sequence.capture(integerRule),
        lop.rules.tokenOfType("close-paren")
      ).map(function(listType, levelNumber) {
        return {
          list: {
            isOrdered: listType.isOrdered,
            levelIndex: levelNumber - 1
          }
        };
      });
      function createMatcherSuffixesRule(rules) {
        var matcherSuffix = lop.rules.firstOf.apply(
          lop.rules.firstOf,
          ["matcher suffix"].concat(rules)
        );
        var matcherSuffixes = lop.rules.zeroOrMore(matcherSuffix);
        return lop.rules.then(matcherSuffixes, function(suffixes) {
          var matcherOptions = {};
          suffixes.forEach(function(suffix) {
            _3.extend(matcherOptions, suffix);
          });
          return matcherOptions;
        });
      }
      var paragraphOrRun = sequence(
        sequence.capture(elementTypeRule),
        sequence.capture(createMatcherSuffixesRule([
          styleIdRule,
          styleNameRule,
          listRule
        ]))
      ).map(function(createMatcher, matcherOptions) {
        return createMatcher(matcherOptions);
      });
      var table = sequence(
        lop.rules.token("identifier", "table"),
        sequence.capture(createMatcherSuffixesRule([
          styleIdRule,
          styleNameRule
        ]))
      ).map(function(options) {
        return documentMatchers.table(options);
      });
      var bold = identifierToConstant("b", documentMatchers.bold);
      var italic = identifierToConstant("i", documentMatchers.italic);
      var underline = identifierToConstant("u", documentMatchers.underline);
      var strikethrough = identifierToConstant("strike", documentMatchers.strikethrough);
      var allCaps = identifierToConstant("all-caps", documentMatchers.allCaps);
      var smallCaps = identifierToConstant("small-caps", documentMatchers.smallCaps);
      var highlight = sequence(
        lop.rules.token("identifier", "highlight"),
        lop.rules.sequence.capture(lop.rules.optional(lop.rules.sequence(
          lop.rules.tokenOfType("open-square-bracket"),
          lop.rules.sequence.cut(),
          lop.rules.token("identifier", "color"),
          lop.rules.tokenOfType("equals"),
          lop.rules.sequence.capture(stringRule),
          lop.rules.tokenOfType("close-square-bracket")
        ).head()))
      ).map(function(color) {
        return documentMatchers.highlight({
          color: color.valueOrElse(void 0)
        });
      });
      var commentReference = identifierToConstant("comment-reference", documentMatchers.commentReference);
      var breakMatcher = sequence(
        lop.rules.token("identifier", "br"),
        sequence.cut(),
        lop.rules.tokenOfType("open-square-bracket"),
        lop.rules.token("identifier", "type"),
        lop.rules.tokenOfType("equals"),
        sequence.capture(stringRule),
        lop.rules.tokenOfType("close-square-bracket")
      ).map(function(breakType) {
        switch (breakType) {
          case "line":
            return documentMatchers.lineBreak;
          case "page":
            return documentMatchers.pageBreak;
          case "column":
            return documentMatchers.columnBreak;
          default:
        }
      });
      return lop.rules.firstOf(
        "element type",
        paragraphOrRun,
        table,
        bold,
        italic,
        underline,
        strikethrough,
        allCaps,
        smallCaps,
        highlight,
        commentReference,
        breakMatcher
      );
    }
    function readHtmlPath(string) {
      return parseString(htmlPathRule(), string);
    }
    function htmlPathRule() {
      var capture = lop.rules.sequence.capture;
      var whitespaceRule = lop.rules.tokenOfType("whitespace");
      var freshRule = lop.rules.then(
        lop.rules.optional(lop.rules.sequence(
          lop.rules.tokenOfType("colon"),
          lop.rules.token("identifier", "fresh")
        )),
        function(option) {
          return option.map(function() {
            return true;
          }).valueOrElse(false);
        }
      );
      var separatorRule = lop.rules.then(
        lop.rules.optional(lop.rules.sequence(
          lop.rules.tokenOfType("colon"),
          lop.rules.token("identifier", "separator"),
          lop.rules.tokenOfType("open-paren"),
          capture(stringRule),
          lop.rules.tokenOfType("close-paren")
        ).head()),
        function(option) {
          return option.valueOrElse("");
        }
      );
      var tagNamesRule = lop.rules.oneOrMoreWithSeparator(
        identifierRule,
        lop.rules.tokenOfType("choice")
      );
      var styleElementRule = lop.rules.sequence(
        capture(tagNamesRule),
        capture(lop.rules.zeroOrMore(attributeOrClassRule)),
        capture(freshRule),
        capture(separatorRule)
      ).map(function(tagName, attributesList, fresh, separator) {
        var attributes = {};
        var options = {};
        attributesList.forEach(function(attribute) {
          if (attribute.append && attributes[attribute.name]) {
            attributes[attribute.name] += " " + attribute.value;
          } else {
            attributes[attribute.name] = attribute.value;
          }
        });
        if (fresh) {
          options.fresh = true;
        }
        if (separator) {
          options.separator = separator;
        }
        return htmlPaths.element(tagName, attributes, options);
      });
      return lop.rules.firstOf(
        "html path",
        lop.rules.then(lop.rules.tokenOfType("bang"), function() {
          return htmlPaths.ignore;
        }),
        lop.rules.then(
          lop.rules.zeroOrMoreWithSeparator(
            styleElementRule,
            lop.rules.sequence(
              whitespaceRule,
              lop.rules.tokenOfType("gt"),
              whitespaceRule
            )
          ),
          htmlPaths.elements
        )
      );
    }
    var identifierRule = lop.rules.then(
      lop.rules.tokenOfType("identifier"),
      decodeEscapeSequences
    );
    var integerRule = lop.rules.tokenOfType("integer");
    var stringRule = lop.rules.then(
      lop.rules.tokenOfType("string"),
      decodeEscapeSequences
    );
    var escapeSequences = {
      "n": "\n",
      "r": "\r",
      "t": "	"
    };
    function decodeEscapeSequences(value) {
      return value.replace(/\\(.)/g, function(match, code) {
        return escapeSequences[code] || code;
      });
    }
    var attributeRule = lop.rules.sequence(
      lop.rules.tokenOfType("open-square-bracket"),
      lop.rules.sequence.cut(),
      lop.rules.sequence.capture(identifierRule),
      lop.rules.tokenOfType("equals"),
      lop.rules.sequence.capture(stringRule),
      lop.rules.tokenOfType("close-square-bracket")
    ).map(function(name, value) {
      return { name, value, append: false };
    });
    var classRule = lop.rules.sequence(
      lop.rules.tokenOfType("dot"),
      lop.rules.sequence.cut(),
      lop.rules.sequence.capture(identifierRule)
    ).map(function(className) {
      return { name: "class", value: className, append: true };
    });
    var attributeOrClassRule = lop.rules.firstOf(
      "attribute or class",
      attributeRule,
      classRule
    );
    function parseString(rule, string) {
      var tokens = tokenise(string);
      var parser = lop.Parser();
      var parseResult = parser.parseTokens(rule, tokens);
      if (parseResult.isSuccess()) {
        return results.success(parseResult.value());
      } else {
        return new results.Result(null, [results.warning(describeFailure(string, parseResult))]);
      }
    }
    function describeFailure(input, parseResult) {
      return "Did not understand this style mapping, so ignored it: " + input + "\n" + parseResult.errors().map(describeError).join("\n");
    }
    function describeError(error) {
      return "Error was at character number " + error.characterNumber() + ": Expected " + error.expected + " but got " + error.actual;
    }
    var styleRule = createStyleRule();
  }
});

// node_modules/mammoth/lib/options-reader.js
var require_options_reader = __commonJS({
  "node_modules/mammoth/lib/options-reader.js"(exports2) {
    exports2.readOptions = readOptions;
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var defaultStyleMap = exports2._defaultStyleMap = [
      "p.Heading1 => h1:fresh",
      "p.Heading2 => h2:fresh",
      "p.Heading3 => h3:fresh",
      "p.Heading4 => h4:fresh",
      "p.Heading5 => h5:fresh",
      "p.Heading6 => h6:fresh",
      "p[style-name='Heading 1'] => h1:fresh",
      "p[style-name='Heading 2'] => h2:fresh",
      "p[style-name='Heading 3'] => h3:fresh",
      "p[style-name='Heading 4'] => h4:fresh",
      "p[style-name='Heading 5'] => h5:fresh",
      "p[style-name='Heading 6'] => h6:fresh",
      "p[style-name='heading 1'] => h1:fresh",
      "p[style-name='heading 2'] => h2:fresh",
      "p[style-name='heading 3'] => h3:fresh",
      "p[style-name='heading 4'] => h4:fresh",
      "p[style-name='heading 5'] => h5:fresh",
      "p[style-name='heading 6'] => h6:fresh",
      // Apple Pages
      "p.Heading => h1:fresh",
      "p[style-name='Heading'] => h1:fresh",
      "r[style-name='Strong'] => strong",
      "p[style-name='footnote text'] => p:fresh",
      "r[style-name='footnote reference'] =>",
      "p[style-name='endnote text'] => p:fresh",
      "r[style-name='endnote reference'] =>",
      "p[style-name='annotation text'] => p:fresh",
      "r[style-name='annotation reference'] =>",
      // LibreOffice
      "p[style-name='Footnote'] => p:fresh",
      "r[style-name='Footnote anchor'] =>",
      "p[style-name='Endnote'] => p:fresh",
      "r[style-name='Endnote anchor'] =>",
      "p:unordered-list(1) => ul > li:fresh",
      "p:unordered-list(2) => ul|ol > li > ul > li:fresh",
      "p:unordered-list(3) => ul|ol > li > ul|ol > li > ul > li:fresh",
      "p:unordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
      "p:unordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ul > li:fresh",
      "p:ordered-list(1) => ol > li:fresh",
      "p:ordered-list(2) => ul|ol > li > ol > li:fresh",
      "p:ordered-list(3) => ul|ol > li > ul|ol > li > ol > li:fresh",
      "p:ordered-list(4) => ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
      "p:ordered-list(5) => ul|ol > li > ul|ol > li > ul|ol > li > ul|ol > li > ol > li:fresh",
      "r[style-name='Hyperlink'] =>",
      "p[style-name='Normal'] => p:fresh",
      // Apple Pages
      "p.Body => p:fresh",
      "p[style-name='Body'] => p:fresh"
    ];
    var standardOptions = exports2._standardOptions = {
      externalFileAccess: false,
      transformDocument: identity2,
      includeDefaultStyleMap: true,
      includeEmbeddedStyleMap: true
    };
    function readOptions(options) {
      options = options || {};
      return _3.extend({}, standardOptions, options, {
        customStyleMap: readStyleMap(options.styleMap),
        readStyleMap: function() {
          var styleMap = this.customStyleMap;
          if (this.includeEmbeddedStyleMap) {
            styleMap = styleMap.concat(readStyleMap(this.embeddedStyleMap));
          }
          if (this.includeDefaultStyleMap) {
            styleMap = styleMap.concat(defaultStyleMap);
          }
          return styleMap;
        }
      });
    }
    function readStyleMap(styleMap) {
      if (!styleMap) {
        return [];
      } else if (_3.isString(styleMap)) {
        return styleMap.split("\n").map(function(line) {
          return line.trim();
        }).filter(function(line) {
          return line !== "" && line.charAt(0) !== "#";
        });
      } else {
        return styleMap;
      }
    }
    function identity2(value) {
      return value;
    }
  }
});

// node_modules/mammoth/lib/unzip.js
var require_unzip = __commonJS({
  "node_modules/mammoth/lib/unzip.js"(exports2) {
    var fs2 = __require("fs");
    var promises = require_promises();
    var zipfile = require_zipfile();
    exports2.openZip = openZip;
    var readFile = promises.promisify(fs2.readFile);
    function openZip(options) {
      if (options.path) {
        return readFile(options.path).then(zipfile.openArrayBuffer);
      } else if (options.buffer) {
        return promises.resolve(zipfile.openArrayBuffer(options.buffer));
      } else if (options.file) {
        return promises.resolve(options.file);
      } else {
        return promises.reject(new Error("Could not find file in options"));
      }
    }
  }
});

// node_modules/mammoth/lib/underline.js
var require_underline = __commonJS({
  "node_modules/mammoth/lib/underline.js"(exports2) {
    var htmlPaths = require_html_paths();
    var Html = require_html();
    exports2.element = element;
    function element(name) {
      return function(html) {
        return Html.elementWithTag(htmlPaths.element(name), [html]);
      };
    }
  }
});

// node_modules/mammoth/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/mammoth/lib/index.js"(exports2) {
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var docxReader = require_docx_reader();
    var docxStyleMap = require_style_map();
    var DocumentConverter = require_document_to_html().DocumentConverter;
    var convertElementToRawText = require_raw_text().convertElementToRawText;
    var readStyle = require_style_reader().readStyle;
    var readOptions = require_options_reader().readOptions;
    var unzip2 = require_unzip();
    var Result = require_results().Result;
    exports2.convertToHtml = convertToHtml;
    exports2.convertToMarkdown = convertToMarkdown;
    exports2.convert = convert;
    exports2.extractRawText = extractRawText;
    exports2.images = require_images();
    exports2.transforms = require_transforms();
    exports2.underline = require_underline();
    exports2.embedStyleMap = embedStyleMap;
    exports2.readEmbeddedStyleMap = readEmbeddedStyleMap;
    function convertToHtml(input, options) {
      return convert(input, options);
    }
    function convertToMarkdown(input, options) {
      var markdownOptions = Object.create(options || {});
      markdownOptions.outputFormat = "markdown";
      return convert(input, markdownOptions);
    }
    function convert(input, options) {
      options = readOptions(options);
      return unzip2.openZip(input).tap(function(docxFile) {
        return docxStyleMap.readStyleMap(docxFile).then(function(styleMap) {
          options.embeddedStyleMap = styleMap;
        });
      }).then(function(docxFile) {
        return docxReader.read(docxFile, input, options).then(function(documentResult) {
          return documentResult.map(options.transformDocument);
        }).then(function(documentResult) {
          return convertDocumentToHtml(documentResult, options);
        });
      });
    }
    function readEmbeddedStyleMap(input) {
      return unzip2.openZip(input).then(docxStyleMap.readStyleMap);
    }
    function convertDocumentToHtml(documentResult, options) {
      var styleMapResult = parseStyleMap(options.readStyleMap());
      var parsedOptions = _3.extend({}, options, {
        styleMap: styleMapResult.value
      });
      var documentConverter = new DocumentConverter(parsedOptions);
      return documentResult.flatMapThen(function(document2) {
        return styleMapResult.flatMapThen(function(styleMap) {
          return documentConverter.convertToHtml(document2);
        });
      });
    }
    function parseStyleMap(styleMap) {
      return Result.combine((styleMap || []).map(readStyle)).map(function(styleMap2) {
        return styleMap2.filter(function(styleMapping) {
          return !!styleMapping;
        });
      });
    }
    function extractRawText(input) {
      return unzip2.openZip(input).then(docxReader.read).then(function(documentResult) {
        return documentResult.map(convertElementToRawText);
      });
    }
    function embedStyleMap(input, styleMap) {
      return unzip2.openZip(input).tap(function(docxFile) {
        return docxStyleMap.writeStyleMap(docxFile, styleMap);
      }).then(function(docxFile) {
        return docxFile.toArrayBuffer();
      }).then(function(arrayBuffer) {
        return {
          toArrayBuffer: function() {
            return arrayBuffer;
          },
          toBuffer: function() {
            return Buffer.from(arrayBuffer);
          }
        };
      });
    }
    exports2.styleMapping = function() {
      throw new Error(`Use a raw string instead of mammoth.styleMapping e.g. "p[style-name='Title'] => h1" instead of mammoth.styleMapping("p[style-name='Title'] => h1")`);
    };
  }
});

// node_modules/pdfjs-dist/legacy/build/pdf.mjs
var pdf_exports = {};
__export(pdf_exports, {
  AbortException: () => AbortException,
  AnnotationEditorLayer: () => AnnotationEditorLayer,
  AnnotationEditorParamsType: () => AnnotationEditorParamsType,
  AnnotationEditorType: () => AnnotationEditorType,
  AnnotationEditorUIManager: () => AnnotationEditorUIManager,
  AnnotationLayer: () => AnnotationLayer,
  AnnotationMode: () => AnnotationMode,
  AnnotationType: () => AnnotationType,
  CSSConstants: () => CSSConstants,
  ColorPicker: () => ColorPicker,
  DOMSVGFactory: () => DOMSVGFactory,
  DrawLayer: () => DrawLayer,
  FeatureTest: () => util_FeatureTest,
  GlobalWorkerOptions: () => GlobalWorkerOptions,
  ImageKind: () => util_ImageKind,
  InvalidPDFException: () => InvalidPDFException,
  MathClamp: () => MathClamp,
  OPS: () => OPS,
  OutputScale: () => OutputScale,
  PDFDataRangeTransport: () => PDFDataRangeTransport,
  PDFDateString: () => PDFDateString,
  PDFWorker: () => PDFWorker,
  PasswordResponses: () => PasswordResponses,
  PermissionFlag: () => PermissionFlag,
  PixelsPerInch: () => PixelsPerInch,
  RenderingCancelledException: () => RenderingCancelledException,
  ResponseException: () => ResponseException,
  SignatureExtractor: () => SignatureExtractor,
  SupportedImageMimeTypes: () => SupportedImageMimeTypes,
  TextLayer: () => TextLayer,
  TouchManager: () => TouchManager,
  Util: () => Util,
  VerbosityLevel: () => VerbosityLevel,
  XfaLayer: () => XfaLayer,
  applyOpacity: () => applyOpacity,
  build: () => build,
  createValidAbsoluteUrl: () => createValidAbsoluteUrl,
  fetchData: () => fetchData,
  findContrastColor: () => findContrastColor,
  getDocument: () => getDocument,
  getFilenameFromUrl: () => getFilenameFromUrl,
  getPdfFilenameFromUrl: () => getPdfFilenameFromUrl,
  getRGB: () => getRGB,
  getUuid: () => getUuid,
  getXfaPageViewport: () => getXfaPageViewport,
  isDataScheme: () => isDataScheme,
  isPdfFile: () => isPdfFile,
  isValidExplicitDest: () => isValidExplicitDest,
  noContextMenu: () => noContextMenu,
  normalizeUnicode: () => normalizeUnicode,
  renderRichText: () => renderRichText,
  setLayerDimensions: () => setLayerDimensions,
  shadow: () => shadow,
  stopEvent: () => stopEvent,
  updateUrlHash: () => updateUrlHash,
  version: () => version
});
function __webpack_require__(moduleId) {
  var cachedModule = __webpack_module_cache__[moduleId];
  if (cachedModule !== void 0) {
    return cachedModule.exports;
  }
  var module2 = __webpack_module_cache__[moduleId] = {
    /******/
    // no module.id needed
    /******/
    // no module.loaded needed
    /******/
    exports: {}
    /******/
  };
  __webpack_modules__[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
  return module2.exports;
}
function setVerbosityLevel(level) {
  if (Number.isInteger(level)) {
    verbosity = level;
  }
}
function getVerbosityLevel() {
  return verbosity;
}
function info(msg) {
  if (verbosity >= VerbosityLevel.INFOS) {
    console.info(`Info: ${msg}`);
  }
}
function warn(msg) {
  if (verbosity >= VerbosityLevel.WARNINGS) {
    console.warn(`Warning: ${msg}`);
  }
}
function unreachable(msg) {
  throw new Error(msg);
}
function assert(cond, msg) {
  if (!cond) {
    unreachable(msg);
  }
}
function _isValidProtocol(url) {
  switch (url?.protocol) {
    case "http:":
    case "https:":
    case "ftp:":
    case "mailto:":
    case "tel:":
      return true;
    default:
      return false;
  }
}
function createValidAbsoluteUrl(url, baseUrl = null, options = null) {
  if (!url) {
    return null;
  }
  if (options && typeof url === "string") {
    if (options.addDefaultProtocol && url.startsWith("www.")) {
      const dots = url.match(/\./g);
      if (dots?.length >= 2) {
        url = `http://${url}`;
      }
    }
    if (options.tryConvertEncoding) {
      try {
        url = stringToUTF8String(url);
      } catch {
      }
    }
  }
  const absoluteUrl = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);
  return _isValidProtocol(absoluteUrl) ? absoluteUrl : null;
}
function updateUrlHash(url, hash, allowRel = false) {
  const res = URL.parse(url);
  if (res) {
    res.hash = hash;
    return res.href;
  }
  if (allowRel && createValidAbsoluteUrl(url, "http://example.com")) {
    return url.split("#", 1)[0] + `${hash ? `#${hash}` : ""}`;
  }
  return "";
}
function shadow(obj2, prop, value, nonSerializable = false) {
  Object.defineProperty(obj2, prop, {
    value,
    enumerable: !nonSerializable,
    configurable: true,
    writable: false
  });
  return value;
}
function bytesToString(bytes) {
  if (typeof bytes !== "object" || bytes?.length === void 0) {
    unreachable("Invalid argument for bytesToString");
  }
  const length = bytes.length;
  const MAX_ARGUMENT_COUNT = 8192;
  if (length < MAX_ARGUMENT_COUNT) {
    return String.fromCharCode.apply(null, bytes);
  }
  const strBuf = [];
  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {
    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);
    const chunk2 = bytes.subarray(i, chunkEnd);
    strBuf.push(String.fromCharCode.apply(null, chunk2));
  }
  return strBuf.join("");
}
function stringToBytes(str) {
  if (typeof str !== "string") {
    unreachable("Invalid argument for stringToBytes");
  }
  const length = str.length;
  const bytes = new Uint8Array(length);
  for (let i = 0; i < length; ++i) {
    bytes[i] = str.charCodeAt(i) & 255;
  }
  return bytes;
}
function string32(value) {
  return String.fromCharCode(value >> 24 & 255, value >> 16 & 255, value >> 8 & 255, value & 255);
}
function isLittleEndian() {
  const buffer8 = new Uint8Array(4);
  buffer8[0] = 1;
  const view32 = new Uint32Array(buffer8.buffer, 0, 1);
  return view32[0] === 1;
}
function isEvalSupported() {
  try {
    new Function("");
    return true;
  } catch {
    return false;
  }
}
function stringToUTF8String(str) {
  return decodeURIComponent(escape(str));
}
function normalizeUnicode(str) {
  if (!NormalizeRegex) {
    NormalizeRegex = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu;
    NormalizationMap = /* @__PURE__ */ new Map([["\uFB05", "\u017Ft"]]);
  }
  return str.replaceAll(NormalizeRegex, (_3, p1, p2) => p1 ? p1.normalize("NFKC") : NormalizationMap.get(p2));
}
function getUuid() {
  if (typeof crypto.randomUUID === "function") {
    return crypto.randomUUID();
  }
  const buf = new Uint8Array(32);
  crypto.getRandomValues(buf);
  return bytesToString(buf);
}
function _isValidExplicitDest(validRef, validName, dest) {
  if (!Array.isArray(dest) || dest.length < 2) {
    return false;
  }
  const [page, zoom, ...args] = dest;
  if (!validRef(page) && !Number.isInteger(page)) {
    return false;
  }
  if (!validName(zoom)) {
    return false;
  }
  const argsLen = args.length;
  let allowNull = true;
  switch (zoom.name) {
    case "XYZ":
      if (argsLen < 2 || argsLen > 3) {
        return false;
      }
      break;
    case "Fit":
    case "FitB":
      return argsLen === 0;
    case "FitH":
    case "FitBH":
    case "FitV":
    case "FitBV":
      if (argsLen > 1) {
        return false;
      }
      break;
    case "FitR":
      if (argsLen !== 4) {
        return false;
      }
      allowNull = false;
      break;
    default:
      return false;
  }
  for (const arg of args) {
    if (typeof arg === "number" || allowNull && arg === null) {
      continue;
    }
    return false;
  }
  return true;
}
function MathClamp(v, min2, max2) {
  return Math.min(Math.max(v, min2), max2);
}
function toBase64Util(arr) {
  if (Uint8Array.prototype.toBase64) {
    return arr.toBase64();
  }
  return btoa(bytesToString(arr));
}
function fromBase64Util(str) {
  if (Uint8Array.fromBase64) {
    return Uint8Array.fromBase64(str);
  }
  return stringToBytes(atob(str));
}
async function fetchData(url, type = "text") {
  if (isValidFetchUrl(url, document.baseURI)) {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(response.statusText);
    }
    switch (type) {
      case "arraybuffer":
        return response.arrayBuffer();
      case "blob":
        return response.blob();
      case "json":
        return response.json();
    }
    return response.text();
  }
  return new Promise((resolve, reject2) => {
    const request = new XMLHttpRequest();
    request.open("GET", url, true);
    request.responseType = type;
    request.onreadystatechange = () => {
      if (request.readyState !== XMLHttpRequest.DONE) {
        return;
      }
      if (request.status === 200 || request.status === 0) {
        switch (type) {
          case "arraybuffer":
          case "blob":
          case "json":
            resolve(request.response);
            return;
        }
        resolve(request.responseText);
        return;
      }
      reject2(new Error(request.statusText));
    };
    request.send(null);
  });
}
function isDataScheme(url) {
  const ii = url.length;
  let i = 0;
  while (i < ii && url[i].trim() === "") {
    i++;
  }
  return url.substring(i, i + 5).toLowerCase() === "data:";
}
function isPdfFile(filename) {
  return typeof filename === "string" && /\.pdf$/i.test(filename);
}
function getFilenameFromUrl(url) {
  [url] = url.split(/[#?]/, 1);
  return url.substring(url.lastIndexOf("/") + 1);
}
function getPdfFilenameFromUrl(url, defaultFilename = "document.pdf") {
  if (typeof url !== "string") {
    return defaultFilename;
  }
  if (isDataScheme(url)) {
    warn('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.');
    return defaultFilename;
  }
  const getURL = (urlString) => {
    try {
      return new URL(urlString);
    } catch {
      try {
        return new URL(decodeURIComponent(urlString));
      } catch {
        try {
          return new URL(urlString, "https://foo.bar");
        } catch {
          try {
            return new URL(decodeURIComponent(urlString), "https://foo.bar");
          } catch {
            return null;
          }
        }
      }
    }
  };
  const newURL = getURL(url);
  if (!newURL) {
    return defaultFilename;
  }
  const decode = (name) => {
    try {
      let decoded = decodeURIComponent(name);
      if (decoded.includes("/")) {
        decoded = decoded.split("/").at(-1);
        if (decoded.test(/^\.pdf$/i)) {
          return decoded;
        }
        return name;
      }
      return decoded;
    } catch {
      return name;
    }
  };
  const pdfRegex = /\.pdf$/i;
  const filename = newURL.pathname.split("/").at(-1);
  if (pdfRegex.test(filename)) {
    return decode(filename);
  }
  if (newURL.searchParams.size > 0) {
    const values2 = Array.from(newURL.searchParams.values()).reverse();
    for (const value of values2) {
      if (pdfRegex.test(value)) {
        return decode(value);
      }
    }
    const keys2 = Array.from(newURL.searchParams.keys()).reverse();
    for (const key of keys2) {
      if (pdfRegex.test(key)) {
        return decode(key);
      }
    }
  }
  if (newURL.hash) {
    const reFilename = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i;
    const hashFilename = reFilename.exec(newURL.hash);
    if (hashFilename) {
      return decode(hashFilename[0]);
    }
  }
  return defaultFilename;
}
function isValidFetchUrl(url, baseUrl) {
  const res = baseUrl ? URL.parse(url, baseUrl) : URL.parse(url);
  return res?.protocol === "http:" || res?.protocol === "https:";
}
function noContextMenu(e) {
  e.preventDefault();
}
function stopEvent(e) {
  e.preventDefault();
  e.stopPropagation();
}
function deprecated(details) {
  console.log("Deprecated API usage: " + details);
}
function getXfaPageViewport(xfaPage, {
  scale = 1,
  rotation = 0
}) {
  const {
    width,
    height
  } = xfaPage.attributes.style;
  const viewBox = [0, 0, parseInt(width), parseInt(height)];
  return new PageViewport({
    viewBox,
    userUnit: 1,
    scale,
    rotation
  });
}
function getRGB(color) {
  if (color.startsWith("#")) {
    const colorRGB = parseInt(color.slice(1), 16);
    return [(colorRGB & 16711680) >> 16, (colorRGB & 65280) >> 8, colorRGB & 255];
  }
  if (color.startsWith("rgb(")) {
    return color.slice(4, -1).split(",").map((x) => parseInt(x));
  }
  if (color.startsWith("rgba(")) {
    return color.slice(5, -1).split(",").map((x) => parseInt(x)).slice(0, 3);
  }
  warn(`Not a valid color format: "${color}"`);
  return [0, 0, 0];
}
function getColorValues(colors) {
  const span = document.createElement("span");
  span.style.visibility = "hidden";
  span.style.colorScheme = "only light";
  document.body.append(span);
  for (const name of colors.keys()) {
    span.style.color = name;
    const computedColor = window.getComputedStyle(span).color;
    colors.set(name, getRGB(computedColor));
  }
  span.remove();
}
function getCurrentTransform(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform();
  return [a, b, c, d, e, f];
}
function getCurrentTransformInverse(ctx) {
  const {
    a,
    b,
    c,
    d,
    e,
    f
  } = ctx.getTransform().invertSelf();
  return [a, b, c, d, e, f];
}
function setLayerDimensions(div, viewport, mustFlip = false, mustRotate = true) {
  if (viewport instanceof PageViewport) {
    const {
      pageWidth,
      pageHeight
    } = viewport.rawDims;
    const {
      style
    } = div;
    const useRound = util_FeatureTest.isCSSRoundSupported;
    const w = `var(--total-scale-factor) * ${pageWidth}px`, h = `var(--total-scale-factor) * ${pageHeight}px`;
    const widthStr = useRound ? `round(down, ${w}, var(--scale-round-x))` : `calc(${w})`, heightStr = useRound ? `round(down, ${h}, var(--scale-round-y))` : `calc(${h})`;
    if (!mustFlip || viewport.rotation % 180 === 0) {
      style.width = widthStr;
      style.height = heightStr;
    } else {
      style.width = heightStr;
      style.height = widthStr;
    }
  }
  if (mustRotate) {
    div.setAttribute("data-main-rotation", viewport.rotation);
  }
}
function applyOpacity(r, g, b, opacity) {
  opacity = Math.min(Math.max(opacity ?? 1, 0), 1);
  const white = 255 * (1 - opacity);
  r = Math.round(r * opacity + white);
  g = Math.round(g * opacity + white);
  b = Math.round(b * opacity + white);
  return [r, g, b];
}
function RGBToHSL(rgb, output) {
  const r = rgb[0] / 255;
  const g = rgb[1] / 255;
  const b = rgb[2] / 255;
  const max2 = Math.max(r, g, b);
  const min2 = Math.min(r, g, b);
  const l2 = (max2 + min2) / 2;
  if (max2 === min2) {
    output[0] = output[1] = 0;
  } else {
    const d = max2 - min2;
    output[1] = l2 < 0.5 ? d / (max2 + min2) : d / (2 - max2 - min2);
    switch (max2) {
      case r:
        output[0] = ((g - b) / d + (g < b ? 6 : 0)) * 60;
        break;
      case g:
        output[0] = ((b - r) / d + 2) * 60;
        break;
      case b:
        output[0] = ((r - g) / d + 4) * 60;
        break;
    }
  }
  output[2] = l2;
}
function HSLToRGB(hsl, output) {
  const h = hsl[0];
  const s = hsl[1];
  const l2 = hsl[2];
  const c = (1 - Math.abs(2 * l2 - 1)) * s;
  const x = c * (1 - Math.abs(h / 60 % 2 - 1));
  const m = l2 - c / 2;
  switch (Math.floor(h / 60)) {
    case 0:
      output[0] = c + m;
      output[1] = x + m;
      output[2] = m;
      break;
    case 1:
      output[0] = x + m;
      output[1] = c + m;
      output[2] = m;
      break;
    case 2:
      output[0] = m;
      output[1] = c + m;
      output[2] = x + m;
      break;
    case 3:
      output[0] = m;
      output[1] = x + m;
      output[2] = c + m;
      break;
    case 4:
      output[0] = x + m;
      output[1] = m;
      output[2] = c + m;
      break;
    case 5:
    case 6:
      output[0] = c + m;
      output[1] = m;
      output[2] = x + m;
      break;
  }
}
function computeLuminance(x) {
  return x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
}
function contrastRatio(hsl1, hsl2, output) {
  HSLToRGB(hsl1, output);
  output.map(computeLuminance);
  const lum1 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];
  HSLToRGB(hsl2, output);
  output.map(computeLuminance);
  const lum2 = 0.2126 * output[0] + 0.7152 * output[1] + 0.0722 * output[2];
  return lum1 > lum2 ? (lum1 + 0.05) / (lum2 + 0.05) : (lum2 + 0.05) / (lum1 + 0.05);
}
function findContrastColor(baseColor, fixedColor) {
  const key = baseColor[0] + baseColor[1] * 256 + baseColor[2] * 65536 + fixedColor[0] * 16777216 + fixedColor[1] * 4294967296 + fixedColor[2] * 1099511627776;
  let cachedValue = contrastCache.get(key);
  if (cachedValue) {
    return cachedValue;
  }
  const array = new Float32Array(9);
  const output = array.subarray(0, 3);
  const baseHSL = array.subarray(3, 6);
  RGBToHSL(baseColor, baseHSL);
  const fixedHSL = array.subarray(6, 9);
  RGBToHSL(fixedColor, fixedHSL);
  const isFixedColorDark = fixedHSL[2] < 0.5;
  const minContrast = isFixedColorDark ? 12 : 4.5;
  baseHSL[2] = isFixedColorDark ? Math.sqrt(baseHSL[2]) : 1 - Math.sqrt(1 - baseHSL[2]);
  if (contrastRatio(baseHSL, fixedHSL, output) < minContrast) {
    let start, end;
    if (isFixedColorDark) {
      start = baseHSL[2];
      end = 1;
    } else {
      start = 0;
      end = baseHSL[2];
    }
    const PRECISION = 5e-3;
    while (end - start > PRECISION) {
      const mid = baseHSL[2] = (start + end) / 2;
      if (isFixedColorDark === contrastRatio(baseHSL, fixedHSL, output) < minContrast) {
        start = mid;
      } else {
        end = mid;
      }
    }
    baseHSL[2] = isFixedColorDark ? end : start;
  }
  HSLToRGB(baseHSL, output);
  cachedValue = Util.makeHexColor(Math.round(output[0] * 255), Math.round(output[1] * 255), Math.round(output[2] * 255));
  contrastCache.set(key, cachedValue);
  return cachedValue;
}
function renderRichText({
  html,
  dir,
  className
}, container) {
  const fragment = document.createDocumentFragment();
  if (typeof html === "string") {
    const p = document.createElement("p");
    p.dir = dir || "auto";
    const lines = html.split(/(?:\r\n?|\n)/);
    for (let i = 0, ii = lines.length; i < ii; ++i) {
      const line = lines[i];
      p.append(document.createTextNode(line));
      if (i < ii - 1) {
        p.append(document.createElement("br"));
      }
    }
    fragment.append(p);
  } else {
    XfaLayer.render({
      xfaHtml: html,
      div: fragment,
      intent: "richText"
    });
  }
  fragment.firstChild.classList.add("richText", className);
  container.append(fragment);
}
function bindEvents(obj2, element, names) {
  for (const name of names) {
    element.addEventListener(name, obj2[name].bind(obj2));
  }
}
function getUrlProp(val) {
  if (val instanceof URL) {
    return val.href;
  }
  if (typeof val === "string") {
    if (isNodeJS) {
      return val;
    }
    const url = URL.parse(val, window.location);
    if (url) {
      return url.href;
    }
  }
  throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.");
}
function getDataProp(val) {
  if (isNodeJS && typeof Buffer !== "undefined" && val instanceof Buffer) {
    throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`.");
  }
  if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {
    return val;
  }
  if (typeof val === "string") {
    return stringToBytes(val);
  }
  if (val instanceof ArrayBuffer || ArrayBuffer.isView(val) || typeof val === "object" && !isNaN(val?.length)) {
    return new Uint8Array(val);
  }
  throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.");
}
function getFactoryUrlProp(val) {
  if (typeof val !== "string") {
    return null;
  }
  if (val.endsWith("/")) {
    return val;
  }
  throw new Error(`Invalid factory url: "${val}" must include trailing slash.`);
}
function onFn() {
}
function wrapReason(ex) {
  if (ex instanceof AbortException || ex instanceof InvalidPDFException || ex instanceof PasswordException || ex instanceof ResponseException || ex instanceof UnknownErrorException) {
    return ex;
  }
  if (!(ex instanceof Error || typeof ex === "object" && ex !== null)) {
    unreachable('wrapReason: Expected "reason" to be a (possibly cloned) Error.');
  }
  switch (ex.name) {
    case "AbortException":
      return new AbortException(ex.message);
    case "InvalidPDFException":
      return new InvalidPDFException(ex.message);
    case "PasswordException":
      return new PasswordException(ex.message, ex.code);
    case "ResponseException":
      return new ResponseException(ex.message, ex.status, ex.missing);
    case "UnknownErrorException":
      return new UnknownErrorException(ex.message, ex.details);
  }
  return new UnknownErrorException(ex.message, ex.toString());
}
async function node_utils_fetchData(url) {
  const fs2 = process.getBuiltinModule("fs");
  const data = await fs2.promises.readFile(url);
  return new Uint8Array(data);
}
function expandBBox(array, index, minX, minY, maxX, maxY) {
  array[index * 4 + 0] = Math.min(array[index * 4 + 0], minX);
  array[index * 4 + 1] = Math.min(array[index * 4 + 1], minY);
  array[index * 4 + 2] = Math.max(array[index * 4 + 2], maxX);
  array[index * 4 + 3] = Math.max(array[index * 4 + 3], maxY);
}
function applyBoundingBox(ctx, bbox) {
  if (!bbox) {
    return;
  }
  const width = bbox[2] - bbox[0];
  const height = bbox[3] - bbox[1];
  const region = new Path2D();
  region.rect(bbox[0], bbox[1], width, height);
  ctx.clip(region);
}
function drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {
  const coords = context.coords, colors = context.colors;
  const bytes = data.data, rowSize = data.width * 4;
  let tmp;
  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }
  if (coords[p2 + 1] > coords[p3 + 1]) {
    tmp = p2;
    p2 = p3;
    p3 = tmp;
    tmp = c2;
    c2 = c3;
    c3 = tmp;
  }
  if (coords[p1 + 1] > coords[p2 + 1]) {
    tmp = p1;
    p1 = p2;
    p2 = tmp;
    tmp = c1;
    c1 = c2;
    c2 = tmp;
  }
  const x1 = (coords[p1] + context.offsetX) * context.scaleX;
  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;
  const x2 = (coords[p2] + context.offsetX) * context.scaleX;
  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;
  const x3 = (coords[p3] + context.offsetX) * context.scaleX;
  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;
  if (y1 >= y3) {
    return;
  }
  const c1r = colors[c1], c1g = colors[c1 + 1], c1b = colors[c1 + 2];
  const c2r = colors[c2], c2g = colors[c2 + 1], c2b = colors[c2 + 2];
  const c3r = colors[c3], c3g = colors[c3 + 1], c3b = colors[c3 + 2];
  const minY = Math.round(y1), maxY = Math.round(y3);
  let xa, car, cag, cab;
  let xb, cbr, cbg, cbb;
  for (let y = minY; y <= maxY; y++) {
    if (y < y2) {
      const k2 = y < y1 ? 0 : (y1 - y) / (y1 - y2);
      xa = x1 - (x1 - x2) * k2;
      car = c1r - (c1r - c2r) * k2;
      cag = c1g - (c1g - c2g) * k2;
      cab = c1b - (c1b - c2b) * k2;
    } else {
      let k2;
      if (y > y3) {
        k2 = 1;
      } else if (y2 === y3) {
        k2 = 0;
      } else {
        k2 = (y2 - y) / (y2 - y3);
      }
      xa = x2 - (x2 - x3) * k2;
      car = c2r - (c2r - c3r) * k2;
      cag = c2g - (c2g - c3g) * k2;
      cab = c2b - (c2b - c3b) * k2;
    }
    let k;
    if (y < y1) {
      k = 0;
    } else if (y > y3) {
      k = 1;
    } else {
      k = (y1 - y) / (y1 - y3);
    }
    xb = x1 - (x1 - x3) * k;
    cbr = c1r - (c1r - c3r) * k;
    cbg = c1g - (c1g - c3g) * k;
    cbb = c1b - (c1b - c3b) * k;
    const x1_ = Math.round(Math.min(xa, xb));
    const x2_ = Math.round(Math.max(xa, xb));
    let j = rowSize * y + x1_ * 4;
    for (let x = x1_; x <= x2_; x++) {
      k = (xa - x) / (xa - xb);
      if (k < 0) {
        k = 0;
      } else if (k > 1) {
        k = 1;
      }
      bytes[j++] = car - (car - cbr) * k | 0;
      bytes[j++] = cag - (cag - cbg) * k | 0;
      bytes[j++] = cab - (cab - cbb) * k | 0;
      bytes[j++] = 255;
    }
  }
}
function drawFigure(data, figure, context) {
  const ps = figure.coords;
  const cs = figure.colors;
  let i, ii;
  switch (figure.type) {
    case "lattice":
      const verticesPerRow = figure.verticesPerRow;
      const rows = Math.floor(ps.length / verticesPerRow) - 1;
      const cols = verticesPerRow - 1;
      for (i = 0; i < rows; i++) {
        let q = i * verticesPerRow;
        for (let j = 0; j < cols; j++, q++) {
          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);
          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);
        }
      }
      break;
    case "triangles":
      for (i = 0, ii = ps.length; i < ii; i += 3) {
        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);
      }
      break;
    default:
      throw new Error("illegal figure");
  }
}
function getShadingPattern(IR) {
  switch (IR[0]) {
    case "RadialAxial":
      return new RadialAxialShadingPattern(IR);
    case "Mesh":
      return new MeshShadingPattern(IR);
    case "Dummy":
      return new DummyShadingPattern();
  }
  throw new Error(`Unknown IR type: ${IR[0]}`);
}
function convertBlackAndWhiteToRGBA({
  src,
  srcPos = 0,
  dest,
  width,
  height,
  nonBlackColor = 4294967295,
  inverseDecode = false
}) {
  const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];
  const widthInSource = width >> 3;
  const widthRemainder = width & 7;
  const srcLength = src.length;
  dest = new Uint32Array(dest.buffer);
  let destPos = 0;
  for (let i = 0; i < height; i++) {
    for (const max2 = srcPos + widthInSource; srcPos < max2; srcPos++) {
      const elem2 = srcPos < srcLength ? src[srcPos] : 255;
      dest[destPos++] = elem2 & 128 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 64 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 32 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 16 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 8 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 4 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 2 ? oneMapping : zeroMapping;
      dest[destPos++] = elem2 & 1 ? oneMapping : zeroMapping;
    }
    if (widthRemainder === 0) {
      continue;
    }
    const elem = srcPos < srcLength ? src[srcPos++] : 255;
    for (let j = 0; j < widthRemainder; j++) {
      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;
    }
  }
  return {
    srcPos,
    destPos
  };
}
function mirrorContextOperations(ctx, destCtx) {
  if (ctx._removeMirroring) {
    throw new Error("Context is already forwarding operations.");
  }
  ctx.__originalSave = ctx.save;
  ctx.__originalRestore = ctx.restore;
  ctx.__originalRotate = ctx.rotate;
  ctx.__originalScale = ctx.scale;
  ctx.__originalTranslate = ctx.translate;
  ctx.__originalTransform = ctx.transform;
  ctx.__originalSetTransform = ctx.setTransform;
  ctx.__originalResetTransform = ctx.resetTransform;
  ctx.__originalClip = ctx.clip;
  ctx.__originalMoveTo = ctx.moveTo;
  ctx.__originalLineTo = ctx.lineTo;
  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;
  ctx.__originalRect = ctx.rect;
  ctx.__originalClosePath = ctx.closePath;
  ctx.__originalBeginPath = ctx.beginPath;
  ctx._removeMirroring = () => {
    ctx.save = ctx.__originalSave;
    ctx.restore = ctx.__originalRestore;
    ctx.rotate = ctx.__originalRotate;
    ctx.scale = ctx.__originalScale;
    ctx.translate = ctx.__originalTranslate;
    ctx.transform = ctx.__originalTransform;
    ctx.setTransform = ctx.__originalSetTransform;
    ctx.resetTransform = ctx.__originalResetTransform;
    ctx.clip = ctx.__originalClip;
    ctx.moveTo = ctx.__originalMoveTo;
    ctx.lineTo = ctx.__originalLineTo;
    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;
    ctx.rect = ctx.__originalRect;
    ctx.closePath = ctx.__originalClosePath;
    ctx.beginPath = ctx.__originalBeginPath;
    delete ctx._removeMirroring;
  };
  ctx.save = function() {
    destCtx.save();
    this.__originalSave();
  };
  ctx.restore = function() {
    destCtx.restore();
    this.__originalRestore();
  };
  ctx.translate = function(x, y) {
    destCtx.translate(x, y);
    this.__originalTranslate(x, y);
  };
  ctx.scale = function(x, y) {
    destCtx.scale(x, y);
    this.__originalScale(x, y);
  };
  ctx.transform = function(a, b, c, d, e, f) {
    destCtx.transform(a, b, c, d, e, f);
    this.__originalTransform(a, b, c, d, e, f);
  };
  ctx.setTransform = function(a, b, c, d, e, f) {
    destCtx.setTransform(a, b, c, d, e, f);
    this.__originalSetTransform(a, b, c, d, e, f);
  };
  ctx.resetTransform = function() {
    destCtx.resetTransform();
    this.__originalResetTransform();
  };
  ctx.rotate = function(angle) {
    destCtx.rotate(angle);
    this.__originalRotate(angle);
  };
  ctx.clip = function(rule) {
    destCtx.clip(rule);
    this.__originalClip(rule);
  };
  ctx.moveTo = function(x, y) {
    destCtx.moveTo(x, y);
    this.__originalMoveTo(x, y);
  };
  ctx.lineTo = function(x, y) {
    destCtx.lineTo(x, y);
    this.__originalLineTo(x, y);
  };
  ctx.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
  };
  ctx.rect = function(x, y, width, height) {
    destCtx.rect(x, y, width, height);
    this.__originalRect(x, y, width, height);
  };
  ctx.closePath = function() {
    destCtx.closePath();
    this.__originalClosePath();
  };
  ctx.beginPath = function() {
    destCtx.beginPath();
    this.__originalBeginPath();
  };
}
function drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {
  const [a, b, c, d, tx, ty] = getCurrentTransform(ctx);
  if (b === 0 && c === 0) {
    const tlX = destX * a + tx;
    const rTlX = Math.round(tlX);
    const tlY = destY * d + ty;
    const rTlY = Math.round(tlY);
    const brX = (destX + destW) * a + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destY + destH) * d + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rWidth, rHeight];
  }
  if (a === 0 && d === 0) {
    const tlX = destY * c + tx;
    const rTlX = Math.round(tlX);
    const tlY = destX * b + ty;
    const rTlY = Math.round(tlY);
    const brX = (destY + destH) * c + tx;
    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;
    const brY = (destX + destW) * b + ty;
    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;
    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);
    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);
    ctx.setTransform(a, b, c, d, tx, ty);
    return [rHeight, rWidth];
  }
  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);
  const scaleX = Math.hypot(a, b);
  const scaleY = Math.hypot(c, d);
  return [scaleX * destW, scaleY * destH];
}
function putBinaryImageData(ctx, imgData) {
  if (imgData instanceof ImageData) {
    ctx.putImageData(imgData, 0, 0);
    return;
  }
  const height = imgData.height, width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0, destPos;
  const src = imgData.data;
  const dest = chunkImgData.data;
  let i, j, thisChunkHeight, elemsInThisChunk;
  if (imgData.kind === util_ImageKind.GRAYSCALE_1BPP) {
    const srcLength = src.byteLength;
    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);
    const dest32DataLength = dest32.length;
    const fullSrcDiff = width + 7 >> 3;
    const white = 4294967295;
    const black = util_FeatureTest.isLittleEndian ? 4278190080 : 255;
    for (i = 0; i < totalChunks; i++) {
      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
      destPos = 0;
      for (j = 0; j < thisChunkHeight; j++) {
        const srcDiff = srcLength - srcPos;
        let k = 0;
        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;
        const kEndUnrolled = kEnd & ~7;
        let mask = 0;
        let srcByte = 0;
        for (; k < kEndUnrolled; k += 8) {
          srcByte = src[srcPos++];
          dest32[destPos++] = srcByte & 128 ? white : black;
          dest32[destPos++] = srcByte & 64 ? white : black;
          dest32[destPos++] = srcByte & 32 ? white : black;
          dest32[destPos++] = srcByte & 16 ? white : black;
          dest32[destPos++] = srcByte & 8 ? white : black;
          dest32[destPos++] = srcByte & 4 ? white : black;
          dest32[destPos++] = srcByte & 2 ? white : black;
          dest32[destPos++] = srcByte & 1 ? white : black;
        }
        for (; k < kEnd; k++) {
          if (mask === 0) {
            srcByte = src[srcPos++];
            mask = 128;
          }
          dest32[destPos++] = srcByte & mask ? white : black;
          mask >>= 1;
        }
      }
      while (destPos < dest32DataLength) {
        dest32[destPos++] = 0;
      }
      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else if (imgData.kind === util_ImageKind.RGBA_32BPP) {
    j = 0;
    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;
    for (i = 0; i < fullChunks; i++) {
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      srcPos += elemsInThisChunk;
      ctx.putImageData(chunkImgData, 0, j);
      j += FULL_CHUNK_HEIGHT;
    }
    if (i < totalChunks) {
      elemsInThisChunk = width * partialChunkHeight * 4;
      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));
      ctx.putImageData(chunkImgData, 0, j);
    }
  } else if (imgData.kind === util_ImageKind.RGB_24BPP) {
    thisChunkHeight = FULL_CHUNK_HEIGHT;
    elemsInThisChunk = width * thisChunkHeight;
    for (i = 0; i < totalChunks; i++) {
      if (i >= fullChunks) {
        thisChunkHeight = partialChunkHeight;
        elemsInThisChunk = width * thisChunkHeight;
      }
      destPos = 0;
      for (j = elemsInThisChunk; j--; ) {
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = src[srcPos++];
        dest[destPos++] = 255;
      }
      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
    }
  } else {
    throw new Error(`bad image kind: ${imgData.kind}`);
  }
}
function putBinaryImageMask(ctx, imgData) {
  if (imgData.bitmap) {
    ctx.drawImage(imgData.bitmap, 0, 0);
    return;
  }
  const height = imgData.height, width = imgData.width;
  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;
  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;
  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;
  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);
  let srcPos = 0;
  const src = imgData.data;
  const dest = chunkImgData.data;
  for (let i = 0; i < totalChunks; i++) {
    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;
    ({
      srcPos
    } = convertBlackAndWhiteToRGBA({
      src,
      srcPos,
      dest,
      width,
      height: thisChunkHeight,
      nonBlackColor: 0
    }));
    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);
  }
}
function copyCtxState(sourceCtx, destCtx) {
  const properties = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"];
  for (const property2 of properties) {
    if (sourceCtx[property2] !== void 0) {
      destCtx[property2] = sourceCtx[property2];
    }
  }
  if (sourceCtx.setLineDash !== void 0) {
    destCtx.setLineDash(sourceCtx.getLineDash());
    destCtx.lineDashOffset = sourceCtx.lineDashOffset;
  }
}
function resetCtxToDefault(ctx) {
  ctx.strokeStyle = ctx.fillStyle = "#000000";
  ctx.fillRule = "nonzero";
  ctx.globalAlpha = 1;
  ctx.lineWidth = 1;
  ctx.lineCap = "butt";
  ctx.lineJoin = "miter";
  ctx.miterLimit = 10;
  ctx.globalCompositeOperation = "source-over";
  ctx.font = "10px sans-serif";
  if (ctx.setLineDash !== void 0) {
    ctx.setLineDash([]);
    ctx.lineDashOffset = 0;
  }
  const {
    filter: filter2
  } = ctx;
  if (filter2 !== "none" && filter2 !== "") {
    ctx.filter = "none";
  }
}
function getImageSmoothingEnabled(transform, interpolate) {
  if (interpolate) {
    return true;
  }
  Util.singularValueDecompose2dScale(transform, XY);
  const actualScale = Math.fround(OutputScale.pixelRatio * PixelsPerInch.PDF_TO_CSS_UNITS);
  return XY[0] <= actualScale && XY[1] <= actualScale;
}
function getFilenameFromContentDispositionHeader(contentDisposition) {
  let needsEncodingFixup = true;
  let tmp = toParamRegExp("filename\\*", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = unescape(filename);
    filename = rfc5987decode(filename);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  tmp = rfc2231getparam(contentDisposition);
  if (tmp) {
    const filename = rfc2047decode(tmp);
    return fixupEncoding(filename);
  }
  tmp = toParamRegExp("filename", "i").exec(contentDisposition);
  if (tmp) {
    tmp = tmp[1];
    let filename = rfc2616unquote(tmp);
    filename = rfc2047decode(filename);
    return fixupEncoding(filename);
  }
  function toParamRegExp(attributePattern, flags) {
    return new RegExp("(?:^|;)\\s*" + attributePattern + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', flags);
  }
  function textdecode(encoding, value) {
    if (encoding) {
      if (!/^[\x00-\xFF]+$/.test(value)) {
        return value;
      }
      try {
        const decoder = new TextDecoder(encoding, {
          fatal: true
        });
        const buffer = stringToBytes(value);
        value = decoder.decode(buffer);
        needsEncodingFixup = false;
      } catch {
      }
    }
    return value;
  }
  function fixupEncoding(value) {
    if (needsEncodingFixup && /[\x80-\xff]/.test(value)) {
      value = textdecode("utf-8", value);
      if (needsEncodingFixup) {
        value = textdecode("iso-8859-1", value);
      }
    }
    return value;
  }
  function rfc2231getparam(contentDispositionStr) {
    const matches = [];
    let match;
    const iter = toParamRegExp("filename\\*((?!0\\d)\\d+)(\\*?)", "ig");
    while ((match = iter.exec(contentDispositionStr)) !== null) {
      let [, n, quot, part] = match;
      n = parseInt(n, 10);
      if (n in matches) {
        if (n === 0) {
          break;
        }
        continue;
      }
      matches[n] = [quot, part];
    }
    const parts = [];
    for (let n = 0; n < matches.length; ++n) {
      if (!(n in matches)) {
        break;
      }
      let [quot, part] = matches[n];
      part = rfc2616unquote(part);
      if (quot) {
        part = unescape(part);
        if (n === 0) {
          part = rfc5987decode(part);
        }
      }
      parts.push(part);
    }
    return parts.join("");
  }
  function rfc2616unquote(value) {
    if (value.startsWith('"')) {
      const parts = value.slice(1).split('\\"');
      for (let i = 0; i < parts.length; ++i) {
        const quotindex = parts[i].indexOf('"');
        if (quotindex !== -1) {
          parts[i] = parts[i].slice(0, quotindex);
          parts.length = i + 1;
        }
        parts[i] = parts[i].replaceAll(/\\(.)/g, "$1");
      }
      value = parts.join('"');
    }
    return value;
  }
  function rfc5987decode(extvalue) {
    const encodingend = extvalue.indexOf("'");
    if (encodingend === -1) {
      return extvalue;
    }
    const encoding = extvalue.slice(0, encodingend);
    const langvalue = extvalue.slice(encodingend + 1);
    const value = langvalue.replace(/^[^']*'/, "");
    return textdecode(encoding, value);
  }
  function rfc2047decode(value) {
    if (!value.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(value)) {
      return value;
    }
    return value.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function(matches, charset, encoding, text) {
      if (encoding === "q" || encoding === "Q") {
        text = text.replaceAll("_", " ");
        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function(match, hex) {
          return String.fromCharCode(parseInt(hex, 16));
        });
        return textdecode(charset, text);
      }
      try {
        text = atob(text);
      } catch {
      }
      return textdecode(charset, text);
    });
  }
  return "";
}
function createHeaders(isHttp, httpHeaders) {
  const headers = new Headers();
  if (!isHttp || !httpHeaders || typeof httpHeaders !== "object") {
    return headers;
  }
  for (const key in httpHeaders) {
    const val = httpHeaders[key];
    if (val !== void 0) {
      headers.append(key, val);
    }
  }
  return headers;
}
function getResponseOrigin(url) {
  return URL.parse(url)?.origin ?? null;
}
function validateRangeRequestCapabilities({
  responseHeaders,
  isHttp,
  rangeChunkSize,
  disableRange
}) {
  const returnValues = {
    allowRangeRequests: false,
    suggestedLength: void 0
  };
  const length = parseInt(responseHeaders.get("Content-Length"), 10);
  if (!Number.isInteger(length)) {
    return returnValues;
  }
  returnValues.suggestedLength = length;
  if (length <= 2 * rangeChunkSize) {
    return returnValues;
  }
  if (disableRange || !isHttp) {
    return returnValues;
  }
  if (responseHeaders.get("Accept-Ranges") !== "bytes") {
    return returnValues;
  }
  const contentEncoding = responseHeaders.get("Content-Encoding") || "identity";
  if (contentEncoding !== "identity") {
    return returnValues;
  }
  returnValues.allowRangeRequests = true;
  return returnValues;
}
function extractFilenameFromHeader(responseHeaders) {
  const contentDisposition = responseHeaders.get("Content-Disposition");
  if (contentDisposition) {
    let filename = getFilenameFromContentDispositionHeader(contentDisposition);
    if (filename.includes("%")) {
      try {
        filename = decodeURIComponent(filename);
      } catch {
      }
    }
    if (isPdfFile(filename)) {
      return filename;
    }
  }
  return null;
}
function createResponseError(status, url) {
  return new ResponseException(`Unexpected server response (${status}) while retrieving PDF "${url}".`, status, status === 404 || status === 0 && url.startsWith("file:"));
}
function validateResponseStatus(status) {
  return status === 200 || status === 206;
}
function createFetchOptions(headers, withCredentials, abortController) {
  return {
    method: "GET",
    headers,
    signal: abortController.signal,
    mode: "cors",
    credentials: withCredentials ? "include" : "same-origin",
    redirect: "follow"
  };
}
function getArrayBuffer(val) {
  if (val instanceof Uint8Array) {
    return val.buffer;
  }
  if (val instanceof ArrayBuffer) {
    return val;
  }
  warn(`getArrayBuffer - unexpected data format: ${val}`);
  return new Uint8Array(val).buffer;
}
function network_getArrayBuffer(xhr) {
  const data = xhr.response;
  if (typeof data !== "string") {
    return data;
  }
  return stringToBytes(data).buffer;
}
function parseUrlOrPath(sourceUrl) {
  if (urlRegex.test(sourceUrl)) {
    return new URL(sourceUrl);
  }
  const url = process.getBuiltinModule("url");
  return new URL(url.pathToFileURL(sourceUrl));
}
function getDocument(src = {}) {
  if (typeof src === "string" || src instanceof URL) {
    src = {
      url: src
    };
  } else if (src instanceof ArrayBuffer || ArrayBuffer.isView(src)) {
    src = {
      data: src
    };
  }
  const task = new PDFDocumentLoadingTask();
  const {
    docId
  } = task;
  const url = src.url ? getUrlProp(src.url) : null;
  const data = src.data ? getDataProp(src.data) : null;
  const httpHeaders = src.httpHeaders || null;
  const withCredentials = src.withCredentials === true;
  const password = src.password ?? null;
  const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;
  const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : 2 ** 16;
  let worker = src.worker instanceof PDFWorker ? src.worker : null;
  const verbosity2 = src.verbosity;
  const docBaseUrl = typeof src.docBaseUrl === "string" && !isDataScheme(src.docBaseUrl) ? src.docBaseUrl : null;
  const cMapUrl = getFactoryUrlProp(src.cMapUrl);
  const cMapPacked = src.cMapPacked !== false;
  const CMapReaderFactory = src.CMapReaderFactory || (isNodeJS ? NodeCMapReaderFactory : DOMCMapReaderFactory);
  const iccUrl = getFactoryUrlProp(src.iccUrl);
  const standardFontDataUrl = getFactoryUrlProp(src.standardFontDataUrl);
  const StandardFontDataFactory = src.StandardFontDataFactory || (isNodeJS ? NodeStandardFontDataFactory : DOMStandardFontDataFactory);
  const wasmUrl = getFactoryUrlProp(src.wasmUrl);
  const WasmFactory = src.WasmFactory || (isNodeJS ? NodeWasmFactory : DOMWasmFactory);
  const ignoreErrors = src.stopAtErrors !== true;
  const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;
  const isEvalSupported2 = src.isEvalSupported !== false;
  const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === "boolean" ? src.isOffscreenCanvasSupported : !isNodeJS;
  const isImageDecoderSupported = typeof src.isImageDecoderSupported === "boolean" ? src.isImageDecoderSupported : !isNodeJS && (util_FeatureTest.platform.isFirefox || !globalThis.chrome);
  const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;
  const disableFontFace = typeof src.disableFontFace === "boolean" ? src.disableFontFace : isNodeJS;
  const fontExtraProperties = src.fontExtraProperties === true;
  const enableXfa = src.enableXfa === true;
  const ownerDocument = src.ownerDocument || globalThis.document;
  const disableRange = src.disableRange === true;
  const disableStream = src.disableStream === true;
  const disableAutoFetch = src.disableAutoFetch === true;
  const pdfBug = src.pdfBug === true;
  const CanvasFactory = src.CanvasFactory || (isNodeJS ? NodeCanvasFactory : DOMCanvasFactory);
  const FilterFactory = src.FilterFactory || (isNodeJS ? NodeFilterFactory : DOMFilterFactory);
  const enableHWA = src.enableHWA === true;
  const useWasm = src.useWasm !== false;
  const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;
  const useSystemFonts = typeof src.useSystemFonts === "boolean" ? src.useSystemFonts : !isNodeJS && !disableFontFace;
  const useWorkerFetch = typeof src.useWorkerFetch === "boolean" ? src.useWorkerFetch : !!(CMapReaderFactory === DOMCMapReaderFactory && StandardFontDataFactory === DOMStandardFontDataFactory && WasmFactory === DOMWasmFactory && cMapUrl && standardFontDataUrl && wasmUrl && isValidFetchUrl(cMapUrl, document.baseURI) && isValidFetchUrl(standardFontDataUrl, document.baseURI) && isValidFetchUrl(wasmUrl, document.baseURI));
  const styleElement = null;
  setVerbosityLevel(verbosity2);
  const transportFactory = {
    canvasFactory: new CanvasFactory({
      ownerDocument,
      enableHWA
    }),
    filterFactory: new FilterFactory({
      docId,
      ownerDocument
    }),
    cMapReaderFactory: useWorkerFetch ? null : new CMapReaderFactory({
      baseUrl: cMapUrl,
      isCompressed: cMapPacked
    }),
    standardFontDataFactory: useWorkerFetch ? null : new StandardFontDataFactory({
      baseUrl: standardFontDataUrl
    }),
    wasmFactory: useWorkerFetch ? null : new WasmFactory({
      baseUrl: wasmUrl
    })
  };
  if (!worker) {
    worker = PDFWorker.create({
      verbosity: verbosity2,
      port: GlobalWorkerOptions.workerPort
    });
    task._worker = worker;
  }
  const docParams = {
    docId,
    apiVersion: "5.4.296",
    data,
    password,
    disableAutoFetch,
    rangeChunkSize,
    length,
    docBaseUrl,
    enableXfa,
    evaluatorOptions: {
      maxImageSize,
      disableFontFace,
      ignoreErrors,
      isEvalSupported: isEvalSupported2,
      isOffscreenCanvasSupported,
      isImageDecoderSupported,
      canvasMaxAreaInBytes,
      fontExtraProperties,
      useSystemFonts,
      useWasm,
      useWorkerFetch,
      cMapUrl,
      iccUrl,
      standardFontDataUrl,
      wasmUrl
    }
  };
  const transportParams = {
    ownerDocument,
    pdfBug,
    styleElement,
    loadingParams: {
      disableAutoFetch,
      enableXfa
    }
  };
  worker.promise.then(function() {
    if (task.destroyed) {
      throw new Error("Loading aborted");
    }
    if (worker.destroyed) {
      throw new Error("Worker was destroyed");
    }
    const workerIdPromise = worker.messageHandler.sendWithPromise("GetDocRequest", docParams, data ? [data.buffer] : null);
    let networkStream;
    if (rangeTransport) {
      networkStream = new PDFDataTransportStream(rangeTransport, {
        disableRange,
        disableStream
      });
    } else if (!data) {
      if (!url) {
        throw new Error("getDocument - no `url` parameter provided.");
      }
      const NetworkStream = isValidFetchUrl(url) ? PDFFetchStream : isNodeJS ? PDFNodeStream : PDFNetworkStream;
      networkStream = new NetworkStream({
        url,
        length,
        httpHeaders,
        withCredentials,
        rangeChunkSize,
        disableRange,
        disableStream
      });
    }
    return workerIdPromise.then((workerId) => {
      if (task.destroyed) {
        throw new Error("Loading aborted");
      }
      if (worker.destroyed) {
        throw new Error("Worker was destroyed");
      }
      const messageHandler = new MessageHandler(docId, workerId, worker.port);
      const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory, enableHWA);
      task._transport = transport;
      messageHandler.send("Ready", null);
    });
  }).catch(task._capability.reject);
  return task;
}
function makeColorComp(n) {
  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, "0");
}
function scaleAndClamp(x) {
  return Math.max(0, Math.min(255, 255 * x));
}
var __webpack_modules__, __webpack_module_cache__, es_array_push, es_array_buffer_detached, es_array_buffer_transfer, es_array_buffer_transfer_to_fixed_length, es_iterator_constructor, es_iterator_reduce, es_promise_try, es_typed_array_with, esnext_math_sum_precise, esnext_uint8_array_from_base64, esnext_uint8_array_set_from_base64, esnext_uint8_array_set_from_hex, esnext_uint8_array_to_base64, esnext_uint8_array_to_hex, web_dom_exception_stack, web_url_parse, isNodeJS, FONT_IDENTITY_MATRIX, LINE_FACTOR, LINE_DESCENT_FACTOR, BASELINE_FACTOR, RenderingIntentFlag, AnnotationMode, AnnotationEditorPrefix, AnnotationEditorType, AnnotationEditorParamsType, PermissionFlag, TextRenderingMode, util_ImageKind, AnnotationType, AnnotationBorderStyleType, VerbosityLevel, OPS, DrawOPS, PasswordResponses, verbosity, BaseException, PasswordException, UnknownErrorException, InvalidPDFException, ResponseException, FormatError, AbortException, util_FeatureTest, hexNumbers, Util, NormalizeRegex, NormalizationMap, AnnotationPrefix, es_iterator_map, web_url_search_params_delete, web_url_search_params_has, web_url_search_params_size, XfaText, XfaLayer, SVG_NS, PixelsPerInch, PageViewport, RenderingCancelledException, StatTimer, PDFDateString, OutputScale, SupportedImageMimeTypes, ColorScheme, CSSConstants, contrastCache, es_iterator_take, es_promise_with_resolvers, es_set_difference_v2, es_set_intersection_v2, es_set_is_disjoint_from_v2, es_set_is_subset_of_v2, es_set_is_superset_of_v2, es_set_symmetric_difference_v2, es_set_union_v2, es_iterator_drop, es_iterator_every, es_iterator_some, esnext_json_parse, EditorToolbar, FloatingToolbar, IdManager, ImageManager, CommandManager, KeyboardManager, ColorManager, AnnotationEditorUIManager, AltText, Comment, TouchManager, AnnotationEditor, FakeEditor, SEED, MASK_HIGH, MASK_LOW, MurmurHash3_64, SerializableEmpty, AnnotationStorage, PrintAnnotationStorage, FontLoader, FontFaceObject, isRefProxy, isNameProxy, isValidExplicitDest, LoopbackPort, CallbackKind, StreamKind, MessageHandler, BaseCanvasFactory, DOMCanvasFactory, BaseCMapReaderFactory, DOMCMapReaderFactory, es_iterator_filter, BaseFilterFactory, DOMFilterFactory, BaseStandardFontDataFactory, DOMStandardFontDataFactory, BaseWasmFactory, DOMWasmFactory, NodeFilterFactory, NodeCanvasFactory, NodeCMapReaderFactory, NodeStandardFontDataFactory, NodeWasmFactory, es_iterator_for_each, FORCED_DEPENDENCY_LABEL, floor, ceil, EMPTY_BBOX, BBoxReader, ensureDebugMetadata, CanvasDependencyTracker, CanvasNestedDependencyTracker, Dependencies, PathType, BaseShadingPattern, RadialAxialShadingPattern, MeshShadingPattern, DummyShadingPattern, PaintType, TilingPattern, MIN_FONT_SIZE, MAX_FONT_SIZE, EXECUTION_TIME, EXECUTION_STEPS, FULL_CHUNK_HEIGHT, SCALE_MATRIX, XY, MIN_MAX_INIT, CachedCanvases, CanvasExtraState, LINE_CAP_STYLES, LINE_JOIN_STYLES, NORMAL_CLIP, EO_CLIP, CanvasGraphics, CssFontInfo, SystemFontInfo, FontInfo, GlobalWorkerOptions, Metadata, INTERNAL, OptionalContentGroup, OptionalContentConfig, PDFDataTransportStream, PDFDataTransportStreamReader, PDFDataTransportStreamRangeReader, PDFFetchStream, PDFFetchStreamReader, PDFFetchStreamRangeReader, OK_RESPONSE, PARTIAL_CONTENT_RESPONSE, NetworkManager, PDFNetworkStream, PDFNetworkStreamFullRequestReader, PDFNetworkStreamRangeRequestReader, urlRegex, PDFNodeStream, PDFNodeStreamFsFullReader, PDFNodeStreamFsRangeReader, INITIAL_DATA, PDFObjects, MAX_TEXT_DIVS_TO_RENDER, DEFAULT_FONT_SIZE, TextLayer, RENDERING_CANCELLED_TIMEOUT, PDFDocumentLoadingTask, PDFDataRangeTransport, PDFDocumentProxy, PDFPageProxy, PDFWorker, WorkerTransport, RenderTask, InternalRenderTask, version, build, ColorPicker, BasicColorPicker, es_iterator_find, es_iterator_flat_map, ColorConverters, BaseSVGFactory, DOMSVGFactory, annotation_layer_DEFAULT_FONT_SIZE, GetElementsByNameSet, TIMEZONE_OFFSET, AnnotationElementFactory, AnnotationElement, EditorAnnotationElement, LinkAnnotationElement, TextAnnotationElement, WidgetAnnotationElement, TextWidgetAnnotationElement, SignatureWidgetAnnotationElement, CheckboxWidgetAnnotationElement, RadioButtonWidgetAnnotationElement, PushButtonWidgetAnnotationElement, ChoiceWidgetAnnotationElement, PopupAnnotationElement, PopupElement, FreeTextAnnotationElement, LineAnnotationElement, SquareAnnotationElement, CircleAnnotationElement, PolylineAnnotationElement, PolygonAnnotationElement, CaretAnnotationElement, InkAnnotationElement, HighlightAnnotationElement, UnderlineAnnotationElement, SquigglyAnnotationElement, StrikeOutAnnotationElement, StampAnnotationElement, FileAttachmentAnnotationElement, AnnotationLayer, EOL_PATTERN, FreeTextEditor, Outline, FreeDrawOutliner, FreeDrawOutline, HighlightOutliner, HighlightOutline, FreeHighlightOutliner, FreeHighlightOutline, HighlightEditor, DrawingOptions, DrawingEditor, InkDrawOutliner, InkDrawOutline, InkDrawingOptions, InkEditor, ContourDrawOutline, BASE_HEADER_LENGTH, POINTS_PROPERTIES_NUMBER, SignatureExtractor, SignatureOptions, DrawnSignatureOptions, SignatureEditor, StampEditor, AnnotationEditorLayer, DrawLayer;
var init_pdf = __esm({
  "node_modules/pdfjs-dist/legacy/build/pdf.mjs"() {
    __webpack_modules__ = {
      /***/
      34: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var isCallable = __webpack_require__2(4901);
          module2.exports = function(it) {
            return typeof it == "object" ? it !== null : isCallable(it);
          };
        })
      ),
      /***/
      81: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var call = __webpack_require__2(9565);
          var aCallable = __webpack_require__2(9306);
          var anObject = __webpack_require__2(8551);
          var tryToString = __webpack_require__2(6823);
          var getIteratorMethod = __webpack_require__2(851);
          var $TypeError = TypeError;
          module2.exports = function(argument, usingIterator) {
            var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
            if (aCallable(iteratorMethod)) return anObject(call(iteratorMethod, argument));
            throw new $TypeError(tryToString(argument) + " is not iterable");
          };
        })
      ),
      /***/
      116: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var call = __webpack_require__2(9565);
          var iterate = __webpack_require__2(2652);
          var aCallable = __webpack_require__2(9306);
          var anObject = __webpack_require__2(8551);
          var getIteratorDirect = __webpack_require__2(1767);
          var iteratorClose = __webpack_require__2(9539);
          var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
          var findWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("find", TypeError);
          $({ target: "Iterator", proto: true, real: true, forced: findWithoutClosingOnEarlyError }, {
            find: function find2(predicate) {
              anObject(this);
              try {
                aCallable(predicate);
              } catch (error) {
                iteratorClose(this, "throw", error);
              }
              if (findWithoutClosingOnEarlyError) return call(findWithoutClosingOnEarlyError, this, predicate);
              var record = getIteratorDirect(this);
              var counter = 0;
              return iterate(record, function(value, stop) {
                if (predicate(value, counter++)) return stop(value);
              }, { IS_RECORD: true, INTERRUPTED: true }).result;
            }
          });
        })
      ),
      /***/
      283: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          var fails = __webpack_require__2(9039);
          var isCallable = __webpack_require__2(4901);
          var hasOwn = __webpack_require__2(9297);
          var DESCRIPTORS = __webpack_require__2(3724);
          var CONFIGURABLE_FUNCTION_NAME = __webpack_require__2(350).CONFIGURABLE;
          var inspectSource = __webpack_require__2(3706);
          var InternalStateModule = __webpack_require__2(1181);
          var enforceInternalState = InternalStateModule.enforce;
          var getInternalState = InternalStateModule.get;
          var $String = String;
          var defineProperty = Object.defineProperty;
          var stringSlice = uncurryThis("".slice);
          var replace = uncurryThis("".replace);
          var join = uncurryThis([].join);
          var CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function() {
            return defineProperty(function() {
            }, "length", { value: 8 }).length !== 8;
          });
          var TEMPLATE = String(String).split("String");
          var makeBuiltIn = module2.exports = function(value, name, options) {
            if (stringSlice($String(name), 0, 7) === "Symbol(") {
              name = "[" + replace($String(name), /^Symbol\(([^)]*)\).*$/, "$1") + "]";
            }
            if (options && options.getter) name = "get " + name;
            if (options && options.setter) name = "set " + name;
            if (!hasOwn(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
              if (DESCRIPTORS) defineProperty(value, "name", { value: name, configurable: true });
              else value.name = name;
            }
            if (CONFIGURABLE_LENGTH && options && hasOwn(options, "arity") && value.length !== options.arity) {
              defineProperty(value, "length", { value: options.arity });
            }
            try {
              if (options && hasOwn(options, "constructor") && options.constructor) {
                if (DESCRIPTORS) defineProperty(value, "prototype", { writable: false });
              } else if (value.prototype) value.prototype = void 0;
            } catch (error) {
            }
            var state = enforceInternalState(value);
            if (!hasOwn(state, "source")) {
              state.source = join(TEMPLATE, typeof name == "string" ? name : "");
            }
            return value;
          };
          Function.prototype.toString = makeBuiltIn(function toString2() {
            return isCallable(this) && getInternalState(this).source || inspectSource(this);
          }, "toString");
        })
      ),
      /***/
      350: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var DESCRIPTORS = __webpack_require__2(3724);
          var hasOwn = __webpack_require__2(9297);
          var FunctionPrototype = Function.prototype;
          var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
          var EXISTS = hasOwn(FunctionPrototype, "name");
          var PROPER = EXISTS && (function something() {
          }).name === "something";
          var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
          module2.exports = {
            EXISTS,
            PROPER,
            CONFIGURABLE
          };
        })
      ),
      /***/
      397: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var getBuiltIn = __webpack_require__2(7751);
          module2.exports = getBuiltIn("document", "documentElement");
        })
      ),
      /***/
      421: (
        /***/
        ((module2) => {
          module2.exports = {};
        })
      ),
      /***/
      456: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var globalThis2 = __webpack_require__2(4576);
          var uncurryThis = __webpack_require__2(9504);
          var anUint8Array = __webpack_require__2(4154);
          var notDetached = __webpack_require__2(5169);
          var numberToString = uncurryThis(1.1.toString);
          var Uint8Array2 = globalThis2.Uint8Array;
          var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.prototype.toHex || !(function() {
            try {
              var target = new Uint8Array2([255, 255, 255, 255, 255, 255, 255, 255]);
              return target.toHex() === "ffffffffffffffff";
            } catch (error) {
              return false;
            }
          })();
          if (Uint8Array2) $({ target: "Uint8Array", proto: true, forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS }, {
            toHex: function toHex() {
              anUint8Array(this);
              notDetached(this.buffer);
              var result2 = "";
              for (var i = 0, length = this.length; i < length; i++) {
                var hex = numberToString(this[i], 16);
                result2 += hex.length === 1 ? "0" + hex : hex;
              }
              return result2;
            }
          });
        })
      ),
      /***/
      507: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var call = __webpack_require__2(9565);
          module2.exports = function(record, fn, ITERATOR_INSTEAD_OF_RECORD) {
            var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;
            var next = record.next;
            var step, result2;
            while (!(step = call(next, iterator)).done) {
              result2 = fn(step.value);
              if (result2 !== void 0) return result2;
            }
          };
        })
      ),
      /***/
      531: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var call = __webpack_require__2(9565);
          var aCallable = __webpack_require__2(9306);
          var anObject = __webpack_require__2(8551);
          var getIteratorDirect = __webpack_require__2(1767);
          var getIteratorFlattenable = __webpack_require__2(8646);
          var createIteratorProxy = __webpack_require__2(9462);
          var iteratorClose = __webpack_require__2(9539);
          var IS_PURE = __webpack_require__2(6395);
          var iteratorHelperThrowsOnInvalidIterator = __webpack_require__2(684);
          var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
          var FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator("flatMap", function() {
          });
          var flatMapWithoutClosingOnEarlyError = !IS_PURE && !FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError("flatMap", TypeError);
          var FORCED = IS_PURE || FLAT_MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || flatMapWithoutClosingOnEarlyError;
          var IteratorProxy = createIteratorProxy(function() {
            var iterator = this.iterator;
            var mapper = this.mapper;
            var result2, inner;
            while (true) {
              if (inner = this.inner) try {
                result2 = anObject(call(inner.next, inner.iterator));
                if (!result2.done) return result2.value;
                this.inner = null;
              } catch (error) {
                iteratorClose(iterator, "throw", error);
              }
              result2 = anObject(call(this.next, iterator));
              if (this.done = !!result2.done) return;
              try {
                this.inner = getIteratorFlattenable(mapper(result2.value, this.counter++), false);
              } catch (error) {
                iteratorClose(iterator, "throw", error);
              }
            }
          });
          $({ target: "Iterator", proto: true, real: true, forced: FORCED }, {
            flatMap: function flatMap(mapper) {
              anObject(this);
              try {
                aCallable(mapper);
              } catch (error) {
                iteratorClose(this, "throw", error);
              }
              if (flatMapWithoutClosingOnEarlyError) return call(flatMapWithoutClosingOnEarlyError, this, mapper);
              return new IteratorProxy(getIteratorDirect(this), {
                mapper,
                inner: null
              });
            }
          });
        })
      ),
      /***/
      616: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var fails = __webpack_require__2(9039);
          module2.exports = !fails(function() {
            var test = (function() {
            }).bind();
            return typeof test != "function" || test.hasOwnProperty("prototype");
          });
        })
      ),
      /***/
      655: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var classof = __webpack_require__2(6955);
          var $String = String;
          module2.exports = function(argument) {
            if (classof(argument) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
            return $String(argument);
          };
        })
      ),
      /***/
      679: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var isPrototypeOf = __webpack_require__2(1625);
          var $TypeError = TypeError;
          module2.exports = function(it, Prototype) {
            if (isPrototypeOf(Prototype, it)) return it;
            throw new $TypeError("Incorrect invocation");
          };
        })
      ),
      /***/
      684: (
        /***/
        ((module2) => {
          module2.exports = function(methodName, argument) {
            var method = typeof Iterator == "function" && Iterator.prototype[methodName];
            if (method) try {
              method.call({ next: null }, argument).next();
            } catch (error) {
              return true;
            }
          };
        })
      ),
      /***/
      741: (
        /***/
        ((module2) => {
          var ceil2 = Math.ceil;
          var floor2 = Math.floor;
          module2.exports = Math.trunc || function trunc(x) {
            var n = +x;
            return (n > 0 ? floor2 : ceil2)(n);
          };
        })
      ),
      /***/
      757: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var getBuiltIn = __webpack_require__2(7751);
          var isCallable = __webpack_require__2(4901);
          var isPrototypeOf = __webpack_require__2(1625);
          var USE_SYMBOL_AS_UID = __webpack_require__2(7040);
          var $Object = Object;
          module2.exports = USE_SYMBOL_AS_UID ? function(it) {
            return typeof it == "symbol";
          } : function(it) {
            var $Symbol = getBuiltIn("Symbol");
            return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));
          };
        })
      ),
      /***/
      851: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var classof = __webpack_require__2(6955);
          var getMethod = __webpack_require__2(5966);
          var isNullOrUndefined = __webpack_require__2(4117);
          var Iterators = __webpack_require__2(6269);
          var wellKnownSymbol = __webpack_require__2(8227);
          var ITERATOR = wellKnownSymbol("iterator");
          module2.exports = function(it) {
            if (!isNullOrUndefined(it)) return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
          };
        })
      ),
      /***/
      944: (
        /***/
        ((module2) => {
          var $TypeError = TypeError;
          module2.exports = function(options) {
            var alphabet = options && options.alphabet;
            if (alphabet === void 0 || alphabet === "base64" || alphabet === "base64url") return alphabet || "base64";
            throw new $TypeError("Incorrect `alphabet` option");
          };
        })
      ),
      /***/
      1072: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var internalObjectKeys = __webpack_require__2(1828);
          var enumBugKeys = __webpack_require__2(8727);
          module2.exports = Object.keys || function keys2(O) {
            return internalObjectKeys(O, enumBugKeys);
          };
        })
      ),
      /***/
      1103: (
        /***/
        ((module2) => {
          module2.exports = function(exec) {
            try {
              return { error: false, value: exec() };
            } catch (error) {
              return { error: true, value: error };
            }
          };
        })
      ),
      /***/
      1108: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var classof = __webpack_require__2(6955);
          module2.exports = function(it) {
            var klass = classof(it);
            return klass === "BigInt64Array" || klass === "BigUint64Array";
          };
        })
      ),
      /***/
      1148: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var call = __webpack_require__2(9565);
          var iterate = __webpack_require__2(2652);
          var aCallable = __webpack_require__2(9306);
          var anObject = __webpack_require__2(8551);
          var getIteratorDirect = __webpack_require__2(1767);
          var iteratorClose = __webpack_require__2(9539);
          var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
          var everyWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("every", TypeError);
          $({ target: "Iterator", proto: true, real: true, forced: everyWithoutClosingOnEarlyError }, {
            every: function every2(predicate) {
              anObject(this);
              try {
                aCallable(predicate);
              } catch (error) {
                iteratorClose(this, "throw", error);
              }
              if (everyWithoutClosingOnEarlyError) return call(everyWithoutClosingOnEarlyError, this, predicate);
              var record = getIteratorDirect(this);
              var counter = 0;
              return !iterate(record, function(value, stop) {
                if (!predicate(value, counter++)) return stop();
              }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
            }
          });
        })
      ),
      /***/
      1181: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var NATIVE_WEAK_MAP = __webpack_require__2(8622);
          var globalThis2 = __webpack_require__2(4576);
          var isObject3 = __webpack_require__2(34);
          var createNonEnumerableProperty = __webpack_require__2(6699);
          var hasOwn = __webpack_require__2(9297);
          var shared = __webpack_require__2(7629);
          var sharedKey = __webpack_require__2(6119);
          var hiddenKeys = __webpack_require__2(421);
          var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
          var TypeError2 = globalThis2.TypeError;
          var WeakMap2 = globalThis2.WeakMap;
          var set, get2, has3;
          var enforce = function(it) {
            return has3(it) ? get2(it) : set(it, {});
          };
          var getterFor = function(TYPE) {
            return function(it) {
              var state;
              if (!isObject3(it) || (state = get2(it)).type !== TYPE) {
                throw new TypeError2("Incompatible receiver, " + TYPE + " required");
              }
              return state;
            };
          };
          if (NATIVE_WEAK_MAP || shared.state) {
            var store = shared.state || (shared.state = new WeakMap2());
            store.get = store.get;
            store.has = store.has;
            store.set = store.set;
            set = function(it, metadata) {
              if (store.has(it)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
              metadata.facade = it;
              store.set(it, metadata);
              return metadata;
            };
            get2 = function(it) {
              return store.get(it) || {};
            };
            has3 = function(it) {
              return store.has(it);
            };
          } else {
            var STATE = sharedKey("state");
            hiddenKeys[STATE] = true;
            set = function(it, metadata) {
              if (hasOwn(it, STATE)) throw new TypeError2(OBJECT_ALREADY_INITIALIZED);
              metadata.facade = it;
              createNonEnumerableProperty(it, STATE, metadata);
              return metadata;
            };
            get2 = function(it) {
              return hasOwn(it, STATE) ? it[STATE] : {};
            };
            has3 = function(it) {
              return hasOwn(it, STATE);
            };
          }
          module2.exports = {
            set,
            get: get2,
            has: has3,
            enforce,
            getterFor
          };
        })
      ),
      /***/
      1291: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var trunc = __webpack_require__2(741);
          module2.exports = function(argument) {
            var number = +argument;
            return number !== number || number === 0 ? 0 : trunc(number);
          };
        })
      ),
      /***/
      1385: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var iteratorClose = __webpack_require__2(9539);
          module2.exports = function(iters, kind, value) {
            for (var i = iters.length - 1; i >= 0; i--) {
              if (iters[i] === void 0) continue;
              try {
                value = iteratorClose(iters[i].iterator, kind, value);
              } catch (error) {
                kind = "throw";
                value = error;
              }
            }
            if (kind === "throw") throw value;
            return value;
          };
        })
      ),
      /***/
      1548: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var fails = __webpack_require__2(9039);
          var V8 = __webpack_require__2(9519);
          var ENVIRONMENT = __webpack_require__2(4215);
          var structuredClone2 = globalThis2.structuredClone;
          module2.exports = !!structuredClone2 && !fails(function() {
            if (ENVIRONMENT === "DENO" && V8 > 92 || ENVIRONMENT === "NODE" && V8 > 94 || ENVIRONMENT === "BROWSER" && V8 > 97) return false;
            var buffer = new ArrayBuffer(8);
            var clone2 = structuredClone2(buffer, { transfer: [buffer] });
            return buffer.byteLength !== 0 || clone2.byteLength !== 8;
          });
        })
      ),
      /***/
      1549: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          __webpack_require__2(6632);
        })
      ),
      /***/
      1625: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          module2.exports = uncurryThis({}.isPrototypeOf);
        })
      ),
      /***/
      1689: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var globalThis2 = __webpack_require__2(4576);
          var apply = __webpack_require__2(8745);
          var slice2 = __webpack_require__2(7680);
          var newPromiseCapabilityModule = __webpack_require__2(6043);
          var aCallable = __webpack_require__2(9306);
          var perform = __webpack_require__2(1103);
          var Promise2 = globalThis2.Promise;
          var ACCEPT_ARGUMENTS = false;
          var FORCED = !Promise2 || !Promise2["try"] || perform(function() {
            Promise2["try"](function(argument) {
              ACCEPT_ARGUMENTS = argument === 8;
            }, 8);
          }).error || !ACCEPT_ARGUMENTS;
          $({ target: "Promise", stat: true, forced: FORCED }, {
            "try": function(callbackfn) {
              var args = arguments.length > 1 ? slice2(arguments, 1) : [];
              var promiseCapability = newPromiseCapabilityModule.f(this);
              var result2 = perform(function() {
                return apply(aCallable(callbackfn), void 0, args);
              });
              (result2.error ? promiseCapability.reject : promiseCapability.resolve)(result2.value);
              return promiseCapability.promise;
            }
          });
        })
      ),
      /***/
      1698: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var union = __webpack_require__2(4204);
          var setMethodGetKeysBeforeCloning = __webpack_require__2(9835);
          var setMethodAcceptSetLike = __webpack_require__2(4916);
          var FORCED = !setMethodAcceptSetLike("union") || !setMethodGetKeysBeforeCloning("union");
          $({ target: "Set", proto: true, real: true, forced: FORCED }, {
            union
          });
        })
      ),
      /***/
      1701: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var call = __webpack_require__2(9565);
          var aCallable = __webpack_require__2(9306);
          var anObject = __webpack_require__2(8551);
          var getIteratorDirect = __webpack_require__2(1767);
          var createIteratorProxy = __webpack_require__2(9462);
          var callWithSafeIterationClosing = __webpack_require__2(6319);
          var iteratorClose = __webpack_require__2(9539);
          var iteratorHelperThrowsOnInvalidIterator = __webpack_require__2(684);
          var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
          var IS_PURE = __webpack_require__2(6395);
          var MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator("map", function() {
          });
          var mapWithoutClosingOnEarlyError = !IS_PURE && !MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError("map", TypeError);
          var FORCED = IS_PURE || MAP_WITHOUT_THROWING_ON_INVALID_ITERATOR || mapWithoutClosingOnEarlyError;
          var IteratorProxy = createIteratorProxy(function() {
            var iterator = this.iterator;
            var result2 = anObject(call(this.next, iterator));
            var done = this.done = !!result2.done;
            if (!done) return callWithSafeIterationClosing(iterator, this.mapper, [result2.value, this.counter++], true);
          });
          $({ target: "Iterator", proto: true, real: true, forced: FORCED }, {
            map: function map2(mapper) {
              anObject(this);
              try {
                aCallable(mapper);
              } catch (error) {
                iteratorClose(this, "throw", error);
              }
              if (mapWithoutClosingOnEarlyError) return call(mapWithoutClosingOnEarlyError, this, mapper);
              return new IteratorProxy(getIteratorDirect(this), {
                mapper
              });
            }
          });
        })
      ),
      /***/
      1767: (
        /***/
        ((module2) => {
          module2.exports = function(obj2) {
            return {
              iterator: obj2,
              next: obj2.next,
              done: false
            };
          };
        })
      ),
      /***/
      1828: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          var hasOwn = __webpack_require__2(9297);
          var toIndexedObject = __webpack_require__2(5397);
          var indexOf = __webpack_require__2(9617).indexOf;
          var hiddenKeys = __webpack_require__2(421);
          var push2 = uncurryThis([].push);
          module2.exports = function(object2, names) {
            var O = toIndexedObject(object2);
            var i = 0;
            var result2 = [];
            var key;
            for (key in O) !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push2(result2, key);
            while (names.length > i) if (hasOwn(O, key = names[i++])) {
              ~indexOf(result2, key) || push2(result2, key);
            }
            return result2;
          };
        })
      ),
      /***/
      2106: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var makeBuiltIn = __webpack_require__2(283);
          var defineProperty = __webpack_require__2(4913);
          module2.exports = function(target, name, descriptor) {
            if (descriptor.get) makeBuiltIn(descriptor.get, name, { getter: true });
            if (descriptor.set) makeBuiltIn(descriptor.set, name, { setter: true });
            return defineProperty.f(target, name, descriptor);
          };
        })
      ),
      /***/
      2140: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var wellKnownSymbol = __webpack_require__2(8227);
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var test = {};
          test[TO_STRING_TAG] = "z";
          module2.exports = String(test) === "[object z]";
        })
      ),
      /***/
      2195: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          var toString2 = uncurryThis({}.toString);
          var stringSlice = uncurryThis("".slice);
          module2.exports = function(it) {
            return stringSlice(toString2(it), 8, -1);
          };
        })
      ),
      /***/
      2211: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var fails = __webpack_require__2(9039);
          module2.exports = !fails(function() {
            function F() {
            }
            F.prototype.constructor = null;
            return Object.getPrototypeOf(new F()) !== F.prototype;
          });
        })
      ),
      /***/
      2303: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var uncurryThis = __webpack_require__2(9504);
          var Uint8Array2 = globalThis2.Uint8Array;
          var SyntaxError2 = globalThis2.SyntaxError;
          var parseInt2 = globalThis2.parseInt;
          var min2 = Math.min;
          var NOT_HEX = /[^\da-f]/i;
          var exec = uncurryThis(NOT_HEX.exec);
          var stringSlice = uncurryThis("".slice);
          module2.exports = function(string, into) {
            var stringLength = string.length;
            if (stringLength % 2 !== 0) throw new SyntaxError2("String should be an even number of characters");
            var maxLength = into ? min2(into.length, stringLength / 2) : stringLength / 2;
            var bytes = into || new Uint8Array2(maxLength);
            var read = 0;
            var written = 0;
            while (written < maxLength) {
              var hexits = stringSlice(string, read, read += 2);
              if (exec(NOT_HEX, hexits)) throw new SyntaxError2("String should only contain hex characters");
              bytes[written++] = parseInt2(hexits, 16);
            }
            return { bytes, read };
          };
        })
      ),
      /***/
      2360: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var anObject = __webpack_require__2(8551);
          var definePropertiesModule = __webpack_require__2(6801);
          var enumBugKeys = __webpack_require__2(8727);
          var hiddenKeys = __webpack_require__2(421);
          var html = __webpack_require__2(397);
          var documentCreateElement = __webpack_require__2(4055);
          var sharedKey = __webpack_require__2(6119);
          var GT = ">";
          var LT = "<";
          var PROTOTYPE = "prototype";
          var SCRIPT = "script";
          var IE_PROTO = sharedKey("IE_PROTO");
          var EmptyConstructor = function() {
          };
          var scriptTag = function(content) {
            return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
          };
          var NullProtoObjectViaActiveX = function(activeXDocument2) {
            activeXDocument2.write(scriptTag(""));
            activeXDocument2.close();
            var temp = activeXDocument2.parentWindow.Object;
            activeXDocument2 = null;
            return temp;
          };
          var NullProtoObjectViaIFrame = function() {
            var iframe = documentCreateElement("iframe");
            var JS = "java" + SCRIPT + ":";
            var iframeDocument;
            iframe.style.display = "none";
            html.appendChild(iframe);
            iframe.src = String(JS);
            iframeDocument = iframe.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(scriptTag("document.F=Object"));
            iframeDocument.close();
            return iframeDocument.F;
          };
          var activeXDocument;
          var NullProtoObject = function() {
            try {
              activeXDocument = new ActiveXObject("htmlfile");
            } catch (error) {
            }
            NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
            var length = enumBugKeys.length;
            while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
            return NullProtoObject();
          };
          hiddenKeys[IE_PROTO] = true;
          module2.exports = Object.create || function create2(O, Properties) {
            var result2;
            if (O !== null) {
              EmptyConstructor[PROTOTYPE] = anObject(O);
              result2 = new EmptyConstructor();
              EmptyConstructor[PROTOTYPE] = null;
              result2[IE_PROTO] = O;
            } else result2 = NullProtoObject();
            return Properties === void 0 ? result2 : definePropertiesModule.f(result2, Properties);
          };
        })
      ),
      /***/
      2475: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var isSupersetOf = __webpack_require__2(8527);
          var setMethodAcceptSetLike = __webpack_require__2(4916);
          var INCORRECT = !setMethodAcceptSetLike("isSupersetOf", function(result2) {
            return !result2;
          });
          $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
            isSupersetOf
          });
        })
      ),
      /***/
      2489: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var call = __webpack_require__2(9565);
          var aCallable = __webpack_require__2(9306);
          var anObject = __webpack_require__2(8551);
          var getIteratorDirect = __webpack_require__2(1767);
          var createIteratorProxy = __webpack_require__2(9462);
          var callWithSafeIterationClosing = __webpack_require__2(6319);
          var IS_PURE = __webpack_require__2(6395);
          var iteratorClose = __webpack_require__2(9539);
          var iteratorHelperThrowsOnInvalidIterator = __webpack_require__2(684);
          var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
          var FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator("filter", function() {
          });
          var filterWithoutClosingOnEarlyError = !IS_PURE && !FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError("filter", TypeError);
          var FORCED = IS_PURE || FILTER_WITHOUT_THROWING_ON_INVALID_ITERATOR || filterWithoutClosingOnEarlyError;
          var IteratorProxy = createIteratorProxy(function() {
            var iterator = this.iterator;
            var predicate = this.predicate;
            var next = this.next;
            var result2, done, value;
            while (true) {
              result2 = anObject(call(next, iterator));
              done = this.done = !!result2.done;
              if (done) return;
              value = result2.value;
              if (callWithSafeIterationClosing(iterator, predicate, [value, this.counter++], true)) return value;
            }
          });
          $({ target: "Iterator", proto: true, real: true, forced: FORCED }, {
            filter: function filter2(predicate) {
              anObject(this);
              try {
                aCallable(predicate);
              } catch (error) {
                iteratorClose(this, "throw", error);
              }
              if (filterWithoutClosingOnEarlyError) return call(filterWithoutClosingOnEarlyError, this, predicate);
              return new IteratorProxy(getIteratorDirect(this), {
                predicate
              });
            }
          });
        })
      ),
      /***/
      2529: (
        /***/
        ((module2) => {
          module2.exports = function(value, done) {
            return { value, done };
          };
        })
      ),
      /***/
      2603: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var toString2 = __webpack_require__2(655);
          module2.exports = function(argument, $default) {
            return argument === void 0 ? arguments.length < 2 ? "" : $default : toString2(argument);
          };
        })
      ),
      /***/
      2652: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var bind = __webpack_require__2(6080);
          var call = __webpack_require__2(9565);
          var anObject = __webpack_require__2(8551);
          var tryToString = __webpack_require__2(6823);
          var isArrayIteratorMethod = __webpack_require__2(4209);
          var lengthOfArrayLike = __webpack_require__2(6198);
          var isPrototypeOf = __webpack_require__2(1625);
          var getIterator = __webpack_require__2(81);
          var getIteratorMethod = __webpack_require__2(851);
          var iteratorClose = __webpack_require__2(9539);
          var $TypeError = TypeError;
          var Result = function(stopped, result2) {
            this.stopped = stopped;
            this.result = result2;
          };
          var ResultPrototype = Result.prototype;
          module2.exports = function(iterable, unboundFunction, options) {
            var that = options && options.that;
            var AS_ENTRIES = !!(options && options.AS_ENTRIES);
            var IS_RECORD = !!(options && options.IS_RECORD);
            var IS_ITERATOR = !!(options && options.IS_ITERATOR);
            var INTERRUPTED = !!(options && options.INTERRUPTED);
            var fn = bind(unboundFunction, that);
            var iterator, iterFn, index, length, result2, next, step;
            var stop = function(condition) {
              if (iterator) iteratorClose(iterator, "normal");
              return new Result(true, condition);
            };
            var callFn = function(value) {
              if (AS_ENTRIES) {
                anObject(value);
                return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);
              }
              return INTERRUPTED ? fn(value, stop) : fn(value);
            };
            if (IS_RECORD) {
              iterator = iterable.iterator;
            } else if (IS_ITERATOR) {
              iterator = iterable;
            } else {
              iterFn = getIteratorMethod(iterable);
              if (!iterFn) throw new $TypeError(tryToString(iterable) + " is not iterable");
              if (isArrayIteratorMethod(iterFn)) {
                for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {
                  result2 = callFn(iterable[index]);
                  if (result2 && isPrototypeOf(ResultPrototype, result2)) return result2;
                }
                return new Result(false);
              }
              iterator = getIterator(iterable, iterFn);
            }
            next = IS_RECORD ? iterable.next : iterator.next;
            while (!(step = call(next, iterator)).done) {
              try {
                result2 = callFn(step.value);
              } catch (error) {
                iteratorClose(iterator, "throw", error);
              }
              if (typeof result2 == "object" && result2 && isPrototypeOf(ResultPrototype, result2)) return result2;
            }
            return new Result(false);
          };
        })
      ),
      /***/
      2777: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var call = __webpack_require__2(9565);
          var isObject3 = __webpack_require__2(34);
          var isSymbol = __webpack_require__2(757);
          var getMethod = __webpack_require__2(5966);
          var ordinaryToPrimitive = __webpack_require__2(4270);
          var wellKnownSymbol = __webpack_require__2(8227);
          var $TypeError = TypeError;
          var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
          module2.exports = function(input, pref) {
            if (!isObject3(input) || isSymbol(input)) return input;
            var exoticToPrim = getMethod(input, TO_PRIMITIVE);
            var result2;
            if (exoticToPrim) {
              if (pref === void 0) pref = "default";
              result2 = call(exoticToPrim, input, pref);
              if (!isObject3(result2) || isSymbol(result2)) return result2;
              throw new $TypeError("Can't convert object to primitive value");
            }
            if (pref === void 0) pref = "number";
            return ordinaryToPrimitive(input, pref);
          };
        })
      ),
      /***/
      2787: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var hasOwn = __webpack_require__2(9297);
          var isCallable = __webpack_require__2(4901);
          var toObject = __webpack_require__2(8981);
          var sharedKey = __webpack_require__2(6119);
          var CORRECT_PROTOTYPE_GETTER = __webpack_require__2(2211);
          var IE_PROTO = sharedKey("IE_PROTO");
          var $Object = Object;
          var ObjectPrototype = $Object.prototype;
          module2.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function(O) {
            var object2 = toObject(O);
            if (hasOwn(object2, IE_PROTO)) return object2[IE_PROTO];
            var constructor = object2.constructor;
            if (isCallable(constructor) && object2 instanceof constructor) {
              return constructor.prototype;
            }
            return object2 instanceof $Object ? ObjectPrototype : null;
          };
        })
      ),
      /***/
      2796: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var fails = __webpack_require__2(9039);
          var isCallable = __webpack_require__2(4901);
          var replacement = /#|\.prototype\./;
          var isForced = function(feature, detection) {
            var value = data[normalize(feature)];
            return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
          };
          var normalize = isForced.normalize = function(string) {
            return String(string).replace(replacement, ".").toLowerCase();
          };
          var data = isForced.data = {};
          var NATIVE = isForced.NATIVE = "N";
          var POLYFILL = isForced.POLYFILL = "P";
          module2.exports = isForced;
        })
      ),
      /***/
      2804: (
        /***/
        ((module2) => {
          var commonAlphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
          var base64Alphabet = commonAlphabet + "+/";
          var base64UrlAlphabet = commonAlphabet + "-_";
          var inverse = function(characters) {
            var result2 = {};
            var index = 0;
            for (; index < 64; index++) result2[characters.charAt(index)] = index;
            return result2;
          };
          module2.exports = {
            i2c: base64Alphabet,
            c2i: inverse(base64Alphabet),
            i2cUrl: base64UrlAlphabet,
            c2iUrl: inverse(base64UrlAlphabet)
          };
        })
      ),
      /***/
      2812: (
        /***/
        ((module2) => {
          var $TypeError = TypeError;
          module2.exports = function(passed, required) {
            if (passed < required) throw new $TypeError("Not enough arguments");
            return passed;
          };
        })
      ),
      /***/
      2839: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var navigator2 = globalThis2.navigator;
          var userAgent = navigator2 && navigator2.userAgent;
          module2.exports = userAgent ? String(userAgent) : "";
        })
      ),
      /***/
      2967: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThisAccessor = __webpack_require__2(6706);
          var isObject3 = __webpack_require__2(34);
          var requireObjectCoercible = __webpack_require__2(7750);
          var aPossiblePrototype = __webpack_require__2(3506);
          module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? (function() {
            var CORRECT_SETTER = false;
            var test = {};
            var setter;
            try {
              setter = uncurryThisAccessor(Object.prototype, "__proto__", "set");
              setter(test, []);
              CORRECT_SETTER = test instanceof Array;
            } catch (error) {
            }
            return function setPrototypeOf(O, proto) {
              requireObjectCoercible(O);
              aPossiblePrototype(proto);
              if (!isObject3(O)) return O;
              if (CORRECT_SETTER) setter(O, proto);
              else O.__proto__ = proto;
              return O;
            };
          })() : void 0);
        })
      ),
      /***/
      3068: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var uncurryThis = __webpack_require__2(9504);
          var iterate = __webpack_require__2(2652);
          var $RangeError = RangeError;
          var $TypeError = TypeError;
          var $Infinity = Infinity;
          var $NaN = NaN;
          var abs = Math.abs;
          var pow = Math.pow;
          var push2 = uncurryThis([].push);
          var POW_2_1023 = pow(2, 1023);
          var MAX_SAFE_INTEGER = pow(2, 53) - 1;
          var MAX_DOUBLE = Number.MAX_VALUE;
          var MAX_ULP = pow(2, 971);
          var NOT_A_NUMBER = {};
          var MINUS_INFINITY = {};
          var PLUS_INFINITY = {};
          var MINUS_ZERO = {};
          var FINITE = {};
          var twosum = function(x, y) {
            var hi = x + y;
            var lo = y - (hi - x);
            return { hi, lo };
          };
          $({ target: "Math", stat: true }, {
            // eslint-disable-next-line max-statements -- ok
            sumPrecise: function sumPrecise(items) {
              var numbers = [];
              var count = 0;
              var state = MINUS_ZERO;
              iterate(items, function(n2) {
                if (++count >= MAX_SAFE_INTEGER) throw new $RangeError("Maximum allowed index exceeded");
                if (typeof n2 != "number") throw new $TypeError("Value is not a number");
                if (state !== NOT_A_NUMBER) {
                  if (n2 !== n2) state = NOT_A_NUMBER;
                  else if (n2 === $Infinity) state = state === MINUS_INFINITY ? NOT_A_NUMBER : PLUS_INFINITY;
                  else if (n2 === -$Infinity) state = state === PLUS_INFINITY ? NOT_A_NUMBER : MINUS_INFINITY;
                  else if ((n2 !== 0 || 1 / n2 === $Infinity) && (state === MINUS_ZERO || state === FINITE)) {
                    state = FINITE;
                    push2(numbers, n2);
                  }
                }
              });
              switch (state) {
                case NOT_A_NUMBER:
                  return $NaN;
                case MINUS_INFINITY:
                  return -$Infinity;
                case PLUS_INFINITY:
                  return $Infinity;
                case MINUS_ZERO:
                  return -0;
              }
              var partials = [];
              var overflow = 0;
              var x, y, sum, hi, lo, tmp;
              for (var i = 0; i < numbers.length; i++) {
                x = numbers[i];
                var actuallyUsedPartials = 0;
                for (var j = 0; j < partials.length; j++) {
                  y = partials[j];
                  if (abs(x) < abs(y)) {
                    tmp = x;
                    x = y;
                    y = tmp;
                  }
                  sum = twosum(x, y);
                  hi = sum.hi;
                  lo = sum.lo;
                  if (abs(hi) === $Infinity) {
                    var sign = hi === $Infinity ? 1 : -1;
                    overflow += sign;
                    x = x - sign * POW_2_1023 - sign * POW_2_1023;
                    if (abs(x) < abs(y)) {
                      tmp = x;
                      x = y;
                      y = tmp;
                    }
                    sum = twosum(x, y);
                    hi = sum.hi;
                    lo = sum.lo;
                  }
                  if (lo !== 0) partials[actuallyUsedPartials++] = lo;
                  x = hi;
                }
                partials.length = actuallyUsedPartials;
                if (x !== 0) push2(partials, x);
              }
              var n = partials.length - 1;
              hi = 0;
              lo = 0;
              if (overflow !== 0) {
                var next = n >= 0 ? partials[n] : 0;
                n--;
                if (abs(overflow) > 1 || overflow > 0 && next > 0 || overflow < 0 && next < 0) {
                  return overflow > 0 ? $Infinity : -$Infinity;
                }
                sum = twosum(overflow * POW_2_1023, next / 2);
                hi = sum.hi;
                lo = sum.lo;
                lo *= 2;
                if (abs(2 * hi) === $Infinity) {
                  if (hi > 0) {
                    return hi === POW_2_1023 && lo === -(MAX_ULP / 2) && n >= 0 && partials[n] < 0 ? MAX_DOUBLE : $Infinity;
                  }
                  return hi === -POW_2_1023 && lo === MAX_ULP / 2 && n >= 0 && partials[n] > 0 ? -MAX_DOUBLE : -$Infinity;
                }
                if (lo !== 0) {
                  partials[++n] = lo;
                  lo = 0;
                }
                hi *= 2;
              }
              while (n >= 0) {
                sum = twosum(hi, partials[n--]);
                hi = sum.hi;
                lo = sum.lo;
                if (lo !== 0) break;
              }
              if (n >= 0 && (lo < 0 && partials[n] < 0 || lo > 0 && partials[n] > 0)) {
                y = lo * 2;
                x = hi + y;
                if (y === x - hi) hi = x;
              }
              return hi;
            }
          });
        })
      ),
      /***/
      3167: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var isCallable = __webpack_require__2(4901);
          var isObject3 = __webpack_require__2(34);
          var setPrototypeOf = __webpack_require__2(2967);
          module2.exports = function($this, dummy, Wrapper) {
            var NewTarget, NewTargetPrototype;
            if (
              // it can work only with native `setPrototypeOf`
              setPrototypeOf && // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
              isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject3(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype
            ) setPrototypeOf($this, NewTargetPrototype);
            return $this;
          };
        })
      ),
      /***/
      3238: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var NATIVE_ARRAY_BUFFER = __webpack_require__2(7811);
          var arrayBufferByteLength = __webpack_require__2(7394);
          var DataView2 = globalThis2.DataView;
          module2.exports = function(O) {
            if (!NATIVE_ARRAY_BUFFER || arrayBufferByteLength(O) !== 0) return false;
            try {
              new DataView2(O);
              return false;
            } catch (error) {
              return true;
            }
          };
        })
      ),
      /***/
      3392: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          var id = 0;
          var postfix = Math.random();
          var toString2 = uncurryThis(1.1.toString);
          module2.exports = function(key) {
            return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString2(++id + postfix, 36);
          };
        })
      ),
      /***/
      3440: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var aSet = __webpack_require__2(7080);
          var SetHelpers = __webpack_require__2(4402);
          var clone2 = __webpack_require__2(9286);
          var size2 = __webpack_require__2(5170);
          var getSetRecord = __webpack_require__2(3789);
          var iterateSet = __webpack_require__2(8469);
          var iterateSimple = __webpack_require__2(507);
          var has3 = SetHelpers.has;
          var remove = SetHelpers.remove;
          module2.exports = function difference(other) {
            var O = aSet(this);
            var otherRec = getSetRecord(other);
            var result2 = clone2(O);
            if (size2(O) <= otherRec.size) iterateSet(O, function(e) {
              if (otherRec.includes(e)) remove(result2, e);
            });
            else iterateSimple(otherRec.getIterator(), function(e) {
              if (has3(result2, e)) remove(result2, e);
            });
            return result2;
          };
        })
      ),
      /***/
      3463: (
        /***/
        ((module2) => {
          var $TypeError = TypeError;
          module2.exports = function(argument) {
            if (typeof argument == "string") return argument;
            throw new $TypeError("Argument is not a string");
          };
        })
      ),
      /***/
      3506: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var isPossiblePrototype = __webpack_require__2(3925);
          var $String = String;
          var $TypeError = TypeError;
          module2.exports = function(argument) {
            if (isPossiblePrototype(argument)) return argument;
            throw new $TypeError("Can't set " + $String(argument) + " as a prototype");
          };
        })
      ),
      /***/
      3579: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var call = __webpack_require__2(9565);
          var iterate = __webpack_require__2(2652);
          var aCallable = __webpack_require__2(9306);
          var anObject = __webpack_require__2(8551);
          var getIteratorDirect = __webpack_require__2(1767);
          var iteratorClose = __webpack_require__2(9539);
          var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
          var someWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("some", TypeError);
          $({ target: "Iterator", proto: true, real: true, forced: someWithoutClosingOnEarlyError }, {
            some: function some2(predicate) {
              anObject(this);
              try {
                aCallable(predicate);
              } catch (error) {
                iteratorClose(this, "throw", error);
              }
              if (someWithoutClosingOnEarlyError) return call(someWithoutClosingOnEarlyError, this, predicate);
              var record = getIteratorDirect(this);
              var counter = 0;
              return iterate(record, function(value, stop) {
                if (predicate(value, counter++)) return stop();
              }, { IS_RECORD: true, INTERRUPTED: true }).stopped;
            }
          });
        })
      ),
      /***/
      3650: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var aSet = __webpack_require__2(7080);
          var SetHelpers = __webpack_require__2(4402);
          var clone2 = __webpack_require__2(9286);
          var getSetRecord = __webpack_require__2(3789);
          var iterateSimple = __webpack_require__2(507);
          var add = SetHelpers.add;
          var has3 = SetHelpers.has;
          var remove = SetHelpers.remove;
          module2.exports = function symmetricDifference(other) {
            var O = aSet(this);
            var keysIter = getSetRecord(other).getIterator();
            var result2 = clone2(O);
            iterateSimple(keysIter, function(e) {
              if (has3(O, e)) remove(result2, e);
              else add(result2, e);
            });
            return result2;
          };
        })
      ),
      /***/
      3706: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          var isCallable = __webpack_require__2(4901);
          var store = __webpack_require__2(7629);
          var functionToString = uncurryThis(Function.toString);
          if (!isCallable(store.inspectSource)) {
            store.inspectSource = function(it) {
              return functionToString(it);
            };
          }
          module2.exports = store.inspectSource;
        })
      ),
      /***/
      3717: (
        /***/
        ((__unused_webpack_module, exports2) => {
          exports2.f = Object.getOwnPropertySymbols;
        })
      ),
      /***/
      3724: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var fails = __webpack_require__2(9039);
          module2.exports = !fails(function() {
            return Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1] !== 7;
          });
        })
      ),
      /***/
      3789: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var aCallable = __webpack_require__2(9306);
          var anObject = __webpack_require__2(8551);
          var call = __webpack_require__2(9565);
          var toIntegerOrInfinity = __webpack_require__2(1291);
          var getIteratorDirect = __webpack_require__2(1767);
          var INVALID_SIZE = "Invalid size";
          var $RangeError = RangeError;
          var $TypeError = TypeError;
          var max2 = Math.max;
          var SetRecord = function(set, intSize) {
            this.set = set;
            this.size = max2(intSize, 0);
            this.has = aCallable(set.has);
            this.keys = aCallable(set.keys);
          };
          SetRecord.prototype = {
            getIterator: function() {
              return getIteratorDirect(anObject(call(this.keys, this.set)));
            },
            includes: function(it) {
              return call(this.has, this.set, it);
            }
          };
          module2.exports = function(obj2) {
            anObject(obj2);
            var numSize = +obj2.size;
            if (numSize !== numSize) throw new $TypeError(INVALID_SIZE);
            var intSize = toIntegerOrInfinity(numSize);
            if (intSize < 0) throw new $RangeError(INVALID_SIZE);
            return new SetRecord(obj2, intSize);
          };
        })
      ),
      /***/
      3838: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var aSet = __webpack_require__2(7080);
          var size2 = __webpack_require__2(5170);
          var iterate = __webpack_require__2(8469);
          var getSetRecord = __webpack_require__2(3789);
          module2.exports = function isSubsetOf(other) {
            var O = aSet(this);
            var otherRec = getSetRecord(other);
            if (size2(O) > otherRec.size) return false;
            return iterate(O, function(e) {
              if (!otherRec.includes(e)) return false;
            }, true) !== false;
          };
        })
      ),
      /***/
      3853: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var isDisjointFrom = __webpack_require__2(4449);
          var setMethodAcceptSetLike = __webpack_require__2(4916);
          var INCORRECT = !setMethodAcceptSetLike("isDisjointFrom", function(result2) {
            return !result2;
          });
          $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
            isDisjointFrom
          });
        })
      ),
      /***/
      3925: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var isObject3 = __webpack_require__2(34);
          module2.exports = function(argument) {
            return isObject3(argument) || argument === null;
          };
        })
      ),
      /***/
      3972: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var isObject3 = __webpack_require__2(34);
          var $String = String;
          var $TypeError = TypeError;
          module2.exports = function(argument) {
            if (argument === void 0 || isObject3(argument)) return argument;
            throw new $TypeError($String(argument) + " is not an object or undefined");
          };
        })
      ),
      /***/
      4055: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var isObject3 = __webpack_require__2(34);
          var document2 = globalThis2.document;
          var EXISTS = isObject3(document2) && isObject3(document2.createElement);
          module2.exports = function(it) {
            return EXISTS ? document2.createElement(it) : {};
          };
        })
      ),
      /***/
      4114: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var toObject = __webpack_require__2(8981);
          var lengthOfArrayLike = __webpack_require__2(6198);
          var setArrayLength = __webpack_require__2(4527);
          var doesNotExceedSafeInteger = __webpack_require__2(6837);
          var fails = __webpack_require__2(9039);
          var INCORRECT_TO_LENGTH = fails(function() {
            return [].push.call({ length: 4294967296 }, 1) !== 4294967297;
          });
          var properErrorOnNonWritableLength = function() {
            try {
              Object.defineProperty([], "length", { writable: false }).push();
            } catch (error) {
              return error instanceof TypeError;
            }
          };
          var FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();
          $({ target: "Array", proto: true, arity: 1, forced: FORCED }, {
            // eslint-disable-next-line no-unused-vars -- required for `.length`
            push: function push2(item) {
              var O = toObject(this);
              var len = lengthOfArrayLike(O);
              var argCount = arguments.length;
              doesNotExceedSafeInteger(len + argCount);
              for (var i = 0; i < argCount; i++) {
                O[len] = arguments[i];
                len++;
              }
              setArrayLength(O, len);
              return len;
            }
          });
        })
      ),
      /***/
      4117: (
        /***/
        ((module2) => {
          module2.exports = function(it) {
            return it === null || it === void 0;
          };
        })
      ),
      /***/
      4149: (
        /***/
        ((module2) => {
          var $RangeError = RangeError;
          module2.exports = function(it) {
            if (it === it) return it;
            throw new $RangeError("NaN is not allowed");
          };
        })
      ),
      /***/
      4154: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var classof = __webpack_require__2(6955);
          var $TypeError = TypeError;
          module2.exports = function(argument) {
            if (classof(argument) === "Uint8Array") return argument;
            throw new $TypeError("Argument is not an Uint8Array");
          };
        })
      ),
      /***/
      4204: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var aSet = __webpack_require__2(7080);
          var add = __webpack_require__2(4402).add;
          var clone2 = __webpack_require__2(9286);
          var getSetRecord = __webpack_require__2(3789);
          var iterateSimple = __webpack_require__2(507);
          module2.exports = function union(other) {
            var O = aSet(this);
            var keysIter = getSetRecord(other).getIterator();
            var result2 = clone2(O);
            iterateSimple(keysIter, function(it) {
              add(result2, it);
            });
            return result2;
          };
        })
      ),
      /***/
      4209: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var wellKnownSymbol = __webpack_require__2(8227);
          var Iterators = __webpack_require__2(6269);
          var ITERATOR = wellKnownSymbol("iterator");
          var ArrayPrototype = Array.prototype;
          module2.exports = function(it) {
            return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
          };
        })
      ),
      /***/
      4215: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var userAgent = __webpack_require__2(2839);
          var classof = __webpack_require__2(2195);
          var userAgentStartsWith = function(string) {
            return userAgent.slice(0, string.length) === string;
          };
          module2.exports = (function() {
            if (userAgentStartsWith("Bun/")) return "BUN";
            if (userAgentStartsWith("Cloudflare-Workers")) return "CLOUDFLARE";
            if (userAgentStartsWith("Deno/")) return "DENO";
            if (userAgentStartsWith("Node.js/")) return "NODE";
            if (globalThis2.Bun && typeof Bun.version == "string") return "BUN";
            if (globalThis2.Deno && typeof Deno.version == "object") return "DENO";
            if (classof(globalThis2.process) === "process") return "NODE";
            if (globalThis2.window && globalThis2.document) return "BROWSER";
            return "REST";
          })();
        })
      ),
      /***/
      4226: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var globalThis2 = __webpack_require__2(4576);
          var aString = __webpack_require__2(3463);
          var anUint8Array = __webpack_require__2(4154);
          var notDetached = __webpack_require__2(5169);
          var $fromHex = __webpack_require__2(2303);
          if (globalThis2.Uint8Array) $({ target: "Uint8Array", proto: true }, {
            setFromHex: function setFromHex(string) {
              anUint8Array(this);
              aString(string);
              notDetached(this.buffer);
              var read = $fromHex(string, this).read;
              return { read, written: read / 2 };
            }
          });
        })
      ),
      /***/
      4235: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          __webpack_require__2(3068);
        })
      ),
      /***/
      4270: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var call = __webpack_require__2(9565);
          var isCallable = __webpack_require__2(4901);
          var isObject3 = __webpack_require__2(34);
          var $TypeError = TypeError;
          module2.exports = function(input, pref) {
            var fn, val;
            if (pref === "string" && isCallable(fn = input.toString) && !isObject3(val = call(fn, input))) return val;
            if (isCallable(fn = input.valueOf) && !isObject3(val = call(fn, input))) return val;
            if (pref !== "string" && isCallable(fn = input.toString) && !isObject3(val = call(fn, input))) return val;
            throw new $TypeError("Can't convert object to primitive value");
          };
        })
      ),
      /***/
      4376: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var classof = __webpack_require__2(2195);
          module2.exports = Array.isArray || function isArray(argument) {
            return classof(argument) === "Array";
          };
        })
      ),
      /***/
      4402: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          var SetPrototype = Set.prototype;
          module2.exports = {
            // eslint-disable-next-line es/no-set -- safe
            Set,
            add: uncurryThis(SetPrototype.add),
            has: uncurryThis(SetPrototype.has),
            remove: uncurryThis(SetPrototype["delete"]),
            proto: SetPrototype
          };
        })
      ),
      /***/
      4449: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var aSet = __webpack_require__2(7080);
          var has3 = __webpack_require__2(4402).has;
          var size2 = __webpack_require__2(5170);
          var getSetRecord = __webpack_require__2(3789);
          var iterateSet = __webpack_require__2(8469);
          var iterateSimple = __webpack_require__2(507);
          var iteratorClose = __webpack_require__2(9539);
          module2.exports = function isDisjointFrom(other) {
            var O = aSet(this);
            var otherRec = getSetRecord(other);
            if (size2(O) <= otherRec.size) return iterateSet(O, function(e) {
              if (otherRec.includes(e)) return false;
            }, true) !== false;
            var iterator = otherRec.getIterator();
            return iterateSimple(iterator, function(e) {
              if (has3(O, e)) return iteratorClose(iterator, "normal", false);
            }) !== false;
          };
        })
      ),
      /***/
      4483: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var getBuiltInNodeModule = __webpack_require__2(9429);
          var PROPER_STRUCTURED_CLONE_TRANSFER = __webpack_require__2(1548);
          var structuredClone2 = globalThis2.structuredClone;
          var $ArrayBuffer = globalThis2.ArrayBuffer;
          var $MessageChannel = globalThis2.MessageChannel;
          var detach = false;
          var WorkerThreads, channel, buffer, $detach;
          if (PROPER_STRUCTURED_CLONE_TRANSFER) {
            detach = function(transferable) {
              structuredClone2(transferable, { transfer: [transferable] });
            };
          } else if ($ArrayBuffer) try {
            if (!$MessageChannel) {
              WorkerThreads = getBuiltInNodeModule("worker_threads");
              if (WorkerThreads) $MessageChannel = WorkerThreads.MessageChannel;
            }
            if ($MessageChannel) {
              channel = new $MessageChannel();
              buffer = new $ArrayBuffer(2);
              $detach = function(transferable) {
                channel.port1.postMessage(null, [transferable]);
              };
              if (buffer.byteLength === 2) {
                $detach(buffer);
                if (buffer.byteLength === 0) detach = $detach;
              }
            }
          } catch (error) {
          }
          module2.exports = detach;
        })
      ),
      /***/
      4495: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var V8_VERSION = __webpack_require__2(9519);
          var fails = __webpack_require__2(9039);
          var globalThis2 = __webpack_require__2(4576);
          var $String = globalThis2.String;
          module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
            var symbol = Symbol("symbol detection");
            return !$String(symbol) || !(Object(symbol) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
            !Symbol.sham && V8_VERSION && V8_VERSION < 41;
          });
        })
      ),
      /***/
      4527: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var DESCRIPTORS = __webpack_require__2(3724);
          var isArray = __webpack_require__2(4376);
          var $TypeError = TypeError;
          var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          var SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !(function() {
            if (this !== void 0) return true;
            try {
              Object.defineProperty([], "length", { writable: false }).length = 1;
            } catch (error) {
              return error instanceof TypeError;
            }
          })();
          module2.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function(O, length) {
            if (isArray(O) && !getOwnPropertyDescriptor(O, "length").writable) {
              throw new $TypeError("Cannot set read only .length");
            }
            return O.length = length;
          } : function(O, length) {
            return O.length = length;
          };
        })
      ),
      /***/
      4549: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          module2.exports = function(METHOD_NAME, ExpectedError) {
            var Iterator2 = globalThis2.Iterator;
            var IteratorPrototype = Iterator2 && Iterator2.prototype;
            var method = IteratorPrototype && IteratorPrototype[METHOD_NAME];
            var CLOSED = false;
            if (method) try {
              method.call({
                next: function() {
                  return { done: true };
                },
                "return": function() {
                  CLOSED = true;
                }
              }, -1);
            } catch (error) {
              if (!(error instanceof ExpectedError)) CLOSED = false;
            }
            if (!CLOSED) return method;
          };
        })
      ),
      /***/
      4576: (
        /***/
        (function(module2) {
          var check = function(it) {
            return it && it.Math === Math && it;
          };
          module2.exports = // eslint-disable-next-line es/no-global-this -- safe
          check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
          check(typeof self == "object" && self) || check(typeof global == "object" && global) || check(typeof this == "object" && this) || // eslint-disable-next-line no-new-func -- fallback
          /* @__PURE__ */ (function() {
            return this;
          })() || Function("return this")();
        })
      ),
      /***/
      4603: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var defineBuiltIn = __webpack_require__2(6840);
          var uncurryThis = __webpack_require__2(9504);
          var toString2 = __webpack_require__2(655);
          var validateArgumentsLength = __webpack_require__2(2812);
          var $URLSearchParams = URLSearchParams;
          var URLSearchParamsPrototype = $URLSearchParams.prototype;
          var append = uncurryThis(URLSearchParamsPrototype.append);
          var $delete = uncurryThis(URLSearchParamsPrototype["delete"]);
          var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
          var push2 = uncurryThis([].push);
          var params = new $URLSearchParams("a=1&a=2&b=3");
          params["delete"]("a", 1);
          params["delete"]("b", void 0);
          if (params + "" !== "a=2") {
            defineBuiltIn(URLSearchParamsPrototype, "delete", function(name) {
              var length = arguments.length;
              var $value = length < 2 ? void 0 : arguments[1];
              if (length && $value === void 0) return $delete(this, name);
              var entries = [];
              forEach(this, function(v, k) {
                push2(entries, { key: k, value: v });
              });
              validateArgumentsLength(length, 1);
              var key = toString2(name);
              var value = toString2($value);
              var index = 0;
              var dindex = 0;
              var found = false;
              var entriesLength = entries.length;
              var entry;
              while (index < entriesLength) {
                entry = entries[index++];
                if (found || entry.key === key) {
                  found = true;
                  $delete(this, entry.key);
                } else dindex++;
              }
              while (dindex < entriesLength) {
                entry = entries[dindex++];
                if (!(entry.key === key && entry.value === value)) append(this, entry.key, entry.value);
              }
            }, { enumerable: true, unsafe: true });
          }
        })
      ),
      /***/
      4628: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var newPromiseCapabilityModule = __webpack_require__2(6043);
          $({ target: "Promise", stat: true }, {
            withResolvers: function withResolvers() {
              var promiseCapability = newPromiseCapabilityModule.f(this);
              return {
                promise: promiseCapability.promise,
                resolve: promiseCapability.resolve,
                reject: promiseCapability.reject
              };
            }
          });
        })
      ),
      /***/
      4644: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var NATIVE_ARRAY_BUFFER = __webpack_require__2(7811);
          var DESCRIPTORS = __webpack_require__2(3724);
          var globalThis2 = __webpack_require__2(4576);
          var isCallable = __webpack_require__2(4901);
          var isObject3 = __webpack_require__2(34);
          var hasOwn = __webpack_require__2(9297);
          var classof = __webpack_require__2(6955);
          var tryToString = __webpack_require__2(6823);
          var createNonEnumerableProperty = __webpack_require__2(6699);
          var defineBuiltIn = __webpack_require__2(6840);
          var defineBuiltInAccessor = __webpack_require__2(2106);
          var isPrototypeOf = __webpack_require__2(1625);
          var getPrototypeOf = __webpack_require__2(2787);
          var setPrototypeOf = __webpack_require__2(2967);
          var wellKnownSymbol = __webpack_require__2(8227);
          var uid = __webpack_require__2(3392);
          var InternalStateModule = __webpack_require__2(1181);
          var enforceInternalState = InternalStateModule.enforce;
          var getInternalState = InternalStateModule.get;
          var Int8Array2 = globalThis2.Int8Array;
          var Int8ArrayPrototype = Int8Array2 && Int8Array2.prototype;
          var Uint8ClampedArray2 = globalThis2.Uint8ClampedArray;
          var Uint8ClampedArrayPrototype = Uint8ClampedArray2 && Uint8ClampedArray2.prototype;
          var TypedArray = Int8Array2 && getPrototypeOf(Int8Array2);
          var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
          var ObjectPrototype = Object.prototype;
          var TypeError2 = globalThis2.TypeError;
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var TYPED_ARRAY_TAG = uid("TYPED_ARRAY_TAG");
          var TYPED_ARRAY_CONSTRUCTOR = "TypedArrayConstructor";
          var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(globalThis2.opera) !== "Opera";
          var TYPED_ARRAY_TAG_REQUIRED = false;
          var NAME, Constructor, Prototype;
          var TypedArrayConstructorsList = {
            Int8Array: 1,
            Uint8Array: 1,
            Uint8ClampedArray: 1,
            Int16Array: 2,
            Uint16Array: 2,
            Int32Array: 4,
            Uint32Array: 4,
            Float32Array: 4,
            Float64Array: 8
          };
          var BigIntArrayConstructorsList = {
            BigInt64Array: 8,
            BigUint64Array: 8
          };
          var isView = function isView2(it) {
            if (!isObject3(it)) return false;
            var klass = classof(it);
            return klass === "DataView" || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
          };
          var getTypedArrayConstructor = function(it) {
            var proto = getPrototypeOf(it);
            if (!isObject3(proto)) return;
            var state = getInternalState(proto);
            return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);
          };
          var isTypedArray2 = function(it) {
            if (!isObject3(it)) return false;
            var klass = classof(it);
            return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);
          };
          var aTypedArray = function(it) {
            if (isTypedArray2(it)) return it;
            throw new TypeError2("Target is not a typed array");
          };
          var aTypedArrayConstructor = function(C) {
            if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C))) return C;
            throw new TypeError2(tryToString(C) + " is not a typed array constructor");
          };
          var exportTypedArrayMethod = function(KEY, property2, forced, options) {
            if (!DESCRIPTORS) return;
            if (forced) for (var ARRAY in TypedArrayConstructorsList) {
              var TypedArrayConstructor = globalThis2[ARRAY];
              if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY)) try {
                delete TypedArrayConstructor.prototype[KEY];
              } catch (error) {
                try {
                  TypedArrayConstructor.prototype[KEY] = property2;
                } catch (error2) {
                }
              }
            }
            if (!TypedArrayPrototype[KEY] || forced) {
              defineBuiltIn(TypedArrayPrototype, KEY, forced ? property2 : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property2, options);
            }
          };
          var exportTypedArrayStaticMethod = function(KEY, property2, forced) {
            var ARRAY, TypedArrayConstructor;
            if (!DESCRIPTORS) return;
            if (setPrototypeOf) {
              if (forced) for (ARRAY in TypedArrayConstructorsList) {
                TypedArrayConstructor = globalThis2[ARRAY];
                if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY)) try {
                  delete TypedArrayConstructor[KEY];
                } catch (error) {
                }
              }
              if (!TypedArray[KEY] || forced) {
                try {
                  return defineBuiltIn(TypedArray, KEY, forced ? property2 : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property2);
                } catch (error) {
                }
              } else return;
            }
            for (ARRAY in TypedArrayConstructorsList) {
              TypedArrayConstructor = globalThis2[ARRAY];
              if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
                defineBuiltIn(TypedArrayConstructor, KEY, property2);
              }
            }
          };
          for (NAME in TypedArrayConstructorsList) {
            Constructor = globalThis2[NAME];
            Prototype = Constructor && Constructor.prototype;
            if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
            else NATIVE_ARRAY_BUFFER_VIEWS = false;
          }
          for (NAME in BigIntArrayConstructorsList) {
            Constructor = globalThis2[NAME];
            Prototype = Constructor && Constructor.prototype;
            if (Prototype) enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;
          }
          if (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {
            TypedArray = function TypedArray2() {
              throw new TypeError2("Incorrect invocation");
            };
            if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
              if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME], TypedArray);
            }
          }
          if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
            TypedArrayPrototype = TypedArray.prototype;
            if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
              if (globalThis2[NAME]) setPrototypeOf(globalThis2[NAME].prototype, TypedArrayPrototype);
            }
          }
          if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
            setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
          }
          if (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {
            TYPED_ARRAY_TAG_REQUIRED = true;
            defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {
              configurable: true,
              get: function() {
                return isObject3(this) ? this[TYPED_ARRAY_TAG] : void 0;
              }
            });
            for (NAME in TypedArrayConstructorsList) if (globalThis2[NAME]) {
              createNonEnumerableProperty(globalThis2[NAME], TYPED_ARRAY_TAG, NAME);
            }
          }
          module2.exports = {
            NATIVE_ARRAY_BUFFER_VIEWS,
            TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,
            aTypedArray,
            aTypedArrayConstructor,
            exportTypedArrayMethod,
            exportTypedArrayStaticMethod,
            getTypedArrayConstructor,
            isView,
            isTypedArray: isTypedArray2,
            TypedArray,
            TypedArrayPrototype
          };
        })
      ),
      /***/
      4659: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var DESCRIPTORS = __webpack_require__2(3724);
          var definePropertyModule = __webpack_require__2(4913);
          var createPropertyDescriptor = __webpack_require__2(6980);
          module2.exports = function(object2, key, value) {
            if (DESCRIPTORS) definePropertyModule.f(object2, key, createPropertyDescriptor(0, value));
            else object2[key] = value;
          };
        })
      ),
      /***/
      4901: (
        /***/
        ((module2) => {
          var documentAll = typeof document == "object" && document.all;
          module2.exports = typeof documentAll == "undefined" && documentAll !== void 0 ? function(argument) {
            return typeof argument == "function" || argument === documentAll;
          } : function(argument) {
            return typeof argument == "function";
          };
        })
      ),
      /***/
      4913: (
        /***/
        ((__unused_webpack_module, exports2, __webpack_require__2) => {
          var DESCRIPTORS = __webpack_require__2(3724);
          var IE8_DOM_DEFINE = __webpack_require__2(5917);
          var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__2(8686);
          var anObject = __webpack_require__2(8551);
          var toPropertyKey = __webpack_require__2(6969);
          var $TypeError = TypeError;
          var $defineProperty = Object.defineProperty;
          var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          var ENUMERABLE = "enumerable";
          var CONFIGURABLE = "configurable";
          var WRITABLE = "writable";
          exports2.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPropertyKey(P);
            anObject(Attributes);
            if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
              var current = $getOwnPropertyDescriptor(O, P);
              if (current && current[WRITABLE]) {
                O[P] = Attributes.value;
                Attributes = {
                  configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],
                  enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
                  writable: false
                };
              }
            }
            return $defineProperty(O, P, Attributes);
          } : $defineProperty : function defineProperty(O, P, Attributes) {
            anObject(O);
            P = toPropertyKey(P);
            anObject(Attributes);
            if (IE8_DOM_DEFINE) try {
              return $defineProperty(O, P, Attributes);
            } catch (error) {
            }
            if ("get" in Attributes || "set" in Attributes) throw new $TypeError("Accessors not supported");
            if ("value" in Attributes) O[P] = Attributes.value;
            return O;
          };
        })
      ),
      /***/
      4916: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var getBuiltIn = __webpack_require__2(7751);
          var createSetLike = function(size2) {
            return {
              size: size2,
              has: function() {
                return false;
              },
              keys: function() {
                return {
                  next: function() {
                    return { done: true };
                  }
                };
              }
            };
          };
          var createSetLikeWithInfinitySize = function(size2) {
            return {
              size: size2,
              has: function() {
                return true;
              },
              keys: function() {
                throw new Error("e");
              }
            };
          };
          module2.exports = function(name, callback) {
            var Set2 = getBuiltIn("Set");
            try {
              new Set2()[name](createSetLike(0));
              try {
                new Set2()[name](createSetLike(-1));
                return false;
              } catch (error2) {
                if (!callback) return true;
                try {
                  new Set2()[name](createSetLikeWithInfinitySize(-Infinity));
                  return false;
                } catch (error) {
                  var set = new Set2();
                  set.add(1);
                  set.add(2);
                  return callback(set[name](createSetLikeWithInfinitySize(Infinity)));
                }
              }
            } catch (error) {
              return false;
            }
          };
        })
      ),
      /***/
      4972: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var call = __webpack_require__2(9565);
          var anObject = __webpack_require__2(8551);
          var getIteratorDirect = __webpack_require__2(1767);
          var notANaN = __webpack_require__2(4149);
          var toPositiveInteger = __webpack_require__2(9590);
          var createIteratorProxy = __webpack_require__2(9462);
          var iteratorClose = __webpack_require__2(9539);
          var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
          var IS_PURE = __webpack_require__2(6395);
          var takeWithoutClosingOnEarlyError = !IS_PURE && iteratorHelperWithoutClosingOnEarlyError("take", RangeError);
          var IteratorProxy = createIteratorProxy(function() {
            var iterator = this.iterator;
            if (!this.remaining--) {
              this.done = true;
              return iteratorClose(iterator, "normal", void 0);
            }
            var result2 = anObject(call(this.next, iterator));
            var done = this.done = !!result2.done;
            if (!done) return result2.value;
          });
          $({ target: "Iterator", proto: true, real: true, forced: IS_PURE || takeWithoutClosingOnEarlyError }, {
            take: function take(limit) {
              anObject(this);
              var remaining;
              try {
                remaining = toPositiveInteger(notANaN(+limit));
              } catch (error) {
                iteratorClose(this, "throw", error);
              }
              if (takeWithoutClosingOnEarlyError) return call(takeWithoutClosingOnEarlyError, this, remaining);
              return new IteratorProxy(getIteratorDirect(this), {
                remaining
              });
            }
          });
        })
      ),
      /***/
      4979: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var globalThis2 = __webpack_require__2(4576);
          var getBuiltIn = __webpack_require__2(7751);
          var createPropertyDescriptor = __webpack_require__2(6980);
          var defineProperty = __webpack_require__2(4913).f;
          var hasOwn = __webpack_require__2(9297);
          var anInstance = __webpack_require__2(679);
          var inheritIfRequired = __webpack_require__2(3167);
          var normalizeStringArgument = __webpack_require__2(2603);
          var DOMExceptionConstants = __webpack_require__2(5002);
          var clearErrorStack = __webpack_require__2(8574);
          var DESCRIPTORS = __webpack_require__2(3724);
          var IS_PURE = __webpack_require__2(6395);
          var DOM_EXCEPTION = "DOMException";
          var Error2 = getBuiltIn("Error");
          var NativeDOMException = getBuiltIn(DOM_EXCEPTION);
          var $DOMException = function DOMException() {
            anInstance(this, DOMExceptionPrototype);
            var argumentsLength = arguments.length;
            var message = normalizeStringArgument(argumentsLength < 1 ? void 0 : arguments[0]);
            var name = normalizeStringArgument(argumentsLength < 2 ? void 0 : arguments[1], "Error");
            var that = new NativeDOMException(message, name);
            var error = new Error2(message);
            error.name = DOM_EXCEPTION;
            defineProperty(that, "stack", createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));
            inheritIfRequired(that, this, $DOMException);
            return that;
          };
          var DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;
          var ERROR_HAS_STACK = "stack" in new Error2(DOM_EXCEPTION);
          var DOM_EXCEPTION_HAS_STACK = "stack" in new NativeDOMException(1, 2);
          var descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(globalThis2, DOM_EXCEPTION);
          var BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);
          var FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;
          $({ global: true, constructor: true, forced: IS_PURE || FORCED_CONSTRUCTOR }, {
            // TODO: fix export logic
            DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException
          });
          var PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);
          var PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;
          if (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {
            if (!IS_PURE) {
              defineProperty(PolyfilledDOMExceptionPrototype, "constructor", createPropertyDescriptor(1, PolyfilledDOMException));
            }
            for (var key in DOMExceptionConstants) if (hasOwn(DOMExceptionConstants, key)) {
              var constant2 = DOMExceptionConstants[key];
              var constantName = constant2.s;
              if (!hasOwn(PolyfilledDOMException, constantName)) {
                defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant2.c));
              }
            }
          }
        })
      ),
      /***/
      5002: (
        /***/
        ((module2) => {
          module2.exports = {
            IndexSizeError: { s: "INDEX_SIZE_ERR", c: 1, m: 1 },
            DOMStringSizeError: { s: "DOMSTRING_SIZE_ERR", c: 2, m: 0 },
            HierarchyRequestError: { s: "HIERARCHY_REQUEST_ERR", c: 3, m: 1 },
            WrongDocumentError: { s: "WRONG_DOCUMENT_ERR", c: 4, m: 1 },
            InvalidCharacterError: { s: "INVALID_CHARACTER_ERR", c: 5, m: 1 },
            NoDataAllowedError: { s: "NO_DATA_ALLOWED_ERR", c: 6, m: 0 },
            NoModificationAllowedError: { s: "NO_MODIFICATION_ALLOWED_ERR", c: 7, m: 1 },
            NotFoundError: { s: "NOT_FOUND_ERR", c: 8, m: 1 },
            NotSupportedError: { s: "NOT_SUPPORTED_ERR", c: 9, m: 1 },
            InUseAttributeError: { s: "INUSE_ATTRIBUTE_ERR", c: 10, m: 1 },
            InvalidStateError: { s: "INVALID_STATE_ERR", c: 11, m: 1 },
            SyntaxError: { s: "SYNTAX_ERR", c: 12, m: 1 },
            InvalidModificationError: { s: "INVALID_MODIFICATION_ERR", c: 13, m: 1 },
            NamespaceError: { s: "NAMESPACE_ERR", c: 14, m: 1 },
            InvalidAccessError: { s: "INVALID_ACCESS_ERR", c: 15, m: 1 },
            ValidationError: { s: "VALIDATION_ERR", c: 16, m: 0 },
            TypeMismatchError: { s: "TYPE_MISMATCH_ERR", c: 17, m: 1 },
            SecurityError: { s: "SECURITY_ERR", c: 18, m: 1 },
            NetworkError: { s: "NETWORK_ERR", c: 19, m: 1 },
            AbortError: { s: "ABORT_ERR", c: 20, m: 1 },
            URLMismatchError: { s: "URL_MISMATCH_ERR", c: 21, m: 1 },
            QuotaExceededError: { s: "QUOTA_EXCEEDED_ERR", c: 22, m: 1 },
            TimeoutError: { s: "TIMEOUT_ERR", c: 23, m: 1 },
            InvalidNodeTypeError: { s: "INVALID_NODE_TYPE_ERR", c: 24, m: 1 },
            DataCloneError: { s: "DATA_CLONE_ERR", c: 25, m: 1 }
          };
        })
      ),
      /***/
      5024: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var symmetricDifference = __webpack_require__2(3650);
          var setMethodGetKeysBeforeCloning = __webpack_require__2(9835);
          var setMethodAcceptSetLike = __webpack_require__2(4916);
          var FORCED = !setMethodAcceptSetLike("symmetricDifference") || !setMethodGetKeysBeforeCloning("symmetricDifference");
          $({ target: "Set", proto: true, real: true, forced: FORCED }, {
            symmetricDifference
          });
        })
      ),
      /***/
      5031: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var getBuiltIn = __webpack_require__2(7751);
          var uncurryThis = __webpack_require__2(9504);
          var getOwnPropertyNamesModule = __webpack_require__2(8480);
          var getOwnPropertySymbolsModule = __webpack_require__2(3717);
          var anObject = __webpack_require__2(8551);
          var concat = uncurryThis([].concat);
          module2.exports = getBuiltIn("Reflect", "ownKeys") || function ownKeys(it) {
            var keys2 = getOwnPropertyNamesModule.f(anObject(it));
            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
            return getOwnPropertySymbols ? concat(keys2, getOwnPropertySymbols(it)) : keys2;
          };
        })
      ),
      /***/
      5169: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var isDetached = __webpack_require__2(3238);
          var $TypeError = TypeError;
          module2.exports = function(it) {
            if (isDetached(it)) throw new $TypeError("ArrayBuffer is detached");
            return it;
          };
        })
      ),
      /***/
      5170: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThisAccessor = __webpack_require__2(6706);
          var SetHelpers = __webpack_require__2(4402);
          module2.exports = uncurryThisAccessor(SetHelpers.proto, "size", "get") || function(set) {
            return set.size;
          };
        })
      ),
      /***/
      5213: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var globalThis2 = __webpack_require__2(4576);
          var arrayFromConstructorAndList = __webpack_require__2(5370);
          var $fromBase64 = __webpack_require__2(9143);
          var Uint8Array2 = globalThis2.Uint8Array;
          var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.fromBase64 || !(function() {
            try {
              Uint8Array2.fromBase64("a");
              return;
            } catch (error) {
            }
            try {
              Uint8Array2.fromBase64("", null);
            } catch (error) {
              return true;
            }
          })();
          if (Uint8Array2) $({ target: "Uint8Array", stat: true, forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS }, {
            fromBase64: function fromBase64(string) {
              var result2 = $fromBase64(string, arguments.length > 1 ? arguments[1] : void 0, null, 9007199254740991);
              return arrayFromConstructorAndList(Uint8Array2, result2.bytes);
            }
          });
        })
      ),
      /***/
      5370: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var lengthOfArrayLike = __webpack_require__2(6198);
          module2.exports = function(Constructor, list, $length) {
            var index = 0;
            var length = arguments.length > 2 ? $length : lengthOfArrayLike(list);
            var result2 = new Constructor(length);
            while (length > index) result2[index] = list[index++];
            return result2;
          };
        })
      ),
      /***/
      5397: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var IndexedObject = __webpack_require__2(7055);
          var requireObjectCoercible = __webpack_require__2(7750);
          module2.exports = function(it) {
            return IndexedObject(requireObjectCoercible(it));
          };
        })
      ),
      /***/
      5610: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var toIntegerOrInfinity = __webpack_require__2(1291);
          var max2 = Math.max;
          var min2 = Math.min;
          module2.exports = function(index, length) {
            var integer = toIntegerOrInfinity(index);
            return integer < 0 ? max2(integer + length, 0) : min2(integer, length);
          };
        })
      ),
      /***/
      5623: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          __webpack_require__2(456);
        })
      ),
      /***/
      5636: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var uncurryThis = __webpack_require__2(9504);
          var uncurryThisAccessor = __webpack_require__2(6706);
          var toIndex = __webpack_require__2(7696);
          var notDetached = __webpack_require__2(5169);
          var arrayBufferByteLength = __webpack_require__2(7394);
          var detachTransferable = __webpack_require__2(4483);
          var PROPER_STRUCTURED_CLONE_TRANSFER = __webpack_require__2(1548);
          var structuredClone2 = globalThis2.structuredClone;
          var ArrayBuffer2 = globalThis2.ArrayBuffer;
          var DataView2 = globalThis2.DataView;
          var min2 = Math.min;
          var ArrayBufferPrototype = ArrayBuffer2.prototype;
          var DataViewPrototype = DataView2.prototype;
          var slice2 = uncurryThis(ArrayBufferPrototype.slice);
          var isResizable = uncurryThisAccessor(ArrayBufferPrototype, "resizable", "get");
          var maxByteLength = uncurryThisAccessor(ArrayBufferPrototype, "maxByteLength", "get");
          var getInt8 = uncurryThis(DataViewPrototype.getInt8);
          var setInt8 = uncurryThis(DataViewPrototype.setInt8);
          module2.exports = (PROPER_STRUCTURED_CLONE_TRANSFER || detachTransferable) && function(arrayBuffer, newLength, preserveResizability) {
            var byteLength = arrayBufferByteLength(arrayBuffer);
            var newByteLength = newLength === void 0 ? byteLength : toIndex(newLength);
            var fixedLength = !isResizable || !isResizable(arrayBuffer);
            var newBuffer;
            notDetached(arrayBuffer);
            if (PROPER_STRUCTURED_CLONE_TRANSFER) {
              arrayBuffer = structuredClone2(arrayBuffer, { transfer: [arrayBuffer] });
              if (byteLength === newByteLength && (preserveResizability || fixedLength)) return arrayBuffer;
            }
            if (byteLength >= newByteLength && (!preserveResizability || fixedLength)) {
              newBuffer = slice2(arrayBuffer, 0, newByteLength);
            } else {
              var options = preserveResizability && !fixedLength && maxByteLength ? { maxByteLength: maxByteLength(arrayBuffer) } : void 0;
              newBuffer = new ArrayBuffer2(newByteLength, options);
              var a = new DataView2(arrayBuffer);
              var b = new DataView2(newBuffer);
              var copyLength = min2(newByteLength, byteLength);
              for (var i = 0; i < copyLength; i++) setInt8(b, i, getInt8(a, i));
            }
            if (!PROPER_STRUCTURED_CLONE_TRANSFER) detachTransferable(arrayBuffer);
            return newBuffer;
          };
        })
      ),
      /***/
      5745: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var store = __webpack_require__2(7629);
          module2.exports = function(key, value) {
            return store[key] || (store[key] = value || {});
          };
        })
      ),
      /***/
      5781: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var getBuiltIn = __webpack_require__2(7751);
          var validateArgumentsLength = __webpack_require__2(2812);
          var toString2 = __webpack_require__2(655);
          var USE_NATIVE_URL = __webpack_require__2(7416);
          var URL2 = getBuiltIn("URL");
          $({ target: "URL", stat: true, forced: !USE_NATIVE_URL }, {
            parse: function parse2(url) {
              var length = validateArgumentsLength(arguments.length, 1);
              var urlString = toString2(url);
              var base = length < 2 || arguments[1] === void 0 ? void 0 : toString2(arguments[1]);
              try {
                return new URL2(urlString, base);
              } catch (error) {
                return null;
              }
            }
          });
        })
      ),
      /***/
      5854: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var toPrimitive = __webpack_require__2(2777);
          var $TypeError = TypeError;
          module2.exports = function(argument) {
            var prim = toPrimitive(argument, "number");
            if (typeof prim == "number") throw new $TypeError("Can't convert number to bigint");
            return BigInt(prim);
          };
        })
      ),
      /***/
      5876: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var isSubsetOf = __webpack_require__2(3838);
          var setMethodAcceptSetLike = __webpack_require__2(4916);
          var INCORRECT = !setMethodAcceptSetLike("isSubsetOf", function(result2) {
            return result2;
          });
          $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
            isSubsetOf
          });
        })
      ),
      /***/
      5917: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var DESCRIPTORS = __webpack_require__2(3724);
          var fails = __webpack_require__2(9039);
          var createElement = __webpack_require__2(4055);
          module2.exports = !DESCRIPTORS && !fails(function() {
            return Object.defineProperty(createElement("div"), "a", {
              get: function() {
                return 7;
              }
            }).a !== 7;
          });
        })
      ),
      /***/
      5966: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var aCallable = __webpack_require__2(9306);
          var isNullOrUndefined = __webpack_require__2(4117);
          module2.exports = function(V, P) {
            var func = V[P];
            return isNullOrUndefined(func) ? void 0 : aCallable(func);
          };
        })
      ),
      /***/
      6043: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var aCallable = __webpack_require__2(9306);
          var $TypeError = TypeError;
          var PromiseCapability = function(C) {
            var resolve, reject2;
            this.promise = new C(function($$resolve, $$reject) {
              if (resolve !== void 0 || reject2 !== void 0) throw new $TypeError("Bad Promise constructor");
              resolve = $$resolve;
              reject2 = $$reject;
            });
            this.resolve = aCallable(resolve);
            this.reject = aCallable(reject2);
          };
          module2.exports.f = function(C) {
            return new PromiseCapability(C);
          };
        })
      ),
      /***/
      6080: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(7476);
          var aCallable = __webpack_require__2(9306);
          var NATIVE_BIND = __webpack_require__2(616);
          var bind = uncurryThis(uncurryThis.bind);
          module2.exports = function(fn, that) {
            aCallable(fn);
            return that === void 0 ? fn : NATIVE_BIND ? bind(fn, that) : function() {
              return fn.apply(that, arguments);
            };
          };
        })
      ),
      /***/
      6119: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var shared = __webpack_require__2(5745);
          var uid = __webpack_require__2(3392);
          var keys2 = shared("keys");
          module2.exports = function(key) {
            return keys2[key] || (keys2[key] = uid(key));
          };
        })
      ),
      /***/
      6193: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var ENVIRONMENT = __webpack_require__2(4215);
          module2.exports = ENVIRONMENT === "NODE";
        })
      ),
      /***/
      6198: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var toLength = __webpack_require__2(8014);
          module2.exports = function(obj2) {
            return toLength(obj2.length);
          };
        })
      ),
      /***/
      6269: (
        /***/
        ((module2) => {
          module2.exports = {};
        })
      ),
      /***/
      6279: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var defineBuiltIn = __webpack_require__2(6840);
          module2.exports = function(target, src, options) {
            for (var key in src) defineBuiltIn(target, key, src[key], options);
            return target;
          };
        })
      ),
      /***/
      6319: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var anObject = __webpack_require__2(8551);
          var iteratorClose = __webpack_require__2(9539);
          module2.exports = function(iterator, fn, value, ENTRIES) {
            try {
              return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
            } catch (error) {
              iteratorClose(iterator, "throw", error);
            }
          };
        })
      ),
      /***/
      6395: (
        /***/
        ((module2) => {
          module2.exports = false;
        })
      ),
      /***/
      6518: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var getOwnPropertyDescriptor = __webpack_require__2(7347).f;
          var createNonEnumerableProperty = __webpack_require__2(6699);
          var defineBuiltIn = __webpack_require__2(6840);
          var defineGlobalProperty = __webpack_require__2(9433);
          var copyConstructorProperties = __webpack_require__2(7740);
          var isForced = __webpack_require__2(2796);
          module2.exports = function(options, source) {
            var TARGET = options.target;
            var GLOBAL = options.global;
            var STATIC = options.stat;
            var FORCED, target, key, targetProperty, sourceProperty, descriptor;
            if (GLOBAL) {
              target = globalThis2;
            } else if (STATIC) {
              target = globalThis2[TARGET] || defineGlobalProperty(TARGET, {});
            } else {
              target = globalThis2[TARGET] && globalThis2[TARGET].prototype;
            }
            if (target) for (key in source) {
              sourceProperty = source[key];
              if (options.dontCallGetSet) {
                descriptor = getOwnPropertyDescriptor(target, key);
                targetProperty = descriptor && descriptor.value;
              } else targetProperty = target[key];
              FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
              if (!FORCED && targetProperty !== void 0) {
                if (typeof sourceProperty == typeof targetProperty) continue;
                copyConstructorProperties(sourceProperty, targetProperty);
              }
              if (options.sham || targetProperty && targetProperty.sham) {
                createNonEnumerableProperty(sourceProperty, "sham", true);
              }
              defineBuiltIn(target, key, sourceProperty, options);
            }
          };
        })
      ),
      /***/
      6573: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var DESCRIPTORS = __webpack_require__2(3724);
          var defineBuiltInAccessor = __webpack_require__2(2106);
          var isDetached = __webpack_require__2(3238);
          var ArrayBufferPrototype = ArrayBuffer.prototype;
          if (DESCRIPTORS && !("detached" in ArrayBufferPrototype)) {
            defineBuiltInAccessor(ArrayBufferPrototype, "detached", {
              configurable: true,
              get: function detached() {
                return isDetached(this);
              }
            });
          }
        })
      ),
      /***/
      6632: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var globalThis2 = __webpack_require__2(4576);
          var $fromBase64 = __webpack_require__2(9143);
          var anUint8Array = __webpack_require__2(4154);
          var Uint8Array2 = globalThis2.Uint8Array;
          var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.prototype.setFromBase64 || !(function() {
            var target = new Uint8Array2([255, 255, 255, 255, 255]);
            try {
              target.setFromBase64("", null);
              return;
            } catch (error) {
            }
            try {
              target.setFromBase64("a");
              return;
            } catch (error) {
            }
            try {
              target.setFromBase64("MjYyZg===");
            } catch (error) {
              return target[0] === 50 && target[1] === 54 && target[2] === 50 && target[3] === 255 && target[4] === 255;
            }
          })();
          if (Uint8Array2) $({ target: "Uint8Array", proto: true, forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS }, {
            setFromBase64: function setFromBase64(string) {
              anUint8Array(this);
              var result2 = $fromBase64(string, arguments.length > 1 ? arguments[1] : void 0, this, this.length);
              return { read: result2.read, written: result2.written };
            }
          });
        })
      ),
      /***/
      6699: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var DESCRIPTORS = __webpack_require__2(3724);
          var definePropertyModule = __webpack_require__2(4913);
          var createPropertyDescriptor = __webpack_require__2(6980);
          module2.exports = DESCRIPTORS ? function(object2, key, value) {
            return definePropertyModule.f(object2, key, createPropertyDescriptor(1, value));
          } : function(object2, key, value) {
            object2[key] = value;
            return object2;
          };
        })
      ),
      /***/
      6706: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          var aCallable = __webpack_require__2(9306);
          module2.exports = function(object2, key, method) {
            try {
              return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object2, key)[method]));
            } catch (error) {
            }
          };
        })
      ),
      /***/
      6801: (
        /***/
        ((__unused_webpack_module, exports2, __webpack_require__2) => {
          var DESCRIPTORS = __webpack_require__2(3724);
          var V8_PROTOTYPE_DEFINE_BUG = __webpack_require__2(8686);
          var definePropertyModule = __webpack_require__2(4913);
          var anObject = __webpack_require__2(8551);
          var toIndexedObject = __webpack_require__2(5397);
          var objectKeys = __webpack_require__2(1072);
          exports2.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
            anObject(O);
            var props = toIndexedObject(Properties);
            var keys2 = objectKeys(Properties);
            var length = keys2.length;
            var index = 0;
            var key;
            while (length > index) definePropertyModule.f(O, key = keys2[index++], props[key]);
            return O;
          };
        })
      ),
      /***/
      6823: (
        /***/
        ((module2) => {
          var $String = String;
          module2.exports = function(argument) {
            try {
              return $String(argument);
            } catch (error) {
              return "Object";
            }
          };
        })
      ),
      /***/
      6837: (
        /***/
        ((module2) => {
          var $TypeError = TypeError;
          var MAX_SAFE_INTEGER = 9007199254740991;
          module2.exports = function(it) {
            if (it > MAX_SAFE_INTEGER) throw $TypeError("Maximum allowed index exceeded");
            return it;
          };
        })
      ),
      /***/
      6840: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var isCallable = __webpack_require__2(4901);
          var definePropertyModule = __webpack_require__2(4913);
          var makeBuiltIn = __webpack_require__2(283);
          var defineGlobalProperty = __webpack_require__2(9433);
          module2.exports = function(O, key, value, options) {
            if (!options) options = {};
            var simple = options.enumerable;
            var name = options.name !== void 0 ? options.name : key;
            if (isCallable(value)) makeBuiltIn(value, name, options);
            if (options.global) {
              if (simple) O[key] = value;
              else defineGlobalProperty(key, value);
            } else {
              try {
                if (!options.unsafe) delete O[key];
                else if (O[key]) simple = true;
              } catch (error) {
              }
              if (simple) O[key] = value;
              else definePropertyModule.f(O, key, {
                value,
                enumerable: false,
                configurable: !options.nonConfigurable,
                writable: !options.nonWritable
              });
            }
            return O;
          };
        })
      ),
      /***/
      6955: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var TO_STRING_TAG_SUPPORT = __webpack_require__2(2140);
          var isCallable = __webpack_require__2(4901);
          var classofRaw = __webpack_require__2(2195);
          var wellKnownSymbol = __webpack_require__2(8227);
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var $Object = Object;
          var CORRECT_ARGUMENTS = classofRaw(/* @__PURE__ */ (function() {
            return arguments;
          })()) === "Arguments";
          var tryGet = function(it, key) {
            try {
              return it[key];
            } catch (error) {
            }
          };
          module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
            var O, tag, result2;
            return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result2 = classofRaw(O)) === "Object" && isCallable(O.callee) ? "Arguments" : result2;
          };
        })
      ),
      /***/
      6969: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var toPrimitive = __webpack_require__2(2777);
          var isSymbol = __webpack_require__2(757);
          module2.exports = function(argument) {
            var key = toPrimitive(argument, "string");
            return isSymbol(key) ? key : key + "";
          };
        })
      ),
      /***/
      6980: (
        /***/
        ((module2) => {
          module2.exports = function(bitmap, value) {
            return {
              enumerable: !(bitmap & 1),
              configurable: !(bitmap & 2),
              writable: !(bitmap & 4),
              value
            };
          };
        })
      ),
      /***/
      7040: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var NATIVE_SYMBOL = __webpack_require__2(4495);
          module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
        })
      ),
      /***/
      7055: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          var fails = __webpack_require__2(9039);
          var classof = __webpack_require__2(2195);
          var $Object = Object;
          var split = uncurryThis("".split);
          module2.exports = fails(function() {
            return !$Object("z").propertyIsEnumerable(0);
          }) ? function(it) {
            return classof(it) === "String" ? split(it, "") : $Object(it);
          } : $Object;
        })
      ),
      /***/
      7080: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var has3 = __webpack_require__2(4402).has;
          module2.exports = function(it) {
            has3(it);
            return it;
          };
        })
      ),
      /***/
      7347: (
        /***/
        ((__unused_webpack_module, exports2, __webpack_require__2) => {
          var DESCRIPTORS = __webpack_require__2(3724);
          var call = __webpack_require__2(9565);
          var propertyIsEnumerableModule = __webpack_require__2(8773);
          var createPropertyDescriptor = __webpack_require__2(6980);
          var toIndexedObject = __webpack_require__2(5397);
          var toPropertyKey = __webpack_require__2(6969);
          var hasOwn = __webpack_require__2(9297);
          var IE8_DOM_DEFINE = __webpack_require__2(5917);
          var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
            O = toIndexedObject(O);
            P = toPropertyKey(P);
            if (IE8_DOM_DEFINE) try {
              return $getOwnPropertyDescriptor(O, P);
            } catch (error) {
            }
            if (hasOwn(O, P)) return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);
          };
        })
      ),
      /***/
      7394: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var uncurryThisAccessor = __webpack_require__2(6706);
          var classof = __webpack_require__2(2195);
          var ArrayBuffer2 = globalThis2.ArrayBuffer;
          var TypeError2 = globalThis2.TypeError;
          module2.exports = ArrayBuffer2 && uncurryThisAccessor(ArrayBuffer2.prototype, "byteLength", "get") || function(O) {
            if (classof(O) !== "ArrayBuffer") throw new TypeError2("ArrayBuffer expected");
            return O.byteLength;
          };
        })
      ),
      /***/
      7416: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var fails = __webpack_require__2(9039);
          var wellKnownSymbol = __webpack_require__2(8227);
          var DESCRIPTORS = __webpack_require__2(3724);
          var IS_PURE = __webpack_require__2(6395);
          var ITERATOR = wellKnownSymbol("iterator");
          module2.exports = !fails(function() {
            var url = new URL("b?a=1&b=2&c=3", "https://a");
            var params = url.searchParams;
            var params2 = new URLSearchParams("a=1&a=2&b=3");
            var result2 = "";
            url.pathname = "c%20d";
            params.forEach(function(value, key) {
              params["delete"]("b");
              result2 += key + value;
            });
            params2["delete"]("a", 2);
            params2["delete"]("b", void 0);
            return IS_PURE && (!url.toJSON || !params2.has("a", 1) || params2.has("a", 2) || !params2.has("a", void 0) || params2.has("b")) || !params.size && (IS_PURE || !DESCRIPTORS) || !params.sort || url.href !== "https://a/c%20d?a=1&c=3" || params.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !params[ITERATOR] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("https://\u0442\u0435\u0441\u0442").host !== "xn--e1aybc" || new URL("https://a#\u0431").hash !== "#%D0%B1" || result2 !== "a1c3" || new URL("https://x", void 0).host !== "x";
          });
        })
      ),
      /***/
      7476: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var classofRaw = __webpack_require__2(2195);
          var uncurryThis = __webpack_require__2(9504);
          module2.exports = function(fn) {
            if (classofRaw(fn) === "Function") return uncurryThis(fn);
          };
        })
      ),
      /***/
      7566: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var defineBuiltIn = __webpack_require__2(6840);
          var uncurryThis = __webpack_require__2(9504);
          var toString2 = __webpack_require__2(655);
          var validateArgumentsLength = __webpack_require__2(2812);
          var $URLSearchParams = URLSearchParams;
          var URLSearchParamsPrototype = $URLSearchParams.prototype;
          var getAll = uncurryThis(URLSearchParamsPrototype.getAll);
          var $has = uncurryThis(URLSearchParamsPrototype.has);
          var params = new $URLSearchParams("a=1");
          if (params.has("a", 2) || !params.has("a", void 0)) {
            defineBuiltIn(URLSearchParamsPrototype, "has", function has3(name) {
              var length = arguments.length;
              var $value = length < 2 ? void 0 : arguments[1];
              if (length && $value === void 0) return $has(this, name);
              var values2 = getAll(this, name);
              validateArgumentsLength(length, 1);
              var value = toString2($value);
              var index = 0;
              while (index < values2.length) {
                if (values2[index++] === value) return true;
              }
              return false;
            }, { enumerable: true, unsafe: true });
          }
        })
      ),
      /***/
      7588: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var call = __webpack_require__2(9565);
          var iterate = __webpack_require__2(2652);
          var aCallable = __webpack_require__2(9306);
          var anObject = __webpack_require__2(8551);
          var getIteratorDirect = __webpack_require__2(1767);
          var iteratorClose = __webpack_require__2(9539);
          var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
          var forEachWithoutClosingOnEarlyError = iteratorHelperWithoutClosingOnEarlyError("forEach", TypeError);
          $({ target: "Iterator", proto: true, real: true, forced: forEachWithoutClosingOnEarlyError }, {
            forEach: function forEach(fn) {
              anObject(this);
              try {
                aCallable(fn);
              } catch (error) {
                iteratorClose(this, "throw", error);
              }
              if (forEachWithoutClosingOnEarlyError) return call(forEachWithoutClosingOnEarlyError, this, fn);
              var record = getIteratorDirect(this);
              var counter = 0;
              iterate(record, function(value) {
                fn(value, counter++);
              }, { IS_RECORD: true });
            }
          });
        })
      ),
      /***/
      7629: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var IS_PURE = __webpack_require__2(6395);
          var globalThis2 = __webpack_require__2(4576);
          var defineGlobalProperty = __webpack_require__2(9433);
          var SHARED = "__core-js_shared__";
          var store = module2.exports = globalThis2[SHARED] || defineGlobalProperty(SHARED, {});
          (store.versions || (store.versions = [])).push({
            version: "3.45.1",
            mode: IS_PURE ? "pure" : "global",
            copyright: "\xA9 2014-2025 Denis Pushkarev (zloirock.ru)",
            license: "https://github.com/zloirock/core-js/blob/v3.45.1/LICENSE",
            source: "https://github.com/zloirock/core-js"
          });
        })
      ),
      /***/
      7642: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var difference = __webpack_require__2(3440);
          var fails = __webpack_require__2(9039);
          var setMethodAcceptSetLike = __webpack_require__2(4916);
          var SET_LIKE_INCORRECT_BEHAVIOR = !setMethodAcceptSetLike("difference", function(result2) {
            return result2.size === 0;
          });
          var FORCED = SET_LIKE_INCORRECT_BEHAVIOR || fails(function() {
            var setLike = {
              size: 1,
              has: function() {
                return true;
              },
              keys: function() {
                var index = 0;
                return {
                  next: function() {
                    var done = index++ > 1;
                    if (baseSet.has(1)) baseSet.clear();
                    return { done, value: 2 };
                  }
                };
              }
            };
            var baseSet = /* @__PURE__ */ new Set([1, 2, 3, 4]);
            return baseSet.difference(setLike).size !== 3;
          });
          $({ target: "Set", proto: true, real: true, forced: FORCED }, {
            difference
          });
        })
      ),
      /***/
      7657: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var fails = __webpack_require__2(9039);
          var isCallable = __webpack_require__2(4901);
          var isObject3 = __webpack_require__2(34);
          var create2 = __webpack_require__2(2360);
          var getPrototypeOf = __webpack_require__2(2787);
          var defineBuiltIn = __webpack_require__2(6840);
          var wellKnownSymbol = __webpack_require__2(8227);
          var IS_PURE = __webpack_require__2(6395);
          var ITERATOR = wellKnownSymbol("iterator");
          var BUGGY_SAFARI_ITERATORS = false;
          var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
          if ([].keys) {
            arrayIterator = [].keys();
            if (!("next" in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
            else {
              PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
              if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
            }
          }
          var NEW_ITERATOR_PROTOTYPE = !isObject3(IteratorPrototype) || fails(function() {
            var test = {};
            return IteratorPrototype[ITERATOR].call(test) !== test;
          });
          if (NEW_ITERATOR_PROTOTYPE) IteratorPrototype = {};
          else if (IS_PURE) IteratorPrototype = create2(IteratorPrototype);
          if (!isCallable(IteratorPrototype[ITERATOR])) {
            defineBuiltIn(IteratorPrototype, ITERATOR, function() {
              return this;
            });
          }
          module2.exports = {
            IteratorPrototype,
            BUGGY_SAFARI_ITERATORS
          };
        })
      ),
      /***/
      7680: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          module2.exports = uncurryThis([].slice);
        })
      ),
      /***/
      7696: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var toIntegerOrInfinity = __webpack_require__2(1291);
          var toLength = __webpack_require__2(8014);
          var $RangeError = RangeError;
          module2.exports = function(it) {
            if (it === void 0) return 0;
            var number = toIntegerOrInfinity(it);
            var length = toLength(number);
            if (number !== length) throw new $RangeError("Wrong length or index");
            return length;
          };
        })
      ),
      /***/
      7740: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var hasOwn = __webpack_require__2(9297);
          var ownKeys = __webpack_require__2(5031);
          var getOwnPropertyDescriptorModule = __webpack_require__2(7347);
          var definePropertyModule = __webpack_require__2(4913);
          module2.exports = function(target, source, exceptions) {
            var keys2 = ownKeys(source);
            var defineProperty = definePropertyModule.f;
            var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
            for (var i = 0; i < keys2.length; i++) {
              var key = keys2[i];
              if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
                defineProperty(target, key, getOwnPropertyDescriptor(source, key));
              }
            }
          };
        })
      ),
      /***/
      7750: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var isNullOrUndefined = __webpack_require__2(4117);
          var $TypeError = TypeError;
          module2.exports = function(it) {
            if (isNullOrUndefined(it)) throw new $TypeError("Can't call method on " + it);
            return it;
          };
        })
      ),
      /***/
      7751: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var isCallable = __webpack_require__2(4901);
          var aFunction = function(argument) {
            return isCallable(argument) ? argument : void 0;
          };
          module2.exports = function(namespace, method) {
            return arguments.length < 2 ? aFunction(globalThis2[namespace]) : globalThis2[namespace] && globalThis2[namespace][method];
          };
        })
      ),
      /***/
      7811: (
        /***/
        ((module2) => {
          module2.exports = typeof ArrayBuffer != "undefined" && typeof DataView != "undefined";
        })
      ),
      /***/
      7936: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var $transfer = __webpack_require__2(5636);
          if ($transfer) $({ target: "ArrayBuffer", proto: true }, {
            transferToFixedLength: function transferToFixedLength() {
              return $transfer(this, arguments.length ? arguments[0] : void 0, false);
            }
          });
        })
      ),
      /***/
      8004: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var fails = __webpack_require__2(9039);
          var intersection2 = __webpack_require__2(8750);
          var setMethodAcceptSetLike = __webpack_require__2(4916);
          var INCORRECT = !setMethodAcceptSetLike("intersection", function(result2) {
            return result2.size === 2 && result2.has(1) && result2.has(2);
          }) || fails(function() {
            return String(Array.from((/* @__PURE__ */ new Set([1, 2, 3])).intersection(/* @__PURE__ */ new Set([3, 2])))) !== "3,2";
          });
          $({ target: "Set", proto: true, real: true, forced: INCORRECT }, {
            intersection: intersection2
          });
        })
      ),
      /***/
      8014: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var toIntegerOrInfinity = __webpack_require__2(1291);
          var min2 = Math.min;
          module2.exports = function(argument) {
            var len = toIntegerOrInfinity(argument);
            return len > 0 ? min2(len, 9007199254740991) : 0;
          };
        })
      ),
      /***/
      8100: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var $transfer = __webpack_require__2(5636);
          if ($transfer) $({ target: "ArrayBuffer", proto: true }, {
            transfer: function transfer() {
              return $transfer(this, arguments.length ? arguments[0] : void 0, true);
            }
          });
        })
      ),
      /***/
      8111: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var globalThis2 = __webpack_require__2(4576);
          var anInstance = __webpack_require__2(679);
          var anObject = __webpack_require__2(8551);
          var isCallable = __webpack_require__2(4901);
          var getPrototypeOf = __webpack_require__2(2787);
          var defineBuiltInAccessor = __webpack_require__2(2106);
          var createProperty = __webpack_require__2(4659);
          var fails = __webpack_require__2(9039);
          var hasOwn = __webpack_require__2(9297);
          var wellKnownSymbol = __webpack_require__2(8227);
          var IteratorPrototype = __webpack_require__2(7657).IteratorPrototype;
          var DESCRIPTORS = __webpack_require__2(3724);
          var IS_PURE = __webpack_require__2(6395);
          var CONSTRUCTOR = "constructor";
          var ITERATOR = "Iterator";
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var $TypeError = TypeError;
          var NativeIterator = globalThis2[ITERATOR];
          var FORCED = IS_PURE || !isCallable(NativeIterator) || NativeIterator.prototype !== IteratorPrototype || !fails(function() {
            NativeIterator({});
          });
          var IteratorConstructor = function Iterator2() {
            anInstance(this, IteratorPrototype);
            if (getPrototypeOf(this) === IteratorPrototype) throw new $TypeError("Abstract class Iterator not directly constructable");
          };
          var defineIteratorPrototypeAccessor = function(key, value) {
            if (DESCRIPTORS) {
              defineBuiltInAccessor(IteratorPrototype, key, {
                configurable: true,
                get: function() {
                  return value;
                },
                set: function(replacement) {
                  anObject(this);
                  if (this === IteratorPrototype) throw new $TypeError("You can't redefine this property");
                  if (hasOwn(this, key)) this[key] = replacement;
                  else createProperty(this, key, replacement);
                }
              });
            } else IteratorPrototype[key] = value;
          };
          if (!hasOwn(IteratorPrototype, TO_STRING_TAG)) defineIteratorPrototypeAccessor(TO_STRING_TAG, ITERATOR);
          if (FORCED || !hasOwn(IteratorPrototype, CONSTRUCTOR) || IteratorPrototype[CONSTRUCTOR] === Object) {
            defineIteratorPrototypeAccessor(CONSTRUCTOR, IteratorConstructor);
          }
          IteratorConstructor.prototype = IteratorPrototype;
          $({ global: true, constructor: true, forced: FORCED }, {
            Iterator: IteratorConstructor
          });
        })
      ),
      /***/
      8227: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var shared = __webpack_require__2(5745);
          var hasOwn = __webpack_require__2(9297);
          var uid = __webpack_require__2(3392);
          var NATIVE_SYMBOL = __webpack_require__2(4495);
          var USE_SYMBOL_AS_UID = __webpack_require__2(7040);
          var Symbol2 = globalThis2.Symbol;
          var WellKnownSymbolsStore = shared("wks");
          var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2["for"] || Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
          module2.exports = function(name) {
            if (!hasOwn(WellKnownSymbolsStore, name)) {
              WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol2, name) ? Symbol2[name] : createWellKnownSymbol("Symbol." + name);
            }
            return WellKnownSymbolsStore[name];
          };
        })
      ),
      /***/
      8235: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          var hasOwn = __webpack_require__2(9297);
          var $SyntaxError = SyntaxError;
          var $parseInt = parseInt;
          var fromCharCode = String.fromCharCode;
          var at = uncurryThis("".charAt);
          var slice2 = uncurryThis("".slice);
          var exec = uncurryThis(/./.exec);
          var codePoints = {
            '\\"': '"',
            "\\\\": "\\",
            "\\/": "/",
            "\\b": "\b",
            "\\f": "\f",
            "\\n": "\n",
            "\\r": "\r",
            "\\t": "	"
          };
          var IS_4_HEX_DIGITS = /^[\da-f]{4}$/i;
          var IS_C0_CONTROL_CODE = /^[\u0000-\u001F]$/;
          module2.exports = function(source, i) {
            var unterminated = true;
            var value = "";
            while (i < source.length) {
              var chr = at(source, i);
              if (chr === "\\") {
                var twoChars = slice2(source, i, i + 2);
                if (hasOwn(codePoints, twoChars)) {
                  value += codePoints[twoChars];
                  i += 2;
                } else if (twoChars === "\\u") {
                  i += 2;
                  var fourHexDigits = slice2(source, i, i + 4);
                  if (!exec(IS_4_HEX_DIGITS, fourHexDigits)) throw new $SyntaxError("Bad Unicode escape at: " + i);
                  value += fromCharCode($parseInt(fourHexDigits, 16));
                  i += 4;
                } else throw new $SyntaxError('Unknown escape sequence: "' + twoChars + '"');
              } else if (chr === '"') {
                unterminated = false;
                i++;
                break;
              } else {
                if (exec(IS_C0_CONTROL_CODE, chr)) throw new $SyntaxError("Bad control character in string literal at: " + i);
                value += chr;
                i++;
              }
            }
            if (unterminated) throw new $SyntaxError("Unterminated string at: " + i);
            return { value, end: i };
          };
        })
      ),
      /***/
      8237: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var iterate = __webpack_require__2(2652);
          var aCallable = __webpack_require__2(9306);
          var anObject = __webpack_require__2(8551);
          var getIteratorDirect = __webpack_require__2(1767);
          var iteratorClose = __webpack_require__2(9539);
          var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
          var apply = __webpack_require__2(8745);
          var fails = __webpack_require__2(9039);
          var $TypeError = TypeError;
          var FAILS_ON_INITIAL_UNDEFINED = fails(function() {
            [].keys().reduce(function() {
            }, void 0);
          });
          var reduceWithoutClosingOnEarlyError = !FAILS_ON_INITIAL_UNDEFINED && iteratorHelperWithoutClosingOnEarlyError("reduce", $TypeError);
          $({ target: "Iterator", proto: true, real: true, forced: FAILS_ON_INITIAL_UNDEFINED || reduceWithoutClosingOnEarlyError }, {
            reduce: function reduce(reducer) {
              anObject(this);
              try {
                aCallable(reducer);
              } catch (error) {
                iteratorClose(this, "throw", error);
              }
              var noInitial = arguments.length < 2;
              var accumulator = noInitial ? void 0 : arguments[1];
              if (reduceWithoutClosingOnEarlyError) {
                return apply(reduceWithoutClosingOnEarlyError, this, noInitial ? [reducer] : [reducer, accumulator]);
              }
              var record = getIteratorDirect(this);
              var counter = 0;
              iterate(record, function(value) {
                if (noInitial) {
                  noInitial = false;
                  accumulator = value;
                } else {
                  accumulator = reducer(accumulator, value, counter);
                }
                counter++;
              }, { IS_RECORD: true });
              if (noInitial) throw new $TypeError("Reduce of empty iterator with no initial value");
              return accumulator;
            }
          });
        })
      ),
      /***/
      8335: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var DESCRIPTORS = __webpack_require__2(3724);
          var globalThis2 = __webpack_require__2(4576);
          var getBuiltIn = __webpack_require__2(7751);
          var uncurryThis = __webpack_require__2(9504);
          var call = __webpack_require__2(9565);
          var isCallable = __webpack_require__2(4901);
          var isObject3 = __webpack_require__2(34);
          var isArray = __webpack_require__2(4376);
          var hasOwn = __webpack_require__2(9297);
          var toString2 = __webpack_require__2(655);
          var lengthOfArrayLike = __webpack_require__2(6198);
          var createProperty = __webpack_require__2(4659);
          var fails = __webpack_require__2(9039);
          var parseJSONString = __webpack_require__2(8235);
          var NATIVE_SYMBOL = __webpack_require__2(4495);
          var JSON2 = globalThis2.JSON;
          var Number2 = globalThis2.Number;
          var SyntaxError2 = globalThis2.SyntaxError;
          var nativeParse = JSON2 && JSON2.parse;
          var enumerableOwnProperties = getBuiltIn("Object", "keys");
          var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          var at = uncurryThis("".charAt);
          var slice2 = uncurryThis("".slice);
          var exec = uncurryThis(/./.exec);
          var push2 = uncurryThis([].push);
          var IS_DIGIT = /^\d$/;
          var IS_NON_ZERO_DIGIT = /^[1-9]$/;
          var IS_NUMBER_START = /^[\d-]$/;
          var IS_WHITESPACE = /^[\t\n\r ]$/;
          var PRIMITIVE = 0;
          var OBJECT = 1;
          var $parse = function(source, reviver) {
            source = toString2(source);
            var context = new Context(source, 0, "");
            var root2 = context.parse();
            var value = root2.value;
            var endIndex = context.skip(IS_WHITESPACE, root2.end);
            if (endIndex < source.length) {
              throw new SyntaxError2('Unexpected extra character: "' + at(source, endIndex) + '" after the parsed data at: ' + endIndex);
            }
            return isCallable(reviver) ? internalize({ "": value }, "", reviver, root2) : value;
          };
          var internalize = function(holder, name, reviver, node) {
            var val = holder[name];
            var unmodified = node && val === node.value;
            var context = unmodified && typeof node.source == "string" ? { source: node.source } : {};
            var elementRecordsLen, keys2, len, i, P;
            if (isObject3(val)) {
              var nodeIsArray = isArray(val);
              var nodes = unmodified ? node.nodes : nodeIsArray ? [] : {};
              if (nodeIsArray) {
                elementRecordsLen = nodes.length;
                len = lengthOfArrayLike(val);
                for (i = 0; i < len; i++) {
                  internalizeProperty(val, i, internalize(val, "" + i, reviver, i < elementRecordsLen ? nodes[i] : void 0));
                }
              } else {
                keys2 = enumerableOwnProperties(val);
                len = lengthOfArrayLike(keys2);
                for (i = 0; i < len; i++) {
                  P = keys2[i];
                  internalizeProperty(val, P, internalize(val, P, reviver, hasOwn(nodes, P) ? nodes[P] : void 0));
                }
              }
            }
            return call(reviver, holder, name, val, context);
          };
          var internalizeProperty = function(object2, key, value) {
            if (DESCRIPTORS) {
              var descriptor = getOwnPropertyDescriptor(object2, key);
              if (descriptor && !descriptor.configurable) return;
            }
            if (value === void 0) delete object2[key];
            else createProperty(object2, key, value);
          };
          var Node2 = function(value, end, source, nodes) {
            this.value = value;
            this.end = end;
            this.source = source;
            this.nodes = nodes;
          };
          var Context = function(source, index) {
            this.source = source;
            this.index = index;
          };
          Context.prototype = {
            fork: function(nextIndex) {
              return new Context(this.source, nextIndex);
            },
            parse: function() {
              var source = this.source;
              var i = this.skip(IS_WHITESPACE, this.index);
              var fork = this.fork(i);
              var chr = at(source, i);
              if (exec(IS_NUMBER_START, chr)) return fork.number();
              switch (chr) {
                case "{":
                  return fork.object();
                case "[":
                  return fork.array();
                case '"':
                  return fork.string();
                case "t":
                  return fork.keyword(true);
                case "f":
                  return fork.keyword(false);
                case "n":
                  return fork.keyword(null);
              }
              throw new SyntaxError2('Unexpected character: "' + chr + '" at: ' + i);
            },
            node: function(type, value, start, end, nodes) {
              return new Node2(value, end, type ? null : slice2(this.source, start, end), nodes);
            },
            object: function() {
              var source = this.source;
              var i = this.index + 1;
              var expectKeypair = false;
              var object2 = {};
              var nodes = {};
              while (i < source.length) {
                i = this.until(['"', "}"], i);
                if (at(source, i) === "}" && !expectKeypair) {
                  i++;
                  break;
                }
                var result2 = this.fork(i).string();
                var key = result2.value;
                i = result2.end;
                i = this.until([":"], i) + 1;
                i = this.skip(IS_WHITESPACE, i);
                result2 = this.fork(i).parse();
                createProperty(nodes, key, result2);
                createProperty(object2, key, result2.value);
                i = this.until([",", "}"], result2.end);
                var chr = at(source, i);
                if (chr === ",") {
                  expectKeypair = true;
                  i++;
                } else if (chr === "}") {
                  i++;
                  break;
                }
              }
              return this.node(OBJECT, object2, this.index, i, nodes);
            },
            array: function() {
              var source = this.source;
              var i = this.index + 1;
              var expectElement = false;
              var array = [];
              var nodes = [];
              while (i < source.length) {
                i = this.skip(IS_WHITESPACE, i);
                if (at(source, i) === "]" && !expectElement) {
                  i++;
                  break;
                }
                var result2 = this.fork(i).parse();
                push2(nodes, result2);
                push2(array, result2.value);
                i = this.until([",", "]"], result2.end);
                if (at(source, i) === ",") {
                  expectElement = true;
                  i++;
                } else if (at(source, i) === "]") {
                  i++;
                  break;
                }
              }
              return this.node(OBJECT, array, this.index, i, nodes);
            },
            string: function() {
              var index = this.index;
              var parsed = parseJSONString(this.source, this.index + 1);
              return this.node(PRIMITIVE, parsed.value, index, parsed.end);
            },
            number: function() {
              var source = this.source;
              var startIndex = this.index;
              var i = startIndex;
              if (at(source, i) === "-") i++;
              if (at(source, i) === "0") i++;
              else if (exec(IS_NON_ZERO_DIGIT, at(source, i))) i = this.skip(IS_DIGIT, i + 1);
              else throw new SyntaxError2("Failed to parse number at: " + i);
              if (at(source, i) === ".") i = this.skip(IS_DIGIT, i + 1);
              if (at(source, i) === "e" || at(source, i) === "E") {
                i++;
                if (at(source, i) === "+" || at(source, i) === "-") i++;
                var exponentStartIndex = i;
                i = this.skip(IS_DIGIT, i);
                if (exponentStartIndex === i) throw new SyntaxError2("Failed to parse number's exponent value at: " + i);
              }
              return this.node(PRIMITIVE, Number2(slice2(source, startIndex, i)), startIndex, i);
            },
            keyword: function(value) {
              var keyword = "" + value;
              var index = this.index;
              var endIndex = index + keyword.length;
              if (slice2(this.source, index, endIndex) !== keyword) throw new SyntaxError2("Failed to parse value at: " + index);
              return this.node(PRIMITIVE, value, index, endIndex);
            },
            skip: function(regex, i) {
              var source = this.source;
              for (; i < source.length; i++) if (!exec(regex, at(source, i))) break;
              return i;
            },
            until: function(array, i) {
              i = this.skip(IS_WHITESPACE, i);
              var chr = at(this.source, i);
              for (var j = 0; j < array.length; j++) if (array[j] === chr) return i;
              throw new SyntaxError2('Unexpected character: "' + chr + '" at: ' + i);
            }
          };
          var NO_SOURCE_SUPPORT = fails(function() {
            var unsafeInt = "9007199254740993";
            var source;
            nativeParse(unsafeInt, function(key, value, context) {
              source = context.source;
            });
            return source !== unsafeInt;
          });
          var PROPER_BASE_PARSE = NATIVE_SYMBOL && !fails(function() {
            return 1 / nativeParse("-0 	") !== -Infinity;
          });
          $({ target: "JSON", stat: true, forced: NO_SOURCE_SUPPORT }, {
            parse: function parse2(text, reviver) {
              return PROPER_BASE_PARSE && !isCallable(reviver) ? nativeParse(text) : $parse(text, reviver);
            }
          });
        })
      ),
      /***/
      8469: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          var iterateSimple = __webpack_require__2(507);
          var SetHelpers = __webpack_require__2(4402);
          var Set2 = SetHelpers.Set;
          var SetPrototype = SetHelpers.proto;
          var forEach = uncurryThis(SetPrototype.forEach);
          var keys2 = uncurryThis(SetPrototype.keys);
          var next = keys2(new Set2()).next;
          module2.exports = function(set, fn, interruptible) {
            return interruptible ? iterateSimple({ iterator: keys2(set), next }, fn) : forEach(set, fn);
          };
        })
      ),
      /***/
      8480: (
        /***/
        ((__unused_webpack_module, exports2, __webpack_require__2) => {
          var internalObjectKeys = __webpack_require__2(1828);
          var enumBugKeys = __webpack_require__2(8727);
          var hiddenKeys = enumBugKeys.concat("length", "prototype");
          exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
            return internalObjectKeys(O, hiddenKeys);
          };
        })
      ),
      /***/
      8527: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var aSet = __webpack_require__2(7080);
          var has3 = __webpack_require__2(4402).has;
          var size2 = __webpack_require__2(5170);
          var getSetRecord = __webpack_require__2(3789);
          var iterateSimple = __webpack_require__2(507);
          var iteratorClose = __webpack_require__2(9539);
          module2.exports = function isSupersetOf(other) {
            var O = aSet(this);
            var otherRec = getSetRecord(other);
            if (size2(O) < otherRec.size) return false;
            var iterator = otherRec.getIterator();
            return iterateSimple(iterator, function(e) {
              if (!has3(O, e)) return iteratorClose(iterator, "normal", false);
            }) !== false;
          };
        })
      ),
      /***/
      8551: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var isObject3 = __webpack_require__2(34);
          var $String = String;
          var $TypeError = TypeError;
          module2.exports = function(argument) {
            if (isObject3(argument)) return argument;
            throw new $TypeError($String(argument) + " is not an object");
          };
        })
      ),
      /***/
      8574: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          var $Error = Error;
          var replace = uncurryThis("".replace);
          var TEST = (function(arg) {
            return String(new $Error(arg).stack);
          })("zxcasd");
          var V8_OR_CHAKRA_STACK_ENTRY = /\n\s*at [^:]*:[^\n]*/;
          var IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);
          module2.exports = function(stack, dropEntries) {
            if (IS_V8_OR_CHAKRA_STACK && typeof stack == "string" && !$Error.prepareStackTrace) {
              while (dropEntries--) stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, "");
            }
            return stack;
          };
        })
      ),
      /***/
      8622: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var isCallable = __webpack_require__2(4901);
          var WeakMap2 = globalThis2.WeakMap;
          module2.exports = isCallable(WeakMap2) && /native code/.test(String(WeakMap2));
        })
      ),
      /***/
      8646: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var call = __webpack_require__2(9565);
          var anObject = __webpack_require__2(8551);
          var getIteratorDirect = __webpack_require__2(1767);
          var getIteratorMethod = __webpack_require__2(851);
          module2.exports = function(obj2, stringHandling) {
            if (!stringHandling || typeof obj2 !== "string") anObject(obj2);
            var method = getIteratorMethod(obj2);
            return getIteratorDirect(anObject(method !== void 0 ? call(method, obj2) : obj2));
          };
        })
      ),
      /***/
      8686: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var DESCRIPTORS = __webpack_require__2(3724);
          var fails = __webpack_require__2(9039);
          module2.exports = DESCRIPTORS && fails(function() {
            return Object.defineProperty(function() {
            }, "prototype", {
              value: 42,
              writable: false
            }).prototype !== 42;
          });
        })
      ),
      /***/
      8721: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var DESCRIPTORS = __webpack_require__2(3724);
          var uncurryThis = __webpack_require__2(9504);
          var defineBuiltInAccessor = __webpack_require__2(2106);
          var URLSearchParamsPrototype = URLSearchParams.prototype;
          var forEach = uncurryThis(URLSearchParamsPrototype.forEach);
          if (DESCRIPTORS && !("size" in URLSearchParamsPrototype)) {
            defineBuiltInAccessor(URLSearchParamsPrototype, "size", {
              get: function size2() {
                var count = 0;
                forEach(this, function() {
                  count++;
                });
                return count;
              },
              configurable: true,
              enumerable: true
            });
          }
        })
      ),
      /***/
      8727: (
        /***/
        ((module2) => {
          module2.exports = [
            "constructor",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "toLocaleString",
            "toString",
            "valueOf"
          ];
        })
      ),
      /***/
      8745: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var NATIVE_BIND = __webpack_require__2(616);
          var FunctionPrototype = Function.prototype;
          var apply = FunctionPrototype.apply;
          var call = FunctionPrototype.call;
          module2.exports = typeof Reflect == "object" && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function() {
            return call.apply(apply, arguments);
          });
        })
      ),
      /***/
      8750: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var aSet = __webpack_require__2(7080);
          var SetHelpers = __webpack_require__2(4402);
          var size2 = __webpack_require__2(5170);
          var getSetRecord = __webpack_require__2(3789);
          var iterateSet = __webpack_require__2(8469);
          var iterateSimple = __webpack_require__2(507);
          var Set2 = SetHelpers.Set;
          var add = SetHelpers.add;
          var has3 = SetHelpers.has;
          module2.exports = function intersection2(other) {
            var O = aSet(this);
            var otherRec = getSetRecord(other);
            var result2 = new Set2();
            if (size2(O) > otherRec.size) {
              iterateSimple(otherRec.getIterator(), function(e) {
                if (has3(O, e)) add(result2, e);
              });
            } else {
              iterateSet(O, function(e) {
                if (otherRec.includes(e)) add(result2, e);
              });
            }
            return result2;
          };
        })
      ),
      /***/
      8773: (
        /***/
        ((__unused_webpack_module, exports2) => {
          var $propertyIsEnumerable = {}.propertyIsEnumerable;
          var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
          exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
            var descriptor = getOwnPropertyDescriptor(this, V);
            return !!descriptor && descriptor.enumerable;
          } : $propertyIsEnumerable;
        })
      ),
      /***/
      8981: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var requireObjectCoercible = __webpack_require__2(7750);
          var $Object = Object;
          module2.exports = function(argument) {
            return $Object(requireObjectCoercible(argument));
          };
        })
      ),
      /***/
      9039: (
        /***/
        ((module2) => {
          module2.exports = function(exec) {
            try {
              return !!exec();
            } catch (error) {
              return true;
            }
          };
        })
      ),
      /***/
      9143: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var uncurryThis = __webpack_require__2(9504);
          var anObjectOrUndefined = __webpack_require__2(3972);
          var aString = __webpack_require__2(3463);
          var hasOwn = __webpack_require__2(9297);
          var base64Map = __webpack_require__2(2804);
          var getAlphabetOption = __webpack_require__2(944);
          var notDetached = __webpack_require__2(5169);
          var base64Alphabet = base64Map.c2i;
          var base64UrlAlphabet = base64Map.c2iUrl;
          var SyntaxError2 = globalThis2.SyntaxError;
          var TypeError2 = globalThis2.TypeError;
          var at = uncurryThis("".charAt);
          var skipAsciiWhitespace = function(string, index) {
            var length = string.length;
            for (; index < length; index++) {
              var chr = at(string, index);
              if (chr !== " " && chr !== "	" && chr !== "\n" && chr !== "\f" && chr !== "\r") break;
            }
            return index;
          };
          var decodeBase64Chunk = function(chunk2, alphabet, throwOnExtraBits) {
            var chunkLength = chunk2.length;
            if (chunkLength < 4) {
              chunk2 += chunkLength === 2 ? "AA" : "A";
            }
            var triplet = (alphabet[at(chunk2, 0)] << 18) + (alphabet[at(chunk2, 1)] << 12) + (alphabet[at(chunk2, 2)] << 6) + alphabet[at(chunk2, 3)];
            var chunkBytes = [
              triplet >> 16 & 255,
              triplet >> 8 & 255,
              triplet & 255
            ];
            if (chunkLength === 2) {
              if (throwOnExtraBits && chunkBytes[1] !== 0) {
                throw new SyntaxError2("Extra bits");
              }
              return [chunkBytes[0]];
            }
            if (chunkLength === 3) {
              if (throwOnExtraBits && chunkBytes[2] !== 0) {
                throw new SyntaxError2("Extra bits");
              }
              return [chunkBytes[0], chunkBytes[1]];
            }
            return chunkBytes;
          };
          var writeBytes = function(bytes, elements, written) {
            var elementsLength = elements.length;
            for (var index = 0; index < elementsLength; index++) {
              bytes[written + index] = elements[index];
            }
            return written + elementsLength;
          };
          module2.exports = function(string, options, into, maxLength) {
            aString(string);
            anObjectOrUndefined(options);
            var alphabet = getAlphabetOption(options) === "base64" ? base64Alphabet : base64UrlAlphabet;
            var lastChunkHandling = options ? options.lastChunkHandling : void 0;
            if (lastChunkHandling === void 0) lastChunkHandling = "loose";
            if (lastChunkHandling !== "loose" && lastChunkHandling !== "strict" && lastChunkHandling !== "stop-before-partial") {
              throw new TypeError2("Incorrect `lastChunkHandling` option");
            }
            if (into) notDetached(into.buffer);
            var stringLength = string.length;
            var bytes = into || [];
            var written = 0;
            var read = 0;
            var chunk2 = "";
            var index = 0;
            if (maxLength) while (true) {
              index = skipAsciiWhitespace(string, index);
              if (index === stringLength) {
                if (chunk2.length > 0) {
                  if (lastChunkHandling === "stop-before-partial") {
                    break;
                  }
                  if (lastChunkHandling === "loose") {
                    if (chunk2.length === 1) {
                      throw new SyntaxError2("Malformed padding: exactly one additional character");
                    }
                    written = writeBytes(bytes, decodeBase64Chunk(chunk2, alphabet, false), written);
                  } else {
                    throw new SyntaxError2("Missing padding");
                  }
                }
                read = stringLength;
                break;
              }
              var chr = at(string, index);
              ++index;
              if (chr === "=") {
                if (chunk2.length < 2) {
                  throw new SyntaxError2("Padding is too early");
                }
                index = skipAsciiWhitespace(string, index);
                if (chunk2.length === 2) {
                  if (index === stringLength) {
                    if (lastChunkHandling === "stop-before-partial") {
                      break;
                    }
                    throw new SyntaxError2("Malformed padding: only one =");
                  }
                  if (at(string, index) === "=") {
                    ++index;
                    index = skipAsciiWhitespace(string, index);
                  }
                }
                if (index < stringLength) {
                  throw new SyntaxError2("Unexpected character after padding");
                }
                written = writeBytes(bytes, decodeBase64Chunk(chunk2, alphabet, lastChunkHandling === "strict"), written);
                read = stringLength;
                break;
              }
              if (!hasOwn(alphabet, chr)) {
                throw new SyntaxError2("Unexpected character");
              }
              var remainingBytes = maxLength - written;
              if (remainingBytes === 1 && chunk2.length === 2 || remainingBytes === 2 && chunk2.length === 3) {
                break;
              }
              chunk2 += chr;
              if (chunk2.length === 4) {
                written = writeBytes(bytes, decodeBase64Chunk(chunk2, alphabet, false), written);
                chunk2 = "";
                read = index;
                if (written === maxLength) {
                  break;
                }
              }
            }
            return { bytes, read, written };
          };
        })
      ),
      /***/
      9286: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var SetHelpers = __webpack_require__2(4402);
          var iterate = __webpack_require__2(8469);
          var Set2 = SetHelpers.Set;
          var add = SetHelpers.add;
          module2.exports = function(set) {
            var result2 = new Set2();
            iterate(set, function(it) {
              add(result2, it);
            });
            return result2;
          };
        })
      ),
      /***/
      9297: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var uncurryThis = __webpack_require__2(9504);
          var toObject = __webpack_require__2(8981);
          var hasOwnProperty2 = uncurryThis({}.hasOwnProperty);
          module2.exports = Object.hasOwn || function hasOwn(it, key) {
            return hasOwnProperty2(toObject(it), key);
          };
        })
      ),
      /***/
      9306: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var isCallable = __webpack_require__2(4901);
          var tryToString = __webpack_require__2(6823);
          var $TypeError = TypeError;
          module2.exports = function(argument) {
            if (isCallable(argument)) return argument;
            throw new $TypeError(tryToString(argument) + " is not a function");
          };
        })
      ),
      /***/
      9314: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var call = __webpack_require__2(9565);
          var anObject = __webpack_require__2(8551);
          var getIteratorDirect = __webpack_require__2(1767);
          var notANaN = __webpack_require__2(4149);
          var toPositiveInteger = __webpack_require__2(9590);
          var iteratorClose = __webpack_require__2(9539);
          var createIteratorProxy = __webpack_require__2(9462);
          var iteratorHelperThrowsOnInvalidIterator = __webpack_require__2(684);
          var iteratorHelperWithoutClosingOnEarlyError = __webpack_require__2(4549);
          var IS_PURE = __webpack_require__2(6395);
          var DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR = !IS_PURE && !iteratorHelperThrowsOnInvalidIterator("drop", 0);
          var dropWithoutClosingOnEarlyError = !IS_PURE && !DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR && iteratorHelperWithoutClosingOnEarlyError("drop", RangeError);
          var FORCED = IS_PURE || DROP_WITHOUT_THROWING_ON_INVALID_ITERATOR || dropWithoutClosingOnEarlyError;
          var IteratorProxy = createIteratorProxy(function() {
            var iterator = this.iterator;
            var next = this.next;
            var result2, done;
            while (this.remaining) {
              this.remaining--;
              result2 = anObject(call(next, iterator));
              done = this.done = !!result2.done;
              if (done) return;
            }
            result2 = anObject(call(next, iterator));
            done = this.done = !!result2.done;
            if (!done) return result2.value;
          });
          $({ target: "Iterator", proto: true, real: true, forced: FORCED }, {
            drop: function drop(limit) {
              anObject(this);
              var remaining;
              try {
                remaining = toPositiveInteger(notANaN(+limit));
              } catch (error) {
                iteratorClose(this, "throw", error);
              }
              if (dropWithoutClosingOnEarlyError) return call(dropWithoutClosingOnEarlyError, this, remaining);
              return new IteratorProxy(getIteratorDirect(this), {
                remaining
              });
            }
          });
        })
      ),
      /***/
      9429: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var IS_NODE = __webpack_require__2(6193);
          module2.exports = function(name) {
            if (IS_NODE) {
              try {
                return globalThis2.process.getBuiltinModule(name);
              } catch (error) {
              }
              try {
                return Function('return require("' + name + '")')();
              } catch (error) {
              }
            }
          };
        })
      ),
      /***/
      9432: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          __webpack_require__2(5213);
        })
      ),
      /***/
      9433: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var defineProperty = Object.defineProperty;
          module2.exports = function(key, value) {
            try {
              defineProperty(globalThis2, key, { value, configurable: true, writable: true });
            } catch (error) {
              globalThis2[key] = value;
            }
            return value;
          };
        })
      ),
      /***/
      9462: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var call = __webpack_require__2(9565);
          var create2 = __webpack_require__2(2360);
          var createNonEnumerableProperty = __webpack_require__2(6699);
          var defineBuiltIns = __webpack_require__2(6279);
          var wellKnownSymbol = __webpack_require__2(8227);
          var InternalStateModule = __webpack_require__2(1181);
          var getMethod = __webpack_require__2(5966);
          var IteratorPrototype = __webpack_require__2(7657).IteratorPrototype;
          var createIterResultObject = __webpack_require__2(2529);
          var iteratorClose = __webpack_require__2(9539);
          var iteratorCloseAll = __webpack_require__2(1385);
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var ITERATOR_HELPER = "IteratorHelper";
          var WRAP_FOR_VALID_ITERATOR = "WrapForValidIterator";
          var NORMAL = "normal";
          var THROW = "throw";
          var setInternalState = InternalStateModule.set;
          var createIteratorProxyPrototype = function(IS_ITERATOR) {
            var getInternalState = InternalStateModule.getterFor(IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER);
            return defineBuiltIns(create2(IteratorPrototype), {
              next: function next() {
                var state = getInternalState(this);
                if (IS_ITERATOR) return state.nextHandler();
                if (state.done) return createIterResultObject(void 0, true);
                try {
                  var result2 = state.nextHandler();
                  return state.returnHandlerResult ? result2 : createIterResultObject(result2, state.done);
                } catch (error) {
                  state.done = true;
                  throw error;
                }
              },
              "return": function() {
                var state = getInternalState(this);
                var iterator = state.iterator;
                state.done = true;
                if (IS_ITERATOR) {
                  var returnMethod = getMethod(iterator, "return");
                  return returnMethod ? call(returnMethod, iterator) : createIterResultObject(void 0, true);
                }
                if (state.inner) try {
                  iteratorClose(state.inner.iterator, NORMAL);
                } catch (error) {
                  return iteratorClose(iterator, THROW, error);
                }
                if (state.openIters) try {
                  iteratorCloseAll(state.openIters, NORMAL);
                } catch (error) {
                  return iteratorClose(iterator, THROW, error);
                }
                if (iterator) iteratorClose(iterator, NORMAL);
                return createIterResultObject(void 0, true);
              }
            });
          };
          var WrapForValidIteratorPrototype = createIteratorProxyPrototype(true);
          var IteratorHelperPrototype = createIteratorProxyPrototype(false);
          createNonEnumerableProperty(IteratorHelperPrototype, TO_STRING_TAG, "Iterator Helper");
          module2.exports = function(nextHandler, IS_ITERATOR, RETURN_HANDLER_RESULT) {
            var IteratorProxy = function Iterator2(record, state) {
              if (state) {
                state.iterator = record.iterator;
                state.next = record.next;
              } else state = record;
              state.type = IS_ITERATOR ? WRAP_FOR_VALID_ITERATOR : ITERATOR_HELPER;
              state.returnHandlerResult = !!RETURN_HANDLER_RESULT;
              state.nextHandler = nextHandler;
              state.counter = 0;
              state.done = false;
              setInternalState(this, state);
            };
            IteratorProxy.prototype = IS_ITERATOR ? WrapForValidIteratorPrototype : IteratorHelperPrototype;
            return IteratorProxy;
          };
        })
      ),
      /***/
      9486: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var $ = __webpack_require__2(6518);
          var globalThis2 = __webpack_require__2(4576);
          var uncurryThis = __webpack_require__2(9504);
          var anObjectOrUndefined = __webpack_require__2(3972);
          var anUint8Array = __webpack_require__2(4154);
          var notDetached = __webpack_require__2(5169);
          var base64Map = __webpack_require__2(2804);
          var getAlphabetOption = __webpack_require__2(944);
          var base64Alphabet = base64Map.i2c;
          var base64UrlAlphabet = base64Map.i2cUrl;
          var charAt = uncurryThis("".charAt);
          var Uint8Array2 = globalThis2.Uint8Array;
          var INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS = !Uint8Array2 || !Uint8Array2.prototype.toBase64 || !(function() {
            try {
              var target = new Uint8Array2();
              target.toBase64(null);
            } catch (error) {
              return true;
            }
          })();
          if (Uint8Array2) $({ target: "Uint8Array", proto: true, forced: INCORRECT_BEHAVIOR_OR_DOESNT_EXISTS }, {
            toBase64: function toBase64() {
              var array = anUint8Array(this);
              var options = arguments.length ? anObjectOrUndefined(arguments[0]) : void 0;
              var alphabet = getAlphabetOption(options) === "base64" ? base64Alphabet : base64UrlAlphabet;
              var omitPadding = !!options && !!options.omitPadding;
              notDetached(this.buffer);
              var result2 = "";
              var i = 0;
              var length = array.length;
              var triplet;
              var at = function(shift) {
                return charAt(alphabet, triplet >> 6 * shift & 63);
              };
              for (; i + 2 < length; i += 3) {
                triplet = (array[i] << 16) + (array[i + 1] << 8) + array[i + 2];
                result2 += at(3) + at(2) + at(1) + at(0);
              }
              if (i + 2 === length) {
                triplet = (array[i] << 16) + (array[i + 1] << 8);
                result2 += at(3) + at(2) + at(1) + (omitPadding ? "" : "=");
              } else if (i + 1 === length) {
                triplet = array[i] << 16;
                result2 += at(3) + at(2) + (omitPadding ? "" : "==");
              }
              return result2;
            }
          });
        })
      ),
      /***/
      9504: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var NATIVE_BIND = __webpack_require__2(616);
          var FunctionPrototype = Function.prototype;
          var call = FunctionPrototype.call;
          var uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);
          module2.exports = NATIVE_BIND ? uncurryThisWithBind : function(fn) {
            return function() {
              return call.apply(fn, arguments);
            };
          };
        })
      ),
      /***/
      9519: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var globalThis2 = __webpack_require__2(4576);
          var userAgent = __webpack_require__2(2839);
          var process2 = globalThis2.process;
          var Deno2 = globalThis2.Deno;
          var versions = process2 && process2.versions || Deno2 && Deno2.version;
          var v8 = versions && versions.v8;
          var match, version2;
          if (v8) {
            match = v8.split(".");
            version2 = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
          }
          if (!version2 && userAgent) {
            match = userAgent.match(/Edge\/(\d+)/);
            if (!match || match[1] >= 74) {
              match = userAgent.match(/Chrome\/(\d+)/);
              if (match) version2 = +match[1];
            }
          }
          module2.exports = version2;
        })
      ),
      /***/
      9539: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var call = __webpack_require__2(9565);
          var anObject = __webpack_require__2(8551);
          var getMethod = __webpack_require__2(5966);
          module2.exports = function(iterator, kind, value) {
            var innerResult, innerError;
            anObject(iterator);
            try {
              innerResult = getMethod(iterator, "return");
              if (!innerResult) {
                if (kind === "throw") throw value;
                return value;
              }
              innerResult = call(innerResult, iterator);
            } catch (error) {
              innerError = true;
              innerResult = error;
            }
            if (kind === "throw") throw value;
            if (innerError) throw innerResult;
            anObject(innerResult);
            return value;
          };
        })
      ),
      /***/
      9565: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var NATIVE_BIND = __webpack_require__2(616);
          var call = Function.prototype.call;
          module2.exports = NATIVE_BIND ? call.bind(call) : function() {
            return call.apply(call, arguments);
          };
        })
      ),
      /***/
      9577: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          var arrayWith = __webpack_require__2(9928);
          var ArrayBufferViewCore = __webpack_require__2(4644);
          var isBigIntArray = __webpack_require__2(1108);
          var toIntegerOrInfinity = __webpack_require__2(1291);
          var toBigInt = __webpack_require__2(5854);
          var aTypedArray = ArrayBufferViewCore.aTypedArray;
          var getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;
          var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
          var PROPER_ORDER = (function() {
            try {
              new Int8Array(1)["with"](2, { valueOf: function() {
                throw 8;
              } });
            } catch (error) {
              return error === 8;
            }
          })();
          var THROW_ON_NEGATIVE_FRACTIONAL_INDEX = PROPER_ORDER && (function() {
            try {
              new Int8Array(1)["with"](-0.5, 1);
            } catch (error) {
              return true;
            }
          })();
          exportTypedArrayMethod("with", { "with": function(index, value) {
            var O = aTypedArray(this);
            var relativeIndex = toIntegerOrInfinity(index);
            var actualValue = isBigIntArray(O) ? toBigInt(value) : +value;
            return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);
          } }["with"], !PROPER_ORDER || THROW_ON_NEGATIVE_FRACTIONAL_INDEX);
        })
      ),
      /***/
      9590: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var toIntegerOrInfinity = __webpack_require__2(1291);
          var $RangeError = RangeError;
          module2.exports = function(it) {
            var result2 = toIntegerOrInfinity(it);
            if (result2 < 0) throw new $RangeError("The argument can't be less than 0");
            return result2;
          };
        })
      ),
      /***/
      9617: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var toIndexedObject = __webpack_require__2(5397);
          var toAbsoluteIndex = __webpack_require__2(5610);
          var lengthOfArrayLike = __webpack_require__2(6198);
          var createMethod = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
              var O = toIndexedObject($this);
              var length = lengthOfArrayLike(O);
              if (length === 0) return !IS_INCLUDES && -1;
              var index = toAbsoluteIndex(fromIndex, length);
              var value;
              if (IS_INCLUDES && el !== el) while (length > index) {
                value = O[index++];
                if (value !== value) return true;
              }
              else for (; length > index; index++) {
                if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
              }
              return !IS_INCLUDES && -1;
            };
          };
          module2.exports = {
            // `Array.prototype.includes` method
            // https://tc39.es/ecma262/#sec-array.prototype.includes
            includes: createMethod(true),
            // `Array.prototype.indexOf` method
            // https://tc39.es/ecma262/#sec-array.prototype.indexof
            indexOf: createMethod(false)
          };
        })
      ),
      /***/
      9631: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          __webpack_require__2(9486);
        })
      ),
      /***/
      9797: (
        /***/
        ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) => {
          __webpack_require__2(4226);
        })
      ),
      /***/
      9835: (
        /***/
        ((module2) => {
          module2.exports = function(METHOD_NAME) {
            try {
              var baseSet = /* @__PURE__ */ new Set();
              var setLike = {
                size: 0,
                has: function() {
                  return true;
                },
                keys: function() {
                  return Object.defineProperty({}, "next", {
                    get: function() {
                      baseSet.clear();
                      baseSet.add(4);
                      return function() {
                        return { done: true };
                      };
                    }
                  });
                }
              };
              var result2 = baseSet[METHOD_NAME](setLike);
              return result2.size === 1 && result2.values().next().value === 4;
            } catch (error) {
              return false;
            }
          };
        })
      ),
      /***/
      9928: (
        /***/
        ((module2, __unused_webpack_exports, __webpack_require__2) => {
          var lengthOfArrayLike = __webpack_require__2(6198);
          var toIntegerOrInfinity = __webpack_require__2(1291);
          var $RangeError = RangeError;
          module2.exports = function(O, C, index, value) {
            var len = lengthOfArrayLike(O);
            var relativeIndex = toIntegerOrInfinity(index);
            var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;
            if (actualIndex >= len || actualIndex < 0) throw new $RangeError("Incorrect index");
            var A = new C(len);
            var k = 0;
            for (; k < len; k++) A[k] = k === actualIndex ? value : O[k];
            return A;
          };
        })
      )
      /******/
    };
    __webpack_module_cache__ = {};
    (() => {
      __webpack_require__.d = (exports2, definition) => {
        for (var key in definition) {
          if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
            Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
          }
        }
      };
    })();
    (() => {
      __webpack_require__.o = (obj2, prop) => Object.prototype.hasOwnProperty.call(obj2, prop);
    })();
    es_array_push = __webpack_require__(4114);
    es_array_buffer_detached = __webpack_require__(6573);
    es_array_buffer_transfer = __webpack_require__(8100);
    es_array_buffer_transfer_to_fixed_length = __webpack_require__(7936);
    es_iterator_constructor = __webpack_require__(8111);
    es_iterator_reduce = __webpack_require__(8237);
    es_promise_try = __webpack_require__(1689);
    es_typed_array_with = __webpack_require__(9577);
    esnext_math_sum_precise = __webpack_require__(4235);
    esnext_uint8_array_from_base64 = __webpack_require__(9432);
    esnext_uint8_array_set_from_base64 = __webpack_require__(1549);
    esnext_uint8_array_set_from_hex = __webpack_require__(9797);
    esnext_uint8_array_to_base64 = __webpack_require__(9631);
    esnext_uint8_array_to_hex = __webpack_require__(5623);
    web_dom_exception_stack = __webpack_require__(4979);
    web_url_parse = __webpack_require__(5781);
    isNodeJS = typeof process === "object" && process + "" === "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser");
    FONT_IDENTITY_MATRIX = [1e-3, 0, 0, 1e-3, 0, 0];
    LINE_FACTOR = 1.35;
    LINE_DESCENT_FACTOR = 0.35;
    BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;
    RenderingIntentFlag = {
      ANY: 1,
      DISPLAY: 2,
      PRINT: 4,
      SAVE: 8,
      ANNOTATIONS_FORMS: 16,
      ANNOTATIONS_STORAGE: 32,
      ANNOTATIONS_DISABLE: 64,
      IS_EDITING: 128,
      OPLIST: 256
    };
    AnnotationMode = {
      DISABLE: 0,
      ENABLE: 1,
      ENABLE_FORMS: 2,
      ENABLE_STORAGE: 3
    };
    AnnotationEditorPrefix = "pdfjs_internal_editor_";
    AnnotationEditorType = {
      DISABLE: -1,
      NONE: 0,
      FREETEXT: 3,
      HIGHLIGHT: 9,
      STAMP: 13,
      INK: 15,
      POPUP: 16,
      SIGNATURE: 101,
      COMMENT: 102
    };
    AnnotationEditorParamsType = {
      RESIZE: 1,
      CREATE: 2,
      FREETEXT_SIZE: 11,
      FREETEXT_COLOR: 12,
      FREETEXT_OPACITY: 13,
      INK_COLOR: 21,
      INK_THICKNESS: 22,
      INK_OPACITY: 23,
      HIGHLIGHT_COLOR: 31,
      HIGHLIGHT_THICKNESS: 32,
      HIGHLIGHT_FREE: 33,
      HIGHLIGHT_SHOW_ALL: 34,
      DRAW_STEP: 41
    };
    PermissionFlag = {
      PRINT: 4,
      MODIFY_CONTENTS: 8,
      COPY: 16,
      MODIFY_ANNOTATIONS: 32,
      FILL_INTERACTIVE_FORMS: 256,
      COPY_FOR_ACCESSIBILITY: 512,
      ASSEMBLE: 1024,
      PRINT_HIGH_QUALITY: 2048
    };
    TextRenderingMode = {
      FILL: 0,
      STROKE: 1,
      FILL_STROKE: 2,
      INVISIBLE: 3,
      FILL_ADD_TO_PATH: 4,
      STROKE_ADD_TO_PATH: 5,
      FILL_STROKE_ADD_TO_PATH: 6,
      ADD_TO_PATH: 7,
      FILL_STROKE_MASK: 3,
      ADD_TO_PATH_FLAG: 4
    };
    util_ImageKind = {
      GRAYSCALE_1BPP: 1,
      RGB_24BPP: 2,
      RGBA_32BPP: 3
    };
    AnnotationType = {
      TEXT: 1,
      LINK: 2,
      FREETEXT: 3,
      LINE: 4,
      SQUARE: 5,
      CIRCLE: 6,
      POLYGON: 7,
      POLYLINE: 8,
      HIGHLIGHT: 9,
      UNDERLINE: 10,
      SQUIGGLY: 11,
      STRIKEOUT: 12,
      STAMP: 13,
      CARET: 14,
      INK: 15,
      POPUP: 16,
      FILEATTACHMENT: 17,
      SOUND: 18,
      MOVIE: 19,
      WIDGET: 20,
      SCREEN: 21,
      PRINTERMARK: 22,
      TRAPNET: 23,
      WATERMARK: 24,
      THREED: 25,
      REDACT: 26
    };
    AnnotationBorderStyleType = {
      SOLID: 1,
      DASHED: 2,
      BEVELED: 3,
      INSET: 4,
      UNDERLINE: 5
    };
    VerbosityLevel = {
      ERRORS: 0,
      WARNINGS: 1,
      INFOS: 5
    };
    OPS = {
      dependency: 1,
      setLineWidth: 2,
      setLineCap: 3,
      setLineJoin: 4,
      setMiterLimit: 5,
      setDash: 6,
      setRenderingIntent: 7,
      setFlatness: 8,
      setGState: 9,
      save: 10,
      restore: 11,
      transform: 12,
      moveTo: 13,
      lineTo: 14,
      curveTo: 15,
      curveTo2: 16,
      curveTo3: 17,
      closePath: 18,
      rectangle: 19,
      stroke: 20,
      closeStroke: 21,
      fill: 22,
      eoFill: 23,
      fillStroke: 24,
      eoFillStroke: 25,
      closeFillStroke: 26,
      closeEOFillStroke: 27,
      endPath: 28,
      clip: 29,
      eoClip: 30,
      beginText: 31,
      endText: 32,
      setCharSpacing: 33,
      setWordSpacing: 34,
      setHScale: 35,
      setLeading: 36,
      setFont: 37,
      setTextRenderingMode: 38,
      setTextRise: 39,
      moveText: 40,
      setLeadingMoveText: 41,
      setTextMatrix: 42,
      nextLine: 43,
      showText: 44,
      showSpacedText: 45,
      nextLineShowText: 46,
      nextLineSetSpacingShowText: 47,
      setCharWidth: 48,
      setCharWidthAndBounds: 49,
      setStrokeColorSpace: 50,
      setFillColorSpace: 51,
      setStrokeColor: 52,
      setStrokeColorN: 53,
      setFillColor: 54,
      setFillColorN: 55,
      setStrokeGray: 56,
      setFillGray: 57,
      setStrokeRGBColor: 58,
      setFillRGBColor: 59,
      setStrokeCMYKColor: 60,
      setFillCMYKColor: 61,
      shadingFill: 62,
      beginInlineImage: 63,
      beginImageData: 64,
      endInlineImage: 65,
      paintXObject: 66,
      markPoint: 67,
      markPointProps: 68,
      beginMarkedContent: 69,
      beginMarkedContentProps: 70,
      endMarkedContent: 71,
      beginCompat: 72,
      endCompat: 73,
      paintFormXObjectBegin: 74,
      paintFormXObjectEnd: 75,
      beginGroup: 76,
      endGroup: 77,
      beginAnnotation: 80,
      endAnnotation: 81,
      paintImageMaskXObject: 83,
      paintImageMaskXObjectGroup: 84,
      paintImageXObject: 85,
      paintInlineImageXObject: 86,
      paintInlineImageXObjectGroup: 87,
      paintImageXObjectRepeat: 88,
      paintImageMaskXObjectRepeat: 89,
      paintSolidColorImageMask: 90,
      constructPath: 91,
      setStrokeTransparent: 92,
      setFillTransparent: 93,
      rawFillPath: 94
    };
    DrawOPS = {
      moveTo: 0,
      lineTo: 1,
      curveTo: 2,
      closePath: 3
    };
    PasswordResponses = {
      NEED_PASSWORD: 1,
      INCORRECT_PASSWORD: 2
    };
    verbosity = VerbosityLevel.WARNINGS;
    BaseException = (function BaseExceptionClosure() {
      function BaseException2(message, name) {
        this.message = message;
        this.name = name;
      }
      BaseException2.prototype = new Error();
      BaseException2.constructor = BaseException2;
      return BaseException2;
    })();
    PasswordException = class extends BaseException {
      constructor(msg, code) {
        super(msg, "PasswordException");
        this.code = code;
      }
    };
    UnknownErrorException = class extends BaseException {
      constructor(msg, details) {
        super(msg, "UnknownErrorException");
        this.details = details;
      }
    };
    InvalidPDFException = class extends BaseException {
      constructor(msg) {
        super(msg, "InvalidPDFException");
      }
    };
    ResponseException = class extends BaseException {
      constructor(msg, status, missing) {
        super(msg, "ResponseException");
        this.status = status;
        this.missing = missing;
      }
    };
    FormatError = class extends BaseException {
      constructor(msg) {
        super(msg, "FormatError");
      }
    };
    AbortException = class extends BaseException {
      constructor(msg) {
        super(msg, "AbortException");
      }
    };
    util_FeatureTest = class {
      static get isLittleEndian() {
        return shadow(this, "isLittleEndian", isLittleEndian());
      }
      static get isEvalSupported() {
        return shadow(this, "isEvalSupported", isEvalSupported());
      }
      static get isOffscreenCanvasSupported() {
        return shadow(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas !== "undefined");
      }
      static get isImageDecoderSupported() {
        return shadow(this, "isImageDecoderSupported", typeof ImageDecoder !== "undefined");
      }
      static get platform() {
        const {
          platform,
          userAgent
        } = navigator;
        return shadow(this, "platform", {
          isAndroid: userAgent.includes("Android"),
          isLinux: platform.includes("Linux"),
          isMac: platform.includes("Mac"),
          isWindows: platform.includes("Win"),
          isFirefox: userAgent.includes("Firefox")
        });
      }
      static get isCSSRoundSupported() {
        return shadow(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)"));
      }
    };
    hexNumbers = Array.from(Array(256).keys(), (n) => n.toString(16).padStart(2, "0"));
    Util = class {
      static makeHexColor(r, g, b) {
        return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;
      }
      static domMatrixToTransform(dm) {
        return [dm.a, dm.b, dm.c, dm.d, dm.e, dm.f];
      }
      static scaleMinMax(transform, minMax) {
        let temp;
        if (transform[0]) {
          if (transform[0] < 0) {
            temp = minMax[0];
            minMax[0] = minMax[2];
            minMax[2] = temp;
          }
          minMax[0] *= transform[0];
          minMax[2] *= transform[0];
          if (transform[3] < 0) {
            temp = minMax[1];
            minMax[1] = minMax[3];
            minMax[3] = temp;
          }
          minMax[1] *= transform[3];
          minMax[3] *= transform[3];
        } else {
          temp = minMax[0];
          minMax[0] = minMax[1];
          minMax[1] = temp;
          temp = minMax[2];
          minMax[2] = minMax[3];
          minMax[3] = temp;
          if (transform[1] < 0) {
            temp = minMax[1];
            minMax[1] = minMax[3];
            minMax[3] = temp;
          }
          minMax[1] *= transform[1];
          minMax[3] *= transform[1];
          if (transform[2] < 0) {
            temp = minMax[0];
            minMax[0] = minMax[2];
            minMax[2] = temp;
          }
          minMax[0] *= transform[2];
          minMax[2] *= transform[2];
        }
        minMax[0] += transform[4];
        minMax[1] += transform[5];
        minMax[2] += transform[4];
        minMax[3] += transform[5];
      }
      static transform(m1, m2) {
        return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];
      }
      static multiplyByDOMMatrix(m, md) {
        return [m[0] * md.a + m[2] * md.b, m[1] * md.a + m[3] * md.b, m[0] * md.c + m[2] * md.d, m[1] * md.c + m[3] * md.d, m[0] * md.e + m[2] * md.f + m[4], m[1] * md.e + m[3] * md.f + m[5]];
      }
      static applyTransform(p, m, pos = 0) {
        const p0 = p[pos];
        const p1 = p[pos + 1];
        p[pos] = p0 * m[0] + p1 * m[2] + m[4];
        p[pos + 1] = p0 * m[1] + p1 * m[3] + m[5];
      }
      static applyTransformToBezier(p, transform, pos = 0) {
        const m0 = transform[0];
        const m1 = transform[1];
        const m2 = transform[2];
        const m3 = transform[3];
        const m4 = transform[4];
        const m5 = transform[5];
        for (let i = 0; i < 6; i += 2) {
          const pI = p[pos + i];
          const pI1 = p[pos + i + 1];
          p[pos + i] = pI * m0 + pI1 * m2 + m4;
          p[pos + i + 1] = pI * m1 + pI1 * m3 + m5;
        }
      }
      static applyInverseTransform(p, m) {
        const p0 = p[0];
        const p1 = p[1];
        const d = m[0] * m[3] - m[1] * m[2];
        p[0] = (p0 * m[3] - p1 * m[2] + m[2] * m[5] - m[4] * m[3]) / d;
        p[1] = (-p0 * m[1] + p1 * m[0] + m[4] * m[1] - m[5] * m[0]) / d;
      }
      static axialAlignedBoundingBox(rect, transform, output) {
        const m0 = transform[0];
        const m1 = transform[1];
        const m2 = transform[2];
        const m3 = transform[3];
        const m4 = transform[4];
        const m5 = transform[5];
        const r0 = rect[0];
        const r1 = rect[1];
        const r2 = rect[2];
        const r3 = rect[3];
        let a0 = m0 * r0 + m4;
        let a2 = a0;
        let a1 = m0 * r2 + m4;
        let a3 = a1;
        let b0 = m3 * r1 + m5;
        let b2 = b0;
        let b1 = m3 * r3 + m5;
        let b3 = b1;
        if (m1 !== 0 || m2 !== 0) {
          const m1r0 = m1 * r0;
          const m1r2 = m1 * r2;
          const m2r1 = m2 * r1;
          const m2r3 = m2 * r3;
          a0 += m2r1;
          a3 += m2r1;
          a1 += m2r3;
          a2 += m2r3;
          b0 += m1r0;
          b3 += m1r0;
          b1 += m1r2;
          b2 += m1r2;
        }
        output[0] = Math.min(output[0], a0, a1, a2, a3);
        output[1] = Math.min(output[1], b0, b1, b2, b3);
        output[2] = Math.max(output[2], a0, a1, a2, a3);
        output[3] = Math.max(output[3], b0, b1, b2, b3);
      }
      static inverseTransform(m) {
        const d = m[0] * m[3] - m[1] * m[2];
        return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];
      }
      static singularValueDecompose2dScale(matrix, output) {
        const m0 = matrix[0];
        const m1 = matrix[1];
        const m2 = matrix[2];
        const m3 = matrix[3];
        const a = m0 ** 2 + m1 ** 2;
        const b = m0 * m2 + m1 * m3;
        const c = m2 ** 2 + m3 ** 2;
        const first2 = (a + c) / 2;
        const second = Math.sqrt(first2 ** 2 - (a * c - b ** 2));
        output[0] = Math.sqrt(first2 + second || 1);
        output[1] = Math.sqrt(first2 - second || 1);
      }
      static normalizeRect(rect) {
        const r = rect.slice(0);
        if (rect[0] > rect[2]) {
          r[0] = rect[2];
          r[2] = rect[0];
        }
        if (rect[1] > rect[3]) {
          r[1] = rect[3];
          r[3] = rect[1];
        }
        return r;
      }
      static intersect(rect1, rect2) {
        const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));
        const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));
        if (xLow > xHigh) {
          return null;
        }
        const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));
        const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));
        if (yLow > yHigh) {
          return null;
        }
        return [xLow, yLow, xHigh, yHigh];
      }
      static pointBoundingBox(x, y, minMax) {
        minMax[0] = Math.min(minMax[0], x);
        minMax[1] = Math.min(minMax[1], y);
        minMax[2] = Math.max(minMax[2], x);
        minMax[3] = Math.max(minMax[3], y);
      }
      static rectBoundingBox(x0, y0, x1, y1, minMax) {
        minMax[0] = Math.min(minMax[0], x0, x1);
        minMax[1] = Math.min(minMax[1], y0, y1);
        minMax[2] = Math.max(minMax[2], x0, x1);
        minMax[3] = Math.max(minMax[3], y0, y1);
      }
      static #getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, t, minMax) {
        if (t <= 0 || t >= 1) {
          return;
        }
        const mt = 1 - t;
        const tt = t * t;
        const ttt = tt * t;
        const x = mt * (mt * (mt * x0 + 3 * t * x1) + 3 * tt * x2) + ttt * x3;
        const y = mt * (mt * (mt * y0 + 3 * t * y1) + 3 * tt * y2) + ttt * y3;
        minMax[0] = Math.min(minMax[0], x);
        minMax[1] = Math.min(minMax[1], y);
        minMax[2] = Math.max(minMax[2], x);
        minMax[3] = Math.max(minMax[3], y);
      }
      static #getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, a, b, c, minMax) {
        if (Math.abs(a) < 1e-12) {
          if (Math.abs(b) >= 1e-12) {
            this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, -c / b, minMax);
          }
          return;
        }
        const delta = b ** 2 - 4 * c * a;
        if (delta < 0) {
          return;
        }
        const sqrtDelta = Math.sqrt(delta);
        const a2 = 2 * a;
        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b + sqrtDelta) / a2, minMax);
        this.#getExtremumOnCurve(x0, x1, x2, x3, y0, y1, y2, y3, (-b - sqrtDelta) / a2, minMax);
      }
      static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3, minMax) {
        minMax[0] = Math.min(minMax[0], x0, x3);
        minMax[1] = Math.min(minMax[1], y0, y3);
        minMax[2] = Math.max(minMax[2], x0, x3);
        minMax[3] = Math.max(minMax[3], y0, y3);
        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-x0 + 3 * (x1 - x2) + x3), 6 * (x0 - 2 * x1 + x2), 3 * (x1 - x0), minMax);
        this.#getExtremum(x0, x1, x2, x3, y0, y1, y2, y3, 3 * (-y0 + 3 * (y1 - y2) + y3), 6 * (y0 - 2 * y1 + y2), 3 * (y1 - y0), minMax);
      }
    };
    NormalizeRegex = null;
    NormalizationMap = null;
    AnnotationPrefix = "pdfjs_internal_id_";
    if (typeof Math.sumPrecise !== "function") {
      Math.sumPrecise = function(numbers) {
        return numbers.reduce((a, b) => a + b, 0);
      };
    }
    if (typeof AbortSignal.any !== "function") {
      AbortSignal.any = function(iterable) {
        const ac = new AbortController();
        const {
          signal
        } = ac;
        for (const s of iterable) {
          if (s.aborted) {
            ac.abort(s.reason);
            return signal;
          }
        }
        for (const s of iterable) {
          s.addEventListener("abort", () => {
            ac.abort(s.reason);
          }, {
            signal
          });
        }
        return signal;
      };
    }
    es_iterator_map = __webpack_require__(1701);
    web_url_search_params_delete = __webpack_require__(4603);
    web_url_search_params_has = __webpack_require__(7566);
    web_url_search_params_size = __webpack_require__(8721);
    XfaText = class _XfaText {
      static textContent(xfa) {
        const items = [];
        const output = {
          items,
          styles: /* @__PURE__ */ Object.create(null)
        };
        function walk(node) {
          if (!node) {
            return;
          }
          let str = null;
          const name = node.name;
          if (name === "#text") {
            str = node.value;
          } else if (!_XfaText.shouldBuildText(name)) {
            return;
          } else if (node?.attributes?.textContent) {
            str = node.attributes.textContent;
          } else if (node.value) {
            str = node.value;
          }
          if (str !== null) {
            items.push({
              str
            });
          }
          if (!node.children) {
            return;
          }
          for (const child of node.children) {
            walk(child);
          }
        }
        walk(xfa);
        return output;
      }
      static shouldBuildText(name) {
        return !(name === "textarea" || name === "input" || name === "option" || name === "select");
      }
    };
    XfaLayer = class {
      static setupStorage(html, id, element, storage, intent) {
        const storedData = storage.getValue(id, {
          value: null
        });
        switch (element.name) {
          case "textarea":
            if (storedData.value !== null) {
              html.textContent = storedData.value;
            }
            if (intent === "print") {
              break;
            }
            html.addEventListener("input", (event) => {
              storage.setValue(id, {
                value: event.target.value
              });
            });
            break;
          case "input":
            if (element.attributes.type === "radio" || element.attributes.type === "checkbox") {
              if (storedData.value === element.attributes.xfaOn) {
                html.setAttribute("checked", true);
              } else if (storedData.value === element.attributes.xfaOff) {
                html.removeAttribute("checked");
              }
              if (intent === "print") {
                break;
              }
              html.addEventListener("change", (event) => {
                storage.setValue(id, {
                  value: event.target.checked ? event.target.getAttribute("xfaOn") : event.target.getAttribute("xfaOff")
                });
              });
            } else {
              if (storedData.value !== null) {
                html.setAttribute("value", storedData.value);
              }
              if (intent === "print") {
                break;
              }
              html.addEventListener("input", (event) => {
                storage.setValue(id, {
                  value: event.target.value
                });
              });
            }
            break;
          case "select":
            if (storedData.value !== null) {
              html.setAttribute("value", storedData.value);
              for (const option of element.children) {
                if (option.attributes.value === storedData.value) {
                  option.attributes.selected = true;
                } else if (option.attributes.hasOwnProperty("selected")) {
                  delete option.attributes.selected;
                }
              }
            }
            html.addEventListener("input", (event) => {
              const options = event.target.options;
              const value = options.selectedIndex === -1 ? "" : options[options.selectedIndex].value;
              storage.setValue(id, {
                value
              });
            });
            break;
        }
      }
      static setAttributes({
        html,
        element,
        storage = null,
        intent,
        linkService
      }) {
        const {
          attributes
        } = element;
        const isHTMLAnchorElement = html instanceof HTMLAnchorElement;
        if (attributes.type === "radio") {
          attributes.name = `${attributes.name}-${intent}`;
        }
        for (const [key, value] of Object.entries(attributes)) {
          if (value === null || value === void 0) {
            continue;
          }
          switch (key) {
            case "class":
              if (value.length) {
                html.setAttribute(key, value.join(" "));
              }
              break;
            case "dataId":
              break;
            case "id":
              html.setAttribute("data-element-id", value);
              break;
            case "style":
              Object.assign(html.style, value);
              break;
            case "textContent":
              html.textContent = value;
              break;
            default:
              if (!isHTMLAnchorElement || key !== "href" && key !== "newWindow") {
                html.setAttribute(key, value);
              }
          }
        }
        if (isHTMLAnchorElement) {
          linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);
        }
        if (storage && attributes.dataId) {
          this.setupStorage(html, attributes.dataId, element, storage);
        }
      }
      static render(parameters) {
        const storage = parameters.annotationStorage;
        const linkService = parameters.linkService;
        const root2 = parameters.xfaHtml;
        const intent = parameters.intent || "display";
        const rootHtml = document.createElement(root2.name);
        if (root2.attributes) {
          this.setAttributes({
            html: rootHtml,
            element: root2,
            intent,
            linkService
          });
        }
        const isNotForRichText = intent !== "richText";
        const rootDiv = parameters.div;
        rootDiv.append(rootHtml);
        if (parameters.viewport) {
          const transform = `matrix(${parameters.viewport.transform.join(",")})`;
          rootDiv.style.transform = transform;
        }
        if (isNotForRichText) {
          rootDiv.setAttribute("class", "xfaLayer xfaFont");
        }
        const textDivs = [];
        if (root2.children.length === 0) {
          if (root2.value) {
            const node = document.createTextNode(root2.value);
            rootHtml.append(node);
            if (isNotForRichText && XfaText.shouldBuildText(root2.name)) {
              textDivs.push(node);
            }
          }
          return {
            textDivs
          };
        }
        const stack = [[root2, -1, rootHtml]];
        while (stack.length > 0) {
          const [parent, i, html] = stack.at(-1);
          if (i + 1 === parent.children.length) {
            stack.pop();
            continue;
          }
          const child = parent.children[++stack.at(-1)[1]];
          if (child === null) {
            continue;
          }
          const {
            name
          } = child;
          if (name === "#text") {
            const node = document.createTextNode(child.value);
            textDivs.push(node);
            html.append(node);
            continue;
          }
          const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);
          html.append(childHtml);
          if (child.attributes) {
            this.setAttributes({
              html: childHtml,
              element: child,
              storage,
              intent,
              linkService
            });
          }
          if (child.children?.length > 0) {
            stack.push([child, -1, childHtml]);
          } else if (child.value) {
            const node = document.createTextNode(child.value);
            if (isNotForRichText && XfaText.shouldBuildText(name)) {
              textDivs.push(node);
            }
            childHtml.append(node);
          }
        }
        for (const el of rootDiv.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) {
          el.setAttribute("readOnly", true);
        }
        return {
          textDivs
        };
      }
      static update(parameters) {
        const transform = `matrix(${parameters.viewport.transform.join(",")})`;
        parameters.div.style.transform = transform;
        parameters.div.hidden = false;
      }
    };
    SVG_NS = "http://www.w3.org/2000/svg";
    PixelsPerInch = class {
      static CSS = 96;
      static PDF = 72;
      static PDF_TO_CSS_UNITS = this.CSS / this.PDF;
    };
    PageViewport = class _PageViewport {
      constructor({
        viewBox,
        userUnit,
        scale,
        rotation,
        offsetX = 0,
        offsetY = 0,
        dontFlip = false
      }) {
        this.viewBox = viewBox;
        this.userUnit = userUnit;
        this.scale = scale;
        this.rotation = rotation;
        this.offsetX = offsetX;
        this.offsetY = offsetY;
        scale *= userUnit;
        const centerX = (viewBox[2] + viewBox[0]) / 2;
        const centerY = (viewBox[3] + viewBox[1]) / 2;
        let rotateA, rotateB, rotateC, rotateD;
        rotation %= 360;
        if (rotation < 0) {
          rotation += 360;
        }
        switch (rotation) {
          case 180:
            rotateA = -1;
            rotateB = 0;
            rotateC = 0;
            rotateD = 1;
            break;
          case 90:
            rotateA = 0;
            rotateB = 1;
            rotateC = 1;
            rotateD = 0;
            break;
          case 270:
            rotateA = 0;
            rotateB = -1;
            rotateC = -1;
            rotateD = 0;
            break;
          case 0:
            rotateA = 1;
            rotateB = 0;
            rotateC = 0;
            rotateD = -1;
            break;
          default:
            throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.");
        }
        if (dontFlip) {
          rotateC = -rotateC;
          rotateD = -rotateD;
        }
        let offsetCanvasX, offsetCanvasY;
        let width, height;
        if (rotateA === 0) {
          offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;
          offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;
          width = (viewBox[3] - viewBox[1]) * scale;
          height = (viewBox[2] - viewBox[0]) * scale;
        } else {
          offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;
          offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;
          width = (viewBox[2] - viewBox[0]) * scale;
          height = (viewBox[3] - viewBox[1]) * scale;
        }
        this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];
        this.width = width;
        this.height = height;
      }
      get rawDims() {
        const dims = this.viewBox;
        return shadow(this, "rawDims", {
          pageWidth: dims[2] - dims[0],
          pageHeight: dims[3] - dims[1],
          pageX: dims[0],
          pageY: dims[1]
        });
      }
      clone({
        scale = this.scale,
        rotation = this.rotation,
        offsetX = this.offsetX,
        offsetY = this.offsetY,
        dontFlip = false
      } = {}) {
        return new _PageViewport({
          viewBox: this.viewBox.slice(),
          userUnit: this.userUnit,
          scale,
          rotation,
          offsetX,
          offsetY,
          dontFlip
        });
      }
      convertToViewportPoint(x, y) {
        const p = [x, y];
        Util.applyTransform(p, this.transform);
        return p;
      }
      convertToViewportRectangle(rect) {
        const topLeft = [rect[0], rect[1]];
        Util.applyTransform(topLeft, this.transform);
        const bottomRight = [rect[2], rect[3]];
        Util.applyTransform(bottomRight, this.transform);
        return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];
      }
      convertToPdfPoint(x, y) {
        const p = [x, y];
        Util.applyInverseTransform(p, this.transform);
        return p;
      }
    };
    RenderingCancelledException = class extends BaseException {
      constructor(msg, extraDelay = 0) {
        super(msg, "RenderingCancelledException");
        this.extraDelay = extraDelay;
      }
    };
    StatTimer = class {
      started = /* @__PURE__ */ Object.create(null);
      times = [];
      time(name) {
        if (name in this.started) {
          warn(`Timer is already running for ${name}`);
        }
        this.started[name] = Date.now();
      }
      timeEnd(name) {
        if (!(name in this.started)) {
          warn(`Timer has not been started for ${name}`);
        }
        this.times.push({
          name,
          start: this.started[name],
          end: Date.now()
        });
        delete this.started[name];
      }
      toString() {
        const outBuf = [];
        let longest = 0;
        for (const {
          name
        } of this.times) {
          longest = Math.max(name.length, longest);
        }
        for (const {
          name,
          start,
          end
        } of this.times) {
          outBuf.push(`${name.padEnd(longest)} ${end - start}ms
`);
        }
        return outBuf.join("");
      }
    };
    PDFDateString = class {
      static #regex;
      static toDateObject(input) {
        if (input instanceof Date) {
          return input;
        }
        if (!input || typeof input !== "string") {
          return null;
        }
        this.#regex ||= new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?");
        const matches = this.#regex.exec(input);
        if (!matches) {
          return null;
        }
        const year = parseInt(matches[1], 10);
        let month = parseInt(matches[2], 10);
        month = month >= 1 && month <= 12 ? month - 1 : 0;
        let day = parseInt(matches[3], 10);
        day = day >= 1 && day <= 31 ? day : 1;
        let hour = parseInt(matches[4], 10);
        hour = hour >= 0 && hour <= 23 ? hour : 0;
        let minute = parseInt(matches[5], 10);
        minute = minute >= 0 && minute <= 59 ? minute : 0;
        let second = parseInt(matches[6], 10);
        second = second >= 0 && second <= 59 ? second : 0;
        const universalTimeRelation = matches[7] || "Z";
        let offsetHour = parseInt(matches[8], 10);
        offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;
        let offsetMinute = parseInt(matches[9], 10) || 0;
        offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;
        if (universalTimeRelation === "-") {
          hour += offsetHour;
          minute += offsetMinute;
        } else if (universalTimeRelation === "+") {
          hour -= offsetHour;
          minute -= offsetMinute;
        }
        return new Date(Date.UTC(year, month, day, hour, minute, second));
      }
    };
    OutputScale = class _OutputScale {
      constructor() {
        const {
          pixelRatio
        } = _OutputScale;
        this.sx = pixelRatio;
        this.sy = pixelRatio;
      }
      get scaled() {
        return this.sx !== 1 || this.sy !== 1;
      }
      get symmetric() {
        return this.sx === this.sy;
      }
      limitCanvas(width, height, maxPixels, maxDim, capAreaFactor = -1) {
        let maxAreaScale = Infinity, maxWidthScale = Infinity, maxHeightScale = Infinity;
        maxPixels = _OutputScale.capPixels(maxPixels, capAreaFactor);
        if (maxPixels > 0) {
          maxAreaScale = Math.sqrt(maxPixels / (width * height));
        }
        if (maxDim !== -1) {
          maxWidthScale = maxDim / width;
          maxHeightScale = maxDim / height;
        }
        const maxScale = Math.min(maxAreaScale, maxWidthScale, maxHeightScale);
        if (this.sx > maxScale || this.sy > maxScale) {
          this.sx = maxScale;
          this.sy = maxScale;
          return true;
        }
        return false;
      }
      static get pixelRatio() {
        return globalThis.devicePixelRatio || 1;
      }
      static capPixels(maxPixels, capAreaFactor) {
        if (capAreaFactor >= 0) {
          const winPixels = Math.ceil(window.screen.availWidth * window.screen.availHeight * this.pixelRatio ** 2 * (1 + capAreaFactor / 100));
          return maxPixels > 0 ? Math.min(maxPixels, winPixels) : winPixels;
        }
        return maxPixels;
      }
    };
    SupportedImageMimeTypes = ["image/apng", "image/avif", "image/bmp", "image/gif", "image/jpeg", "image/png", "image/svg+xml", "image/webp", "image/x-icon"];
    ColorScheme = class {
      static get isDarkMode() {
        return shadow(this, "isDarkMode", !!window?.matchMedia?.("(prefers-color-scheme: dark)").matches);
      }
    };
    CSSConstants = class {
      static get commentForegroundColor() {
        const element = document.createElement("span");
        element.classList.add("comment", "sidebar");
        const {
          style
        } = element;
        style.width = style.height = "0";
        style.display = "none";
        style.color = "var(--comment-fg-color)";
        document.body.append(element);
        const {
          color
        } = window.getComputedStyle(element);
        element.remove();
        return shadow(this, "commentForegroundColor", getRGB(color));
      }
    };
    contrastCache = /* @__PURE__ */ new Map();
    es_iterator_take = __webpack_require__(4972);
    es_promise_with_resolvers = __webpack_require__(4628);
    es_set_difference_v2 = __webpack_require__(7642);
    es_set_intersection_v2 = __webpack_require__(8004);
    es_set_is_disjoint_from_v2 = __webpack_require__(3853);
    es_set_is_subset_of_v2 = __webpack_require__(5876);
    es_set_is_superset_of_v2 = __webpack_require__(2475);
    es_set_symmetric_difference_v2 = __webpack_require__(5024);
    es_set_union_v2 = __webpack_require__(1698);
    es_iterator_drop = __webpack_require__(9314);
    es_iterator_every = __webpack_require__(1148);
    es_iterator_some = __webpack_require__(3579);
    esnext_json_parse = __webpack_require__(8335);
    EditorToolbar = class _EditorToolbar {
      #toolbar = null;
      #colorPicker = null;
      #editor;
      #buttons = null;
      #altText = null;
      #comment = null;
      #commentButtonDivider = null;
      #signatureDescriptionButton = null;
      static #l10nRemove = null;
      constructor(editor) {
        this.#editor = editor;
        _EditorToolbar.#l10nRemove ||= Object.freeze({
          freetext: "pdfjs-editor-remove-freetext-button",
          highlight: "pdfjs-editor-remove-highlight-button",
          ink: "pdfjs-editor-remove-ink-button",
          stamp: "pdfjs-editor-remove-stamp-button",
          signature: "pdfjs-editor-remove-signature-button"
        });
      }
      render() {
        const editToolbar = this.#toolbar = document.createElement("div");
        editToolbar.classList.add("editToolbar", "hidden");
        editToolbar.setAttribute("role", "toolbar");
        const signal = this.#editor._uiManager._signal;
        if (signal instanceof AbortSignal && !signal.aborted) {
          editToolbar.addEventListener("contextmenu", noContextMenu, {
            signal
          });
          editToolbar.addEventListener("pointerdown", _EditorToolbar.#pointerDown, {
            signal
          });
        }
        const buttons = this.#buttons = document.createElement("div");
        buttons.className = "buttons";
        editToolbar.append(buttons);
        const position = this.#editor.toolbarPosition;
        if (position) {
          const {
            style
          } = editToolbar;
          const x = this.#editor._uiManager.direction === "ltr" ? 1 - position[0] : position[0];
          style.insetInlineEnd = `${100 * x}%`;
          style.top = `calc(${100 * position[1]}% + var(--editor-toolbar-vert-offset))`;
        }
        return editToolbar;
      }
      get div() {
        return this.#toolbar;
      }
      static #pointerDown(e) {
        e.stopPropagation();
      }
      #focusIn(e) {
        this.#editor._focusEventsAllowed = false;
        stopEvent(e);
      }
      #focusOut(e) {
        this.#editor._focusEventsAllowed = true;
        stopEvent(e);
      }
      #addListenersToElement(element) {
        const signal = this.#editor._uiManager._signal;
        if (!(signal instanceof AbortSignal) || signal.aborted) {
          return false;
        }
        element.addEventListener("focusin", this.#focusIn.bind(this), {
          capture: true,
          signal
        });
        element.addEventListener("focusout", this.#focusOut.bind(this), {
          capture: true,
          signal
        });
        element.addEventListener("contextmenu", noContextMenu, {
          signal
        });
        return true;
      }
      hide() {
        this.#toolbar.classList.add("hidden");
        this.#colorPicker?.hideDropdown();
      }
      show() {
        this.#toolbar.classList.remove("hidden");
        this.#altText?.shown();
        this.#comment?.shown();
      }
      addDeleteButton() {
        const {
          editorType,
          _uiManager
        } = this.#editor;
        const button = document.createElement("button");
        button.classList.add("basic", "deleteButton");
        button.tabIndex = 0;
        button.setAttribute("data-l10n-id", _EditorToolbar.#l10nRemove[editorType]);
        if (this.#addListenersToElement(button)) {
          button.addEventListener("click", (e) => {
            _uiManager.delete();
          }, {
            signal: _uiManager._signal
          });
        }
        this.#buttons.append(button);
      }
      get #divider() {
        const divider = document.createElement("div");
        divider.className = "divider";
        return divider;
      }
      async addAltText(altText) {
        const button = await altText.render();
        this.#addListenersToElement(button);
        this.#buttons.append(button, this.#divider);
        this.#altText = altText;
      }
      addComment(comment, beforeElement = null) {
        if (this.#comment) {
          return;
        }
        const button = comment.renderForToolbar();
        if (!button) {
          return;
        }
        this.#addListenersToElement(button);
        const divider = this.#commentButtonDivider = this.#divider;
        if (!beforeElement) {
          this.#buttons.append(button, divider);
        } else {
          this.#buttons.insertBefore(button, beforeElement);
          this.#buttons.insertBefore(divider, beforeElement);
        }
        this.#comment = comment;
        comment.toolbar = this;
      }
      addColorPicker(colorPicker) {
        if (this.#colorPicker) {
          return;
        }
        this.#colorPicker = colorPicker;
        const button = colorPicker.renderButton();
        this.#addListenersToElement(button);
        this.#buttons.append(button, this.#divider);
      }
      async addEditSignatureButton(signatureManager) {
        const button = this.#signatureDescriptionButton = await signatureManager.renderEditButton(this.#editor);
        this.#addListenersToElement(button);
        this.#buttons.append(button, this.#divider);
      }
      removeButton(name) {
        switch (name) {
          case "comment":
            this.#comment?.removeToolbarCommentButton();
            this.#comment = null;
            this.#commentButtonDivider?.remove();
            this.#commentButtonDivider = null;
            break;
        }
      }
      async addButton(name, tool) {
        switch (name) {
          case "colorPicker":
            this.addColorPicker(tool);
            break;
          case "altText":
            await this.addAltText(tool);
            break;
          case "editSignature":
            await this.addEditSignatureButton(tool);
            break;
          case "delete":
            this.addDeleteButton();
            break;
          case "comment":
            this.addComment(tool);
            break;
        }
      }
      async addButtonBefore(name, tool, beforeSelector) {
        const beforeElement = this.#buttons.querySelector(beforeSelector);
        if (!beforeElement) {
          return;
        }
        if (name === "comment") {
          this.addComment(tool, beforeElement);
        }
      }
      updateEditSignatureButton(description) {
        if (this.#signatureDescriptionButton) {
          this.#signatureDescriptionButton.title = description;
        }
      }
      remove() {
        this.#toolbar.remove();
        this.#colorPicker?.destroy();
        this.#colorPicker = null;
      }
    };
    FloatingToolbar = class {
      #buttons = null;
      #toolbar = null;
      #uiManager;
      constructor(uiManager) {
        this.#uiManager = uiManager;
      }
      #render() {
        const editToolbar = this.#toolbar = document.createElement("div");
        editToolbar.className = "editToolbar";
        editToolbar.setAttribute("role", "toolbar");
        const signal = this.#uiManager._signal;
        if (signal instanceof AbortSignal && !signal.aborted) {
          editToolbar.addEventListener("contextmenu", noContextMenu, {
            signal
          });
        }
        const buttons = this.#buttons = document.createElement("div");
        buttons.className = "buttons";
        editToolbar.append(buttons);
        if (this.#uiManager.hasCommentManager()) {
          this.#makeButton("commentButton", `pdfjs-comment-floating-button`, "pdfjs-comment-floating-button-label", () => {
            this.#uiManager.commentSelection("floating_button");
          });
        }
        this.#makeButton("highlightButton", `pdfjs-highlight-floating-button1`, "pdfjs-highlight-floating-button-label", () => {
          this.#uiManager.highlightSelection("floating_button");
        });
        return editToolbar;
      }
      #getLastPoint(boxes, isLTR) {
        let lastY = 0;
        let lastX = 0;
        for (const box of boxes) {
          const y = box.y + box.height;
          if (y < lastY) {
            continue;
          }
          const x = box.x + (isLTR ? box.width : 0);
          if (y > lastY) {
            lastX = x;
            lastY = y;
            continue;
          }
          if (isLTR) {
            if (x > lastX) {
              lastX = x;
            }
          } else if (x < lastX) {
            lastX = x;
          }
        }
        return [isLTR ? 1 - lastX : lastX, lastY];
      }
      show(parent, boxes, isLTR) {
        const [x, y] = this.#getLastPoint(boxes, isLTR);
        const {
          style
        } = this.#toolbar ||= this.#render();
        parent.append(this.#toolbar);
        style.insetInlineEnd = `${100 * x}%`;
        style.top = `calc(${100 * y}% + var(--editor-toolbar-vert-offset))`;
      }
      hide() {
        this.#toolbar.remove();
      }
      #makeButton(buttonClass, l10nId, labelL10nId, clickHandler) {
        const button = document.createElement("button");
        button.classList.add("basic", buttonClass);
        button.tabIndex = 0;
        button.setAttribute("data-l10n-id", l10nId);
        const span = document.createElement("span");
        button.append(span);
        span.className = "visuallyHidden";
        span.setAttribute("data-l10n-id", labelL10nId);
        const signal = this.#uiManager._signal;
        if (signal instanceof AbortSignal && !signal.aborted) {
          button.addEventListener("contextmenu", noContextMenu, {
            signal
          });
          button.addEventListener("click", clickHandler, {
            signal
          });
        }
        this.#buttons.append(button);
      }
    };
    IdManager = class {
      #id = 0;
      get id() {
        return `${AnnotationEditorPrefix}${this.#id++}`;
      }
    };
    ImageManager = class _ImageManager {
      #baseId = getUuid();
      #id = 0;
      #cache = null;
      static get _isSVGFittingCanvas() {
        const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>`;
        const canvas = new OffscreenCanvas(1, 3);
        const ctx = canvas.getContext("2d", {
          willReadFrequently: true
        });
        const image = new Image();
        image.src = svg;
        const promise = image.decode().then(() => {
          ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);
          return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;
        });
        return shadow(this, "_isSVGFittingCanvas", promise);
      }
      async #get(key, rawData) {
        this.#cache ||= /* @__PURE__ */ new Map();
        let data = this.#cache.get(key);
        if (data === null) {
          return null;
        }
        if (data?.bitmap) {
          data.refCounter += 1;
          return data;
        }
        try {
          data ||= {
            bitmap: null,
            id: `image_${this.#baseId}_${this.#id++}`,
            refCounter: 0,
            isSvg: false
          };
          let image;
          if (typeof rawData === "string") {
            data.url = rawData;
            image = await fetchData(rawData, "blob");
          } else if (rawData instanceof File) {
            image = data.file = rawData;
          } else if (rawData instanceof Blob) {
            image = rawData;
          }
          if (image.type === "image/svg+xml") {
            const mustRemoveAspectRatioPromise = _ImageManager._isSVGFittingCanvas;
            const fileReader = new FileReader();
            const imageElement = new Image();
            const imagePromise = new Promise((resolve, reject2) => {
              imageElement.onload = () => {
                data.bitmap = imageElement;
                data.isSvg = true;
                resolve();
              };
              fileReader.onload = async () => {
                const url = data.svgUrl = fileReader.result;
                imageElement.src = await mustRemoveAspectRatioPromise ? `${url}#svgView(preserveAspectRatio(none))` : url;
              };
              imageElement.onerror = fileReader.onerror = reject2;
            });
            fileReader.readAsDataURL(image);
            await imagePromise;
          } else {
            data.bitmap = await createImageBitmap(image);
          }
          data.refCounter = 1;
        } catch (e) {
          warn(e);
          data = null;
        }
        this.#cache.set(key, data);
        if (data) {
          this.#cache.set(data.id, data);
        }
        return data;
      }
      async getFromFile(file) {
        const {
          lastModified,
          name,
          size: size2,
          type
        } = file;
        return this.#get(`${lastModified}_${name}_${size2}_${type}`, file);
      }
      async getFromUrl(url) {
        return this.#get(url, url);
      }
      async getFromBlob(id, blobPromise) {
        const blob = await blobPromise;
        return this.#get(id, blob);
      }
      async getFromId(id) {
        this.#cache ||= /* @__PURE__ */ new Map();
        const data = this.#cache.get(id);
        if (!data) {
          return null;
        }
        if (data.bitmap) {
          data.refCounter += 1;
          return data;
        }
        if (data.file) {
          return this.getFromFile(data.file);
        }
        if (data.blobPromise) {
          const {
            blobPromise
          } = data;
          delete data.blobPromise;
          return this.getFromBlob(data.id, blobPromise);
        }
        return this.getFromUrl(data.url);
      }
      getFromCanvas(id, canvas) {
        this.#cache ||= /* @__PURE__ */ new Map();
        let data = this.#cache.get(id);
        if (data?.bitmap) {
          data.refCounter += 1;
          return data;
        }
        const offscreen = new OffscreenCanvas(canvas.width, canvas.height);
        const ctx = offscreen.getContext("2d");
        ctx.drawImage(canvas, 0, 0);
        data = {
          bitmap: offscreen.transferToImageBitmap(),
          id: `image_${this.#baseId}_${this.#id++}`,
          refCounter: 1,
          isSvg: false
        };
        this.#cache.set(id, data);
        this.#cache.set(data.id, data);
        return data;
      }
      getSvgUrl(id) {
        const data = this.#cache.get(id);
        if (!data?.isSvg) {
          return null;
        }
        return data.svgUrl;
      }
      deleteId(id) {
        this.#cache ||= /* @__PURE__ */ new Map();
        const data = this.#cache.get(id);
        if (!data) {
          return;
        }
        data.refCounter -= 1;
        if (data.refCounter !== 0) {
          return;
        }
        const {
          bitmap
        } = data;
        if (!data.url && !data.file) {
          const canvas = new OffscreenCanvas(bitmap.width, bitmap.height);
          const ctx = canvas.getContext("bitmaprenderer");
          ctx.transferFromImageBitmap(bitmap);
          data.blobPromise = canvas.convertToBlob();
        }
        bitmap.close?.();
        data.bitmap = null;
      }
      isValidId(id) {
        return id.startsWith(`image_${this.#baseId}_`);
      }
    };
    CommandManager = class {
      #commands = [];
      #locked = false;
      #maxSize;
      #position = -1;
      constructor(maxSize = 128) {
        this.#maxSize = maxSize;
      }
      add({
        cmd,
        undo,
        post,
        mustExec,
        type = NaN,
        overwriteIfSameType = false,
        keepUndo = false
      }) {
        if (mustExec) {
          cmd();
        }
        if (this.#locked) {
          return;
        }
        const save = {
          cmd,
          undo,
          post,
          type
        };
        if (this.#position === -1) {
          if (this.#commands.length > 0) {
            this.#commands.length = 0;
          }
          this.#position = 0;
          this.#commands.push(save);
          return;
        }
        if (overwriteIfSameType && this.#commands[this.#position].type === type) {
          if (keepUndo) {
            save.undo = this.#commands[this.#position].undo;
          }
          this.#commands[this.#position] = save;
          return;
        }
        const next = this.#position + 1;
        if (next === this.#maxSize) {
          this.#commands.splice(0, 1);
        } else {
          this.#position = next;
          if (next < this.#commands.length) {
            this.#commands.splice(next);
          }
        }
        this.#commands.push(save);
      }
      undo() {
        if (this.#position === -1) {
          return;
        }
        this.#locked = true;
        const {
          undo,
          post
        } = this.#commands[this.#position];
        undo();
        post?.();
        this.#locked = false;
        this.#position -= 1;
      }
      redo() {
        if (this.#position < this.#commands.length - 1) {
          this.#position += 1;
          this.#locked = true;
          const {
            cmd,
            post
          } = this.#commands[this.#position];
          cmd();
          post?.();
          this.#locked = false;
        }
      }
      hasSomethingToUndo() {
        return this.#position !== -1;
      }
      hasSomethingToRedo() {
        return this.#position < this.#commands.length - 1;
      }
      cleanType(type) {
        if (this.#position === -1) {
          return;
        }
        for (let i = this.#position; i >= 0; i--) {
          if (this.#commands[i].type !== type) {
            this.#commands.splice(i + 1, this.#position - i);
            this.#position = i;
            return;
          }
        }
        this.#commands.length = 0;
        this.#position = -1;
      }
      destroy() {
        this.#commands = null;
      }
    };
    KeyboardManager = class {
      constructor(callbacks) {
        this.buffer = [];
        this.callbacks = /* @__PURE__ */ new Map();
        this.allKeys = /* @__PURE__ */ new Set();
        const {
          isMac
        } = util_FeatureTest.platform;
        for (const [keys2, callback, options = {}] of callbacks) {
          for (const key of keys2) {
            const isMacKey = key.startsWith("mac+");
            if (isMac && isMacKey) {
              this.callbacks.set(key.slice(4), {
                callback,
                options
              });
              this.allKeys.add(key.split("+").at(-1));
            } else if (!isMac && !isMacKey) {
              this.callbacks.set(key, {
                callback,
                options
              });
              this.allKeys.add(key.split("+").at(-1));
            }
          }
        }
      }
      #serialize(event) {
        if (event.altKey) {
          this.buffer.push("alt");
        }
        if (event.ctrlKey) {
          this.buffer.push("ctrl");
        }
        if (event.metaKey) {
          this.buffer.push("meta");
        }
        if (event.shiftKey) {
          this.buffer.push("shift");
        }
        this.buffer.push(event.key);
        const str = this.buffer.join("+");
        this.buffer.length = 0;
        return str;
      }
      exec(self2, event) {
        if (!this.allKeys.has(event.key)) {
          return;
        }
        const info2 = this.callbacks.get(this.#serialize(event));
        if (!info2) {
          return;
        }
        const {
          callback,
          options: {
            bubbles = false,
            args = [],
            checker = null
          }
        } = info2;
        if (checker && !checker(self2, event)) {
          return;
        }
        callback.bind(self2, ...args, event)();
        if (!bubbles) {
          stopEvent(event);
        }
      }
    };
    ColorManager = class _ColorManager {
      static _colorsMapping = /* @__PURE__ */ new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]);
      get _colors() {
        const colors = /* @__PURE__ */ new Map([["CanvasText", null], ["Canvas", null]]);
        getColorValues(colors);
        return shadow(this, "_colors", colors);
      }
      convert(color) {
        const rgb = getRGB(color);
        if (!window.matchMedia("(forced-colors: active)").matches) {
          return rgb;
        }
        for (const [name, RGB] of this._colors) {
          if (RGB.every((x, i) => x === rgb[i])) {
            return _ColorManager._colorsMapping.get(name);
          }
        }
        return rgb;
      }
      getHexCode(name) {
        const rgb = this._colors.get(name);
        if (!rgb) {
          return name;
        }
        return Util.makeHexColor(...rgb);
      }
    };
    AnnotationEditorUIManager = class _AnnotationEditorUIManager {
      #abortController = new AbortController();
      #activeEditor = null;
      #allEditableAnnotations = null;
      #allEditors = /* @__PURE__ */ new Map();
      #allLayers = /* @__PURE__ */ new Map();
      #altTextManager = null;
      #annotationStorage = null;
      #changedExistingAnnotations = null;
      #commandManager = new CommandManager();
      #commentManager = null;
      #copyPasteAC = null;
      #currentDrawingSession = null;
      #currentPageIndex = 0;
      #deletedAnnotationsElementIds = /* @__PURE__ */ new Set();
      #draggingEditors = null;
      #editorTypes = null;
      #editorsToRescale = /* @__PURE__ */ new Set();
      _editorUndoBar = null;
      #enableHighlightFloatingButton = false;
      #enableUpdatedAddImage = false;
      #enableNewAltTextWhenAddingImage = false;
      #filterFactory = null;
      #focusMainContainerTimeoutId = null;
      #focusManagerAC = null;
      #highlightColors = null;
      #highlightWhenShiftUp = false;
      #floatingToolbar = null;
      #idManager = new IdManager();
      #isEnabled = false;
      #isPointerDown = false;
      #isWaiting = false;
      #keyboardManagerAC = null;
      #lastActiveElement = null;
      #mainHighlightColorPicker = null;
      #missingCanvases = null;
      #mlManager = null;
      #mode = AnnotationEditorType.NONE;
      #selectedEditors = /* @__PURE__ */ new Set();
      #selectedTextNode = null;
      #signatureManager = null;
      #pageColors = null;
      #showAllStates = null;
      #pdfDocument = null;
      #previousStates = {
        isEditing: false,
        isEmpty: true,
        hasSomethingToUndo: false,
        hasSomethingToRedo: false,
        hasSelectedEditor: false,
        hasSelectedText: false
      };
      #translation = [0, 0];
      #translationTimeoutId = null;
      #container = null;
      #viewer = null;
      #viewerAlert = null;
      #updateModeCapability = null;
      static TRANSLATE_SMALL = 1;
      static TRANSLATE_BIG = 10;
      static get _keyboardManager() {
        const proto = _AnnotationEditorUIManager.prototype;
        const arrowChecker = (self2) => self2.#container.contains(document.activeElement) && document.activeElement.tagName !== "BUTTON" && self2.hasSomethingToControl();
        const textInputChecker = (_self, {
          target: el
        }) => {
          if (el instanceof HTMLInputElement) {
            const {
              type
            } = el;
            return type !== "text" && type !== "number";
          }
          return true;
        };
        const small = this.TRANSLATE_SMALL;
        const big = this.TRANSLATE_BIG;
        return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+a", "mac+meta+a"], proto.selectAll, {
          checker: textInputChecker
        }], [["ctrl+z", "mac+meta+z"], proto.undo, {
          checker: textInputChecker
        }], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], proto.redo, {
          checker: textInputChecker
        }], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], proto.delete, {
          checker: textInputChecker
        }], [["Enter", "mac+Enter"], proto.addNewEditorFromKeyboard, {
          checker: (self2, {
            target: el
          }) => !(el instanceof HTMLButtonElement) && self2.#container.contains(el) && !self2.isEnterHandled
        }], [[" ", "mac+ "], proto.addNewEditorFromKeyboard, {
          checker: (self2, {
            target: el
          }) => !(el instanceof HTMLButtonElement) && self2.#container.contains(document.activeElement)
        }], [["Escape", "mac+Escape"], proto.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], proto.translateSelectedEditors, {
          args: [-small, 0],
          checker: arrowChecker
        }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto.translateSelectedEditors, {
          args: [-big, 0],
          checker: arrowChecker
        }], [["ArrowRight", "mac+ArrowRight"], proto.translateSelectedEditors, {
          args: [small, 0],
          checker: arrowChecker
        }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto.translateSelectedEditors, {
          args: [big, 0],
          checker: arrowChecker
        }], [["ArrowUp", "mac+ArrowUp"], proto.translateSelectedEditors, {
          args: [0, -small],
          checker: arrowChecker
        }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto.translateSelectedEditors, {
          args: [0, -big],
          checker: arrowChecker
        }], [["ArrowDown", "mac+ArrowDown"], proto.translateSelectedEditors, {
          args: [0, small],
          checker: arrowChecker
        }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto.translateSelectedEditors, {
          args: [0, big],
          checker: arrowChecker
        }]]));
      }
      constructor(container, viewer, viewerAlert, altTextManager, commentManager, signatureManager, eventBus, pdfDocument, pageColors, highlightColors, enableHighlightFloatingButton, enableUpdatedAddImage, enableNewAltTextWhenAddingImage, mlManager, editorUndoBar, supportsPinchToZoom) {
        const signal = this._signal = this.#abortController.signal;
        this.#container = container;
        this.#viewer = viewer;
        this.#viewerAlert = viewerAlert;
        this.#altTextManager = altTextManager;
        this.#commentManager = commentManager;
        this.#signatureManager = signatureManager;
        this.#pdfDocument = pdfDocument;
        this._eventBus = eventBus;
        eventBus._on("editingaction", this.onEditingAction.bind(this), {
          signal
        });
        eventBus._on("pagechanging", this.onPageChanging.bind(this), {
          signal
        });
        eventBus._on("scalechanging", this.onScaleChanging.bind(this), {
          signal
        });
        eventBus._on("rotationchanging", this.onRotationChanging.bind(this), {
          signal
        });
        eventBus._on("setpreference", this.onSetPreference.bind(this), {
          signal
        });
        eventBus._on("switchannotationeditorparams", (evt) => this.updateParams(evt.type, evt.value), {
          signal
        });
        window.addEventListener("pointerdown", () => {
          this.#isPointerDown = true;
        }, {
          capture: true,
          signal
        });
        window.addEventListener("pointerup", () => {
          this.#isPointerDown = false;
        }, {
          capture: true,
          signal
        });
        this.#addSelectionListener();
        this.#addDragAndDropListeners();
        this.#addKeyboardManager();
        this.#annotationStorage = pdfDocument.annotationStorage;
        this.#filterFactory = pdfDocument.filterFactory;
        this.#pageColors = pageColors;
        this.#highlightColors = highlightColors || null;
        this.#enableHighlightFloatingButton = enableHighlightFloatingButton;
        this.#enableUpdatedAddImage = enableUpdatedAddImage;
        this.#enableNewAltTextWhenAddingImage = enableNewAltTextWhenAddingImage;
        this.#mlManager = mlManager || null;
        this.viewParameters = {
          realScale: PixelsPerInch.PDF_TO_CSS_UNITS,
          rotation: 0
        };
        this.isShiftKeyDown = false;
        this._editorUndoBar = editorUndoBar || null;
        this._supportsPinchToZoom = supportsPinchToZoom !== false;
        commentManager?.setSidebarUiManager(this);
      }
      destroy() {
        this.#updateModeCapability?.resolve();
        this.#updateModeCapability = null;
        this.#abortController?.abort();
        this.#abortController = null;
        this._signal = null;
        for (const layer of this.#allLayers.values()) {
          layer.destroy();
        }
        this.#allLayers.clear();
        this.#allEditors.clear();
        this.#editorsToRescale.clear();
        this.#missingCanvases?.clear();
        this.#activeEditor = null;
        this.#selectedEditors.clear();
        this.#commandManager.destroy();
        this.#altTextManager?.destroy();
        this.#commentManager?.destroy();
        this.#signatureManager?.destroy();
        this.#floatingToolbar?.hide();
        this.#floatingToolbar = null;
        this.#mainHighlightColorPicker?.destroy();
        this.#mainHighlightColorPicker = null;
        this.#allEditableAnnotations = null;
        if (this.#focusMainContainerTimeoutId) {
          clearTimeout(this.#focusMainContainerTimeoutId);
          this.#focusMainContainerTimeoutId = null;
        }
        if (this.#translationTimeoutId) {
          clearTimeout(this.#translationTimeoutId);
          this.#translationTimeoutId = null;
        }
        this._editorUndoBar?.destroy();
        this.#pdfDocument = null;
      }
      combinedSignal(ac) {
        return AbortSignal.any([this._signal, ac.signal]);
      }
      get mlManager() {
        return this.#mlManager;
      }
      get useNewAltTextFlow() {
        return this.#enableUpdatedAddImage;
      }
      get useNewAltTextWhenAddingImage() {
        return this.#enableNewAltTextWhenAddingImage;
      }
      get hcmFilter() {
        return shadow(this, "hcmFilter", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : "none");
      }
      get direction() {
        return shadow(this, "direction", getComputedStyle(this.#container).direction);
      }
      get _highlightColors() {
        return shadow(this, "_highlightColors", this.#highlightColors ? new Map(this.#highlightColors.split(",").map((pair) => {
          pair = pair.split("=").map((x) => x.trim());
          pair[1] = pair[1].toUpperCase();
          return pair;
        })) : null);
      }
      get highlightColors() {
        const {
          _highlightColors
        } = this;
        if (!_highlightColors) {
          return shadow(this, "highlightColors", null);
        }
        const map2 = /* @__PURE__ */ new Map();
        const hasHCM = !!this.#pageColors;
        for (const [name, color] of _highlightColors) {
          const isNameForHCM = name.endsWith("_HCM");
          if (hasHCM && isNameForHCM) {
            map2.set(name.replace("_HCM", ""), color);
            continue;
          }
          if (!hasHCM && !isNameForHCM) {
            map2.set(name, color);
          }
        }
        return shadow(this, "highlightColors", map2);
      }
      get highlightColorNames() {
        return shadow(this, "highlightColorNames", this.highlightColors ? new Map(Array.from(this.highlightColors, (e) => e.reverse())) : null);
      }
      getNonHCMColor(color) {
        if (!this._highlightColors) {
          return color;
        }
        const colorName = this.highlightColorNames.get(color);
        return this._highlightColors.get(colorName) || color;
      }
      getNonHCMColorName(color) {
        return this.highlightColorNames.get(color) || color;
      }
      setCurrentDrawingSession(layer) {
        if (layer) {
          this.unselectAll();
          this.disableUserSelect(true);
        } else {
          this.disableUserSelect(false);
        }
        this.#currentDrawingSession = layer;
      }
      setMainHighlightColorPicker(colorPicker) {
        this.#mainHighlightColorPicker = colorPicker;
      }
      editAltText(editor, firstTime = false) {
        this.#altTextManager?.editAltText(this, editor, firstTime);
      }
      hasCommentManager() {
        return !!this.#commentManager;
      }
      editComment(editor, posX, posY, options) {
        this.#commentManager?.showDialog(this, editor, posX, posY, options);
      }
      selectComment(pageIndex, uid) {
        const layer = this.#allLayers.get(pageIndex);
        const editor = layer?.getEditorByUID(uid);
        editor?.toggleComment(true, true);
      }
      updateComment(editor) {
        this.#commentManager?.updateComment(editor.getData());
      }
      updatePopupColor(editor) {
        this.#commentManager?.updatePopupColor(editor);
      }
      removeComment(editor) {
        this.#commentManager?.removeComments([editor.uid]);
      }
      toggleComment(editor, isSelected, visibility = void 0) {
        this.#commentManager?.toggleCommentPopup(editor, isSelected, visibility);
      }
      makeCommentColor(color, opacity) {
        return color && this.#commentManager?.makeCommentColor(color, opacity) || null;
      }
      getCommentDialogElement() {
        return this.#commentManager?.dialogElement || null;
      }
      async waitForEditorsRendered(pageNumber) {
        if (this.#allLayers.has(pageNumber - 1)) {
          return;
        }
        const {
          resolve,
          promise
        } = Promise.withResolvers();
        const onEditorsRendered = (evt) => {
          if (evt.pageNumber === pageNumber) {
            this._eventBus._off("editorsrendered", onEditorsRendered);
            resolve();
          }
        };
        this._eventBus.on("editorsrendered", onEditorsRendered);
        await promise;
      }
      getSignature(editor) {
        this.#signatureManager?.getSignature({
          uiManager: this,
          editor
        });
      }
      get signatureManager() {
        return this.#signatureManager;
      }
      switchToMode(mode, callback) {
        this._eventBus.on("annotationeditormodechanged", callback, {
          once: true,
          signal: this._signal
        });
        this._eventBus.dispatch("showannotationeditorui", {
          source: this,
          mode
        });
      }
      setPreference(name, value) {
        this._eventBus.dispatch("setpreference", {
          source: this,
          name,
          value
        });
      }
      onSetPreference({
        name,
        value
      }) {
        switch (name) {
          case "enableNewAltTextWhenAddingImage":
            this.#enableNewAltTextWhenAddingImage = value;
            break;
        }
      }
      onPageChanging({
        pageNumber
      }) {
        this.#currentPageIndex = pageNumber - 1;
      }
      focusMainContainer() {
        this.#container.focus();
      }
      findParent(x, y) {
        for (const layer of this.#allLayers.values()) {
          const {
            x: layerX,
            y: layerY,
            width,
            height
          } = layer.div.getBoundingClientRect();
          if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {
            return layer;
          }
        }
        return null;
      }
      disableUserSelect(value = false) {
        this.#viewer.classList.toggle("noUserSelect", value);
      }
      addShouldRescale(editor) {
        this.#editorsToRescale.add(editor);
      }
      removeShouldRescale(editor) {
        this.#editorsToRescale.delete(editor);
      }
      onScaleChanging({
        scale
      }) {
        this.commitOrRemove();
        this.viewParameters.realScale = scale * PixelsPerInch.PDF_TO_CSS_UNITS;
        for (const editor of this.#editorsToRescale) {
          editor.onScaleChanging();
        }
        this.#currentDrawingSession?.onScaleChanging();
      }
      onRotationChanging({
        pagesRotation
      }) {
        this.commitOrRemove();
        this.viewParameters.rotation = pagesRotation;
      }
      #getAnchorElementForSelection({
        anchorNode
      }) {
        return anchorNode.nodeType === Node.TEXT_NODE ? anchorNode.parentElement : anchorNode;
      }
      #getLayerForTextLayer(textLayer) {
        const {
          currentLayer
        } = this;
        if (currentLayer.hasTextLayer(textLayer)) {
          return currentLayer;
        }
        for (const layer of this.#allLayers.values()) {
          if (layer.hasTextLayer(textLayer)) {
            return layer;
          }
        }
        return null;
      }
      highlightSelection(methodOfCreation = "", comment = false) {
        const selection = document.getSelection();
        if (!selection || selection.isCollapsed) {
          return;
        }
        const {
          anchorNode,
          anchorOffset,
          focusNode,
          focusOffset
        } = selection;
        const text = selection.toString();
        const anchorElement = this.#getAnchorElementForSelection(selection);
        const textLayer = anchorElement.closest(".textLayer");
        const boxes = this.getSelectionBoxes(textLayer);
        if (!boxes) {
          return;
        }
        selection.empty();
        const layer = this.#getLayerForTextLayer(textLayer);
        const isNoneMode = this.#mode === AnnotationEditorType.NONE;
        const callback = () => {
          const editor = layer?.createAndAddNewEditor({
            x: 0,
            y: 0
          }, false, {
            methodOfCreation,
            boxes,
            anchorNode,
            anchorOffset,
            focusNode,
            focusOffset,
            text
          });
          if (isNoneMode) {
            this.showAllEditors("highlight", true, true);
          }
          if (comment) {
            editor?.editComment();
          }
        };
        if (isNoneMode) {
          this.switchToMode(AnnotationEditorType.HIGHLIGHT, callback);
          return;
        }
        callback();
      }
      commentSelection(methodOfCreation = "") {
        this.highlightSelection(methodOfCreation, true);
      }
      #displayFloatingToolbar() {
        const selection = document.getSelection();
        if (!selection || selection.isCollapsed) {
          return;
        }
        const anchorElement = this.#getAnchorElementForSelection(selection);
        const textLayer = anchorElement.closest(".textLayer");
        const boxes = this.getSelectionBoxes(textLayer);
        if (!boxes) {
          return;
        }
        this.#floatingToolbar ||= new FloatingToolbar(this);
        this.#floatingToolbar.show(textLayer, boxes, this.direction === "ltr");
      }
      getAndRemoveDataFromAnnotationStorage(annotationId) {
        if (!this.#annotationStorage) {
          return null;
        }
        const key = `${AnnotationEditorPrefix}${annotationId}`;
        const storedValue = this.#annotationStorage.getRawValue(key);
        if (storedValue) {
          this.#annotationStorage.remove(key);
        }
        return storedValue;
      }
      addToAnnotationStorage(editor) {
        if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {
          this.#annotationStorage.setValue(editor.id, editor);
        }
      }
      a11yAlert(messageId, args = null) {
        const viewerAlert = this.#viewerAlert;
        if (!viewerAlert) {
          return;
        }
        viewerAlert.setAttribute("data-l10n-id", messageId);
        if (args) {
          viewerAlert.setAttribute("data-l10n-args", JSON.stringify(args));
        } else {
          viewerAlert.removeAttribute("data-l10n-args");
        }
      }
      #selectionChange() {
        const selection = document.getSelection();
        if (!selection || selection.isCollapsed) {
          if (this.#selectedTextNode) {
            this.#floatingToolbar?.hide();
            this.#selectedTextNode = null;
            this.#dispatchUpdateStates({
              hasSelectedText: false
            });
          }
          return;
        }
        const {
          anchorNode
        } = selection;
        if (anchorNode === this.#selectedTextNode) {
          return;
        }
        const anchorElement = this.#getAnchorElementForSelection(selection);
        const textLayer = anchorElement.closest(".textLayer");
        if (!textLayer) {
          if (this.#selectedTextNode) {
            this.#floatingToolbar?.hide();
            this.#selectedTextNode = null;
            this.#dispatchUpdateStates({
              hasSelectedText: false
            });
          }
          return;
        }
        this.#floatingToolbar?.hide();
        this.#selectedTextNode = anchorNode;
        this.#dispatchUpdateStates({
          hasSelectedText: true
        });
        if (this.#mode !== AnnotationEditorType.HIGHLIGHT && this.#mode !== AnnotationEditorType.NONE) {
          return;
        }
        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {
          this.showAllEditors("highlight", true, true);
        }
        this.#highlightWhenShiftUp = this.isShiftKeyDown;
        if (!this.isShiftKeyDown) {
          const activeLayer = this.#mode === AnnotationEditorType.HIGHLIGHT ? this.#getLayerForTextLayer(textLayer) : null;
          activeLayer?.toggleDrawing();
          if (this.#isPointerDown) {
            const ac = new AbortController();
            const signal = this.combinedSignal(ac);
            const pointerup = (e) => {
              if (e.type === "pointerup" && e.button !== 0) {
                return;
              }
              ac.abort();
              activeLayer?.toggleDrawing(true);
              if (e.type === "pointerup") {
                this.#onSelectEnd("main_toolbar");
              }
            };
            window.addEventListener("pointerup", pointerup, {
              signal
            });
            window.addEventListener("blur", pointerup, {
              signal
            });
          } else {
            activeLayer?.toggleDrawing(true);
            this.#onSelectEnd("main_toolbar");
          }
        }
      }
      #onSelectEnd(methodOfCreation = "") {
        if (this.#mode === AnnotationEditorType.HIGHLIGHT) {
          this.highlightSelection(methodOfCreation);
        } else if (this.#enableHighlightFloatingButton) {
          this.#displayFloatingToolbar();
        }
      }
      #addSelectionListener() {
        document.addEventListener("selectionchange", this.#selectionChange.bind(this), {
          signal: this._signal
        });
      }
      #addFocusManager() {
        if (this.#focusManagerAC) {
          return;
        }
        this.#focusManagerAC = new AbortController();
        const signal = this.combinedSignal(this.#focusManagerAC);
        window.addEventListener("focus", this.focus.bind(this), {
          signal
        });
        window.addEventListener("blur", this.blur.bind(this), {
          signal
        });
      }
      #removeFocusManager() {
        this.#focusManagerAC?.abort();
        this.#focusManagerAC = null;
      }
      blur() {
        this.isShiftKeyDown = false;
        if (this.#highlightWhenShiftUp) {
          this.#highlightWhenShiftUp = false;
          this.#onSelectEnd("main_toolbar");
        }
        if (!this.hasSelection) {
          return;
        }
        const {
          activeElement
        } = document;
        for (const editor of this.#selectedEditors) {
          if (editor.div.contains(activeElement)) {
            this.#lastActiveElement = [editor, activeElement];
            editor._focusEventsAllowed = false;
            break;
          }
        }
      }
      focus() {
        if (!this.#lastActiveElement) {
          return;
        }
        const [lastEditor, lastActiveElement] = this.#lastActiveElement;
        this.#lastActiveElement = null;
        lastActiveElement.addEventListener("focusin", () => {
          lastEditor._focusEventsAllowed = true;
        }, {
          once: true,
          signal: this._signal
        });
        lastActiveElement.focus();
      }
      #addKeyboardManager() {
        if (this.#keyboardManagerAC) {
          return;
        }
        this.#keyboardManagerAC = new AbortController();
        const signal = this.combinedSignal(this.#keyboardManagerAC);
        window.addEventListener("keydown", this.keydown.bind(this), {
          signal
        });
        window.addEventListener("keyup", this.keyup.bind(this), {
          signal
        });
      }
      #removeKeyboardManager() {
        this.#keyboardManagerAC?.abort();
        this.#keyboardManagerAC = null;
      }
      #addCopyPasteListeners() {
        if (this.#copyPasteAC) {
          return;
        }
        this.#copyPasteAC = new AbortController();
        const signal = this.combinedSignal(this.#copyPasteAC);
        document.addEventListener("copy", this.copy.bind(this), {
          signal
        });
        document.addEventListener("cut", this.cut.bind(this), {
          signal
        });
        document.addEventListener("paste", this.paste.bind(this), {
          signal
        });
      }
      #removeCopyPasteListeners() {
        this.#copyPasteAC?.abort();
        this.#copyPasteAC = null;
      }
      #addDragAndDropListeners() {
        const signal = this._signal;
        document.addEventListener("dragover", this.dragOver.bind(this), {
          signal
        });
        document.addEventListener("drop", this.drop.bind(this), {
          signal
        });
      }
      addEditListeners() {
        this.#addKeyboardManager();
        this.#addCopyPasteListeners();
      }
      removeEditListeners() {
        this.#removeKeyboardManager();
        this.#removeCopyPasteListeners();
      }
      dragOver(event) {
        for (const {
          type
        } of event.dataTransfer.items) {
          for (const editorType of this.#editorTypes) {
            if (editorType.isHandlingMimeForPasting(type)) {
              event.dataTransfer.dropEffect = "copy";
              event.preventDefault();
              return;
            }
          }
        }
      }
      drop(event) {
        for (const item of event.dataTransfer.items) {
          for (const editorType of this.#editorTypes) {
            if (editorType.isHandlingMimeForPasting(item.type)) {
              editorType.paste(item, this.currentLayer);
              event.preventDefault();
              return;
            }
          }
        }
      }
      copy(event) {
        event.preventDefault();
        this.#activeEditor?.commitOrRemove();
        if (!this.hasSelection) {
          return;
        }
        const editors = [];
        for (const editor of this.#selectedEditors) {
          const serialized = editor.serialize(true);
          if (serialized) {
            editors.push(serialized);
          }
        }
        if (editors.length === 0) {
          return;
        }
        event.clipboardData.setData("application/pdfjs", JSON.stringify(editors));
      }
      cut(event) {
        this.copy(event);
        this.delete();
      }
      async paste(event) {
        event.preventDefault();
        const {
          clipboardData
        } = event;
        for (const item of clipboardData.items) {
          for (const editorType of this.#editorTypes) {
            if (editorType.isHandlingMimeForPasting(item.type)) {
              editorType.paste(item, this.currentLayer);
              return;
            }
          }
        }
        let data = clipboardData.getData("application/pdfjs");
        if (!data) {
          return;
        }
        try {
          data = JSON.parse(data);
        } catch (ex) {
          warn(`paste: "${ex.message}".`);
          return;
        }
        if (!Array.isArray(data)) {
          return;
        }
        this.unselectAll();
        const layer = this.currentLayer;
        try {
          const newEditors = [];
          for (const editor of data) {
            const deserializedEditor = await layer.deserialize(editor);
            if (!deserializedEditor) {
              return;
            }
            newEditors.push(deserializedEditor);
          }
          const cmd = () => {
            for (const editor of newEditors) {
              this.#addEditorToLayer(editor);
            }
            this.#selectEditors(newEditors);
          };
          const undo = () => {
            for (const editor of newEditors) {
              editor.remove();
            }
          };
          this.addCommands({
            cmd,
            undo,
            mustExec: true
          });
        } catch (ex) {
          warn(`paste: "${ex.message}".`);
        }
      }
      keydown(event) {
        if (!this.isShiftKeyDown && event.key === "Shift") {
          this.isShiftKeyDown = true;
        }
        if (this.#mode !== AnnotationEditorType.NONE && !this.isEditorHandlingKeyboard) {
          _AnnotationEditorUIManager._keyboardManager.exec(this, event);
        }
      }
      keyup(event) {
        if (this.isShiftKeyDown && event.key === "Shift") {
          this.isShiftKeyDown = false;
          if (this.#highlightWhenShiftUp) {
            this.#highlightWhenShiftUp = false;
            this.#onSelectEnd("main_toolbar");
          }
        }
      }
      onEditingAction({
        name
      }) {
        switch (name) {
          case "undo":
          case "redo":
          case "delete":
          case "selectAll":
            this[name]();
            break;
          case "highlightSelection":
            this.highlightSelection("context_menu");
            break;
          case "commentSelection":
            this.commentSelection("context_menu");
            break;
        }
      }
      #dispatchUpdateStates(details) {
        const hasChanged = Object.entries(details).some(([key, value]) => this.#previousStates[key] !== value);
        if (hasChanged) {
          this._eventBus.dispatch("annotationeditorstateschanged", {
            source: this,
            details: Object.assign(this.#previousStates, details)
          });
          if (this.#mode === AnnotationEditorType.HIGHLIGHT && details.hasSelectedEditor === false) {
            this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_FREE, true]]);
          }
        }
      }
      #dispatchUpdateUI(details) {
        this._eventBus.dispatch("annotationeditorparamschanged", {
          source: this,
          details
        });
      }
      setEditingState(isEditing) {
        if (isEditing) {
          this.#addFocusManager();
          this.#addCopyPasteListeners();
          this.#dispatchUpdateStates({
            isEditing: this.#mode !== AnnotationEditorType.NONE,
            isEmpty: this.#isEmpty(),
            hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
            hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
            hasSelectedEditor: false
          });
        } else {
          this.#removeFocusManager();
          this.#removeCopyPasteListeners();
          this.#dispatchUpdateStates({
            isEditing: false
          });
          this.disableUserSelect(false);
        }
      }
      registerEditorTypes(types) {
        if (this.#editorTypes) {
          return;
        }
        this.#editorTypes = types;
        for (const editorType of this.#editorTypes) {
          this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
        }
      }
      getId() {
        return this.#idManager.id;
      }
      get currentLayer() {
        return this.#allLayers.get(this.#currentPageIndex);
      }
      getLayer(pageIndex) {
        return this.#allLayers.get(pageIndex);
      }
      get currentPageIndex() {
        return this.#currentPageIndex;
      }
      addLayer(layer) {
        this.#allLayers.set(layer.pageIndex, layer);
        if (this.#isEnabled) {
          layer.enable();
        } else {
          layer.disable();
        }
      }
      removeLayer(layer) {
        this.#allLayers.delete(layer.pageIndex);
      }
      async updateMode(mode, editId = null, isFromKeyboard = false, mustEnterInEditMode = false, editComment = false) {
        if (this.#mode === mode) {
          return;
        }
        if (this.#updateModeCapability) {
          await this.#updateModeCapability.promise;
          if (!this.#updateModeCapability) {
            return;
          }
        }
        this.#updateModeCapability = Promise.withResolvers();
        this.#currentDrawingSession?.commitOrRemove();
        if (this.#mode === AnnotationEditorType.POPUP) {
          this.#commentManager?.hideSidebar();
        }
        this.#commentManager?.destroyPopup();
        this.#mode = mode;
        if (mode === AnnotationEditorType.NONE) {
          this.setEditingState(false);
          this.#disableAll();
          for (const editor of this.#allEditors.values()) {
            editor.hideStandaloneCommentButton();
          }
          this._editorUndoBar?.hide();
          this.toggleComment(null);
          this.#updateModeCapability.resolve();
          return;
        }
        for (const editor of this.#allEditors.values()) {
          editor.addStandaloneCommentButton();
        }
        if (mode === AnnotationEditorType.SIGNATURE) {
          await this.#signatureManager?.loadSignatures();
        }
        this.setEditingState(true);
        await this.#enableAll();
        this.unselectAll();
        for (const layer of this.#allLayers.values()) {
          layer.updateMode(mode);
        }
        if (mode === AnnotationEditorType.POPUP) {
          this.#allEditableAnnotations ||= await this.#pdfDocument.getAnnotationsByType(new Set(this.#editorTypes.map((editorClass) => editorClass._editorType)));
          const elementIds = /* @__PURE__ */ new Set();
          const allComments = [];
          for (const editor of this.#allEditors.values()) {
            const {
              annotationElementId,
              hasComment,
              deleted
            } = editor;
            if (annotationElementId) {
              elementIds.add(annotationElementId);
            }
            if (hasComment && !deleted) {
              allComments.push(editor.getData());
            }
          }
          for (const annotation of this.#allEditableAnnotations) {
            const {
              id,
              popupRef,
              contentsObj
            } = annotation;
            if (popupRef && contentsObj?.str && !elementIds.has(id) && !this.#deletedAnnotationsElementIds.has(id)) {
              allComments.push(annotation);
            }
          }
          this.#commentManager?.showSidebar(allComments);
        }
        if (!editId) {
          if (isFromKeyboard) {
            this.addNewEditorFromKeyboard();
          }
          this.#updateModeCapability.resolve();
          return;
        }
        for (const editor of this.#allEditors.values()) {
          if (editor.uid === editId) {
            this.setSelected(editor);
            if (editComment) {
              editor.editComment();
            } else if (mustEnterInEditMode) {
              editor.enterInEditMode();
            } else {
              editor.focus();
            }
          } else {
            editor.unselect();
          }
        }
        this.#updateModeCapability.resolve();
      }
      addNewEditorFromKeyboard() {
        if (this.currentLayer.canCreateNewEmptyEditor()) {
          this.currentLayer.addNewEditor();
        }
      }
      updateToolbar(options) {
        if (options.mode === this.#mode) {
          return;
        }
        this._eventBus.dispatch("switchannotationeditormode", {
          source: this,
          ...options
        });
      }
      updateParams(type, value) {
        if (!this.#editorTypes) {
          return;
        }
        switch (type) {
          case AnnotationEditorParamsType.CREATE:
            this.currentLayer.addNewEditor(value);
            return;
          case AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL:
            this._eventBus.dispatch("reporttelemetry", {
              source: this,
              details: {
                type: "editing",
                data: {
                  type: "highlight",
                  action: "toggle_visibility"
                }
              }
            });
            (this.#showAllStates ||= /* @__PURE__ */ new Map()).set(type, value);
            this.showAllEditors("highlight", value);
            break;
        }
        if (this.hasSelection) {
          for (const editor of this.#selectedEditors) {
            editor.updateParams(type, value);
          }
        } else {
          for (const editorType of this.#editorTypes) {
            editorType.updateDefaultParams(type, value);
          }
        }
      }
      showAllEditors(type, visible, updateButton = false) {
        for (const editor of this.#allEditors.values()) {
          if (editor.editorType === type) {
            editor.show(visible);
          }
        }
        const state = this.#showAllStates?.get(AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL) ?? true;
        if (state !== visible) {
          this.#dispatchUpdateUI([[AnnotationEditorParamsType.HIGHLIGHT_SHOW_ALL, visible]]);
        }
      }
      enableWaiting(mustWait = false) {
        if (this.#isWaiting === mustWait) {
          return;
        }
        this.#isWaiting = mustWait;
        for (const layer of this.#allLayers.values()) {
          if (mustWait) {
            layer.disableClick();
          } else {
            layer.enableClick();
          }
          layer.div.classList.toggle("waiting", mustWait);
        }
      }
      async #enableAll() {
        if (!this.#isEnabled) {
          this.#isEnabled = true;
          const promises = [];
          for (const layer of this.#allLayers.values()) {
            promises.push(layer.enable());
          }
          await Promise.all(promises);
          for (const editor of this.#allEditors.values()) {
            editor.enable();
          }
        }
      }
      #disableAll() {
        this.unselectAll();
        if (this.#isEnabled) {
          this.#isEnabled = false;
          for (const layer of this.#allLayers.values()) {
            layer.disable();
          }
          for (const editor of this.#allEditors.values()) {
            editor.disable();
          }
        }
      }
      *getEditors(pageIndex) {
        for (const editor of this.#allEditors.values()) {
          if (editor.pageIndex === pageIndex) {
            yield editor;
          }
        }
      }
      getEditor(id) {
        return this.#allEditors.get(id);
      }
      addEditor(editor) {
        this.#allEditors.set(editor.id, editor);
      }
      removeEditor(editor) {
        if (editor.div.contains(document.activeElement)) {
          if (this.#focusMainContainerTimeoutId) {
            clearTimeout(this.#focusMainContainerTimeoutId);
          }
          this.#focusMainContainerTimeoutId = setTimeout(() => {
            this.focusMainContainer();
            this.#focusMainContainerTimeoutId = null;
          }, 0);
        }
        this.#allEditors.delete(editor.id);
        if (editor.annotationElementId) {
          this.#missingCanvases?.delete(editor.annotationElementId);
        }
        this.unselect(editor);
        if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {
          this.#annotationStorage?.remove(editor.id);
        }
      }
      addDeletedAnnotationElement(editor) {
        this.#deletedAnnotationsElementIds.add(editor.annotationElementId);
        this.addChangedExistingAnnotation(editor);
        editor.deleted = true;
      }
      isDeletedAnnotationElement(annotationElementId) {
        return this.#deletedAnnotationsElementIds.has(annotationElementId);
      }
      removeDeletedAnnotationElement(editor) {
        this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);
        this.removeChangedExistingAnnotation(editor);
        editor.deleted = false;
      }
      #addEditorToLayer(editor) {
        const layer = this.#allLayers.get(editor.pageIndex);
        if (layer) {
          layer.addOrRebuild(editor);
        } else {
          this.addEditor(editor);
          this.addToAnnotationStorage(editor);
        }
      }
      setActiveEditor(editor) {
        if (this.#activeEditor === editor) {
          return;
        }
        this.#activeEditor = editor;
        if (editor) {
          this.#dispatchUpdateUI(editor.propertiesToUpdate);
        }
      }
      get #lastSelectedEditor() {
        let ed = null;
        for (ed of this.#selectedEditors) {
        }
        return ed;
      }
      updateUI(editor) {
        if (this.#lastSelectedEditor === editor) {
          this.#dispatchUpdateUI(editor.propertiesToUpdate);
        }
      }
      updateUIForDefaultProperties(editorType) {
        this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);
      }
      toggleSelected(editor) {
        if (this.#selectedEditors.has(editor)) {
          this.#selectedEditors.delete(editor);
          editor.unselect();
          this.#dispatchUpdateStates({
            hasSelectedEditor: this.hasSelection
          });
          return;
        }
        this.#selectedEditors.add(editor);
        editor.select();
        this.#dispatchUpdateUI(editor.propertiesToUpdate);
        this.#dispatchUpdateStates({
          hasSelectedEditor: true
        });
      }
      setSelected(editor) {
        this.updateToolbar({
          mode: editor.mode,
          editId: editor.id
        });
        this.#currentDrawingSession?.commitOrRemove();
        for (const ed of this.#selectedEditors) {
          if (ed !== editor) {
            ed.unselect();
          }
        }
        this.#selectedEditors.clear();
        this.#selectedEditors.add(editor);
        editor.select();
        this.#dispatchUpdateUI(editor.propertiesToUpdate);
        this.#dispatchUpdateStates({
          hasSelectedEditor: true
        });
      }
      isSelected(editor) {
        return this.#selectedEditors.has(editor);
      }
      get firstSelectedEditor() {
        return this.#selectedEditors.values().next().value;
      }
      unselect(editor) {
        editor.unselect();
        this.#selectedEditors.delete(editor);
        this.#dispatchUpdateStates({
          hasSelectedEditor: this.hasSelection
        });
      }
      get hasSelection() {
        return this.#selectedEditors.size !== 0;
      }
      get isEnterHandled() {
        return this.#selectedEditors.size === 1 && this.firstSelectedEditor.isEnterHandled;
      }
      undo() {
        this.#commandManager.undo();
        this.#dispatchUpdateStates({
          hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),
          hasSomethingToRedo: true,
          isEmpty: this.#isEmpty()
        });
        this._editorUndoBar?.hide();
      }
      redo() {
        this.#commandManager.redo();
        this.#dispatchUpdateStates({
          hasSomethingToUndo: true,
          hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),
          isEmpty: this.#isEmpty()
        });
      }
      addCommands(params) {
        this.#commandManager.add(params);
        this.#dispatchUpdateStates({
          hasSomethingToUndo: true,
          hasSomethingToRedo: false,
          isEmpty: this.#isEmpty()
        });
      }
      cleanUndoStack(type) {
        this.#commandManager.cleanType(type);
      }
      #isEmpty() {
        if (this.#allEditors.size === 0) {
          return true;
        }
        if (this.#allEditors.size === 1) {
          for (const editor of this.#allEditors.values()) {
            return editor.isEmpty();
          }
        }
        return false;
      }
      delete() {
        this.commitOrRemove();
        const drawingEditor = this.currentLayer?.endDrawingSession(true);
        if (!this.hasSelection && !drawingEditor) {
          return;
        }
        const editors = drawingEditor ? [drawingEditor] : [...this.#selectedEditors];
        const cmd = () => {
          this._editorUndoBar?.show(undo, editors.length === 1 ? editors[0].editorType : editors.length);
          for (const editor of editors) {
            editor.remove();
          }
        };
        const undo = () => {
          for (const editor of editors) {
            this.#addEditorToLayer(editor);
          }
        };
        this.addCommands({
          cmd,
          undo,
          mustExec: true
        });
      }
      commitOrRemove() {
        this.#activeEditor?.commitOrRemove();
      }
      hasSomethingToControl() {
        return this.#activeEditor || this.hasSelection;
      }
      #selectEditors(editors) {
        for (const editor of this.#selectedEditors) {
          editor.unselect();
        }
        this.#selectedEditors.clear();
        for (const editor of editors) {
          if (editor.isEmpty()) {
            continue;
          }
          this.#selectedEditors.add(editor);
          editor.select();
        }
        this.#dispatchUpdateStates({
          hasSelectedEditor: this.hasSelection
        });
      }
      selectAll() {
        for (const editor of this.#selectedEditors) {
          editor.commit();
        }
        this.#selectEditors(this.#allEditors.values());
      }
      unselectAll() {
        if (this.#activeEditor) {
          this.#activeEditor.commitOrRemove();
          if (this.#mode !== AnnotationEditorType.NONE) {
            return;
          }
        }
        if (this.#currentDrawingSession?.commitOrRemove()) {
          return;
        }
        if (!this.hasSelection) {
          return;
        }
        for (const editor of this.#selectedEditors) {
          editor.unselect();
        }
        this.#selectedEditors.clear();
        this.#dispatchUpdateStates({
          hasSelectedEditor: false
        });
      }
      translateSelectedEditors(x, y, noCommit = false) {
        if (!noCommit) {
          this.commitOrRemove();
        }
        if (!this.hasSelection) {
          return;
        }
        this.#translation[0] += x;
        this.#translation[1] += y;
        const [totalX, totalY] = this.#translation;
        const editors = [...this.#selectedEditors];
        const TIME_TO_WAIT = 1e3;
        if (this.#translationTimeoutId) {
          clearTimeout(this.#translationTimeoutId);
        }
        this.#translationTimeoutId = setTimeout(() => {
          this.#translationTimeoutId = null;
          this.#translation[0] = this.#translation[1] = 0;
          this.addCommands({
            cmd: () => {
              for (const editor of editors) {
                if (this.#allEditors.has(editor.id)) {
                  editor.translateInPage(totalX, totalY);
                  editor.translationDone();
                }
              }
            },
            undo: () => {
              for (const editor of editors) {
                if (this.#allEditors.has(editor.id)) {
                  editor.translateInPage(-totalX, -totalY);
                  editor.translationDone();
                }
              }
            },
            mustExec: false
          });
        }, TIME_TO_WAIT);
        for (const editor of editors) {
          editor.translateInPage(x, y);
          editor.translationDone();
        }
      }
      setUpDragSession() {
        if (!this.hasSelection) {
          return;
        }
        this.disableUserSelect(true);
        this.#draggingEditors = /* @__PURE__ */ new Map();
        for (const editor of this.#selectedEditors) {
          this.#draggingEditors.set(editor, {
            savedX: editor.x,
            savedY: editor.y,
            savedPageIndex: editor.pageIndex,
            newX: 0,
            newY: 0,
            newPageIndex: -1
          });
        }
      }
      endDragSession() {
        if (!this.#draggingEditors) {
          return false;
        }
        this.disableUserSelect(false);
        const map2 = this.#draggingEditors;
        this.#draggingEditors = null;
        let mustBeAddedInUndoStack = false;
        for (const [{
          x,
          y,
          pageIndex
        }, value] of map2) {
          value.newX = x;
          value.newY = y;
          value.newPageIndex = pageIndex;
          mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;
        }
        if (!mustBeAddedInUndoStack) {
          return false;
        }
        const move = (editor, x, y, pageIndex) => {
          if (this.#allEditors.has(editor.id)) {
            const parent = this.#allLayers.get(pageIndex);
            if (parent) {
              editor._setParentAndPosition(parent, x, y);
            } else {
              editor.pageIndex = pageIndex;
              editor.x = x;
              editor.y = y;
            }
          }
        };
        this.addCommands({
          cmd: () => {
            for (const [editor, {
              newX,
              newY,
              newPageIndex
            }] of map2) {
              move(editor, newX, newY, newPageIndex);
            }
          },
          undo: () => {
            for (const [editor, {
              savedX,
              savedY,
              savedPageIndex
            }] of map2) {
              move(editor, savedX, savedY, savedPageIndex);
            }
          },
          mustExec: true
        });
        return true;
      }
      dragSelectedEditors(tx, ty) {
        if (!this.#draggingEditors) {
          return;
        }
        for (const editor of this.#draggingEditors.keys()) {
          editor.drag(tx, ty);
        }
      }
      rebuild(editor) {
        if (editor.parent === null) {
          const parent = this.getLayer(editor.pageIndex);
          if (parent) {
            parent.changeParent(editor);
            parent.addOrRebuild(editor);
          } else {
            this.addEditor(editor);
            this.addToAnnotationStorage(editor);
            editor.rebuild();
          }
        } else {
          editor.parent.addOrRebuild(editor);
        }
      }
      get isEditorHandlingKeyboard() {
        return this.getActive()?.shouldGetKeyboardEvents() || this.#selectedEditors.size === 1 && this.firstSelectedEditor.shouldGetKeyboardEvents();
      }
      isActive(editor) {
        return this.#activeEditor === editor;
      }
      getActive() {
        return this.#activeEditor;
      }
      getMode() {
        return this.#mode;
      }
      isEditingMode() {
        return this.#mode !== AnnotationEditorType.NONE;
      }
      get imageManager() {
        return shadow(this, "imageManager", new ImageManager());
      }
      getSelectionBoxes(textLayer) {
        if (!textLayer) {
          return null;
        }
        const selection = document.getSelection();
        for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
          if (!textLayer.contains(selection.getRangeAt(i).commonAncestorContainer)) {
            return null;
          }
        }
        const {
          x: layerX,
          y: layerY,
          width: parentWidth,
          height: parentHeight
        } = textLayer.getBoundingClientRect();
        let rotator;
        switch (textLayer.getAttribute("data-main-rotation")) {
          case "90":
            rotator = (x, y, w, h) => ({
              x: (y - layerY) / parentHeight,
              y: 1 - (x + w - layerX) / parentWidth,
              width: h / parentHeight,
              height: w / parentWidth
            });
            break;
          case "180":
            rotator = (x, y, w, h) => ({
              x: 1 - (x + w - layerX) / parentWidth,
              y: 1 - (y + h - layerY) / parentHeight,
              width: w / parentWidth,
              height: h / parentHeight
            });
            break;
          case "270":
            rotator = (x, y, w, h) => ({
              x: 1 - (y + h - layerY) / parentHeight,
              y: (x - layerX) / parentWidth,
              width: h / parentHeight,
              height: w / parentWidth
            });
            break;
          default:
            rotator = (x, y, w, h) => ({
              x: (x - layerX) / parentWidth,
              y: (y - layerY) / parentHeight,
              width: w / parentWidth,
              height: h / parentHeight
            });
            break;
        }
        const boxes = [];
        for (let i = 0, ii = selection.rangeCount; i < ii; i++) {
          const range2 = selection.getRangeAt(i);
          if (range2.collapsed) {
            continue;
          }
          for (const {
            x,
            y,
            width,
            height
          } of range2.getClientRects()) {
            if (width === 0 || height === 0) {
              continue;
            }
            boxes.push(rotator(x, y, width, height));
          }
        }
        return boxes.length === 0 ? null : boxes;
      }
      addChangedExistingAnnotation({
        annotationElementId,
        id
      }) {
        (this.#changedExistingAnnotations ||= /* @__PURE__ */ new Map()).set(annotationElementId, id);
      }
      removeChangedExistingAnnotation({
        annotationElementId
      }) {
        this.#changedExistingAnnotations?.delete(annotationElementId);
      }
      renderAnnotationElement(annotation) {
        const editorId = this.#changedExistingAnnotations?.get(annotation.data.id);
        if (!editorId) {
          return;
        }
        const editor = this.#annotationStorage.getRawValue(editorId);
        if (!editor) {
          return;
        }
        if (this.#mode === AnnotationEditorType.NONE && !editor.hasBeenModified) {
          return;
        }
        editor.renderAnnotationElement(annotation);
      }
      setMissingCanvas(annotationId, annotationElementId, canvas) {
        const editor = this.#missingCanvases?.get(annotationId);
        if (!editor) {
          return;
        }
        editor.setCanvas(annotationElementId, canvas);
        this.#missingCanvases.delete(annotationId);
      }
      addMissingCanvas(annotationId, editor) {
        (this.#missingCanvases ||= /* @__PURE__ */ new Map()).set(annotationId, editor);
      }
    };
    AltText = class _AltText {
      #altText = null;
      #altTextDecorative = false;
      #altTextButton = null;
      #altTextButtonLabel = null;
      #altTextTooltip = null;
      #altTextTooltipTimeout = null;
      #altTextWasFromKeyBoard = false;
      #badge = null;
      #editor = null;
      #guessedText = null;
      #textWithDisclaimer = null;
      #useNewAltTextFlow = false;
      static #l10nNewButton = null;
      static _l10n = null;
      constructor(editor) {
        this.#editor = editor;
        this.#useNewAltTextFlow = editor._uiManager.useNewAltTextFlow;
        _AltText.#l10nNewButton ||= Object.freeze({
          added: "pdfjs-editor-new-alt-text-added-button",
          "added-label": "pdfjs-editor-new-alt-text-added-button-label",
          missing: "pdfjs-editor-new-alt-text-missing-button",
          "missing-label": "pdfjs-editor-new-alt-text-missing-button-label",
          review: "pdfjs-editor-new-alt-text-to-review-button",
          "review-label": "pdfjs-editor-new-alt-text-to-review-button-label"
        });
      }
      static initialize(l10n) {
        _AltText._l10n ??= l10n;
      }
      async render() {
        const altText = this.#altTextButton = document.createElement("button");
        altText.className = "altText";
        altText.tabIndex = "0";
        const label = this.#altTextButtonLabel = document.createElement("span");
        altText.append(label);
        if (this.#useNewAltTextFlow) {
          altText.classList.add("new");
          altText.setAttribute("data-l10n-id", _AltText.#l10nNewButton.missing);
          label.setAttribute("data-l10n-id", _AltText.#l10nNewButton["missing-label"]);
        } else {
          altText.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button");
          label.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-button-label");
        }
        const signal = this.#editor._uiManager._signal;
        altText.addEventListener("contextmenu", noContextMenu, {
          signal
        });
        altText.addEventListener("pointerdown", (event) => event.stopPropagation(), {
          signal
        });
        const onClick = (event) => {
          event.preventDefault();
          this.#editor._uiManager.editAltText(this.#editor);
          if (this.#useNewAltTextFlow) {
            this.#editor._reportTelemetry({
              action: "pdfjs.image.alt_text.image_status_label_clicked",
              data: {
                label: this.#label
              }
            });
          }
        };
        altText.addEventListener("click", onClick, {
          capture: true,
          signal
        });
        altText.addEventListener("keydown", (event) => {
          if (event.target === altText && event.key === "Enter") {
            this.#altTextWasFromKeyBoard = true;
            onClick(event);
          }
        }, {
          signal
        });
        await this.#setState();
        return altText;
      }
      get #label() {
        return this.#altText && "added" || this.#altText === null && this.guessedText && "review" || "missing";
      }
      finish() {
        if (!this.#altTextButton) {
          return;
        }
        this.#altTextButton.focus({
          focusVisible: this.#altTextWasFromKeyBoard
        });
        this.#altTextWasFromKeyBoard = false;
      }
      isEmpty() {
        if (this.#useNewAltTextFlow) {
          return this.#altText === null;
        }
        return !this.#altText && !this.#altTextDecorative;
      }
      hasData() {
        if (this.#useNewAltTextFlow) {
          return this.#altText !== null || !!this.#guessedText;
        }
        return this.isEmpty();
      }
      get guessedText() {
        return this.#guessedText;
      }
      async setGuessedText(guessedText) {
        if (this.#altText !== null) {
          return;
        }
        this.#guessedText = guessedText;
        this.#textWithDisclaimer = await _AltText._l10n.get("pdfjs-editor-new-alt-text-generated-alt-text-with-disclaimer", {
          generatedAltText: guessedText
        });
        this.#setState();
      }
      toggleAltTextBadge(visibility = false) {
        if (!this.#useNewAltTextFlow || this.#altText) {
          this.#badge?.remove();
          this.#badge = null;
          return;
        }
        if (!this.#badge) {
          const badge = this.#badge = document.createElement("div");
          badge.className = "noAltTextBadge";
          this.#editor.div.append(badge);
        }
        this.#badge.classList.toggle("hidden", !visibility);
      }
      serialize(isForCopying) {
        let altText = this.#altText;
        if (!isForCopying && this.#guessedText === altText) {
          altText = this.#textWithDisclaimer;
        }
        return {
          altText,
          decorative: this.#altTextDecorative,
          guessedText: this.#guessedText,
          textWithDisclaimer: this.#textWithDisclaimer
        };
      }
      get data() {
        return {
          altText: this.#altText,
          decorative: this.#altTextDecorative
        };
      }
      set data({
        altText,
        decorative,
        guessedText,
        textWithDisclaimer,
        cancel = false
      }) {
        if (guessedText) {
          this.#guessedText = guessedText;
          this.#textWithDisclaimer = textWithDisclaimer;
        }
        if (this.#altText === altText && this.#altTextDecorative === decorative) {
          return;
        }
        if (!cancel) {
          this.#altText = altText;
          this.#altTextDecorative = decorative;
        }
        this.#setState();
      }
      toggle(enabled = false) {
        if (!this.#altTextButton) {
          return;
        }
        if (!enabled && this.#altTextTooltipTimeout) {
          clearTimeout(this.#altTextTooltipTimeout);
          this.#altTextTooltipTimeout = null;
        }
        this.#altTextButton.disabled = !enabled;
      }
      shown() {
        this.#editor._reportTelemetry({
          action: "pdfjs.image.alt_text.image_status_label_displayed",
          data: {
            label: this.#label
          }
        });
      }
      destroy() {
        this.#altTextButton?.remove();
        this.#altTextButton = null;
        this.#altTextButtonLabel = null;
        this.#altTextTooltip = null;
        this.#badge?.remove();
        this.#badge = null;
      }
      async #setState() {
        const button = this.#altTextButton;
        if (!button) {
          return;
        }
        if (this.#useNewAltTextFlow) {
          button.classList.toggle("done", !!this.#altText);
          button.setAttribute("data-l10n-id", _AltText.#l10nNewButton[this.#label]);
          this.#altTextButtonLabel?.setAttribute("data-l10n-id", _AltText.#l10nNewButton[`${this.#label}-label`]);
          if (!this.#altText) {
            this.#altTextTooltip?.remove();
            return;
          }
        } else {
          if (!this.#altText && !this.#altTextDecorative) {
            button.classList.remove("done");
            this.#altTextTooltip?.remove();
            return;
          }
          button.classList.add("done");
          button.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-edit-button");
        }
        let tooltip = this.#altTextTooltip;
        if (!tooltip) {
          this.#altTextTooltip = tooltip = document.createElement("span");
          tooltip.className = "tooltip";
          tooltip.setAttribute("role", "tooltip");
          tooltip.id = `alt-text-tooltip-${this.#editor.id}`;
          const DELAY_TO_SHOW_TOOLTIP = 100;
          const signal = this.#editor._uiManager._signal;
          signal.addEventListener("abort", () => {
            clearTimeout(this.#altTextTooltipTimeout);
            this.#altTextTooltipTimeout = null;
          }, {
            once: true
          });
          button.addEventListener("mouseenter", () => {
            this.#altTextTooltipTimeout = setTimeout(() => {
              this.#altTextTooltipTimeout = null;
              this.#altTextTooltip.classList.add("show");
              this.#editor._reportTelemetry({
                action: "alt_text_tooltip"
              });
            }, DELAY_TO_SHOW_TOOLTIP);
          }, {
            signal
          });
          button.addEventListener("mouseleave", () => {
            if (this.#altTextTooltipTimeout) {
              clearTimeout(this.#altTextTooltipTimeout);
              this.#altTextTooltipTimeout = null;
            }
            this.#altTextTooltip?.classList.remove("show");
          }, {
            signal
          });
        }
        if (this.#altTextDecorative) {
          tooltip.setAttribute("data-l10n-id", "pdfjs-editor-alt-text-decorative-tooltip");
        } else {
          tooltip.removeAttribute("data-l10n-id");
          tooltip.textContent = this.#altText;
        }
        if (!tooltip.parentNode) {
          button.append(tooltip);
        }
        const element = this.#editor.getElementForAltText();
        element?.setAttribute("aria-describedby", tooltip.id);
      }
    };
    Comment = class {
      #commentStandaloneButton = null;
      #commentToolbarButton = null;
      #commentWasFromKeyBoard = false;
      #editor = null;
      #initialText = null;
      #richText = null;
      #text = null;
      #date = null;
      #deleted = false;
      #popupPosition = null;
      constructor(editor) {
        this.#editor = editor;
      }
      renderForToolbar() {
        const button = this.#commentToolbarButton = document.createElement("button");
        button.className = "comment";
        return this.#render(button, false);
      }
      renderForStandalone() {
        const button = this.#commentStandaloneButton = document.createElement("button");
        button.className = "annotationCommentButton";
        const position = this.#editor.commentButtonPosition;
        if (position) {
          const {
            style
          } = button;
          style.insetInlineEnd = `calc(${100 * (this.#editor._uiManager.direction === "ltr" ? 1 - position[0] : position[0])}% - var(--comment-button-dim))`;
          style.top = `calc(${100 * position[1]}% - var(--comment-button-dim))`;
          const color = this.#editor.commentButtonColor;
          if (color) {
            style.backgroundColor = color;
          }
        }
        return this.#render(button, true);
      }
      focusButton() {
        setTimeout(() => {
          (this.#commentStandaloneButton ?? this.#commentToolbarButton)?.focus();
        }, 0);
      }
      onUpdatedColor() {
        if (!this.#commentStandaloneButton) {
          return;
        }
        const color = this.#editor.commentButtonColor;
        if (color) {
          this.#commentStandaloneButton.style.backgroundColor = color;
        }
        this.#editor._uiManager.updatePopupColor(this.#editor);
      }
      get commentButtonWidth() {
        return (this.#commentStandaloneButton?.getBoundingClientRect().width ?? 0) / this.#editor.parent.boundingClientRect.width;
      }
      get commentPopupPositionInLayer() {
        if (this.#popupPosition) {
          return this.#popupPosition;
        }
        if (!this.#commentStandaloneButton) {
          return null;
        }
        const {
          x,
          y,
          height
        } = this.#commentStandaloneButton.getBoundingClientRect();
        const {
          x: parentX,
          y: parentY,
          width: parentWidth,
          height: parentHeight
        } = this.#editor.parent.boundingClientRect;
        return [(x - parentX) / parentWidth, (y + height - parentY) / parentHeight];
      }
      set commentPopupPositionInLayer(pos) {
        this.#popupPosition = pos;
      }
      hasDefaultPopupPosition() {
        return this.#popupPosition === null;
      }
      removeStandaloneCommentButton() {
        this.#commentStandaloneButton?.remove();
        this.#commentStandaloneButton = null;
      }
      removeToolbarCommentButton() {
        this.#commentToolbarButton?.remove();
        this.#commentToolbarButton = null;
      }
      setCommentButtonStates({
        selected,
        hasPopup
      }) {
        if (!this.#commentStandaloneButton) {
          return;
        }
        this.#commentStandaloneButton.classList.toggle("selected", selected);
        this.#commentStandaloneButton.ariaExpanded = hasPopup;
      }
      #render(comment, isStandalone) {
        if (!this.#editor._uiManager.hasCommentManager()) {
          return null;
        }
        comment.tabIndex = "0";
        comment.ariaHasPopup = "dialog";
        if (isStandalone) {
          comment.ariaControls = "commentPopup";
          comment.setAttribute("data-l10n-id", "pdfjs-show-comment-button");
        } else {
          comment.ariaControlsElements = [this.#editor._uiManager.getCommentDialogElement()];
          comment.setAttribute("data-l10n-id", "pdfjs-editor-edit-comment-button");
        }
        const signal = this.#editor._uiManager._signal;
        if (!(signal instanceof AbortSignal) || signal.aborted) {
          return comment;
        }
        comment.addEventListener("contextmenu", noContextMenu, {
          signal
        });
        if (isStandalone) {
          comment.addEventListener("focusin", (e) => {
            this.#editor._focusEventsAllowed = false;
            stopEvent(e);
          }, {
            capture: true,
            signal
          });
          comment.addEventListener("focusout", (e) => {
            this.#editor._focusEventsAllowed = true;
            stopEvent(e);
          }, {
            capture: true,
            signal
          });
        }
        comment.addEventListener("pointerdown", (event) => event.stopPropagation(), {
          signal
        });
        const onClick = (event) => {
          event.preventDefault();
          if (comment === this.#commentToolbarButton) {
            this.edit();
          } else {
            this.#editor.toggleComment(true);
          }
        };
        comment.addEventListener("click", onClick, {
          capture: true,
          signal
        });
        comment.addEventListener("keydown", (event) => {
          if (event.target === comment && event.key === "Enter") {
            this.#commentWasFromKeyBoard = true;
            onClick(event);
          }
        }, {
          signal
        });
        comment.addEventListener("pointerenter", () => {
          this.#editor.toggleComment(false, true);
        }, {
          signal
        });
        comment.addEventListener("pointerleave", () => {
          this.#editor.toggleComment(false, false);
        }, {
          signal
        });
        return comment;
      }
      edit(options) {
        const position = this.commentPopupPositionInLayer;
        let posX, posY;
        if (position) {
          [posX, posY] = position;
        } else {
          [posX, posY] = this.#editor.commentButtonPosition;
          const {
            width,
            height,
            x,
            y
          } = this.#editor;
          posX = x + posX * width;
          posY = y + posY * height;
        }
        const parentDimensions = this.#editor.parent.boundingClientRect;
        const {
          x: parentX,
          y: parentY,
          width: parentWidth,
          height: parentHeight
        } = parentDimensions;
        this.#editor._uiManager.editComment(this.#editor, parentX + posX * parentWidth, parentY + posY * parentHeight, {
          ...options,
          parentDimensions
        });
      }
      finish() {
        if (!this.#commentToolbarButton) {
          return;
        }
        this.#commentToolbarButton.focus({
          focusVisible: this.#commentWasFromKeyBoard
        });
        this.#commentWasFromKeyBoard = false;
      }
      isDeleted() {
        return this.#deleted || this.#text === "";
      }
      isEmpty() {
        return this.#text === null;
      }
      hasBeenEdited() {
        return this.isDeleted() || this.#text !== this.#initialText;
      }
      serialize() {
        return this.data;
      }
      get data() {
        return {
          text: this.#text,
          richText: this.#richText,
          date: this.#date,
          deleted: this.isDeleted()
        };
      }
      set data(text) {
        if (text !== this.#text) {
          this.#richText = null;
        }
        if (text === null) {
          this.#text = "";
          this.#deleted = true;
          return;
        }
        this.#text = text;
        this.#date = /* @__PURE__ */ new Date();
        this.#deleted = false;
      }
      setInitialText(text, richText = null) {
        this.#initialText = text;
        this.data = text;
        this.#date = null;
        this.#richText = richText;
      }
      shown() {
      }
      destroy() {
        this.#commentToolbarButton?.remove();
        this.#commentToolbarButton = null;
        this.#commentStandaloneButton?.remove();
        this.#commentStandaloneButton = null;
        this.#text = "";
        this.#richText = null;
        this.#date = null;
        this.#editor = null;
        this.#commentWasFromKeyBoard = false;
        this.#deleted = false;
      }
    };
    TouchManager = class _TouchManager {
      #container;
      #isPinching = false;
      #isPinchingStopped = null;
      #isPinchingDisabled;
      #onPinchStart;
      #onPinching;
      #onPinchEnd;
      #pointerDownAC = null;
      #signal;
      #touchInfo = null;
      #touchManagerAC;
      #touchMoveAC = null;
      constructor({
        container,
        isPinchingDisabled = null,
        isPinchingStopped = null,
        onPinchStart = null,
        onPinching = null,
        onPinchEnd = null,
        signal
      }) {
        this.#container = container;
        this.#isPinchingStopped = isPinchingStopped;
        this.#isPinchingDisabled = isPinchingDisabled;
        this.#onPinchStart = onPinchStart;
        this.#onPinching = onPinching;
        this.#onPinchEnd = onPinchEnd;
        this.#touchManagerAC = new AbortController();
        this.#signal = AbortSignal.any([signal, this.#touchManagerAC.signal]);
        container.addEventListener("touchstart", this.#onTouchStart.bind(this), {
          passive: false,
          signal: this.#signal
        });
      }
      get MIN_TOUCH_DISTANCE_TO_PINCH() {
        return 35 / OutputScale.pixelRatio;
      }
      #onTouchStart(evt) {
        if (this.#isPinchingDisabled?.()) {
          return;
        }
        if (evt.touches.length === 1) {
          if (this.#pointerDownAC) {
            return;
          }
          const pointerDownAC = this.#pointerDownAC = new AbortController();
          const signal = AbortSignal.any([this.#signal, pointerDownAC.signal]);
          const container = this.#container;
          const opts = {
            capture: true,
            signal,
            passive: false
          };
          const cancelPointerDown = (e) => {
            if (e.pointerType === "touch") {
              this.#pointerDownAC?.abort();
              this.#pointerDownAC = null;
            }
          };
          container.addEventListener("pointerdown", (e) => {
            if (e.pointerType === "touch") {
              stopEvent(e);
              cancelPointerDown(e);
            }
          }, opts);
          container.addEventListener("pointerup", cancelPointerDown, opts);
          container.addEventListener("pointercancel", cancelPointerDown, opts);
          return;
        }
        if (!this.#touchMoveAC) {
          this.#touchMoveAC = new AbortController();
          const signal = AbortSignal.any([this.#signal, this.#touchMoveAC.signal]);
          const container = this.#container;
          const opt = {
            signal,
            capture: false,
            passive: false
          };
          container.addEventListener("touchmove", this.#onTouchMove.bind(this), opt);
          const onTouchEnd = this.#onTouchEnd.bind(this);
          container.addEventListener("touchend", onTouchEnd, opt);
          container.addEventListener("touchcancel", onTouchEnd, opt);
          opt.capture = true;
          container.addEventListener("pointerdown", stopEvent, opt);
          container.addEventListener("pointermove", stopEvent, opt);
          container.addEventListener("pointercancel", stopEvent, opt);
          container.addEventListener("pointerup", stopEvent, opt);
          this.#onPinchStart?.();
        }
        stopEvent(evt);
        if (evt.touches.length !== 2 || this.#isPinchingStopped?.()) {
          this.#touchInfo = null;
          return;
        }
        let [touch0, touch1] = evt.touches;
        if (touch0.identifier > touch1.identifier) {
          [touch0, touch1] = [touch1, touch0];
        }
        this.#touchInfo = {
          touch0X: touch0.screenX,
          touch0Y: touch0.screenY,
          touch1X: touch1.screenX,
          touch1Y: touch1.screenY
        };
      }
      #onTouchMove(evt) {
        if (!this.#touchInfo || evt.touches.length !== 2) {
          return;
        }
        stopEvent(evt);
        let [touch0, touch1] = evt.touches;
        if (touch0.identifier > touch1.identifier) {
          [touch0, touch1] = [touch1, touch0];
        }
        const {
          screenX: screen0X,
          screenY: screen0Y
        } = touch0;
        const {
          screenX: screen1X,
          screenY: screen1Y
        } = touch1;
        const touchInfo = this.#touchInfo;
        const {
          touch0X: pTouch0X,
          touch0Y: pTouch0Y,
          touch1X: pTouch1X,
          touch1Y: pTouch1Y
        } = touchInfo;
        const prevGapX = pTouch1X - pTouch0X;
        const prevGapY = pTouch1Y - pTouch0Y;
        const currGapX = screen1X - screen0X;
        const currGapY = screen1Y - screen0Y;
        const distance = Math.hypot(currGapX, currGapY) || 1;
        const pDistance = Math.hypot(prevGapX, prevGapY) || 1;
        if (!this.#isPinching && Math.abs(pDistance - distance) <= _TouchManager.MIN_TOUCH_DISTANCE_TO_PINCH) {
          return;
        }
        touchInfo.touch0X = screen0X;
        touchInfo.touch0Y = screen0Y;
        touchInfo.touch1X = screen1X;
        touchInfo.touch1Y = screen1Y;
        if (!this.#isPinching) {
          this.#isPinching = true;
          return;
        }
        const origin = [(screen0X + screen1X) / 2, (screen0Y + screen1Y) / 2];
        this.#onPinching?.(origin, pDistance, distance);
      }
      #onTouchEnd(evt) {
        if (evt.touches.length >= 2) {
          return;
        }
        if (this.#touchMoveAC) {
          this.#touchMoveAC.abort();
          this.#touchMoveAC = null;
          this.#onPinchEnd?.();
        }
        if (!this.#touchInfo) {
          return;
        }
        stopEvent(evt);
        this.#touchInfo = null;
        this.#isPinching = false;
      }
      destroy() {
        this.#touchManagerAC?.abort();
        this.#touchManagerAC = null;
        this.#pointerDownAC?.abort();
        this.#pointerDownAC = null;
      }
    };
    AnnotationEditor = class _AnnotationEditor {
      #accessibilityData = null;
      #allResizerDivs = null;
      #altText = null;
      #comment = null;
      #commentStandaloneButton = null;
      #disabled = false;
      #dragPointerId = null;
      #dragPointerType = "";
      #resizersDiv = null;
      #lastPointerCoords = null;
      #savedDimensions = null;
      #fakeAnnotation = null;
      #focusAC = null;
      #focusedResizerName = "";
      #hasBeenClicked = false;
      #initialRect = null;
      #isEditing = false;
      #isInEditMode = false;
      #isResizerEnabledForKeyboard = false;
      #moveInDOMTimeout = null;
      #prevDragX = 0;
      #prevDragY = 0;
      #telemetryTimeouts = null;
      #touchManager = null;
      isSelected = false;
      _isCopy = false;
      _editToolbar = null;
      _initialOptions = /* @__PURE__ */ Object.create(null);
      _initialData = null;
      _isVisible = true;
      _uiManager = null;
      _focusEventsAllowed = true;
      static _l10n = null;
      static _l10nResizer = null;
      #isDraggable = false;
      #zIndex = _AnnotationEditor._zIndex++;
      static _borderLineWidth = -1;
      static _colorManager = new ColorManager();
      static _zIndex = 1;
      static _telemetryTimeout = 1e3;
      static get _resizerKeyboardManager() {
        const resize = _AnnotationEditor.prototype._resizeWithKeyboard;
        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
        const big = AnnotationEditorUIManager.TRANSLATE_BIG;
        return shadow(this, "_resizerKeyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], resize, {
          args: [-small, 0]
        }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], resize, {
          args: [-big, 0]
        }], [["ArrowRight", "mac+ArrowRight"], resize, {
          args: [small, 0]
        }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], resize, {
          args: [big, 0]
        }], [["ArrowUp", "mac+ArrowUp"], resize, {
          args: [0, -small]
        }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], resize, {
          args: [0, -big]
        }], [["ArrowDown", "mac+ArrowDown"], resize, {
          args: [0, small]
        }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], resize, {
          args: [0, big]
        }], [["Escape", "mac+Escape"], _AnnotationEditor.prototype._stopResizingWithKeyboard]]));
      }
      constructor(parameters) {
        this.parent = parameters.parent;
        this.id = parameters.id;
        this.width = this.height = null;
        this.pageIndex = parameters.parent.pageIndex;
        this.name = parameters.name;
        this.div = null;
        this._uiManager = parameters.uiManager;
        this.annotationElementId = null;
        this._willKeepAspectRatio = false;
        this._initialOptions.isCentered = parameters.isCentered;
        this._structTreeParentId = null;
        this.annotationElementId = parameters.annotationElementId || null;
        this.creationDate = parameters.creationDate || /* @__PURE__ */ new Date();
        this.modificationDate = parameters.modificationDate || null;
        const {
          rotation,
          rawDims: {
            pageWidth,
            pageHeight,
            pageX,
            pageY
          }
        } = this.parent.viewport;
        this.rotation = rotation;
        this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;
        this.pageDimensions = [pageWidth, pageHeight];
        this.pageTranslation = [pageX, pageY];
        const [width, height] = this.parentDimensions;
        this.x = parameters.x / width;
        this.y = parameters.y / height;
        this.isAttachedToDOM = false;
        this.deleted = false;
      }
      get editorType() {
        return Object.getPrototypeOf(this).constructor._type;
      }
      get mode() {
        return Object.getPrototypeOf(this).constructor._editorType;
      }
      static get isDrawer() {
        return false;
      }
      static get _defaultLineColor() {
        return shadow(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText"));
      }
      static deleteAnnotationElement(editor) {
        const fakeEditor = new FakeEditor({
          id: editor.parent.getNextId(),
          parent: editor.parent,
          uiManager: editor._uiManager
        });
        fakeEditor.annotationElementId = editor.annotationElementId;
        fakeEditor.deleted = true;
        fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);
      }
      static initialize(l10n, _uiManager) {
        _AnnotationEditor._l10n ??= l10n;
        _AnnotationEditor._l10nResizer ||= Object.freeze({
          topLeft: "pdfjs-editor-resizer-top-left",
          topMiddle: "pdfjs-editor-resizer-top-middle",
          topRight: "pdfjs-editor-resizer-top-right",
          middleRight: "pdfjs-editor-resizer-middle-right",
          bottomRight: "pdfjs-editor-resizer-bottom-right",
          bottomMiddle: "pdfjs-editor-resizer-bottom-middle",
          bottomLeft: "pdfjs-editor-resizer-bottom-left",
          middleLeft: "pdfjs-editor-resizer-middle-left"
        });
        if (_AnnotationEditor._borderLineWidth !== -1) {
          return;
        }
        const style = getComputedStyle(document.documentElement);
        _AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue("--outline-width")) || 0;
      }
      static updateDefaultParams(_type, _value) {
      }
      static get defaultPropertiesToUpdate() {
        return [];
      }
      static isHandlingMimeForPasting(mime) {
        return false;
      }
      static paste(item, parent) {
        unreachable("Not implemented");
      }
      get propertiesToUpdate() {
        return [];
      }
      get _isDraggable() {
        return this.#isDraggable;
      }
      set _isDraggable(value) {
        this.#isDraggable = value;
        this.div?.classList.toggle("draggable", value);
      }
      get uid() {
        return this.annotationElementId || this.id;
      }
      get isEnterHandled() {
        return true;
      }
      center() {
        const [pageWidth, pageHeight] = this.pageDimensions;
        switch (this.parentRotation) {
          case 90:
            this.x -= this.height * pageHeight / (pageWidth * 2);
            this.y += this.width * pageWidth / (pageHeight * 2);
            break;
          case 180:
            this.x += this.width / 2;
            this.y += this.height / 2;
            break;
          case 270:
            this.x += this.height * pageHeight / (pageWidth * 2);
            this.y -= this.width * pageWidth / (pageHeight * 2);
            break;
          default:
            this.x -= this.width / 2;
            this.y -= this.height / 2;
            break;
        }
        this.fixAndSetPosition();
      }
      addCommands(params) {
        this._uiManager.addCommands(params);
      }
      get currentLayer() {
        return this._uiManager.currentLayer;
      }
      setInBackground() {
        this.div.style.zIndex = 0;
      }
      setInForeground() {
        this.div.style.zIndex = this.#zIndex;
      }
      setParent(parent) {
        if (parent !== null) {
          this.pageIndex = parent.pageIndex;
          this.pageDimensions = parent.pageDimensions;
        } else {
          this.#stopResizing();
          this.#fakeAnnotation?.remove();
          this.#fakeAnnotation = null;
        }
        this.parent = parent;
      }
      focusin(event) {
        if (!this._focusEventsAllowed) {
          return;
        }
        if (!this.#hasBeenClicked) {
          this.parent.setSelected(this);
        } else {
          this.#hasBeenClicked = false;
        }
      }
      focusout(event) {
        if (!this._focusEventsAllowed) {
          return;
        }
        if (!this.isAttachedToDOM) {
          return;
        }
        const target = event.relatedTarget;
        if (target?.closest(`#${this.id}`)) {
          return;
        }
        event.preventDefault();
        if (!this.parent?.isMultipleSelection) {
          this.commitOrRemove();
        }
      }
      commitOrRemove() {
        if (this.isEmpty()) {
          this.remove();
        } else {
          this.commit();
        }
      }
      commit() {
        if (!this.isInEditMode()) {
          return;
        }
        this.addToAnnotationStorage();
      }
      addToAnnotationStorage() {
        this._uiManager.addToAnnotationStorage(this);
      }
      setAt(x, y, tx, ty) {
        const [width, height] = this.parentDimensions;
        [tx, ty] = this.screenToPageTranslation(tx, ty);
        this.x = (x + tx) / width;
        this.y = (y + ty) / height;
        this.fixAndSetPosition();
      }
      _moveAfterPaste(baseX, baseY) {
        const [parentWidth, parentHeight] = this.parentDimensions;
        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);
        this._onTranslated();
      }
      #translate([width, height], x, y) {
        [x, y] = this.screenToPageTranslation(x, y);
        this.x += x / width;
        this.y += y / height;
        this._onTranslating(this.x, this.y);
        this.fixAndSetPosition();
      }
      translate(x, y) {
        this.#translate(this.parentDimensions, x, y);
      }
      translateInPage(x, y) {
        this.#initialRect ||= [this.x, this.y, this.width, this.height];
        this.#translate(this.pageDimensions, x, y);
        this.div.scrollIntoView({
          block: "nearest"
        });
      }
      translationDone() {
        this._onTranslated(this.x, this.y);
      }
      drag(tx, ty) {
        this.#initialRect ||= [this.x, this.y, this.width, this.height];
        const {
          div,
          parentDimensions: [parentWidth, parentHeight]
        } = this;
        this.x += tx / parentWidth;
        this.y += ty / parentHeight;
        if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {
          const {
            x: x2,
            y: y2
          } = this.div.getBoundingClientRect();
          if (this.parent.findNewParent(this, x2, y2)) {
            this.x -= Math.floor(this.x);
            this.y -= Math.floor(this.y);
          }
        }
        let {
          x,
          y
        } = this;
        const [bx, by] = this.getBaseTranslation();
        x += bx;
        y += by;
        const {
          style
        } = div;
        style.left = `${(100 * x).toFixed(2)}%`;
        style.top = `${(100 * y).toFixed(2)}%`;
        this._onTranslating(x, y);
        div.scrollIntoView({
          block: "nearest"
        });
      }
      _onTranslating(x, y) {
      }
      _onTranslated(x, y) {
      }
      get _hasBeenMoved() {
        return !!this.#initialRect && (this.#initialRect[0] !== this.x || this.#initialRect[1] !== this.y);
      }
      get _hasBeenResized() {
        return !!this.#initialRect && (this.#initialRect[2] !== this.width || this.#initialRect[3] !== this.height);
      }
      getBaseTranslation() {
        const [parentWidth, parentHeight] = this.parentDimensions;
        const {
          _borderLineWidth
        } = _AnnotationEditor;
        const x = _borderLineWidth / parentWidth;
        const y = _borderLineWidth / parentHeight;
        switch (this.rotation) {
          case 90:
            return [-x, y];
          case 180:
            return [x, y];
          case 270:
            return [x, -y];
          default:
            return [-x, -y];
        }
      }
      get _mustFixPosition() {
        return true;
      }
      fixAndSetPosition(rotation = this.rotation) {
        const {
          div: {
            style
          },
          pageDimensions: [pageWidth, pageHeight]
        } = this;
        let {
          x,
          y,
          width,
          height
        } = this;
        width *= pageWidth;
        height *= pageHeight;
        x *= pageWidth;
        y *= pageHeight;
        if (this._mustFixPosition) {
          switch (rotation) {
            case 0:
              x = MathClamp(x, 0, pageWidth - width);
              y = MathClamp(y, 0, pageHeight - height);
              break;
            case 90:
              x = MathClamp(x, 0, pageWidth - height);
              y = MathClamp(y, width, pageHeight);
              break;
            case 180:
              x = MathClamp(x, width, pageWidth);
              y = MathClamp(y, height, pageHeight);
              break;
            case 270:
              x = MathClamp(x, height, pageWidth);
              y = MathClamp(y, 0, pageHeight - width);
              break;
          }
        }
        this.x = x /= pageWidth;
        this.y = y /= pageHeight;
        const [bx, by] = this.getBaseTranslation();
        x += bx;
        y += by;
        style.left = `${(100 * x).toFixed(2)}%`;
        style.top = `${(100 * y).toFixed(2)}%`;
        this.moveInDOM();
      }
      static #rotatePoint(x, y, angle) {
        switch (angle) {
          case 90:
            return [y, -x];
          case 180:
            return [-x, -y];
          case 270:
            return [-y, x];
          default:
            return [x, y];
        }
      }
      screenToPageTranslation(x, y) {
        return _AnnotationEditor.#rotatePoint(x, y, this.parentRotation);
      }
      pageTranslationToScreen(x, y) {
        return _AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);
      }
      #getRotationMatrix(rotation) {
        switch (rotation) {
          case 90: {
            const [pageWidth, pageHeight] = this.pageDimensions;
            return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];
          }
          case 180:
            return [-1, 0, 0, -1];
          case 270: {
            const [pageWidth, pageHeight] = this.pageDimensions;
            return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];
          }
          default:
            return [1, 0, 0, 1];
        }
      }
      get parentScale() {
        return this._uiManager.viewParameters.realScale;
      }
      get parentRotation() {
        return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;
      }
      get parentDimensions() {
        const {
          parentScale,
          pageDimensions: [pageWidth, pageHeight]
        } = this;
        return [pageWidth * parentScale, pageHeight * parentScale];
      }
      setDims() {
        const {
          div: {
            style
          },
          width,
          height
        } = this;
        style.width = `${(100 * width).toFixed(2)}%`;
        style.height = `${(100 * height).toFixed(2)}%`;
      }
      getInitialTranslation() {
        return [0, 0];
      }
      #createResizers() {
        if (this.#resizersDiv) {
          return;
        }
        this.#resizersDiv = document.createElement("div");
        this.#resizersDiv.classList.add("resizers");
        const classes = this._willKeepAspectRatio ? ["topLeft", "topRight", "bottomRight", "bottomLeft"] : ["topLeft", "topMiddle", "topRight", "middleRight", "bottomRight", "bottomMiddle", "bottomLeft", "middleLeft"];
        const signal = this._uiManager._signal;
        for (const name of classes) {
          const div = document.createElement("div");
          this.#resizersDiv.append(div);
          div.classList.add("resizer", name);
          div.setAttribute("data-resizer-name", name);
          div.addEventListener("pointerdown", this.#resizerPointerdown.bind(this, name), {
            signal
          });
          div.addEventListener("contextmenu", noContextMenu, {
            signal
          });
          div.tabIndex = -1;
        }
        this.div.prepend(this.#resizersDiv);
      }
      #resizerPointerdown(name, event) {
        event.preventDefault();
        const {
          isMac
        } = util_FeatureTest.platform;
        if (event.button !== 0 || event.ctrlKey && isMac) {
          return;
        }
        this.#altText?.toggle(false);
        const savedDraggable = this._isDraggable;
        this._isDraggable = false;
        this.#lastPointerCoords = [event.screenX, event.screenY];
        const ac = new AbortController();
        const signal = this._uiManager.combinedSignal(ac);
        this.parent.togglePointerEvents(false);
        window.addEventListener("pointermove", this.#resizerPointermove.bind(this, name), {
          passive: true,
          capture: true,
          signal
        });
        window.addEventListener("touchmove", stopEvent, {
          passive: false,
          signal
        });
        window.addEventListener("contextmenu", noContextMenu, {
          signal
        });
        this.#savedDimensions = {
          savedX: this.x,
          savedY: this.y,
          savedWidth: this.width,
          savedHeight: this.height
        };
        const savedParentCursor = this.parent.div.style.cursor;
        const savedCursor = this.div.style.cursor;
        this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;
        const pointerUpCallback = () => {
          ac.abort();
          this.parent.togglePointerEvents(true);
          this.#altText?.toggle(true);
          this._isDraggable = savedDraggable;
          this.parent.div.style.cursor = savedParentCursor;
          this.div.style.cursor = savedCursor;
          this.#addResizeToUndoStack();
        };
        window.addEventListener("pointerup", pointerUpCallback, {
          signal
        });
        window.addEventListener("blur", pointerUpCallback, {
          signal
        });
      }
      #resize(x, y, width, height) {
        this.width = width;
        this.height = height;
        this.x = x;
        this.y = y;
        this.setDims();
        this.fixAndSetPosition();
        this._onResized();
      }
      _onResized() {
      }
      #addResizeToUndoStack() {
        if (!this.#savedDimensions) {
          return;
        }
        const {
          savedX,
          savedY,
          savedWidth,
          savedHeight
        } = this.#savedDimensions;
        this.#savedDimensions = null;
        const newX = this.x;
        const newY = this.y;
        const newWidth = this.width;
        const newHeight = this.height;
        if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {
          return;
        }
        this.addCommands({
          cmd: this.#resize.bind(this, newX, newY, newWidth, newHeight),
          undo: this.#resize.bind(this, savedX, savedY, savedWidth, savedHeight),
          mustExec: true
        });
      }
      static _round(x) {
        return Math.round(x * 1e4) / 1e4;
      }
      #resizerPointermove(name, event) {
        const [parentWidth, parentHeight] = this.parentDimensions;
        const savedX = this.x;
        const savedY = this.y;
        const savedWidth = this.width;
        const savedHeight = this.height;
        const minWidth = _AnnotationEditor.MIN_SIZE / parentWidth;
        const minHeight = _AnnotationEditor.MIN_SIZE / parentHeight;
        const rotationMatrix = this.#getRotationMatrix(this.rotation);
        const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
        const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);
        const invTransf = (x, y) => [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];
        let getPoint;
        let getOpposite;
        let isDiagonal = false;
        let isHorizontal = false;
        switch (name) {
          case "topLeft":
            isDiagonal = true;
            getPoint = (w, h) => [0, 0];
            getOpposite = (w, h) => [w, h];
            break;
          case "topMiddle":
            getPoint = (w, h) => [w / 2, 0];
            getOpposite = (w, h) => [w / 2, h];
            break;
          case "topRight":
            isDiagonal = true;
            getPoint = (w, h) => [w, 0];
            getOpposite = (w, h) => [0, h];
            break;
          case "middleRight":
            isHorizontal = true;
            getPoint = (w, h) => [w, h / 2];
            getOpposite = (w, h) => [0, h / 2];
            break;
          case "bottomRight":
            isDiagonal = true;
            getPoint = (w, h) => [w, h];
            getOpposite = (w, h) => [0, 0];
            break;
          case "bottomMiddle":
            getPoint = (w, h) => [w / 2, h];
            getOpposite = (w, h) => [w / 2, 0];
            break;
          case "bottomLeft":
            isDiagonal = true;
            getPoint = (w, h) => [0, h];
            getOpposite = (w, h) => [w, 0];
            break;
          case "middleLeft":
            isHorizontal = true;
            getPoint = (w, h) => [0, h / 2];
            getOpposite = (w, h) => [w, h / 2];
            break;
        }
        const point = getPoint(savedWidth, savedHeight);
        const oppositePoint = getOpposite(savedWidth, savedHeight);
        let transfOppositePoint = transf(...oppositePoint);
        const oppositeX = _AnnotationEditor._round(savedX + transfOppositePoint[0]);
        const oppositeY = _AnnotationEditor._round(savedY + transfOppositePoint[1]);
        let ratioX = 1;
        let ratioY = 1;
        let deltaX, deltaY;
        if (!event.fromKeyboard) {
          const {
            screenX,
            screenY
          } = event;
          const [lastScreenX, lastScreenY] = this.#lastPointerCoords;
          [deltaX, deltaY] = this.screenToPageTranslation(screenX - lastScreenX, screenY - lastScreenY);
          this.#lastPointerCoords[0] = screenX;
          this.#lastPointerCoords[1] = screenY;
        } else {
          ({
            deltaX,
            deltaY
          } = event);
        }
        [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);
        if (isDiagonal) {
          const oldDiag = Math.hypot(savedWidth, savedHeight);
          ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
        } else if (isHorizontal) {
          ratioX = MathClamp(Math.abs(oppositePoint[0] - point[0] - deltaX), minWidth, 1) / savedWidth;
        } else {
          ratioY = MathClamp(Math.abs(oppositePoint[1] - point[1] - deltaY), minHeight, 1) / savedHeight;
        }
        const newWidth = _AnnotationEditor._round(savedWidth * ratioX);
        const newHeight = _AnnotationEditor._round(savedHeight * ratioY);
        transfOppositePoint = transf(...getOpposite(newWidth, newHeight));
        const newX = oppositeX - transfOppositePoint[0];
        const newY = oppositeY - transfOppositePoint[1];
        this.#initialRect ||= [this.x, this.y, this.width, this.height];
        this.width = newWidth;
        this.height = newHeight;
        this.x = newX;
        this.y = newY;
        this.setDims();
        this.fixAndSetPosition();
        this._onResizing();
      }
      _onResizing() {
      }
      altTextFinish() {
        this.#altText?.finish();
      }
      get toolbarButtons() {
        return null;
      }
      async addEditToolbar() {
        if (this._editToolbar || this.#isInEditMode) {
          return this._editToolbar;
        }
        this._editToolbar = new EditorToolbar(this);
        this.div.append(this._editToolbar.render());
        const {
          toolbarButtons
        } = this;
        if (toolbarButtons) {
          for (const [name, tool] of toolbarButtons) {
            await this._editToolbar.addButton(name, tool);
          }
        }
        if (!this.hasComment) {
          this._editToolbar.addButton("comment", this.addCommentButton());
        }
        this._editToolbar.addButton("delete");
        return this._editToolbar;
      }
      addCommentButtonInToolbar() {
        this._editToolbar?.addButtonBefore("comment", this.addCommentButton(), ".deleteButton");
      }
      removeCommentButtonFromToolbar() {
        this._editToolbar?.removeButton("comment");
      }
      removeEditToolbar() {
        this._editToolbar?.remove();
        this._editToolbar = null;
        this.#altText?.destroy();
      }
      addContainer(container) {
        const editToolbarDiv = this._editToolbar?.div;
        if (editToolbarDiv) {
          editToolbarDiv.before(container);
        } else {
          this.div.append(container);
        }
      }
      getClientDimensions() {
        return this.div.getBoundingClientRect();
      }
      createAltText() {
        if (!this.#altText) {
          AltText.initialize(_AnnotationEditor._l10n);
          this.#altText = new AltText(this);
          if (this.#accessibilityData) {
            this.#altText.data = this.#accessibilityData;
            this.#accessibilityData = null;
          }
        }
        return this.#altText;
      }
      get altTextData() {
        return this.#altText?.data;
      }
      set altTextData(data) {
        if (!this.#altText) {
          return;
        }
        this.#altText.data = data;
      }
      get guessedAltText() {
        return this.#altText?.guessedText;
      }
      async setGuessedAltText(text) {
        await this.#altText?.setGuessedText(text);
      }
      serializeAltText(isForCopying) {
        return this.#altText?.serialize(isForCopying);
      }
      hasAltText() {
        return !!this.#altText && !this.#altText.isEmpty();
      }
      hasAltTextData() {
        return this.#altText?.hasData() ?? false;
      }
      focusCommentButton() {
        this.#comment?.focusButton();
      }
      addCommentButton() {
        return this.#comment ||= new Comment(this);
      }
      addStandaloneCommentButton() {
        if (this.#commentStandaloneButton) {
          if (this._uiManager.isEditingMode()) {
            this.#commentStandaloneButton.classList.remove("hidden");
          }
          return;
        }
        if (!this.hasComment) {
          return;
        }
        this.#commentStandaloneButton = this.#comment.renderForStandalone();
        this.div.append(this.#commentStandaloneButton);
      }
      removeStandaloneCommentButton() {
        this.#comment.removeStandaloneCommentButton();
        this.#commentStandaloneButton = null;
      }
      hideStandaloneCommentButton() {
        this.#commentStandaloneButton?.classList.add("hidden");
      }
      get comment() {
        const {
          data: {
            richText,
            text,
            date,
            deleted
          }
        } = this.#comment;
        return {
          text,
          richText,
          date,
          deleted,
          color: this.getNonHCMColor(),
          opacity: this.opacity ?? 1
        };
      }
      set comment(text) {
        this.#comment ||= new Comment(this);
        this.#comment.data = text;
        if (this.hasComment) {
          this.removeCommentButtonFromToolbar();
          this.addStandaloneCommentButton();
          this._uiManager.updateComment(this);
        } else {
          this.addCommentButtonInToolbar();
          this.removeStandaloneCommentButton();
          this._uiManager.removeComment(this);
        }
      }
      setCommentData({
        comment,
        popupRef,
        richText
      }) {
        if (!popupRef) {
          return;
        }
        this.#comment ||= new Comment(this);
        this.#comment.setInitialText(comment, richText);
        if (!this.annotationElementId) {
          return;
        }
        const storedData = this._uiManager.getAndRemoveDataFromAnnotationStorage(this.annotationElementId);
        if (storedData) {
          this.updateFromAnnotationLayer(storedData);
        }
      }
      get hasEditedComment() {
        return this.#comment?.hasBeenEdited();
      }
      get hasDeletedComment() {
        return this.#comment?.isDeleted();
      }
      get hasComment() {
        return !!this.#comment && !this.#comment.isEmpty() && !this.#comment.isDeleted();
      }
      async editComment(options) {
        this.#comment ||= new Comment(this);
        this.#comment.edit(options);
      }
      toggleComment(isSelected, visibility = void 0) {
        if (this.hasComment) {
          this._uiManager.toggleComment(this, isSelected, visibility);
        }
      }
      setSelectedCommentButton(selected) {
        this.#comment.setSelectedButton(selected);
      }
      addComment(serialized) {
        if (this.hasEditedComment) {
          const DEFAULT_POPUP_WIDTH = 180;
          const DEFAULT_POPUP_HEIGHT = 100;
          const [, , , trY] = serialized.rect;
          const [pageWidth] = this.pageDimensions;
          const [pageX] = this.pageTranslation;
          const blX = pageX + pageWidth + 1;
          const blY = trY - DEFAULT_POPUP_HEIGHT;
          const trX = blX + DEFAULT_POPUP_WIDTH;
          serialized.popup = {
            contents: this.comment.text,
            deleted: this.comment.deleted,
            rect: [blX, blY, trX, trY]
          };
        }
      }
      updateFromAnnotationLayer({
        popup: {
          contents,
          deleted
        }
      }) {
        this.#comment.data = deleted ? null : contents;
      }
      get parentBoundingClientRect() {
        return this.parent.boundingClientRect;
      }
      render() {
        const div = this.div = document.createElement("div");
        div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360);
        div.className = this.name;
        div.setAttribute("id", this.id);
        div.tabIndex = this.#disabled ? -1 : 0;
        div.setAttribute("role", "application");
        if (this.defaultL10nId) {
          div.setAttribute("data-l10n-id", this.defaultL10nId);
        }
        if (!this._isVisible) {
          div.classList.add("hidden");
        }
        this.setInForeground();
        this.#addFocusListeners();
        const [parentWidth, parentHeight] = this.parentDimensions;
        if (this.parentRotation % 180 !== 0) {
          div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;
          div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;
        }
        const [tx, ty] = this.getInitialTranslation();
        this.translate(tx, ty);
        bindEvents(this, div, ["keydown", "pointerdown", "dblclick"]);
        if (this.isResizable && this._uiManager._supportsPinchToZoom) {
          this.#touchManager ||= new TouchManager({
            container: div,
            isPinchingDisabled: () => !this.isSelected,
            onPinchStart: this.#touchPinchStartCallback.bind(this),
            onPinching: this.#touchPinchCallback.bind(this),
            onPinchEnd: this.#touchPinchEndCallback.bind(this),
            signal: this._uiManager._signal
          });
        }
        this.addStandaloneCommentButton();
        this._uiManager._editorUndoBar?.hide();
        return div;
      }
      #touchPinchStartCallback() {
        this.#savedDimensions = {
          savedX: this.x,
          savedY: this.y,
          savedWidth: this.width,
          savedHeight: this.height
        };
        this.#altText?.toggle(false);
        this.parent.togglePointerEvents(false);
      }
      #touchPinchCallback(_origin, prevDistance, distance) {
        const slowDownFactor = 0.7;
        let factor = slowDownFactor * (distance / prevDistance) + 1 - slowDownFactor;
        if (factor === 1) {
          return;
        }
        const rotationMatrix = this.#getRotationMatrix(this.rotation);
        const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];
        const [parentWidth, parentHeight] = this.parentDimensions;
        const savedX = this.x;
        const savedY = this.y;
        const savedWidth = this.width;
        const savedHeight = this.height;
        const minWidth = _AnnotationEditor.MIN_SIZE / parentWidth;
        const minHeight = _AnnotationEditor.MIN_SIZE / parentHeight;
        factor = Math.max(Math.min(factor, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);
        const newWidth = _AnnotationEditor._round(savedWidth * factor);
        const newHeight = _AnnotationEditor._round(savedHeight * factor);
        if (newWidth === savedWidth && newHeight === savedHeight) {
          return;
        }
        this.#initialRect ||= [savedX, savedY, savedWidth, savedHeight];
        const transfCenterPoint = transf(savedWidth / 2, savedHeight / 2);
        const centerX = _AnnotationEditor._round(savedX + transfCenterPoint[0]);
        const centerY = _AnnotationEditor._round(savedY + transfCenterPoint[1]);
        const newTransfCenterPoint = transf(newWidth / 2, newHeight / 2);
        this.x = centerX - newTransfCenterPoint[0];
        this.y = centerY - newTransfCenterPoint[1];
        this.width = newWidth;
        this.height = newHeight;
        this.setDims();
        this.fixAndSetPosition();
        this._onResizing();
      }
      #touchPinchEndCallback() {
        this.#altText?.toggle(true);
        this.parent.togglePointerEvents(true);
        this.#addResizeToUndoStack();
      }
      pointerdown(event) {
        const {
          isMac
        } = util_FeatureTest.platform;
        if (event.button !== 0 || event.ctrlKey && isMac) {
          event.preventDefault();
          return;
        }
        this.#hasBeenClicked = true;
        if (this._isDraggable) {
          this.#setUpDragSession(event);
          return;
        }
        this.#selectOnPointerEvent(event);
      }
      #selectOnPointerEvent(event) {
        const {
          isMac
        } = util_FeatureTest.platform;
        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {
          this.parent.toggleSelected(this);
        } else {
          this.parent.setSelected(this);
        }
      }
      #setUpDragSession(event) {
        const {
          isSelected
        } = this;
        this._uiManager.setUpDragSession();
        let hasDraggingStarted = false;
        const ac = new AbortController();
        const signal = this._uiManager.combinedSignal(ac);
        const opts = {
          capture: true,
          passive: false,
          signal
        };
        const cancelDrag = (e) => {
          ac.abort();
          this.#dragPointerId = null;
          this.#hasBeenClicked = false;
          if (!this._uiManager.endDragSession()) {
            this.#selectOnPointerEvent(e);
          }
          if (hasDraggingStarted) {
            this._onStopDragging();
          }
        };
        if (isSelected) {
          this.#prevDragX = event.clientX;
          this.#prevDragY = event.clientY;
          this.#dragPointerId = event.pointerId;
          this.#dragPointerType = event.pointerType;
          window.addEventListener("pointermove", (e) => {
            if (!hasDraggingStarted) {
              hasDraggingStarted = true;
              this._uiManager.toggleComment(this, true, false);
              this._onStartDragging();
            }
            const {
              clientX: x,
              clientY: y,
              pointerId
            } = e;
            if (pointerId !== this.#dragPointerId) {
              stopEvent(e);
              return;
            }
            const [tx, ty] = this.screenToPageTranslation(x - this.#prevDragX, y - this.#prevDragY);
            this.#prevDragX = x;
            this.#prevDragY = y;
            this._uiManager.dragSelectedEditors(tx, ty);
          }, opts);
          window.addEventListener("touchmove", stopEvent, opts);
          window.addEventListener("pointerdown", (e) => {
            if (e.pointerType === this.#dragPointerType) {
              if (this.#touchManager || e.isPrimary) {
                cancelDrag(e);
              }
            }
            stopEvent(e);
          }, opts);
        }
        const pointerUpCallback = (e) => {
          if (!this.#dragPointerId || this.#dragPointerId === e.pointerId) {
            cancelDrag(e);
            return;
          }
          stopEvent(e);
        };
        window.addEventListener("pointerup", pointerUpCallback, {
          signal
        });
        window.addEventListener("blur", pointerUpCallback, {
          signal
        });
      }
      _onStartDragging() {
      }
      _onStopDragging() {
      }
      moveInDOM() {
        if (this.#moveInDOMTimeout) {
          clearTimeout(this.#moveInDOMTimeout);
        }
        this.#moveInDOMTimeout = setTimeout(() => {
          this.#moveInDOMTimeout = null;
          this.parent?.moveEditorInDOM(this);
        }, 0);
      }
      _setParentAndPosition(parent, x, y) {
        parent.changeParent(this);
        this.x = x;
        this.y = y;
        this.fixAndSetPosition();
        this._onTranslated();
      }
      getRect(tx, ty, rotation = this.rotation) {
        const scale = this.parentScale;
        const [pageWidth, pageHeight] = this.pageDimensions;
        const [pageX, pageY] = this.pageTranslation;
        const shiftX = tx / scale;
        const shiftY = ty / scale;
        const x = this.x * pageWidth;
        const y = this.y * pageHeight;
        const width = this.width * pageWidth;
        const height = this.height * pageHeight;
        switch (rotation) {
          case 0:
            return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];
          case 90:
            return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];
          case 180:
            return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];
          case 270:
            return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];
          default:
            throw new Error("Invalid rotation");
        }
      }
      getRectInCurrentCoords(rect, pageHeight) {
        const [x1, y1, x2, y2] = rect;
        const width = x2 - x1;
        const height = y2 - y1;
        switch (this.rotation) {
          case 0:
            return [x1, pageHeight - y2, width, height];
          case 90:
            return [x1, pageHeight - y1, height, width];
          case 180:
            return [x2, pageHeight - y1, width, height];
          case 270:
            return [x2, pageHeight - y2, height, width];
          default:
            throw new Error("Invalid rotation");
        }
      }
      getPDFRect() {
        return this.getRect(0, 0);
      }
      getNonHCMColor() {
        return this.color && _AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
      }
      onUpdatedColor() {
        this.#comment?.onUpdatedColor();
      }
      getData() {
        const {
          comment: {
            text: str,
            color,
            date,
            opacity,
            deleted,
            richText
          },
          uid: id,
          pageIndex,
          creationDate,
          modificationDate
        } = this;
        return {
          id,
          pageIndex,
          rect: this.getPDFRect(),
          richText,
          contentsObj: {
            str
          },
          creationDate,
          modificationDate: date || modificationDate,
          popupRef: !deleted,
          color,
          opacity
        };
      }
      onceAdded(focus) {
      }
      isEmpty() {
        return false;
      }
      enableEditMode() {
        if (this.isInEditMode()) {
          return false;
        }
        this.parent.setEditingState(false);
        this.#isInEditMode = true;
        return true;
      }
      disableEditMode() {
        if (!this.isInEditMode()) {
          return false;
        }
        this.parent.setEditingState(true);
        this.#isInEditMode = false;
        return true;
      }
      isInEditMode() {
        return this.#isInEditMode;
      }
      shouldGetKeyboardEvents() {
        return this.#isResizerEnabledForKeyboard;
      }
      needsToBeRebuilt() {
        return this.div && !this.isAttachedToDOM;
      }
      get isOnScreen() {
        const {
          top,
          left,
          bottom,
          right
        } = this.getClientDimensions();
        const {
          innerHeight,
          innerWidth
        } = window;
        return left < innerWidth && right > 0 && top < innerHeight && bottom > 0;
      }
      #addFocusListeners() {
        if (this.#focusAC || !this.div) {
          return;
        }
        this.#focusAC = new AbortController();
        const signal = this._uiManager.combinedSignal(this.#focusAC);
        this.div.addEventListener("focusin", this.focusin.bind(this), {
          signal
        });
        this.div.addEventListener("focusout", this.focusout.bind(this), {
          signal
        });
      }
      rebuild() {
        this.#addFocusListeners();
      }
      rotate(_angle) {
      }
      resize() {
      }
      serializeDeleted() {
        return {
          id: this.annotationElementId,
          deleted: true,
          pageIndex: this.pageIndex,
          popupRef: this._initialData?.popupRef || ""
        };
      }
      serialize(isForCopying = false, context = null) {
        return {
          annotationType: this.mode,
          pageIndex: this.pageIndex,
          rect: this.getPDFRect(),
          rotation: this.rotation,
          structTreeParentId: this._structTreeParentId,
          popupRef: this._initialData?.popupRef || ""
        };
      }
      static async deserialize(data, parent, uiManager) {
        const editor = new this.prototype.constructor({
          parent,
          id: parent.getNextId(),
          uiManager,
          annotationElementId: data.annotationElementId,
          creationDate: data.creationDate,
          modificationDate: data.modificationDate
        });
        editor.rotation = data.rotation;
        editor.#accessibilityData = data.accessibilityData;
        editor._isCopy = data.isCopy || false;
        const [pageWidth, pageHeight] = editor.pageDimensions;
        const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);
        editor.x = x / pageWidth;
        editor.y = y / pageHeight;
        editor.width = width / pageWidth;
        editor.height = height / pageHeight;
        return editor;
      }
      get hasBeenModified() {
        return !!this.annotationElementId && (this.deleted || this.serialize() !== null);
      }
      remove() {
        this.#focusAC?.abort();
        this.#focusAC = null;
        if (!this.isEmpty()) {
          this.commit();
        }
        if (this.parent) {
          this.parent.remove(this);
        } else {
          this._uiManager.removeEditor(this);
        }
        if (this.#moveInDOMTimeout) {
          clearTimeout(this.#moveInDOMTimeout);
          this.#moveInDOMTimeout = null;
        }
        this.#stopResizing();
        this.removeEditToolbar();
        if (this.#telemetryTimeouts) {
          for (const timeout of this.#telemetryTimeouts.values()) {
            clearTimeout(timeout);
          }
          this.#telemetryTimeouts = null;
        }
        this.parent = null;
        this.#touchManager?.destroy();
        this.#touchManager = null;
      }
      get isResizable() {
        return false;
      }
      makeResizable() {
        if (this.isResizable) {
          this.#createResizers();
          this.#resizersDiv.classList.remove("hidden");
        }
      }
      get toolbarPosition() {
        return null;
      }
      get commentButtonPosition() {
        return this._uiManager.direction === "ltr" ? [1, 0] : [0, 0];
      }
      get commentButtonPositionInPage() {
        const {
          commentButtonPosition: [posX, posY]
        } = this;
        const [blX, blY, trX, trY] = this.getPDFRect();
        return [_AnnotationEditor._round(blX + (trX - blX) * posX), _AnnotationEditor._round(blY + (trY - blY) * (1 - posY))];
      }
      get commentButtonColor() {
        return this._uiManager.makeCommentColor(this.getNonHCMColor(), this.opacity);
      }
      get commentPopupPosition() {
        return this.#comment.commentPopupPositionInLayer;
      }
      set commentPopupPosition(pos) {
        this.#comment.commentPopupPositionInLayer = pos;
      }
      hasDefaultPopupPosition() {
        return this.#comment.hasDefaultPopupPosition();
      }
      get commentButtonWidth() {
        return this.#comment.commentButtonWidth;
      }
      get elementBeforePopup() {
        return this.div;
      }
      setCommentButtonStates(options) {
        this.#comment.setCommentButtonStates(options);
      }
      keydown(event) {
        if (!this.isResizable || event.target !== this.div || event.key !== "Enter") {
          return;
        }
        this._uiManager.setSelected(this);
        this.#savedDimensions = {
          savedX: this.x,
          savedY: this.y,
          savedWidth: this.width,
          savedHeight: this.height
        };
        const children = this.#resizersDiv.children;
        if (!this.#allResizerDivs) {
          this.#allResizerDivs = Array.from(children);
          const boundResizerKeydown = this.#resizerKeydown.bind(this);
          const boundResizerBlur = this.#resizerBlur.bind(this);
          const signal = this._uiManager._signal;
          for (const div of this.#allResizerDivs) {
            const name = div.getAttribute("data-resizer-name");
            div.setAttribute("role", "spinbutton");
            div.addEventListener("keydown", boundResizerKeydown, {
              signal
            });
            div.addEventListener("blur", boundResizerBlur, {
              signal
            });
            div.addEventListener("focus", this.#resizerFocus.bind(this, name), {
              signal
            });
            div.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[name]);
          }
        }
        const first2 = this.#allResizerDivs[0];
        let firstPosition = 0;
        for (const div of children) {
          if (div === first2) {
            break;
          }
          firstPosition++;
        }
        const nextFirstPosition = (360 - this.rotation + this.parentRotation) % 360 / 90 * (this.#allResizerDivs.length / 4);
        if (nextFirstPosition !== firstPosition) {
          if (nextFirstPosition < firstPosition) {
            for (let i2 = 0; i2 < firstPosition - nextFirstPosition; i2++) {
              this.#resizersDiv.append(this.#resizersDiv.firstChild);
            }
          } else if (nextFirstPosition > firstPosition) {
            for (let i2 = 0; i2 < nextFirstPosition - firstPosition; i2++) {
              this.#resizersDiv.firstChild.before(this.#resizersDiv.lastChild);
            }
          }
          let i = 0;
          for (const child of children) {
            const div = this.#allResizerDivs[i++];
            const name = div.getAttribute("data-resizer-name");
            child.setAttribute("data-l10n-id", _AnnotationEditor._l10nResizer[name]);
          }
        }
        this.#setResizerTabIndex(0);
        this.#isResizerEnabledForKeyboard = true;
        this.#resizersDiv.firstChild.focus({
          focusVisible: true
        });
        event.preventDefault();
        event.stopImmediatePropagation();
      }
      #resizerKeydown(event) {
        _AnnotationEditor._resizerKeyboardManager.exec(this, event);
      }
      #resizerBlur(event) {
        if (this.#isResizerEnabledForKeyboard && event.relatedTarget?.parentNode !== this.#resizersDiv) {
          this.#stopResizing();
        }
      }
      #resizerFocus(name) {
        this.#focusedResizerName = this.#isResizerEnabledForKeyboard ? name : "";
      }
      #setResizerTabIndex(value) {
        if (!this.#allResizerDivs) {
          return;
        }
        for (const div of this.#allResizerDivs) {
          div.tabIndex = value;
        }
      }
      _resizeWithKeyboard(x, y) {
        if (!this.#isResizerEnabledForKeyboard) {
          return;
        }
        this.#resizerPointermove(this.#focusedResizerName, {
          deltaX: x,
          deltaY: y,
          fromKeyboard: true
        });
      }
      #stopResizing() {
        this.#isResizerEnabledForKeyboard = false;
        this.#setResizerTabIndex(-1);
        this.#addResizeToUndoStack();
      }
      _stopResizingWithKeyboard() {
        this.#stopResizing();
        this.div.focus();
      }
      select() {
        if (this.isSelected && this._editToolbar) {
          this._editToolbar.show();
          return;
        }
        this.isSelected = true;
        this.makeResizable();
        this.div?.classList.add("selectedEditor");
        if (!this._editToolbar) {
          this.addEditToolbar().then(() => {
            if (this.div?.classList.contains("selectedEditor")) {
              this._editToolbar?.show();
            }
          });
          return;
        }
        this._editToolbar?.show();
        this.#altText?.toggleAltTextBadge(false);
      }
      focus() {
        if (this.div && !this.div.contains(document.activeElement)) {
          setTimeout(() => this.div?.focus({
            preventScroll: true
          }), 0);
        }
      }
      unselect() {
        if (!this.isSelected) {
          return;
        }
        this.isSelected = false;
        this.#resizersDiv?.classList.add("hidden");
        this.div?.classList.remove("selectedEditor");
        if (this.div?.contains(document.activeElement)) {
          this._uiManager.currentLayer.div.focus({
            preventScroll: true
          });
        }
        this._editToolbar?.hide();
        this.#altText?.toggleAltTextBadge(true);
        if (this.hasComment) {
          this._uiManager.toggleComment(this, false, false);
        }
      }
      updateParams(type, value) {
      }
      disableEditing() {
      }
      enableEditing() {
      }
      get canChangeContent() {
        return false;
      }
      enterInEditMode() {
        if (!this.canChangeContent) {
          return;
        }
        this.enableEditMode();
        this.div.focus();
      }
      dblclick(event) {
        if (event.target.nodeName === "BUTTON") {
          return;
        }
        this.enterInEditMode();
        this.parent.updateToolbar({
          mode: this.constructor._editorType,
          editId: this.id
        });
      }
      getElementForAltText() {
        return this.div;
      }
      get contentDiv() {
        return this.div;
      }
      get isEditing() {
        return this.#isEditing;
      }
      set isEditing(value) {
        this.#isEditing = value;
        if (!this.parent) {
          return;
        }
        if (value) {
          this.parent.setSelected(this);
          this.parent.setActiveEditor(this);
        } else {
          this.parent.setActiveEditor(null);
        }
      }
      static get MIN_SIZE() {
        return 16;
      }
      static canCreateNewEmptyEditor() {
        return true;
      }
      get telemetryInitialData() {
        return {
          action: "added"
        };
      }
      get telemetryFinalData() {
        return null;
      }
      _reportTelemetry(data, mustWait = false) {
        if (mustWait) {
          this.#telemetryTimeouts ||= /* @__PURE__ */ new Map();
          const {
            action
          } = data;
          let timeout = this.#telemetryTimeouts.get(action);
          if (timeout) {
            clearTimeout(timeout);
          }
          timeout = setTimeout(() => {
            this._reportTelemetry(data);
            this.#telemetryTimeouts.delete(action);
            if (this.#telemetryTimeouts.size === 0) {
              this.#telemetryTimeouts = null;
            }
          }, _AnnotationEditor._telemetryTimeout);
          this.#telemetryTimeouts.set(action, timeout);
          return;
        }
        data.type ||= this.editorType;
        this._uiManager._eventBus.dispatch("reporttelemetry", {
          source: this,
          details: {
            type: "editing",
            data
          }
        });
      }
      show(visible = this._isVisible) {
        this.div.classList.toggle("hidden", !visible);
        this._isVisible = visible;
      }
      enable() {
        if (this.div) {
          this.div.tabIndex = 0;
        }
        this.#disabled = false;
      }
      disable() {
        if (this.div) {
          this.div.tabIndex = -1;
        }
        this.#disabled = true;
      }
      updateFakeAnnotationElement(annotationLayer) {
        if (!this.#fakeAnnotation && !this.deleted) {
          this.#fakeAnnotation = annotationLayer.addFakeAnnotation(this);
          return;
        }
        if (this.deleted) {
          this.#fakeAnnotation.remove();
          this.#fakeAnnotation = null;
          return;
        }
        if (this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized) {
          this.#fakeAnnotation.updateEdited({
            rect: this.getPDFRect(),
            popup: this.comment
          });
        }
      }
      renderAnnotationElement(annotation) {
        if (this.deleted) {
          annotation.hide();
          return null;
        }
        let content = annotation.container.querySelector(".annotationContent");
        if (!content) {
          content = document.createElement("div");
          content.classList.add("annotationContent", this.editorType);
          annotation.container.prepend(content);
        } else if (content.nodeName === "CANVAS") {
          const canvas = content;
          content = document.createElement("div");
          content.classList.add("annotationContent", this.editorType);
          canvas.before(content);
        }
        return content;
      }
      resetAnnotationElement(annotation) {
        const {
          firstChild
        } = annotation.container;
        if (firstChild?.nodeName === "DIV" && firstChild.classList.contains("annotationContent")) {
          firstChild.remove();
        }
      }
    };
    FakeEditor = class extends AnnotationEditor {
      constructor(params) {
        super(params);
        this.annotationElementId = params.annotationElementId;
        this.deleted = true;
      }
      serialize() {
        return this.serializeDeleted();
      }
    };
    SEED = 3285377520;
    MASK_HIGH = 4294901760;
    MASK_LOW = 65535;
    MurmurHash3_64 = class {
      constructor(seed) {
        this.h1 = seed ? seed & 4294967295 : SEED;
        this.h2 = seed ? seed & 4294967295 : SEED;
      }
      update(input) {
        let data, length;
        if (typeof input === "string") {
          data = new Uint8Array(input.length * 2);
          length = 0;
          for (let i = 0, ii = input.length; i < ii; i++) {
            const code = input.charCodeAt(i);
            if (code <= 255) {
              data[length++] = code;
            } else {
              data[length++] = code >>> 8;
              data[length++] = code & 255;
            }
          }
        } else if (ArrayBuffer.isView(input)) {
          data = input.slice();
          length = data.byteLength;
        } else {
          throw new Error("Invalid data format, must be a string or TypedArray.");
        }
        const blockCounts = length >> 2;
        const tailLength = length - blockCounts * 4;
        const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);
        let k1 = 0, k2 = 0;
        let h1 = this.h1, h2 = this.h2;
        const C1 = 3432918353, C2 = 461845907;
        const C1_LOW = C1 & MASK_LOW, C2_LOW = C2 & MASK_LOW;
        for (let i = 0; i < blockCounts; i++) {
          if (i & 1) {
            k1 = dataUint32[i];
            k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
            h1 ^= k1;
            h1 = h1 << 13 | h1 >>> 19;
            h1 = h1 * 5 + 3864292196;
          } else {
            k2 = dataUint32[i];
            k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;
            k2 = k2 << 15 | k2 >>> 17;
            k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;
            h2 ^= k2;
            h2 = h2 << 13 | h2 >>> 19;
            h2 = h2 * 5 + 3864292196;
          }
        }
        k1 = 0;
        switch (tailLength) {
          case 3:
            k1 ^= data[blockCounts * 4 + 2] << 16;
          case 2:
            k1 ^= data[blockCounts * 4 + 1] << 8;
          case 1:
            k1 ^= data[blockCounts * 4];
            k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;
            k1 = k1 << 15 | k1 >>> 17;
            k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;
            if (blockCounts & 1) {
              h1 ^= k1;
            } else {
              h2 ^= k1;
            }
        }
        this.h1 = h1;
        this.h2 = h2;
      }
      hexdigest() {
        let h1 = this.h1, h2 = this.h2;
        h1 ^= h2 >>> 1;
        h1 = h1 * 3981806797 & MASK_HIGH | h1 * 36045 & MASK_LOW;
        h2 = h2 * 4283543511 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 2950163797 & MASK_HIGH) >>> 16;
        h1 ^= h2 >>> 1;
        h1 = h1 * 444984403 & MASK_HIGH | h1 * 60499 & MASK_LOW;
        h2 = h2 * 3301882366 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 3120437893 & MASK_HIGH) >>> 16;
        h1 ^= h2 >>> 1;
        return (h1 >>> 0).toString(16).padStart(8, "0") + (h2 >>> 0).toString(16).padStart(8, "0");
      }
    };
    SerializableEmpty = Object.freeze({
      map: null,
      hash: "",
      transfer: void 0
    });
    AnnotationStorage = class {
      #modified = false;
      #modifiedIds = null;
      #editorsMap = null;
      #storage = /* @__PURE__ */ new Map();
      constructor() {
        this.onSetModified = null;
        this.onResetModified = null;
        this.onAnnotationEditor = null;
      }
      getValue(key, defaultValue) {
        const value = this.#storage.get(key);
        if (value === void 0) {
          return defaultValue;
        }
        return Object.assign(defaultValue, value);
      }
      getRawValue(key) {
        return this.#storage.get(key);
      }
      remove(key) {
        const storedValue = this.#storage.get(key);
        if (storedValue === void 0) {
          return;
        }
        if (storedValue instanceof AnnotationEditor) {
          this.#editorsMap.delete(storedValue.annotationElementId);
        }
        this.#storage.delete(key);
        if (this.#storage.size === 0) {
          this.resetModified();
        }
        if (typeof this.onAnnotationEditor === "function") {
          for (const value of this.#storage.values()) {
            if (value instanceof AnnotationEditor) {
              return;
            }
          }
          this.onAnnotationEditor(null);
        }
      }
      setValue(key, value) {
        const obj2 = this.#storage.get(key);
        let modified = false;
        if (obj2 !== void 0) {
          for (const [entry, val] of Object.entries(value)) {
            if (obj2[entry] !== val) {
              modified = true;
              obj2[entry] = val;
            }
          }
        } else {
          modified = true;
          this.#storage.set(key, value);
        }
        if (modified) {
          this.#setModified();
        }
        if (value instanceof AnnotationEditor) {
          (this.#editorsMap ||= /* @__PURE__ */ new Map()).set(value.annotationElementId, value);
          if (typeof this.onAnnotationEditor === "function") {
            this.onAnnotationEditor(value.constructor._type);
          }
        }
      }
      has(key) {
        return this.#storage.has(key);
      }
      get size() {
        return this.#storage.size;
      }
      #setModified() {
        if (!this.#modified) {
          this.#modified = true;
          if (typeof this.onSetModified === "function") {
            this.onSetModified();
          }
        }
      }
      resetModified() {
        if (this.#modified) {
          this.#modified = false;
          if (typeof this.onResetModified === "function") {
            this.onResetModified();
          }
        }
      }
      get print() {
        return new PrintAnnotationStorage(this);
      }
      get serializable() {
        if (this.#storage.size === 0) {
          return SerializableEmpty;
        }
        const map2 = /* @__PURE__ */ new Map(), hash = new MurmurHash3_64(), transfer = [];
        const context = /* @__PURE__ */ Object.create(null);
        let hasBitmap = false;
        for (const [key, val] of this.#storage) {
          const serialized = val instanceof AnnotationEditor ? val.serialize(false, context) : val;
          if (serialized) {
            map2.set(key, serialized);
            hash.update(`${key}:${JSON.stringify(serialized)}`);
            hasBitmap ||= !!serialized.bitmap;
          }
        }
        if (hasBitmap) {
          for (const value of map2.values()) {
            if (value.bitmap) {
              transfer.push(value.bitmap);
            }
          }
        }
        return map2.size > 0 ? {
          map: map2,
          hash: hash.hexdigest(),
          transfer
        } : SerializableEmpty;
      }
      get editorStats() {
        let stats = null;
        const typeToEditor = /* @__PURE__ */ new Map();
        let numberOfEditedComments = 0;
        let numberOfDeletedComments = 0;
        for (const value of this.#storage.values()) {
          if (!(value instanceof AnnotationEditor)) {
            if (value.popup) {
              if (value.popup.deleted) {
                numberOfDeletedComments += 1;
              } else {
                numberOfEditedComments += 1;
              }
            }
            continue;
          }
          if (value.isCommentDeleted) {
            numberOfDeletedComments += 1;
          } else if (value.hasEditedComment) {
            numberOfEditedComments += 1;
          }
          const editorStats = value.telemetryFinalData;
          if (!editorStats) {
            continue;
          }
          const {
            type
          } = editorStats;
          if (!typeToEditor.has(type)) {
            typeToEditor.set(type, Object.getPrototypeOf(value).constructor);
          }
          stats ||= /* @__PURE__ */ Object.create(null);
          const map2 = stats[type] ||= /* @__PURE__ */ new Map();
          for (const [key, val] of Object.entries(editorStats)) {
            if (key === "type") {
              continue;
            }
            let counters = map2.get(key);
            if (!counters) {
              counters = /* @__PURE__ */ new Map();
              map2.set(key, counters);
            }
            const count = counters.get(val) ?? 0;
            counters.set(val, count + 1);
          }
        }
        if (numberOfDeletedComments > 0 || numberOfEditedComments > 0) {
          stats ||= /* @__PURE__ */ Object.create(null);
          stats.comments = {
            deleted: numberOfDeletedComments,
            edited: numberOfEditedComments
          };
        }
        if (!stats) {
          return null;
        }
        for (const [type, editor] of typeToEditor) {
          stats[type] = editor.computeTelemetryFinalData(stats[type]);
        }
        return stats;
      }
      resetModifiedIds() {
        this.#modifiedIds = null;
      }
      updateEditor(annotationId, data) {
        const value = this.#editorsMap?.get(annotationId);
        if (value) {
          value.updateFromAnnotationLayer(data);
          return true;
        }
        return false;
      }
      getEditor(annotationId) {
        return this.#editorsMap?.get(annotationId) || null;
      }
      get modifiedIds() {
        if (this.#modifiedIds) {
          return this.#modifiedIds;
        }
        const ids = [];
        if (this.#editorsMap) {
          for (const value of this.#editorsMap.values()) {
            if (!value.serialize()) {
              continue;
            }
            ids.push(value.annotationElementId);
          }
        }
        return this.#modifiedIds = {
          ids: new Set(ids),
          hash: ids.join(",")
        };
      }
      [Symbol.iterator]() {
        return this.#storage.entries();
      }
    };
    PrintAnnotationStorage = class extends AnnotationStorage {
      #serializable;
      constructor(parent) {
        super();
        const {
          map: map2,
          hash,
          transfer
        } = parent.serializable;
        const clone2 = structuredClone(map2, transfer ? {
          transfer
        } : null);
        this.#serializable = {
          map: clone2,
          hash,
          transfer
        };
      }
      get print() {
        unreachable("Should not call PrintAnnotationStorage.print");
      }
      get serializable() {
        return this.#serializable;
      }
      get modifiedIds() {
        return shadow(this, "modifiedIds", {
          ids: /* @__PURE__ */ new Set(),
          hash: ""
        });
      }
    };
    FontLoader = class {
      #systemFonts = /* @__PURE__ */ new Set();
      constructor({
        ownerDocument = globalThis.document,
        styleElement = null
      }) {
        this._document = ownerDocument;
        this.nativeFontFaces = /* @__PURE__ */ new Set();
        this.styleElement = null;
        this.loadingRequests = [];
        this.loadTestFontId = 0;
      }
      addNativeFontFace(nativeFontFace) {
        this.nativeFontFaces.add(nativeFontFace);
        this._document.fonts.add(nativeFontFace);
      }
      removeNativeFontFace(nativeFontFace) {
        this.nativeFontFaces.delete(nativeFontFace);
        this._document.fonts.delete(nativeFontFace);
      }
      insertRule(rule) {
        if (!this.styleElement) {
          this.styleElement = this._document.createElement("style");
          this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement);
        }
        const styleSheet = this.styleElement.sheet;
        styleSheet.insertRule(rule, styleSheet.cssRules.length);
      }
      clear() {
        for (const nativeFontFace of this.nativeFontFaces) {
          this._document.fonts.delete(nativeFontFace);
        }
        this.nativeFontFaces.clear();
        this.#systemFonts.clear();
        if (this.styleElement) {
          this.styleElement.remove();
          this.styleElement = null;
        }
      }
      async loadSystemFont({
        systemFontInfo: info2,
        disableFontFace,
        _inspectFont
      }) {
        if (!info2 || this.#systemFonts.has(info2.loadedName)) {
          return;
        }
        assert(!disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set.");
        if (this.isFontLoadingAPISupported) {
          const {
            loadedName,
            src,
            style
          } = info2;
          const fontFace = new FontFace(loadedName, src, style);
          this.addNativeFontFace(fontFace);
          try {
            await fontFace.load();
            this.#systemFonts.add(loadedName);
            _inspectFont?.(info2);
          } catch {
            warn(`Cannot load system font: ${info2.baseFontName}, installing it could help to improve PDF rendering.`);
            this.removeNativeFontFace(fontFace);
          }
          return;
        }
        unreachable("Not implemented: loadSystemFont without the Font Loading API.");
      }
      async bind(font) {
        if (font.attached || font.missingFile && !font.systemFontInfo) {
          return;
        }
        font.attached = true;
        if (font.systemFontInfo) {
          await this.loadSystemFont(font);
          return;
        }
        if (this.isFontLoadingAPISupported) {
          const nativeFontFace = font.createNativeFontFace();
          if (nativeFontFace) {
            this.addNativeFontFace(nativeFontFace);
            try {
              await nativeFontFace.loaded;
            } catch (ex) {
              warn(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);
              font.disableFontFace = true;
              throw ex;
            }
          }
          return;
        }
        const rule = font.createFontFaceRule();
        if (rule) {
          this.insertRule(rule);
          if (this.isSyncFontLoadingSupported) {
            return;
          }
          await new Promise((resolve) => {
            const request = this._queueLoadingCallback(resolve);
            this._prepareFontLoadEvent(font, request);
          });
        }
      }
      get isFontLoadingAPISupported() {
        const hasFonts = !!this._document?.fonts;
        return shadow(this, "isFontLoadingAPISupported", hasFonts);
      }
      get isSyncFontLoadingSupported() {
        return shadow(this, "isSyncFontLoadingSupported", isNodeJS || util_FeatureTest.platform.isFirefox);
      }
      _queueLoadingCallback(callback) {
        function completeRequest() {
          assert(!request.done, "completeRequest() cannot be called twice.");
          request.done = true;
          while (loadingRequests.length > 0 && loadingRequests[0].done) {
            const otherRequest = loadingRequests.shift();
            setTimeout(otherRequest.callback, 0);
          }
        }
        const {
          loadingRequests
        } = this;
        const request = {
          done: false,
          complete: completeRequest,
          callback
        };
        loadingRequests.push(request);
        return request;
      }
      get _loadTestFont() {
        const testFont = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==");
        return shadow(this, "_loadTestFont", testFont);
      }
      _prepareFontLoadEvent(font, request) {
        function int32(data2, offset) {
          return data2.charCodeAt(offset) << 24 | data2.charCodeAt(offset + 1) << 16 | data2.charCodeAt(offset + 2) << 8 | data2.charCodeAt(offset + 3) & 255;
        }
        function spliceString(s, offset, remove, insert) {
          const chunk1 = s.substring(0, offset);
          const chunk2 = s.substring(offset + remove);
          return chunk1 + insert + chunk2;
        }
        let i, ii;
        const canvas = this._document.createElement("canvas");
        canvas.width = 1;
        canvas.height = 1;
        const ctx = canvas.getContext("2d");
        let called = 0;
        function isFontReady(name, callback) {
          if (++called > 30) {
            warn("Load test font never loaded.");
            callback();
            return;
          }
          ctx.font = "30px " + name;
          ctx.fillText(".", 0, 20);
          const imageData = ctx.getImageData(0, 0, 1, 1);
          if (imageData.data[3] > 0) {
            callback();
            return;
          }
          setTimeout(isFontReady.bind(null, name, callback));
        }
        const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;
        let data = this._loadTestFont;
        const COMMENT_OFFSET = 976;
        data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);
        const CFF_CHECKSUM_OFFSET = 16;
        const XXXX_VALUE = 1482184792;
        let checksum = int32(data, CFF_CHECKSUM_OFFSET);
        for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {
          checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;
        }
        if (i < loadTestFontId.length) {
          checksum = checksum - XXXX_VALUE + int32(loadTestFontId + "XXX", i) | 0;
        }
        data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, string32(checksum));
        const url = `url(data:font/opentype;base64,${btoa(data)});`;
        const rule = `@font-face {font-family:"${loadTestFontId}";src:${url}}`;
        this.insertRule(rule);
        const div = this._document.createElement("div");
        div.style.visibility = "hidden";
        div.style.width = div.style.height = "10px";
        div.style.position = "absolute";
        div.style.top = div.style.left = "0px";
        for (const name of [font.loadedName, loadTestFontId]) {
          const span = this._document.createElement("span");
          span.textContent = "Hi";
          span.style.fontFamily = name;
          div.append(span);
        }
        this._document.body.append(div);
        isFontReady(loadTestFontId, () => {
          div.remove();
          request.complete();
        });
      }
    };
    FontFaceObject = class {
      #fontData;
      constructor(translatedData, inspectFont = null, extra, charProcOperatorList) {
        this.compiledGlyphs = /* @__PURE__ */ Object.create(null);
        this.#fontData = translatedData;
        this._inspectFont = inspectFont;
        if (extra) {
          Object.assign(this, extra);
        }
        if (charProcOperatorList) {
          this.charProcOperatorList = charProcOperatorList;
        }
      }
      createNativeFontFace() {
        if (!this.data || this.disableFontFace) {
          return null;
        }
        let nativeFontFace;
        if (!this.cssFontInfo) {
          nativeFontFace = new FontFace(this.loadedName, this.data, {});
        } else {
          const css = {
            weight: this.cssFontInfo.fontWeight
          };
          if (this.cssFontInfo.italicAngle) {
            css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;
          }
          nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);
        }
        this._inspectFont?.(this);
        return nativeFontFace;
      }
      createFontFaceRule() {
        if (!this.data || this.disableFontFace) {
          return null;
        }
        const url = `url(data:${this.mimetype};base64,${toBase64Util(this.data)});`;
        let rule;
        if (!this.cssFontInfo) {
          rule = `@font-face {font-family:"${this.loadedName}";src:${url}}`;
        } else {
          let css = `font-weight: ${this.cssFontInfo.fontWeight};`;
          if (this.cssFontInfo.italicAngle) {
            css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;
          }
          rule = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${css}src:${url}}`;
        }
        this._inspectFont?.(this, url);
        return rule;
      }
      getPathGenerator(objs, character) {
        if (this.compiledGlyphs[character] !== void 0) {
          return this.compiledGlyphs[character];
        }
        const objId = this.loadedName + "_path_" + character;
        let cmds;
        try {
          cmds = objs.get(objId);
        } catch (ex) {
          warn(`getPathGenerator - ignoring character: "${ex}".`);
        }
        const path = new Path2D(cmds || "");
        if (!this.fontExtraProperties) {
          objs.delete(objId);
        }
        return this.compiledGlyphs[character] = path;
      }
      get black() {
        return this.#fontData.black;
      }
      get bold() {
        return this.#fontData.bold;
      }
      get disableFontFace() {
        return this.#fontData.disableFontFace ?? false;
      }
      get fontExtraProperties() {
        return this.#fontData.fontExtraProperties ?? false;
      }
      get isInvalidPDFjsFont() {
        return this.#fontData.isInvalidPDFjsFont;
      }
      get isType3Font() {
        return this.#fontData.isType3Font;
      }
      get italic() {
        return this.#fontData.italic;
      }
      get missingFile() {
        return this.#fontData.missingFile;
      }
      get remeasure() {
        return this.#fontData.remeasure;
      }
      get vertical() {
        return this.#fontData.vertical;
      }
      get ascent() {
        return this.#fontData.ascent;
      }
      get defaultWidth() {
        return this.#fontData.defaultWidth;
      }
      get descent() {
        return this.#fontData.descent;
      }
      get bbox() {
        return this.#fontData.bbox;
      }
      get fontMatrix() {
        return this.#fontData.fontMatrix;
      }
      get fallbackName() {
        return this.#fontData.fallbackName;
      }
      get loadedName() {
        return this.#fontData.loadedName;
      }
      get mimetype() {
        return this.#fontData.mimetype;
      }
      get name() {
        return this.#fontData.name;
      }
      get data() {
        return this.#fontData.data;
      }
      clearData() {
        this.#fontData.clearData();
      }
      get cssFontInfo() {
        return this.#fontData.cssFontInfo;
      }
      get systemFontInfo() {
        return this.#fontData.systemFontInfo;
      }
      get defaultVMetrics() {
        return this.#fontData.defaultVMetrics;
      }
    };
    isRefProxy = (v) => typeof v === "object" && Number.isInteger(v?.num) && v.num >= 0 && Number.isInteger(v?.gen) && v.gen >= 0;
    isNameProxy = (v) => typeof v === "object" && typeof v?.name === "string";
    isValidExplicitDest = _isValidExplicitDest.bind(null, isRefProxy, isNameProxy);
    LoopbackPort = class {
      #listeners = /* @__PURE__ */ new Map();
      #deferred = Promise.resolve();
      postMessage(obj2, transfer) {
        const event = {
          data: structuredClone(obj2, transfer ? {
            transfer
          } : null)
        };
        this.#deferred.then(() => {
          for (const [listener] of this.#listeners) {
            listener.call(this, event);
          }
        });
      }
      addEventListener(name, listener, options = null) {
        let rmAbort = null;
        if (options?.signal instanceof AbortSignal) {
          const {
            signal
          } = options;
          if (signal.aborted) {
            warn("LoopbackPort - cannot use an `aborted` signal.");
            return;
          }
          const onAbort = () => this.removeEventListener(name, listener);
          rmAbort = () => signal.removeEventListener("abort", onAbort);
          signal.addEventListener("abort", onAbort);
        }
        this.#listeners.set(listener, rmAbort);
      }
      removeEventListener(name, listener) {
        const rmAbort = this.#listeners.get(listener);
        rmAbort?.();
        this.#listeners.delete(listener);
      }
      terminate() {
        for (const [, rmAbort] of this.#listeners) {
          rmAbort?.();
        }
        this.#listeners.clear();
      }
    };
    CallbackKind = {
      DATA: 1,
      ERROR: 2
    };
    StreamKind = {
      CANCEL: 1,
      CANCEL_COMPLETE: 2,
      CLOSE: 3,
      ENQUEUE: 4,
      ERROR: 5,
      PULL: 6,
      PULL_COMPLETE: 7,
      START_COMPLETE: 8
    };
    MessageHandler = class {
      #messageAC = new AbortController();
      constructor(sourceName, targetName, comObj) {
        this.sourceName = sourceName;
        this.targetName = targetName;
        this.comObj = comObj;
        this.callbackId = 1;
        this.streamId = 1;
        this.streamSinks = /* @__PURE__ */ Object.create(null);
        this.streamControllers = /* @__PURE__ */ Object.create(null);
        this.callbackCapabilities = /* @__PURE__ */ Object.create(null);
        this.actionHandler = /* @__PURE__ */ Object.create(null);
        comObj.addEventListener("message", this.#onMessage.bind(this), {
          signal: this.#messageAC.signal
        });
      }
      #onMessage({
        data
      }) {
        if (data.targetName !== this.sourceName) {
          return;
        }
        if (data.stream) {
          this.#processStreamMessage(data);
          return;
        }
        if (data.callback) {
          const callbackId = data.callbackId;
          const capability = this.callbackCapabilities[callbackId];
          if (!capability) {
            throw new Error(`Cannot resolve callback ${callbackId}`);
          }
          delete this.callbackCapabilities[callbackId];
          if (data.callback === CallbackKind.DATA) {
            capability.resolve(data.data);
          } else if (data.callback === CallbackKind.ERROR) {
            capability.reject(wrapReason(data.reason));
          } else {
            throw new Error("Unexpected callback case");
          }
          return;
        }
        const action = this.actionHandler[data.action];
        if (!action) {
          throw new Error(`Unknown action from worker: ${data.action}`);
        }
        if (data.callbackId) {
          const sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
          Promise.try(action, data.data).then(function(result2) {
            comObj.postMessage({
              sourceName,
              targetName,
              callback: CallbackKind.DATA,
              callbackId: data.callbackId,
              data: result2
            });
          }, function(reason) {
            comObj.postMessage({
              sourceName,
              targetName,
              callback: CallbackKind.ERROR,
              callbackId: data.callbackId,
              reason: wrapReason(reason)
            });
          });
          return;
        }
        if (data.streamId) {
          this.#createStreamSink(data);
          return;
        }
        action(data.data);
      }
      on(actionName, handler2) {
        const ah = this.actionHandler;
        if (ah[actionName]) {
          throw new Error(`There is already an actionName called "${actionName}"`);
        }
        ah[actionName] = handler2;
      }
      send(actionName, data, transfers) {
        this.comObj.postMessage({
          sourceName: this.sourceName,
          targetName: this.targetName,
          action: actionName,
          data
        }, transfers);
      }
      sendWithPromise(actionName, data, transfers) {
        const callbackId = this.callbackId++;
        const capability = Promise.withResolvers();
        this.callbackCapabilities[callbackId] = capability;
        try {
          this.comObj.postMessage({
            sourceName: this.sourceName,
            targetName: this.targetName,
            action: actionName,
            callbackId,
            data
          }, transfers);
        } catch (ex) {
          capability.reject(ex);
        }
        return capability.promise;
      }
      sendWithStream(actionName, data, queueingStrategy, transfers) {
        const streamId = this.streamId++, sourceName = this.sourceName, targetName = this.targetName, comObj = this.comObj;
        return new ReadableStream({
          start: (controller) => {
            const startCapability = Promise.withResolvers();
            this.streamControllers[streamId] = {
              controller,
              startCall: startCapability,
              pullCall: null,
              cancelCall: null,
              isClosed: false
            };
            comObj.postMessage({
              sourceName,
              targetName,
              action: actionName,
              streamId,
              data,
              desiredSize: controller.desiredSize
            }, transfers);
            return startCapability.promise;
          },
          pull: (controller) => {
            const pullCapability = Promise.withResolvers();
            this.streamControllers[streamId].pullCall = pullCapability;
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.PULL,
              streamId,
              desiredSize: controller.desiredSize
            });
            return pullCapability.promise;
          },
          cancel: (reason) => {
            assert(reason instanceof Error, "cancel must have a valid reason");
            const cancelCapability = Promise.withResolvers();
            this.streamControllers[streamId].cancelCall = cancelCapability;
            this.streamControllers[streamId].isClosed = true;
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.CANCEL,
              streamId,
              reason: wrapReason(reason)
            });
            return cancelCapability.promise;
          }
        }, queueingStrategy);
      }
      #createStreamSink(data) {
        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
        const self2 = this, action = this.actionHandler[data.action];
        const streamSink = {
          enqueue(chunk2, size2 = 1, transfers) {
            if (this.isCancelled) {
              return;
            }
            const lastDesiredSize = this.desiredSize;
            this.desiredSize -= size2;
            if (lastDesiredSize > 0 && this.desiredSize <= 0) {
              this.sinkCapability = Promise.withResolvers();
              this.ready = this.sinkCapability.promise;
            }
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.ENQUEUE,
              streamId,
              chunk: chunk2
            }, transfers);
          },
          close() {
            if (this.isCancelled) {
              return;
            }
            this.isCancelled = true;
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.CLOSE,
              streamId
            });
            delete self2.streamSinks[streamId];
          },
          error(reason) {
            assert(reason instanceof Error, "error must have a valid reason");
            if (this.isCancelled) {
              return;
            }
            this.isCancelled = true;
            comObj.postMessage({
              sourceName,
              targetName,
              stream: StreamKind.ERROR,
              streamId,
              reason: wrapReason(reason)
            });
          },
          sinkCapability: Promise.withResolvers(),
          onPull: null,
          onCancel: null,
          isCancelled: false,
          desiredSize: data.desiredSize,
          ready: null
        };
        streamSink.sinkCapability.resolve();
        streamSink.ready = streamSink.sinkCapability.promise;
        this.streamSinks[streamId] = streamSink;
        Promise.try(action, data.data, streamSink).then(function() {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.START_COMPLETE,
            streamId,
            success: true
          });
        }, function(reason) {
          comObj.postMessage({
            sourceName,
            targetName,
            stream: StreamKind.START_COMPLETE,
            streamId,
            reason: wrapReason(reason)
          });
        });
      }
      #processStreamMessage(data) {
        const streamId = data.streamId, sourceName = this.sourceName, targetName = data.sourceName, comObj = this.comObj;
        const streamController = this.streamControllers[streamId], streamSink = this.streamSinks[streamId];
        switch (data.stream) {
          case StreamKind.START_COMPLETE:
            if (data.success) {
              streamController.startCall.resolve();
            } else {
              streamController.startCall.reject(wrapReason(data.reason));
            }
            break;
          case StreamKind.PULL_COMPLETE:
            if (data.success) {
              streamController.pullCall.resolve();
            } else {
              streamController.pullCall.reject(wrapReason(data.reason));
            }
            break;
          case StreamKind.PULL:
            if (!streamSink) {
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.PULL_COMPLETE,
                streamId,
                success: true
              });
              break;
            }
            if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {
              streamSink.sinkCapability.resolve();
            }
            streamSink.desiredSize = data.desiredSize;
            Promise.try(streamSink.onPull || onFn).then(function() {
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.PULL_COMPLETE,
                streamId,
                success: true
              });
            }, function(reason) {
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.PULL_COMPLETE,
                streamId,
                reason: wrapReason(reason)
              });
            });
            break;
          case StreamKind.ENQUEUE:
            assert(streamController, "enqueue should have stream controller");
            if (streamController.isClosed) {
              break;
            }
            streamController.controller.enqueue(data.chunk);
            break;
          case StreamKind.CLOSE:
            assert(streamController, "close should have stream controller");
            if (streamController.isClosed) {
              break;
            }
            streamController.isClosed = true;
            streamController.controller.close();
            this.#deleteStreamController(streamController, streamId);
            break;
          case StreamKind.ERROR:
            assert(streamController, "error should have stream controller");
            streamController.controller.error(wrapReason(data.reason));
            this.#deleteStreamController(streamController, streamId);
            break;
          case StreamKind.CANCEL_COMPLETE:
            if (data.success) {
              streamController.cancelCall.resolve();
            } else {
              streamController.cancelCall.reject(wrapReason(data.reason));
            }
            this.#deleteStreamController(streamController, streamId);
            break;
          case StreamKind.CANCEL:
            if (!streamSink) {
              break;
            }
            const dataReason = wrapReason(data.reason);
            Promise.try(streamSink.onCancel || onFn, dataReason).then(function() {
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.CANCEL_COMPLETE,
                streamId,
                success: true
              });
            }, function(reason) {
              comObj.postMessage({
                sourceName,
                targetName,
                stream: StreamKind.CANCEL_COMPLETE,
                streamId,
                reason: wrapReason(reason)
              });
            });
            streamSink.sinkCapability.reject(dataReason);
            streamSink.isCancelled = true;
            delete this.streamSinks[streamId];
            break;
          default:
            throw new Error("Unexpected stream case");
        }
      }
      async #deleteStreamController(streamController, streamId) {
        await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);
        delete this.streamControllers[streamId];
      }
      destroy() {
        this.#messageAC?.abort();
        this.#messageAC = null;
      }
    };
    BaseCanvasFactory = class {
      #enableHWA = false;
      constructor({
        enableHWA = false
      }) {
        this.#enableHWA = enableHWA;
      }
      create(width, height) {
        if (width <= 0 || height <= 0) {
          throw new Error("Invalid canvas size");
        }
        const canvas = this._createCanvas(width, height);
        return {
          canvas,
          context: canvas.getContext("2d", {
            willReadFrequently: !this.#enableHWA
          })
        };
      }
      reset(canvasAndContext, width, height) {
        if (!canvasAndContext.canvas) {
          throw new Error("Canvas is not specified");
        }
        if (width <= 0 || height <= 0) {
          throw new Error("Invalid canvas size");
        }
        canvasAndContext.canvas.width = width;
        canvasAndContext.canvas.height = height;
      }
      destroy(canvasAndContext) {
        if (!canvasAndContext.canvas) {
          throw new Error("Canvas is not specified");
        }
        canvasAndContext.canvas.width = 0;
        canvasAndContext.canvas.height = 0;
        canvasAndContext.canvas = null;
        canvasAndContext.context = null;
      }
      _createCanvas(width, height) {
        unreachable("Abstract method `_createCanvas` called.");
      }
    };
    DOMCanvasFactory = class extends BaseCanvasFactory {
      constructor({
        ownerDocument = globalThis.document,
        enableHWA = false
      }) {
        super({
          enableHWA
        });
        this._document = ownerDocument;
      }
      _createCanvas(width, height) {
        const canvas = this._document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        return canvas;
      }
    };
    BaseCMapReaderFactory = class {
      constructor({
        baseUrl = null,
        isCompressed = true
      }) {
        this.baseUrl = baseUrl;
        this.isCompressed = isCompressed;
      }
      async fetch({
        name
      }) {
        if (!this.baseUrl) {
          throw new Error("Ensure that the `cMapUrl` and `cMapPacked` API parameters are provided.");
        }
        if (!name) {
          throw new Error("CMap name must be specified.");
        }
        const url = this.baseUrl + name + (this.isCompressed ? ".bcmap" : "");
        return this._fetch(url).then((cMapData) => ({
          cMapData,
          isCompressed: this.isCompressed
        })).catch((reason) => {
          throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${url}`);
        });
      }
      async _fetch(url) {
        unreachable("Abstract method `_fetch` called.");
      }
    };
    DOMCMapReaderFactory = class extends BaseCMapReaderFactory {
      async _fetch(url) {
        const data = await fetchData(url, this.isCompressed ? "arraybuffer" : "text");
        return data instanceof ArrayBuffer ? new Uint8Array(data) : stringToBytes(data);
      }
    };
    es_iterator_filter = __webpack_require__(2489);
    BaseFilterFactory = class {
      addFilter(maps) {
        return "none";
      }
      addHCMFilter(fgColor, bgColor) {
        return "none";
      }
      addAlphaFilter(map2) {
        return "none";
      }
      addLuminosityFilter(map2) {
        return "none";
      }
      addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
        return "none";
      }
      destroy(keepHCM = false) {
      }
    };
    DOMFilterFactory = class extends BaseFilterFactory {
      #baseUrl;
      #_cache;
      #_defs;
      #docId;
      #document;
      #_hcmCache;
      #id = 0;
      constructor({
        docId,
        ownerDocument = globalThis.document
      }) {
        super();
        this.#docId = docId;
        this.#document = ownerDocument;
      }
      get #cache() {
        return this.#_cache ||= /* @__PURE__ */ new Map();
      }
      get #hcmCache() {
        return this.#_hcmCache ||= /* @__PURE__ */ new Map();
      }
      get #defs() {
        if (!this.#_defs) {
          const div = this.#document.createElement("div");
          const {
            style
          } = div;
          style.visibility = "hidden";
          style.contain = "strict";
          style.width = style.height = 0;
          style.position = "absolute";
          style.top = style.left = 0;
          style.zIndex = -1;
          const svg = this.#document.createElementNS(SVG_NS, "svg");
          svg.setAttribute("width", 0);
          svg.setAttribute("height", 0);
          this.#_defs = this.#document.createElementNS(SVG_NS, "defs");
          div.append(svg);
          svg.append(this.#_defs);
          this.#document.body.append(div);
        }
        return this.#_defs;
      }
      #createTables(maps) {
        if (maps.length === 1) {
          const mapR2 = maps[0];
          const buffer = new Array(256);
          for (let i = 0; i < 256; i++) {
            buffer[i] = mapR2[i] / 255;
          }
          const table = buffer.join(",");
          return [table, table, table];
        }
        const [mapR, mapG, mapB] = maps;
        const bufferR = new Array(256);
        const bufferG = new Array(256);
        const bufferB = new Array(256);
        for (let i = 0; i < 256; i++) {
          bufferR[i] = mapR[i] / 255;
          bufferG[i] = mapG[i] / 255;
          bufferB[i] = mapB[i] / 255;
        }
        return [bufferR.join(","), bufferG.join(","), bufferB.join(",")];
      }
      #createUrl(id) {
        if (this.#baseUrl === void 0) {
          this.#baseUrl = "";
          const url = this.#document.URL;
          if (url !== this.#document.baseURI) {
            if (isDataScheme(url)) {
              warn('#createUrl: ignore "data:"-URL for performance reasons.');
            } else {
              this.#baseUrl = updateUrlHash(url, "");
            }
          }
        }
        return `url(${this.#baseUrl}#${id})`;
      }
      addFilter(maps) {
        if (!maps) {
          return "none";
        }
        let value = this.#cache.get(maps);
        if (value) {
          return value;
        }
        const [tableR, tableG, tableB] = this.#createTables(maps);
        const key = maps.length === 1 ? tableR : `${tableR}${tableG}${tableB}`;
        value = this.#cache.get(key);
        if (value) {
          this.#cache.set(maps, value);
          return value;
        }
        const id = `g_${this.#docId}_transfer_map_${this.#id++}`;
        const url = this.#createUrl(id);
        this.#cache.set(maps, url);
        this.#cache.set(key, url);
        const filter2 = this.#createFilter(id);
        this.#addTransferMapConversion(tableR, tableG, tableB, filter2);
        return url;
      }
      addHCMFilter(fgColor, bgColor) {
        const key = `${fgColor}-${bgColor}`;
        const filterName = "base";
        let info2 = this.#hcmCache.get(filterName);
        if (info2?.key === key) {
          return info2.url;
        }
        if (info2) {
          info2.filter?.remove();
          info2.key = key;
          info2.url = "none";
          info2.filter = null;
        } else {
          info2 = {
            key,
            url: "none",
            filter: null
          };
          this.#hcmCache.set(filterName, info2);
        }
        if (!fgColor || !bgColor) {
          return info2.url;
        }
        const fgRGB = this.#getRGB(fgColor);
        fgColor = Util.makeHexColor(...fgRGB);
        const bgRGB = this.#getRGB(bgColor);
        bgColor = Util.makeHexColor(...bgRGB);
        this.#defs.style.color = "";
        if (fgColor === "#000000" && bgColor === "#ffffff" || fgColor === bgColor) {
          return info2.url;
        }
        const map2 = new Array(256);
        for (let i = 0; i <= 255; i++) {
          const x = i / 255;
          map2[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;
        }
        const table = map2.join(",");
        const id = `g_${this.#docId}_hcm_filter`;
        const filter2 = info2.filter = this.#createFilter(id);
        this.#addTransferMapConversion(table, table, table, filter2);
        this.#addGrayConversion(filter2);
        const getSteps = (c, n) => {
          const start = fgRGB[c] / 255;
          const end = bgRGB[c] / 255;
          const arr = new Array(n + 1);
          for (let i = 0; i <= n; i++) {
            arr[i] = start + i / n * (end - start);
          }
          return arr.join(",");
        };
        this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter2);
        info2.url = this.#createUrl(id);
        return info2.url;
      }
      addAlphaFilter(map2) {
        let value = this.#cache.get(map2);
        if (value) {
          return value;
        }
        const [tableA] = this.#createTables([map2]);
        const key = `alpha_${tableA}`;
        value = this.#cache.get(key);
        if (value) {
          this.#cache.set(map2, value);
          return value;
        }
        const id = `g_${this.#docId}_alpha_map_${this.#id++}`;
        const url = this.#createUrl(id);
        this.#cache.set(map2, url);
        this.#cache.set(key, url);
        const filter2 = this.#createFilter(id);
        this.#addTransferMapAlphaConversion(tableA, filter2);
        return url;
      }
      addLuminosityFilter(map2) {
        let value = this.#cache.get(map2 || "luminosity");
        if (value) {
          return value;
        }
        let tableA, key;
        if (map2) {
          [tableA] = this.#createTables([map2]);
          key = `luminosity_${tableA}`;
        } else {
          key = "luminosity";
        }
        value = this.#cache.get(key);
        if (value) {
          this.#cache.set(map2, value);
          return value;
        }
        const id = `g_${this.#docId}_luminosity_map_${this.#id++}`;
        const url = this.#createUrl(id);
        this.#cache.set(map2, url);
        this.#cache.set(key, url);
        const filter2 = this.#createFilter(id);
        this.#addLuminosityConversion(filter2);
        if (map2) {
          this.#addTransferMapAlphaConversion(tableA, filter2);
        }
        return url;
      }
      addHighlightHCMFilter(filterName, fgColor, bgColor, newFgColor, newBgColor) {
        const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;
        let info2 = this.#hcmCache.get(filterName);
        if (info2?.key === key) {
          return info2.url;
        }
        if (info2) {
          info2.filter?.remove();
          info2.key = key;
          info2.url = "none";
          info2.filter = null;
        } else {
          info2 = {
            key,
            url: "none",
            filter: null
          };
          this.#hcmCache.set(filterName, info2);
        }
        if (!fgColor || !bgColor) {
          return info2.url;
        }
        const [fgRGB, bgRGB] = [fgColor, bgColor].map(this.#getRGB.bind(this));
        let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);
        let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);
        let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(this.#getRGB.bind(this));
        if (bgGray < fgGray) {
          [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];
        }
        this.#defs.style.color = "";
        const getSteps = (fg, bg, n) => {
          const arr = new Array(256);
          const step = (bgGray - fgGray) / n;
          const newStart = fg / 255;
          const newStep = (bg - fg) / (255 * n);
          let prev = 0;
          for (let i = 0; i <= n; i++) {
            const k = Math.round(fgGray + i * step);
            const value = newStart + i * newStep;
            for (let j = prev; j <= k; j++) {
              arr[j] = value;
            }
            prev = k + 1;
          }
          for (let i = prev; i < 256; i++) {
            arr[i] = arr[prev - 1];
          }
          return arr.join(",");
        };
        const id = `g_${this.#docId}_hcm_${filterName}_filter`;
        const filter2 = info2.filter = this.#createFilter(id);
        this.#addGrayConversion(filter2);
        this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter2);
        info2.url = this.#createUrl(id);
        return info2.url;
      }
      destroy(keepHCM = false) {
        if (keepHCM && this.#_hcmCache?.size) {
          return;
        }
        this.#_defs?.parentNode.parentNode.remove();
        this.#_defs = null;
        this.#_cache?.clear();
        this.#_cache = null;
        this.#_hcmCache?.clear();
        this.#_hcmCache = null;
        this.#id = 0;
      }
      #addLuminosityConversion(filter2) {
        const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("values", "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0.59 0.11 0 0");
        filter2.append(feColorMatrix);
      }
      #addGrayConversion(filter2) {
        const feColorMatrix = this.#document.createElementNS(SVG_NS, "feColorMatrix");
        feColorMatrix.setAttribute("type", "matrix");
        feColorMatrix.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0");
        filter2.append(feColorMatrix);
      }
      #createFilter(id) {
        const filter2 = this.#document.createElementNS(SVG_NS, "filter");
        filter2.setAttribute("color-interpolation-filters", "sRGB");
        filter2.setAttribute("id", id);
        this.#defs.append(filter2);
        return filter2;
      }
      #appendFeFunc(feComponentTransfer, func, table) {
        const feFunc = this.#document.createElementNS(SVG_NS, func);
        feFunc.setAttribute("type", "discrete");
        feFunc.setAttribute("tableValues", table);
        feComponentTransfer.append(feFunc);
      }
      #addTransferMapConversion(rTable, gTable, bTable, filter2) {
        const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
        filter2.append(feComponentTransfer);
        this.#appendFeFunc(feComponentTransfer, "feFuncR", rTable);
        this.#appendFeFunc(feComponentTransfer, "feFuncG", gTable);
        this.#appendFeFunc(feComponentTransfer, "feFuncB", bTable);
      }
      #addTransferMapAlphaConversion(aTable, filter2) {
        const feComponentTransfer = this.#document.createElementNS(SVG_NS, "feComponentTransfer");
        filter2.append(feComponentTransfer);
        this.#appendFeFunc(feComponentTransfer, "feFuncA", aTable);
      }
      #getRGB(color) {
        this.#defs.style.color = color;
        return getRGB(getComputedStyle(this.#defs).getPropertyValue("color"));
      }
    };
    BaseStandardFontDataFactory = class {
      constructor({
        baseUrl = null
      }) {
        this.baseUrl = baseUrl;
      }
      async fetch({
        filename
      }) {
        if (!this.baseUrl) {
          throw new Error("Ensure that the `standardFontDataUrl` API parameter is provided.");
        }
        if (!filename) {
          throw new Error("Font filename must be specified.");
        }
        const url = `${this.baseUrl}${filename}`;
        return this._fetch(url).catch((reason) => {
          throw new Error(`Unable to load font data at: ${url}`);
        });
      }
      async _fetch(url) {
        unreachable("Abstract method `_fetch` called.");
      }
    };
    DOMStandardFontDataFactory = class extends BaseStandardFontDataFactory {
      async _fetch(url) {
        const data = await fetchData(url, "arraybuffer");
        return new Uint8Array(data);
      }
    };
    BaseWasmFactory = class {
      constructor({
        baseUrl = null
      }) {
        this.baseUrl = baseUrl;
      }
      async fetch({
        filename
      }) {
        if (!this.baseUrl) {
          throw new Error("Ensure that the `wasmUrl` API parameter is provided.");
        }
        if (!filename) {
          throw new Error("Wasm filename must be specified.");
        }
        const url = `${this.baseUrl}${filename}`;
        return this._fetch(url).catch((reason) => {
          throw new Error(`Unable to load wasm data at: ${url}`);
        });
      }
      async _fetch(url) {
        unreachable("Abstract method `_fetch` called.");
      }
    };
    DOMWasmFactory = class extends BaseWasmFactory {
      async _fetch(url) {
        const data = await fetchData(url, "arraybuffer");
        return new Uint8Array(data);
      }
    };
    if (isNodeJS) {
      let canvas;
      try {
        const require2 = process.getBuiltinModule("module").createRequire(import.meta.url);
        try {
          canvas = require2("@napi-rs/canvas");
        } catch (ex) {
          warn(`Cannot load "@napi-rs/canvas" package: "${ex}".`);
        }
      } catch (ex) {
        warn(`Cannot access the \`require\` function: "${ex}".`);
      }
      if (!globalThis.DOMMatrix) {
        if (canvas?.DOMMatrix) {
          globalThis.DOMMatrix = canvas.DOMMatrix;
        } else {
          warn("Cannot polyfill `DOMMatrix`, rendering may be broken.");
        }
      }
      if (!globalThis.ImageData) {
        if (canvas?.ImageData) {
          globalThis.ImageData = canvas.ImageData;
        } else {
          warn("Cannot polyfill `ImageData`, rendering may be broken.");
        }
      }
      if (!globalThis.Path2D) {
        if (canvas?.Path2D) {
          globalThis.Path2D = canvas.Path2D;
        } else {
          warn("Cannot polyfill `Path2D`, rendering may be broken.");
        }
      }
      if (!globalThis.navigator?.language) {
        globalThis.navigator = {
          language: "en-US",
          platform: "",
          userAgent: ""
        };
      }
    }
    NodeFilterFactory = class extends BaseFilterFactory {
    };
    NodeCanvasFactory = class extends BaseCanvasFactory {
      _createCanvas(width, height) {
        const require2 = process.getBuiltinModule("module").createRequire(import.meta.url);
        const canvas = require2("@napi-rs/canvas");
        return canvas.createCanvas(width, height);
      }
    };
    NodeCMapReaderFactory = class extends BaseCMapReaderFactory {
      async _fetch(url) {
        return node_utils_fetchData(url);
      }
    };
    NodeStandardFontDataFactory = class extends BaseStandardFontDataFactory {
      async _fetch(url) {
        return node_utils_fetchData(url);
      }
    };
    NodeWasmFactory = class extends BaseWasmFactory {
      async _fetch(url) {
        return node_utils_fetchData(url);
      }
    };
    es_iterator_for_each = __webpack_require__(7588);
    FORCED_DEPENDENCY_LABEL = "__forcedDependency";
    ({
      floor,
      ceil
    } = Math);
    EMPTY_BBOX = new Uint32Array(new Uint8Array([255, 255, 0, 0]).buffer)[0];
    BBoxReader = class {
      #bboxes;
      #coords;
      constructor(bboxes, coords) {
        this.#bboxes = bboxes;
        this.#coords = coords;
      }
      get length() {
        return this.#bboxes.length;
      }
      isEmpty(i) {
        return this.#bboxes[i] === EMPTY_BBOX;
      }
      minX(i) {
        return this.#coords[i * 4 + 0] / 256;
      }
      minY(i) {
        return this.#coords[i * 4 + 1] / 256;
      }
      maxX(i) {
        return (this.#coords[i * 4 + 2] + 1) / 256;
      }
      maxY(i) {
        return (this.#coords[i * 4 + 3] + 1) / 256;
      }
    };
    ensureDebugMetadata = (map2, key) => {
      if (!map2) {
        return void 0;
      }
      let value = map2.get(key);
      if (!value) {
        value = {
          dependencies: /* @__PURE__ */ new Set(),
          isRenderingOperation: false
        };
        map2.set(key, value);
      }
      return value;
    };
    CanvasDependencyTracker = class {
      #simple = {
        __proto__: null
      };
      #incremental = {
        __proto__: null,
        transform: [],
        moveText: [],
        sameLineText: [],
        [FORCED_DEPENDENCY_LABEL]: []
      };
      #namedDependencies = /* @__PURE__ */ new Map();
      #savesStack = [];
      #markedContentStack = [];
      #baseTransformStack = [[1, 0, 0, 1, 0, 0]];
      #clipBox = [-Infinity, -Infinity, Infinity, Infinity];
      #pendingBBox = new Float64Array([Infinity, Infinity, -Infinity, -Infinity]);
      #pendingBBoxIdx = -1;
      #pendingDependencies = /* @__PURE__ */ new Set();
      #operations = /* @__PURE__ */ new Map();
      #fontBBoxTrustworthy = /* @__PURE__ */ new Map();
      #canvasWidth;
      #canvasHeight;
      #bboxesCoords;
      #bboxes;
      #debugMetadata;
      constructor(canvas, operationsCount, recordDebugMetadata = false) {
        this.#canvasWidth = canvas.width;
        this.#canvasHeight = canvas.height;
        this.#initializeBBoxes(operationsCount);
        if (recordDebugMetadata) {
          this.#debugMetadata = /* @__PURE__ */ new Map();
        }
      }
      growOperationsCount(operationsCount) {
        if (operationsCount >= this.#bboxes.length) {
          this.#initializeBBoxes(operationsCount, this.#bboxes);
        }
      }
      #initializeBBoxes(operationsCount, oldBBoxes) {
        const buffer = new ArrayBuffer(operationsCount * 4);
        this.#bboxesCoords = new Uint8ClampedArray(buffer);
        this.#bboxes = new Uint32Array(buffer);
        if (oldBBoxes && oldBBoxes.length > 0) {
          this.#bboxes.set(oldBBoxes);
          this.#bboxes.fill(EMPTY_BBOX, oldBBoxes.length);
        } else {
          this.#bboxes.fill(EMPTY_BBOX);
        }
      }
      save(opIdx) {
        this.#simple = {
          __proto__: this.#simple
        };
        this.#incremental = {
          __proto__: this.#incremental,
          transform: {
            __proto__: this.#incremental.transform
          },
          moveText: {
            __proto__: this.#incremental.moveText
          },
          sameLineText: {
            __proto__: this.#incremental.sameLineText
          },
          [FORCED_DEPENDENCY_LABEL]: {
            __proto__: this.#incremental[FORCED_DEPENDENCY_LABEL]
          }
        };
        this.#clipBox = {
          __proto__: this.#clipBox
        };
        this.#savesStack.push(opIdx);
        return this;
      }
      restore(opIdx) {
        const previous = Object.getPrototypeOf(this.#simple);
        if (previous === null) {
          return this;
        }
        this.#simple = previous;
        this.#incremental = Object.getPrototypeOf(this.#incremental);
        this.#clipBox = Object.getPrototypeOf(this.#clipBox);
        const lastSave = this.#savesStack.pop();
        if (lastSave !== void 0) {
          ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);
          this.#bboxes[opIdx] = this.#bboxes[lastSave];
        }
        return this;
      }
      recordOpenMarker(idx) {
        this.#savesStack.push(idx);
        return this;
      }
      getOpenMarker() {
        if (this.#savesStack.length === 0) {
          return null;
        }
        return this.#savesStack.at(-1);
      }
      recordCloseMarker(opIdx) {
        const lastSave = this.#savesStack.pop();
        if (lastSave !== void 0) {
          ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);
          this.#bboxes[opIdx] = this.#bboxes[lastSave];
        }
        return this;
      }
      beginMarkedContent(opIdx) {
        this.#markedContentStack.push(opIdx);
        return this;
      }
      endMarkedContent(opIdx) {
        const lastSave = this.#markedContentStack.pop();
        if (lastSave !== void 0) {
          ensureDebugMetadata(this.#debugMetadata, opIdx)?.dependencies.add(lastSave);
          this.#bboxes[opIdx] = this.#bboxes[lastSave];
        }
        return this;
      }
      pushBaseTransform(ctx) {
        this.#baseTransformStack.push(Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform()));
        return this;
      }
      popBaseTransform() {
        if (this.#baseTransformStack.length > 1) {
          this.#baseTransformStack.pop();
        }
        return this;
      }
      recordSimpleData(name, idx) {
        this.#simple[name] = idx;
        return this;
      }
      recordIncrementalData(name, idx) {
        this.#incremental[name].push(idx);
        return this;
      }
      resetIncrementalData(name, idx) {
        this.#incremental[name].length = 0;
        return this;
      }
      recordNamedData(name, idx) {
        this.#namedDependencies.set(name, idx);
        return this;
      }
      recordSimpleDataFromNamed(name, depName, fallbackIdx) {
        this.#simple[name] = this.#namedDependencies.get(depName) ?? fallbackIdx;
      }
      recordFutureForcedDependency(name, idx) {
        this.recordIncrementalData(FORCED_DEPENDENCY_LABEL, idx);
        return this;
      }
      inheritSimpleDataAsFutureForcedDependencies(names) {
        for (const name of names) {
          if (name in this.#simple) {
            this.recordFutureForcedDependency(name, this.#simple[name]);
          }
        }
        return this;
      }
      inheritPendingDependenciesAsFutureForcedDependencies() {
        for (const dep of this.#pendingDependencies) {
          this.recordFutureForcedDependency(FORCED_DEPENDENCY_LABEL, dep);
        }
        return this;
      }
      resetBBox(idx) {
        if (this.#pendingBBoxIdx !== idx) {
          this.#pendingBBoxIdx = idx;
          this.#pendingBBox[0] = Infinity;
          this.#pendingBBox[1] = Infinity;
          this.#pendingBBox[2] = -Infinity;
          this.#pendingBBox[3] = -Infinity;
        }
        return this;
      }
      recordClipBox(idx, ctx, minX, maxX, minY, maxY) {
        const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());
        const clipBox = [Infinity, Infinity, -Infinity, -Infinity];
        Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, clipBox);
        const intersection2 = Util.intersect(this.#clipBox, clipBox);
        if (intersection2) {
          this.#clipBox[0] = intersection2[0];
          this.#clipBox[1] = intersection2[1];
          this.#clipBox[2] = intersection2[2];
          this.#clipBox[3] = intersection2[3];
        } else {
          this.#clipBox[0] = this.#clipBox[1] = Infinity;
          this.#clipBox[2] = this.#clipBox[3] = -Infinity;
        }
        return this;
      }
      recordBBox(idx, ctx, minX, maxX, minY, maxY) {
        const clipBox = this.#clipBox;
        if (clipBox[0] === Infinity) {
          return this;
        }
        const transform = Util.multiplyByDOMMatrix(this.#baseTransformStack.at(-1), ctx.getTransform());
        if (clipBox[0] === -Infinity) {
          Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, this.#pendingBBox);
          return this;
        }
        const bbox = [Infinity, Infinity, -Infinity, -Infinity];
        Util.axialAlignedBoundingBox([minX, minY, maxX, maxY], transform, bbox);
        this.#pendingBBox[0] = Math.min(this.#pendingBBox[0], Math.max(bbox[0], clipBox[0]));
        this.#pendingBBox[1] = Math.min(this.#pendingBBox[1], Math.max(bbox[1], clipBox[1]));
        this.#pendingBBox[2] = Math.max(this.#pendingBBox[2], Math.min(bbox[2], clipBox[2]));
        this.#pendingBBox[3] = Math.max(this.#pendingBBox[3], Math.min(bbox[3], clipBox[3]));
        return this;
      }
      recordCharacterBBox(idx, ctx, font, scale = 1, x = 0, y = 0, getMeasure) {
        const fontBBox = font.bbox;
        let isBBoxTrustworthy;
        let computedBBox;
        if (fontBBox) {
          isBBoxTrustworthy = fontBBox[2] !== fontBBox[0] && fontBBox[3] !== fontBBox[1] && this.#fontBBoxTrustworthy.get(font);
          if (isBBoxTrustworthy !== false) {
            computedBBox = [0, 0, 0, 0];
            Util.axialAlignedBoundingBox(fontBBox, font.fontMatrix, computedBBox);
            if (scale !== 1 || x !== 0 || y !== 0) {
              Util.scaleMinMax([scale, 0, 0, -scale, x, y], computedBBox);
            }
            if (isBBoxTrustworthy) {
              return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);
            }
          }
        }
        if (!getMeasure) {
          return this.recordFullPageBBox(idx);
        }
        const measure = getMeasure();
        if (fontBBox && computedBBox && isBBoxTrustworthy === void 0) {
          isBBoxTrustworthy = computedBBox[0] <= x - measure.actualBoundingBoxLeft && computedBBox[2] >= x + measure.actualBoundingBoxRight && computedBBox[1] <= y - measure.actualBoundingBoxAscent && computedBBox[3] >= y + measure.actualBoundingBoxDescent;
          this.#fontBBoxTrustworthy.set(font, isBBoxTrustworthy);
          if (isBBoxTrustworthy) {
            return this.recordBBox(idx, ctx, computedBBox[0], computedBBox[2], computedBBox[1], computedBBox[3]);
          }
        }
        return this.recordBBox(idx, ctx, x - measure.actualBoundingBoxLeft, x + measure.actualBoundingBoxRight, y - measure.actualBoundingBoxAscent, y + measure.actualBoundingBoxDescent);
      }
      recordFullPageBBox(idx) {
        this.#pendingBBox[0] = Math.max(0, this.#clipBox[0]);
        this.#pendingBBox[1] = Math.max(0, this.#clipBox[1]);
        this.#pendingBBox[2] = Math.min(this.#canvasWidth, this.#clipBox[2]);
        this.#pendingBBox[3] = Math.min(this.#canvasHeight, this.#clipBox[3]);
        return this;
      }
      getSimpleIndex(dependencyName) {
        return this.#simple[dependencyName];
      }
      recordDependencies(idx, dependencyNames) {
        const pendingDependencies = this.#pendingDependencies;
        const simple = this.#simple;
        const incremental = this.#incremental;
        for (const name of dependencyNames) {
          if (name in this.#simple) {
            pendingDependencies.add(simple[name]);
          } else if (name in incremental) {
            incremental[name].forEach(pendingDependencies.add, pendingDependencies);
          }
        }
        return this;
      }
      recordNamedDependency(idx, name) {
        if (this.#namedDependencies.has(name)) {
          this.#pendingDependencies.add(this.#namedDependencies.get(name));
        }
        return this;
      }
      recordOperation(idx, preserve = false) {
        this.recordDependencies(idx, [FORCED_DEPENDENCY_LABEL]);
        if (this.#debugMetadata) {
          const metadata = ensureDebugMetadata(this.#debugMetadata, idx);
          const {
            dependencies
          } = metadata;
          this.#pendingDependencies.forEach(dependencies.add, dependencies);
          this.#savesStack.forEach(dependencies.add, dependencies);
          this.#markedContentStack.forEach(dependencies.add, dependencies);
          dependencies.delete(idx);
          metadata.isRenderingOperation = true;
        }
        if (this.#pendingBBoxIdx === idx) {
          const minX = floor(this.#pendingBBox[0] * 256 / this.#canvasWidth);
          const minY = floor(this.#pendingBBox[1] * 256 / this.#canvasHeight);
          const maxX = ceil(this.#pendingBBox[2] * 256 / this.#canvasWidth);
          const maxY = ceil(this.#pendingBBox[3] * 256 / this.#canvasHeight);
          expandBBox(this.#bboxesCoords, idx, minX, minY, maxX, maxY);
          for (const depIdx of this.#pendingDependencies) {
            if (depIdx !== idx) {
              expandBBox(this.#bboxesCoords, depIdx, minX, minY, maxX, maxY);
            }
          }
          for (const saveIdx of this.#savesStack) {
            if (saveIdx !== idx) {
              expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);
            }
          }
          for (const saveIdx of this.#markedContentStack) {
            if (saveIdx !== idx) {
              expandBBox(this.#bboxesCoords, saveIdx, minX, minY, maxX, maxY);
            }
          }
          if (!preserve) {
            this.#pendingDependencies.clear();
            this.#pendingBBoxIdx = -1;
          }
        }
        return this;
      }
      recordShowTextOperation(idx, preserve = false) {
        const deps = Array.from(this.#pendingDependencies);
        this.recordOperation(idx, preserve);
        this.recordIncrementalData("sameLineText", idx);
        for (const dep of deps) {
          this.recordIncrementalData("sameLineText", dep);
        }
        return this;
      }
      bboxToClipBoxDropOperation(idx, preserve = false) {
        if (this.#pendingBBoxIdx === idx) {
          this.#pendingBBoxIdx = -1;
          this.#clipBox[0] = Math.max(this.#clipBox[0], this.#pendingBBox[0]);
          this.#clipBox[1] = Math.max(this.#clipBox[1], this.#pendingBBox[1]);
          this.#clipBox[2] = Math.min(this.#clipBox[2], this.#pendingBBox[2]);
          this.#clipBox[3] = Math.min(this.#clipBox[3], this.#pendingBBox[3]);
          if (!preserve) {
            this.#pendingDependencies.clear();
          }
        }
        return this;
      }
      _takePendingDependencies() {
        const pendingDependencies = this.#pendingDependencies;
        this.#pendingDependencies = /* @__PURE__ */ new Set();
        return pendingDependencies;
      }
      _extractOperation(idx) {
        const operation = this.#operations.get(idx);
        this.#operations.delete(idx);
        return operation;
      }
      _pushPendingDependencies(dependencies) {
        for (const dep of dependencies) {
          this.#pendingDependencies.add(dep);
        }
      }
      take() {
        this.#fontBBoxTrustworthy.clear();
        return new BBoxReader(this.#bboxes, this.#bboxesCoords);
      }
      takeDebugMetadata() {
        return this.#debugMetadata;
      }
    };
    CanvasNestedDependencyTracker = class _CanvasNestedDependencyTracker {
      #dependencyTracker;
      #opIdx;
      #ignoreBBoxes;
      #nestingLevel = 0;
      #savesLevel = 0;
      constructor(dependencyTracker, opIdx, ignoreBBoxes) {
        if (dependencyTracker instanceof _CanvasNestedDependencyTracker && dependencyTracker.#ignoreBBoxes === !!ignoreBBoxes) {
          return dependencyTracker;
        }
        this.#dependencyTracker = dependencyTracker;
        this.#opIdx = opIdx;
        this.#ignoreBBoxes = !!ignoreBBoxes;
      }
      growOperationsCount() {
        throw new Error("Unreachable");
      }
      save(opIdx) {
        this.#savesLevel++;
        this.#dependencyTracker.save(this.#opIdx);
        return this;
      }
      restore(opIdx) {
        if (this.#savesLevel > 0) {
          this.#dependencyTracker.restore(this.#opIdx);
          this.#savesLevel--;
        }
        return this;
      }
      recordOpenMarker(idx) {
        this.#nestingLevel++;
        return this;
      }
      getOpenMarker() {
        return this.#nestingLevel > 0 ? this.#opIdx : this.#dependencyTracker.getOpenMarker();
      }
      recordCloseMarker(idx) {
        this.#nestingLevel--;
        return this;
      }
      beginMarkedContent(opIdx) {
        return this;
      }
      endMarkedContent(opIdx) {
        return this;
      }
      pushBaseTransform(ctx) {
        this.#dependencyTracker.pushBaseTransform(ctx);
        return this;
      }
      popBaseTransform() {
        this.#dependencyTracker.popBaseTransform();
        return this;
      }
      recordSimpleData(name, idx) {
        this.#dependencyTracker.recordSimpleData(name, this.#opIdx);
        return this;
      }
      recordIncrementalData(name, idx) {
        this.#dependencyTracker.recordIncrementalData(name, this.#opIdx);
        return this;
      }
      resetIncrementalData(name, idx) {
        this.#dependencyTracker.resetIncrementalData(name, this.#opIdx);
        return this;
      }
      recordNamedData(name, idx) {
        return this;
      }
      recordSimpleDataFromNamed(name, depName, fallbackIdx) {
        this.#dependencyTracker.recordSimpleDataFromNamed(name, depName, this.#opIdx);
        return this;
      }
      recordFutureForcedDependency(name, idx) {
        this.#dependencyTracker.recordFutureForcedDependency(name, this.#opIdx);
        return this;
      }
      inheritSimpleDataAsFutureForcedDependencies(names) {
        this.#dependencyTracker.inheritSimpleDataAsFutureForcedDependencies(names);
        return this;
      }
      inheritPendingDependenciesAsFutureForcedDependencies() {
        this.#dependencyTracker.inheritPendingDependenciesAsFutureForcedDependencies();
        return this;
      }
      resetBBox(idx) {
        if (!this.#ignoreBBoxes) {
          this.#dependencyTracker.resetBBox(this.#opIdx);
        }
        return this;
      }
      recordClipBox(idx, ctx, minX, maxX, minY, maxY) {
        if (!this.#ignoreBBoxes) {
          this.#dependencyTracker.recordClipBox(this.#opIdx, ctx, minX, maxX, minY, maxY);
        }
        return this;
      }
      recordBBox(idx, ctx, minX, maxX, minY, maxY) {
        if (!this.#ignoreBBoxes) {
          this.#dependencyTracker.recordBBox(this.#opIdx, ctx, minX, maxX, minY, maxY);
        }
        return this;
      }
      recordCharacterBBox(idx, ctx, font, scale, x, y, getMeasure) {
        if (!this.#ignoreBBoxes) {
          this.#dependencyTracker.recordCharacterBBox(this.#opIdx, ctx, font, scale, x, y, getMeasure);
        }
        return this;
      }
      recordFullPageBBox(idx) {
        if (!this.#ignoreBBoxes) {
          this.#dependencyTracker.recordFullPageBBox(this.#opIdx);
        }
        return this;
      }
      getSimpleIndex(dependencyName) {
        return this.#dependencyTracker.getSimpleIndex(dependencyName);
      }
      recordDependencies(idx, dependencyNames) {
        this.#dependencyTracker.recordDependencies(this.#opIdx, dependencyNames);
        return this;
      }
      recordNamedDependency(idx, name) {
        this.#dependencyTracker.recordNamedDependency(this.#opIdx, name);
        return this;
      }
      recordOperation(idx) {
        this.#dependencyTracker.recordOperation(this.#opIdx, true);
        return this;
      }
      recordShowTextOperation(idx) {
        this.#dependencyTracker.recordShowTextOperation(this.#opIdx, true);
        return this;
      }
      bboxToClipBoxDropOperation(idx) {
        if (!this.#ignoreBBoxes) {
          this.#dependencyTracker.bboxToClipBoxDropOperation(this.#opIdx, true);
        }
        return this;
      }
      take() {
        throw new Error("Unreachable");
      }
      takeDebugMetadata() {
        throw new Error("Unreachable");
      }
    };
    Dependencies = {
      stroke: ["path", "transform", "filter", "strokeColor", "strokeAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "dash"],
      fill: ["path", "transform", "filter", "fillColor", "fillAlpha", "globalCompositeOperation", "SMask"],
      imageXObject: ["transform", "SMask", "filter", "fillAlpha", "strokeAlpha", "globalCompositeOperation"],
      rawFillPath: ["filter", "fillColor", "fillAlpha"],
      showText: ["transform", "leading", "charSpacing", "wordSpacing", "hScale", "textRise", "moveText", "textMatrix", "font", "fontObj", "filter", "fillColor", "textRenderingMode", "SMask", "fillAlpha", "strokeAlpha", "globalCompositeOperation", "sameLineText"],
      transform: ["transform"],
      transformAndFill: ["transform", "fillColor"]
    };
    PathType = {
      FILL: "Fill",
      STROKE: "Stroke",
      SHADING: "Shading"
    };
    BaseShadingPattern = class {
      isModifyingCurrentTransform() {
        return false;
      }
      getPattern() {
        unreachable("Abstract method `getPattern` called.");
      }
    };
    RadialAxialShadingPattern = class extends BaseShadingPattern {
      constructor(IR) {
        super();
        this._type = IR[1];
        this._bbox = IR[2];
        this._colorStops = IR[3];
        this._p0 = IR[4];
        this._p1 = IR[5];
        this._r0 = IR[6];
        this._r1 = IR[7];
        this.matrix = null;
      }
      _createGradient(ctx) {
        let grad;
        if (this._type === "axial") {
          grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);
        } else if (this._type === "radial") {
          grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);
        }
        for (const colorStop of this._colorStops) {
          grad.addColorStop(colorStop[0], colorStop[1]);
        }
        return grad;
      }
      getPattern(ctx, owner, inverse, pathType) {
        let pattern;
        if (pathType === PathType.STROKE || pathType === PathType.FILL) {
          const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, getCurrentTransform(ctx)) || [0, 0, 0, 0];
          const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;
          const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;
          const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", width, height);
          const tmpCtx = tmpCanvas.context;
          tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
          tmpCtx.beginPath();
          tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);
          tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);
          inverse = Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);
          tmpCtx.transform(...owner.baseTransform);
          if (this.matrix) {
            tmpCtx.transform(...this.matrix);
          }
          applyBoundingBox(tmpCtx, this._bbox);
          tmpCtx.fillStyle = this._createGradient(tmpCtx);
          tmpCtx.fill();
          pattern = ctx.createPattern(tmpCanvas.canvas, "no-repeat");
          const domMatrix = new DOMMatrix(inverse);
          pattern.setTransform(domMatrix);
        } else {
          applyBoundingBox(ctx, this._bbox);
          pattern = this._createGradient(ctx);
        }
        return pattern;
      }
    };
    MeshShadingPattern = class extends BaseShadingPattern {
      constructor(IR) {
        super();
        this._coords = IR[2];
        this._colors = IR[3];
        this._figures = IR[4];
        this._bounds = IR[5];
        this._bbox = IR[6];
        this._background = IR[7];
        this.matrix = null;
      }
      _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {
        const EXPECTED_SCALE = 1.1;
        const MAX_PATTERN_SIZE = 3e3;
        const BORDER_SIZE = 2;
        const offsetX = Math.floor(this._bounds[0]);
        const offsetY = Math.floor(this._bounds[1]);
        const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;
        const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;
        const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
        const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);
        const scaleX = boundsWidth / width;
        const scaleY = boundsHeight / height;
        const context = {
          coords: this._coords,
          colors: this._colors,
          offsetX: -offsetX,
          offsetY: -offsetY,
          scaleX: 1 / scaleX,
          scaleY: 1 / scaleY
        };
        const paddedWidth = width + BORDER_SIZE * 2;
        const paddedHeight = height + BORDER_SIZE * 2;
        const tmpCanvas = cachedCanvases.getCanvas("mesh", paddedWidth, paddedHeight);
        const tmpCtx = tmpCanvas.context;
        const data = tmpCtx.createImageData(width, height);
        if (backgroundColor) {
          const bytes = data.data;
          for (let i = 0, ii = bytes.length; i < ii; i += 4) {
            bytes[i] = backgroundColor[0];
            bytes[i + 1] = backgroundColor[1];
            bytes[i + 2] = backgroundColor[2];
            bytes[i + 3] = 255;
          }
        }
        for (const figure of this._figures) {
          drawFigure(data, figure, context);
        }
        tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);
        const canvas = tmpCanvas.canvas;
        return {
          canvas,
          offsetX: offsetX - BORDER_SIZE * scaleX,
          offsetY: offsetY - BORDER_SIZE * scaleY,
          scaleX,
          scaleY
        };
      }
      isModifyingCurrentTransform() {
        return true;
      }
      getPattern(ctx, owner, inverse, pathType) {
        applyBoundingBox(ctx, this._bbox);
        const scale = new Float32Array(2);
        if (pathType === PathType.SHADING) {
          Util.singularValueDecompose2dScale(getCurrentTransform(ctx), scale);
        } else if (this.matrix) {
          Util.singularValueDecompose2dScale(this.matrix, scale);
          const [matrixScaleX, matrixScaleY] = scale;
          Util.singularValueDecompose2dScale(owner.baseTransform, scale);
          scale[0] *= matrixScaleX;
          scale[1] *= matrixScaleY;
        } else {
          Util.singularValueDecompose2dScale(owner.baseTransform, scale);
        }
        const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);
        if (pathType !== PathType.SHADING) {
          ctx.setTransform(...owner.baseTransform);
          if (this.matrix) {
            ctx.transform(...this.matrix);
          }
        }
        ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
        ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);
        return ctx.createPattern(temporaryPatternCanvas.canvas, "no-repeat");
      }
    };
    DummyShadingPattern = class extends BaseShadingPattern {
      getPattern() {
        return "hotpink";
      }
    };
    PaintType = {
      COLORED: 1,
      UNCOLORED: 2
    };
    TilingPattern = class _TilingPattern {
      static MAX_PATTERN_SIZE = 3e3;
      constructor(IR, ctx, canvasGraphicsFactory, baseTransform) {
        this.color = IR[1];
        this.operatorList = IR[2];
        this.matrix = IR[3];
        this.bbox = IR[4];
        this.xstep = IR[5];
        this.ystep = IR[6];
        this.paintType = IR[7];
        this.tilingType = IR[8];
        this.ctx = ctx;
        this.canvasGraphicsFactory = canvasGraphicsFactory;
        this.baseTransform = baseTransform;
      }
      createPatternCanvas(owner, opIdx) {
        const {
          bbox,
          operatorList,
          paintType,
          tilingType,
          color,
          canvasGraphicsFactory
        } = this;
        let {
          xstep,
          ystep
        } = this;
        xstep = Math.abs(xstep);
        ystep = Math.abs(ystep);
        info("TilingType: " + tilingType);
        const x0 = bbox[0], y0 = bbox[1], x1 = bbox[2], y1 = bbox[3];
        const width = x1 - x0;
        const height = y1 - y0;
        const scale = new Float32Array(2);
        Util.singularValueDecompose2dScale(this.matrix, scale);
        const [matrixScaleX, matrixScaleY] = scale;
        Util.singularValueDecompose2dScale(this.baseTransform, scale);
        const combinedScaleX = matrixScaleX * scale[0];
        const combinedScaleY = matrixScaleY * scale[1];
        let canvasWidth = width, canvasHeight = height, redrawHorizontally = false, redrawVertically = false;
        const xScaledStep = Math.ceil(xstep * combinedScaleX);
        const yScaledStep = Math.ceil(ystep * combinedScaleY);
        const xScaledWidth = Math.ceil(width * combinedScaleX);
        const yScaledHeight = Math.ceil(height * combinedScaleY);
        if (xScaledStep >= xScaledWidth) {
          canvasWidth = xstep;
        } else {
          redrawHorizontally = true;
        }
        if (yScaledStep >= yScaledHeight) {
          canvasHeight = ystep;
        } else {
          redrawVertically = true;
        }
        const dimx = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
        const dimy = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
        const tmpCanvas = owner.cachedCanvases.getCanvas("pattern", dimx.size, dimy.size);
        const tmpCtx = tmpCanvas.context;
        const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx, opIdx);
        graphics.groupLevel = owner.groupLevel;
        this.setFillAndStrokeStyleToContext(graphics, paintType, color);
        tmpCtx.translate(-dimx.scale * x0, -dimy.scale * y0);
        graphics.transform(0, dimx.scale, 0, 0, dimy.scale, 0, 0);
        tmpCtx.save();
        graphics.dependencyTracker?.save();
        this.clipBbox(graphics, x0, y0, x1, y1);
        graphics.baseTransform = getCurrentTransform(graphics.ctx);
        graphics.executeOperatorList(operatorList);
        graphics.endDrawing();
        graphics.dependencyTracker?.restore();
        tmpCtx.restore();
        if (redrawHorizontally || redrawVertically) {
          const image = tmpCanvas.canvas;
          if (redrawHorizontally) {
            canvasWidth = xstep;
          }
          if (redrawVertically) {
            canvasHeight = ystep;
          }
          const dimx2 = this.getSizeAndScale(canvasWidth, this.ctx.canvas.width, combinedScaleX);
          const dimy2 = this.getSizeAndScale(canvasHeight, this.ctx.canvas.height, combinedScaleY);
          const xSize = dimx2.size;
          const ySize = dimy2.size;
          const tmpCanvas2 = owner.cachedCanvases.getCanvas("pattern-workaround", xSize, ySize);
          const tmpCtx2 = tmpCanvas2.context;
          const ii = redrawHorizontally ? Math.floor(width / xstep) : 0;
          const jj = redrawVertically ? Math.floor(height / ystep) : 0;
          for (let i = 0; i <= ii; i++) {
            for (let j = 0; j <= jj; j++) {
              tmpCtx2.drawImage(image, xSize * i, ySize * j, xSize, ySize, 0, 0, xSize, ySize);
            }
          }
          return {
            canvas: tmpCanvas2.canvas,
            scaleX: dimx2.scale,
            scaleY: dimy2.scale,
            offsetX: x0,
            offsetY: y0
          };
        }
        return {
          canvas: tmpCanvas.canvas,
          scaleX: dimx.scale,
          scaleY: dimy.scale,
          offsetX: x0,
          offsetY: y0
        };
      }
      getSizeAndScale(step, realOutputSize, scale) {
        const maxSize = Math.max(_TilingPattern.MAX_PATTERN_SIZE, realOutputSize);
        let size2 = Math.ceil(step * scale);
        if (size2 >= maxSize) {
          size2 = maxSize;
        } else {
          scale = size2 / step;
        }
        return {
          scale,
          size: size2
        };
      }
      clipBbox(graphics, x0, y0, x1, y1) {
        const bboxWidth = x1 - x0;
        const bboxHeight = y1 - y0;
        graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);
        Util.axialAlignedBoundingBox([x0, y0, x1, y1], getCurrentTransform(graphics.ctx), graphics.current.minMax);
        graphics.clip();
        graphics.endPath();
      }
      setFillAndStrokeStyleToContext(graphics, paintType, color) {
        const context = graphics.ctx, current = graphics.current;
        switch (paintType) {
          case PaintType.COLORED:
            const {
              fillStyle,
              strokeStyle
            } = this.ctx;
            context.fillStyle = current.fillColor = fillStyle;
            context.strokeStyle = current.strokeColor = strokeStyle;
            break;
          case PaintType.UNCOLORED:
            context.fillStyle = context.strokeStyle = color;
            current.fillColor = current.strokeColor = color;
            break;
          default:
            throw new FormatError(`Unsupported paint type: ${paintType}`);
        }
      }
      isModifyingCurrentTransform() {
        return false;
      }
      getPattern(ctx, owner, inverse, pathType, opIdx) {
        let matrix = inverse;
        if (pathType !== PathType.SHADING) {
          matrix = Util.transform(matrix, owner.baseTransform);
          if (this.matrix) {
            matrix = Util.transform(matrix, this.matrix);
          }
        }
        const temporaryPatternCanvas = this.createPatternCanvas(owner, opIdx);
        let domMatrix = new DOMMatrix(matrix);
        domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);
        domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);
        const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, "repeat");
        pattern.setTransform(domMatrix);
        return pattern;
      }
    };
    MIN_FONT_SIZE = 16;
    MAX_FONT_SIZE = 100;
    EXECUTION_TIME = 15;
    EXECUTION_STEPS = 10;
    FULL_CHUNK_HEIGHT = 16;
    SCALE_MATRIX = new DOMMatrix();
    XY = new Float32Array(2);
    MIN_MAX_INIT = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
    CachedCanvases = class {
      constructor(canvasFactory) {
        this.canvasFactory = canvasFactory;
        this.cache = /* @__PURE__ */ Object.create(null);
      }
      getCanvas(id, width, height) {
        let canvasEntry;
        if (this.cache[id] !== void 0) {
          canvasEntry = this.cache[id];
          this.canvasFactory.reset(canvasEntry, width, height);
        } else {
          canvasEntry = this.canvasFactory.create(width, height);
          this.cache[id] = canvasEntry;
        }
        return canvasEntry;
      }
      delete(id) {
        delete this.cache[id];
      }
      clear() {
        for (const id in this.cache) {
          const canvasEntry = this.cache[id];
          this.canvasFactory.destroy(canvasEntry);
          delete this.cache[id];
        }
      }
    };
    CanvasExtraState = class {
      alphaIsShape = false;
      fontSize = 0;
      fontSizeScale = 1;
      textMatrix = null;
      textMatrixScale = 1;
      fontMatrix = FONT_IDENTITY_MATRIX;
      leading = 0;
      x = 0;
      y = 0;
      lineX = 0;
      lineY = 0;
      charSpacing = 0;
      wordSpacing = 0;
      textHScale = 1;
      textRenderingMode = TextRenderingMode.FILL;
      textRise = 0;
      fillColor = "#000000";
      strokeColor = "#000000";
      patternFill = false;
      patternStroke = false;
      fillAlpha = 1;
      strokeAlpha = 1;
      lineWidth = 1;
      activeSMask = null;
      transferMaps = "none";
      constructor(width, height, preInit) {
        preInit?.(this);
        this.clipBox = new Float32Array([0, 0, width, height]);
        this.minMax = MIN_MAX_INIT.slice();
      }
      clone() {
        const clone2 = Object.create(this);
        clone2.clipBox = this.clipBox.slice();
        clone2.minMax = this.minMax.slice();
        return clone2;
      }
      getPathBoundingBox(pathType = PathType.FILL, transform = null) {
        const box = this.minMax.slice();
        if (pathType === PathType.STROKE) {
          if (!transform) {
            unreachable("Stroke bounding box must include transform.");
          }
          Util.singularValueDecompose2dScale(transform, XY);
          const xStrokePad = XY[0] * this.lineWidth / 2;
          const yStrokePad = XY[1] * this.lineWidth / 2;
          box[0] -= xStrokePad;
          box[1] -= yStrokePad;
          box[2] += xStrokePad;
          box[3] += yStrokePad;
        }
        return box;
      }
      updateClipFromPath() {
        const intersect = Util.intersect(this.clipBox, this.getPathBoundingBox());
        this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);
      }
      isEmptyClip() {
        return this.minMax[0] === Infinity;
      }
      startNewPathAndClipBox(box) {
        this.clipBox.set(box, 0);
        this.minMax.set(MIN_MAX_INIT, 0);
      }
      getClippedPathBoundingBox(pathType = PathType.FILL, transform = null) {
        return Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));
      }
    };
    LINE_CAP_STYLES = ["butt", "round", "square"];
    LINE_JOIN_STYLES = ["miter", "round", "bevel"];
    NORMAL_CLIP = {};
    EO_CLIP = {};
    CanvasGraphics = class _CanvasGraphics {
      constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, {
        optionalContentConfig,
        markedContentStack = null
      }, annotationCanvasMap, pageColors, dependencyTracker) {
        this.ctx = canvasCtx;
        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
        this.stateStack = [];
        this.pendingClip = null;
        this.pendingEOFill = false;
        this.res = null;
        this.xobjs = null;
        this.commonObjs = commonObjs;
        this.objs = objs;
        this.canvasFactory = canvasFactory;
        this.filterFactory = filterFactory;
        this.groupStack = [];
        this.baseTransform = null;
        this.baseTransformStack = [];
        this.groupLevel = 0;
        this.smaskStack = [];
        this.smaskCounter = 0;
        this.tempSMask = null;
        this.suspendedCtx = null;
        this.contentVisible = true;
        this.markedContentStack = markedContentStack || [];
        this.optionalContentConfig = optionalContentConfig;
        this.cachedCanvases = new CachedCanvases(this.canvasFactory);
        this.cachedPatterns = /* @__PURE__ */ new Map();
        this.annotationCanvasMap = annotationCanvasMap;
        this.viewportScale = 1;
        this.outputScaleX = 1;
        this.outputScaleY = 1;
        this.pageColors = pageColors;
        this._cachedScaleForStroking = [-1, 0];
        this._cachedGetSinglePixelWidth = null;
        this._cachedBitmapsMap = /* @__PURE__ */ new Map();
        this.dependencyTracker = dependencyTracker ?? null;
      }
      getObject(opIdx, data, fallback = null) {
        if (typeof data === "string") {
          this.dependencyTracker?.recordNamedDependency(opIdx, data);
          return data.startsWith("g_") ? this.commonObjs.get(data) : this.objs.get(data);
        }
        return fallback;
      }
      beginDrawing({
        transform,
        viewport,
        transparency = false,
        background = null
      }) {
        const width = this.ctx.canvas.width;
        const height = this.ctx.canvas.height;
        const savedFillStyle = this.ctx.fillStyle;
        this.ctx.fillStyle = background || "#ffffff";
        this.ctx.fillRect(0, 0, width, height);
        this.ctx.fillStyle = savedFillStyle;
        if (transparency) {
          const transparentCanvas = this.cachedCanvases.getCanvas("transparent", width, height);
          this.compositeCtx = this.ctx;
          this.transparentCanvas = transparentCanvas.canvas;
          this.ctx = transparentCanvas.context;
          this.ctx.save();
          this.ctx.transform(...getCurrentTransform(this.compositeCtx));
        }
        this.ctx.save();
        resetCtxToDefault(this.ctx);
        if (transform) {
          this.ctx.transform(...transform);
          this.outputScaleX = transform[0];
          this.outputScaleY = transform[0];
        }
        this.ctx.transform(...viewport.transform);
        this.viewportScale = viewport.scale;
        this.baseTransform = getCurrentTransform(this.ctx);
      }
      executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper, operationsFilter) {
        const argsArray = operatorList.argsArray;
        const fnArray = operatorList.fnArray;
        let i = executionStartIdx || 0;
        const argsArrayLen = argsArray.length;
        if (argsArrayLen === i) {
          return i;
        }
        const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === "function";
        const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;
        let steps = 0;
        const commonObjs = this.commonObjs;
        const objs = this.objs;
        let fnId, fnArgs;
        while (true) {
          if (stepper !== void 0 && i === stepper.nextBreakPoint) {
            stepper.breakIt(i, continueCallback);
            return i;
          }
          if (!operationsFilter || operationsFilter(i)) {
            fnId = fnArray[i];
            fnArgs = argsArray[i] ?? null;
            if (fnId !== OPS.dependency) {
              if (fnArgs === null) {
                this[fnId](i);
              } else {
                this[fnId](i, ...fnArgs);
              }
            } else {
              for (const depObjId of fnArgs) {
                this.dependencyTracker?.recordNamedData(depObjId, i);
                const objsPool = depObjId.startsWith("g_") ? commonObjs : objs;
                if (!objsPool.has(depObjId)) {
                  objsPool.get(depObjId, continueCallback);
                  return i;
                }
              }
            }
          }
          i++;
          if (i === argsArrayLen) {
            return i;
          }
          if (chunkOperations && ++steps > EXECUTION_STEPS) {
            if (Date.now() > endTime) {
              continueCallback();
              return i;
            }
            steps = 0;
          }
        }
      }
      #restoreInitialState() {
        while (this.stateStack.length || this.inSMaskMode) {
          this.restore();
        }
        this.current.activeSMask = null;
        this.ctx.restore();
        if (this.transparentCanvas) {
          this.ctx = this.compositeCtx;
          this.ctx.save();
          this.ctx.setTransform(1, 0, 0, 1, 0, 0);
          this.ctx.drawImage(this.transparentCanvas, 0, 0);
          this.ctx.restore();
          this.transparentCanvas = null;
        }
      }
      endDrawing() {
        this.#restoreInitialState();
        this.cachedCanvases.clear();
        this.cachedPatterns.clear();
        for (const cache of this._cachedBitmapsMap.values()) {
          for (const canvas of cache.values()) {
            if (typeof HTMLCanvasElement !== "undefined" && canvas instanceof HTMLCanvasElement) {
              canvas.width = canvas.height = 0;
            }
          }
          cache.clear();
        }
        this._cachedBitmapsMap.clear();
        this.#drawFilter();
      }
      #drawFilter() {
        if (this.pageColors) {
          const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);
          if (hcmFilterId !== "none") {
            const savedFilter = this.ctx.filter;
            this.ctx.filter = hcmFilterId;
            this.ctx.drawImage(this.ctx.canvas, 0, 0);
            this.ctx.filter = savedFilter;
          }
        }
      }
      _scaleImage(img, inverseTransform) {
        const width = img.width ?? img.displayWidth;
        const height = img.height ?? img.displayHeight;
        let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);
        let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);
        let paintWidth = width, paintHeight = height;
        let tmpCanvasId = "prescale1";
        let tmpCanvas, tmpCtx;
        while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {
          let newWidth = paintWidth, newHeight = paintHeight;
          if (widthScale > 2 && paintWidth > 1) {
            newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);
            widthScale /= paintWidth / newWidth;
          }
          if (heightScale > 2 && paintHeight > 1) {
            newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;
            heightScale /= paintHeight / newHeight;
          }
          tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);
          tmpCtx = tmpCanvas.context;
          tmpCtx.clearRect(0, 0, newWidth, newHeight);
          tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);
          img = tmpCanvas.canvas;
          paintWidth = newWidth;
          paintHeight = newHeight;
          tmpCanvasId = tmpCanvasId === "prescale1" ? "prescale2" : "prescale1";
        }
        return {
          img,
          paintWidth,
          paintHeight
        };
      }
      _createMaskCanvas(opIdx, img) {
        const ctx = this.ctx;
        const {
          width,
          height
        } = img;
        const fillColor = this.current.fillColor;
        const isPatternFill = this.current.patternFill;
        const currentTransform = getCurrentTransform(ctx);
        let cache, cacheKey, scaled, maskCanvas;
        if ((img.bitmap || img.data) && img.count > 1) {
          const mainKey = img.bitmap || img.data.buffer;
          cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);
          cache = this._cachedBitmapsMap.get(mainKey);
          if (!cache) {
            cache = /* @__PURE__ */ new Map();
            this._cachedBitmapsMap.set(mainKey, cache);
          }
          const cachedImage = cache.get(cacheKey);
          if (cachedImage && !isPatternFill) {
            const offsetX2 = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);
            const offsetY2 = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);
            this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);
            return {
              canvas: cachedImage,
              offsetX: offsetX2,
              offsetY: offsetY2
            };
          }
          scaled = cachedImage;
        }
        if (!scaled) {
          maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
          putBinaryImageMask(maskCanvas.context, img);
        }
        let maskToCanvas = Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);
        maskToCanvas = Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);
        const minMax = MIN_MAX_INIT.slice();
        Util.axialAlignedBoundingBox([0, 0, width, height], maskToCanvas, minMax);
        const [minX, minY, maxX, maxY] = minMax;
        const drawnWidth = Math.round(maxX - minX) || 1;
        const drawnHeight = Math.round(maxY - minY) || 1;
        const fillCanvas = this.cachedCanvases.getCanvas("fillCanvas", drawnWidth, drawnHeight);
        const fillCtx = fillCanvas.context;
        const offsetX = minX;
        const offsetY = minY;
        fillCtx.translate(-offsetX, -offsetY);
        fillCtx.transform(...maskToCanvas);
        if (!scaled) {
          scaled = this._scaleImage(maskCanvas.canvas, getCurrentTransformInverse(fillCtx));
          scaled = scaled.img;
          if (cache && isPatternFill) {
            cache.set(cacheKey, scaled);
          }
        }
        fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(fillCtx), img.interpolate);
        drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);
        fillCtx.globalCompositeOperation = "source-in";
        const inverse = Util.transform(getCurrentTransformInverse(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);
        fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, PathType.FILL, opIdx) : fillColor;
        fillCtx.fillRect(0, 0, width, height);
        if (cache && !isPatternFill) {
          this.cachedCanvases.delete("fillCanvas");
          cache.set(cacheKey, fillCanvas.canvas);
        }
        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.transformAndFill);
        return {
          canvas: fillCanvas.canvas,
          offsetX: Math.round(offsetX),
          offsetY: Math.round(offsetY)
        };
      }
      setLineWidth(opIdx, width) {
        this.dependencyTracker?.recordSimpleData("lineWidth", opIdx);
        if (width !== this.current.lineWidth) {
          this._cachedScaleForStroking[0] = -1;
        }
        this.current.lineWidth = width;
        this.ctx.lineWidth = width;
      }
      setLineCap(opIdx, style) {
        this.dependencyTracker?.recordSimpleData("lineCap", opIdx);
        this.ctx.lineCap = LINE_CAP_STYLES[style];
      }
      setLineJoin(opIdx, style) {
        this.dependencyTracker?.recordSimpleData("lineJoin", opIdx);
        this.ctx.lineJoin = LINE_JOIN_STYLES[style];
      }
      setMiterLimit(opIdx, limit) {
        this.dependencyTracker?.recordSimpleData("miterLimit", opIdx);
        this.ctx.miterLimit = limit;
      }
      setDash(opIdx, dashArray, dashPhase) {
        this.dependencyTracker?.recordSimpleData("dash", opIdx);
        const ctx = this.ctx;
        if (ctx.setLineDash !== void 0) {
          ctx.setLineDash(dashArray);
          ctx.lineDashOffset = dashPhase;
        }
      }
      setRenderingIntent(opIdx, intent) {
      }
      setFlatness(opIdx, flatness) {
      }
      setGState(opIdx, states) {
        for (const [key, value] of states) {
          switch (key) {
            case "LW":
              this.setLineWidth(opIdx, value);
              break;
            case "LC":
              this.setLineCap(opIdx, value);
              break;
            case "LJ":
              this.setLineJoin(opIdx, value);
              break;
            case "ML":
              this.setMiterLimit(opIdx, value);
              break;
            case "D":
              this.setDash(opIdx, value[0], value[1]);
              break;
            case "RI":
              this.setRenderingIntent(opIdx, value);
              break;
            case "FL":
              this.setFlatness(opIdx, value);
              break;
            case "Font":
              this.setFont(opIdx, value[0], value[1]);
              break;
            case "CA":
              this.dependencyTracker?.recordSimpleData("strokeAlpha", opIdx);
              this.current.strokeAlpha = value;
              break;
            case "ca":
              this.dependencyTracker?.recordSimpleData("fillAlpha", opIdx);
              this.ctx.globalAlpha = this.current.fillAlpha = value;
              break;
            case "BM":
              this.dependencyTracker?.recordSimpleData("globalCompositeOperation", opIdx);
              this.ctx.globalCompositeOperation = value;
              break;
            case "SMask":
              this.dependencyTracker?.recordSimpleData("SMask", opIdx);
              this.current.activeSMask = value ? this.tempSMask : null;
              this.tempSMask = null;
              this.checkSMaskState();
              break;
            case "TR":
              this.dependencyTracker?.recordSimpleData("filter", opIdx);
              this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);
              break;
          }
        }
      }
      get inSMaskMode() {
        return !!this.suspendedCtx;
      }
      checkSMaskState() {
        const inSMaskMode = this.inSMaskMode;
        if (this.current.activeSMask && !inSMaskMode) {
          this.beginSMaskMode();
        } else if (!this.current.activeSMask && inSMaskMode) {
          this.endSMaskMode();
        }
      }
      beginSMaskMode(opIdx) {
        if (this.inSMaskMode) {
          throw new Error("beginSMaskMode called while already in smask mode");
        }
        const drawnWidth = this.ctx.canvas.width;
        const drawnHeight = this.ctx.canvas.height;
        const cacheId = "smaskGroupAt" + this.groupLevel;
        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
        this.suspendedCtx = this.ctx;
        const ctx = this.ctx = scratchCanvas.context;
        ctx.setTransform(this.suspendedCtx.getTransform());
        copyCtxState(this.suspendedCtx, ctx);
        mirrorContextOperations(ctx, this.suspendedCtx);
        this.setGState(opIdx, [["BM", "source-over"]]);
      }
      endSMaskMode() {
        if (!this.inSMaskMode) {
          throw new Error("endSMaskMode called while not in smask mode");
        }
        this.ctx._removeMirroring();
        copyCtxState(this.ctx, this.suspendedCtx);
        this.ctx = this.suspendedCtx;
        this.suspendedCtx = null;
      }
      compose(dirtyBox) {
        if (!this.current.activeSMask) {
          return;
        }
        if (!dirtyBox) {
          dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];
        } else {
          dirtyBox[0] = Math.floor(dirtyBox[0]);
          dirtyBox[1] = Math.floor(dirtyBox[1]);
          dirtyBox[2] = Math.ceil(dirtyBox[2]);
          dirtyBox[3] = Math.ceil(dirtyBox[3]);
        }
        const smask = this.current.activeSMask;
        const suspendedCtx = this.suspendedCtx;
        this.composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);
        this.ctx.save();
        this.ctx.setTransform(1, 0, 0, 1, 0, 0);
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        this.ctx.restore();
      }
      composeSMask(ctx, smask, layerCtx, layerBox) {
        const layerOffsetX = layerBox[0];
        const layerOffsetY = layerBox[1];
        const layerWidth = layerBox[2] - layerOffsetX;
        const layerHeight = layerBox[3] - layerOffsetY;
        if (layerWidth === 0 || layerHeight === 0) {
          return;
        }
        this.genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);
        ctx.save();
        ctx.globalAlpha = 1;
        ctx.globalCompositeOperation = "source-over";
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.drawImage(layerCtx.canvas, 0, 0);
        ctx.restore();
      }
      genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {
        let maskCanvas = maskCtx.canvas;
        let maskX = layerOffsetX - maskOffsetX;
        let maskY = layerOffsetY - maskOffsetY;
        if (backdrop) {
          if (maskX < 0 || maskY < 0 || maskX + width > maskCanvas.width || maskY + height > maskCanvas.height) {
            const canvas = this.cachedCanvases.getCanvas("maskExtension", width, height);
            const ctx = canvas.context;
            ctx.drawImage(maskCanvas, -maskX, -maskY);
            ctx.globalCompositeOperation = "destination-atop";
            ctx.fillStyle = backdrop;
            ctx.fillRect(0, 0, width, height);
            ctx.globalCompositeOperation = "source-over";
            maskCanvas = canvas.canvas;
            maskX = maskY = 0;
          } else {
            maskCtx.save();
            maskCtx.globalAlpha = 1;
            maskCtx.setTransform(1, 0, 0, 1, 0, 0);
            const clip2 = new Path2D();
            clip2.rect(maskX, maskY, width, height);
            maskCtx.clip(clip2);
            maskCtx.globalCompositeOperation = "destination-atop";
            maskCtx.fillStyle = backdrop;
            maskCtx.fillRect(maskX, maskY, width, height);
            maskCtx.restore();
          }
        }
        layerCtx.save();
        layerCtx.globalAlpha = 1;
        layerCtx.setTransform(1, 0, 0, 1, 0, 0);
        if (subtype === "Alpha" && transferMap) {
          layerCtx.filter = this.filterFactory.addAlphaFilter(transferMap);
        } else if (subtype === "Luminosity") {
          layerCtx.filter = this.filterFactory.addLuminosityFilter(transferMap);
        }
        const clip = new Path2D();
        clip.rect(layerOffsetX, layerOffsetY, width, height);
        layerCtx.clip(clip);
        layerCtx.globalCompositeOperation = "destination-in";
        layerCtx.drawImage(maskCanvas, maskX, maskY, width, height, layerOffsetX, layerOffsetY, width, height);
        layerCtx.restore();
      }
      save(opIdx) {
        if (this.inSMaskMode) {
          copyCtxState(this.ctx, this.suspendedCtx);
        }
        this.ctx.save();
        const old = this.current;
        this.stateStack.push(old);
        this.current = old.clone();
        this.dependencyTracker?.save(opIdx);
      }
      restore(opIdx) {
        this.dependencyTracker?.restore(opIdx);
        if (this.stateStack.length === 0) {
          if (this.inSMaskMode) {
            this.endSMaskMode();
          }
          return;
        }
        this.current = this.stateStack.pop();
        this.ctx.restore();
        if (this.inSMaskMode) {
          copyCtxState(this.suspendedCtx, this.ctx);
        }
        this.checkSMaskState();
        this.pendingClip = null;
        this._cachedScaleForStroking[0] = -1;
        this._cachedGetSinglePixelWidth = null;
      }
      transform(opIdx, a, b, c, d, e, f) {
        this.dependencyTracker?.recordIncrementalData("transform", opIdx);
        this.ctx.transform(a, b, c, d, e, f);
        this._cachedScaleForStroking[0] = -1;
        this._cachedGetSinglePixelWidth = null;
      }
      constructPath(opIdx, op, data, minMax) {
        let [path] = data;
        if (!minMax) {
          path ||= data[0] = new Path2D();
          this[op](opIdx, path);
          return;
        }
        if (this.dependencyTracker !== null) {
          const outerExtraSize = op === OPS.stroke ? this.current.lineWidth / 2 : 0;
          this.dependencyTracker.resetBBox(opIdx).recordBBox(opIdx, this.ctx, minMax[0] - outerExtraSize, minMax[2] + outerExtraSize, minMax[1] - outerExtraSize, minMax[3] + outerExtraSize).recordDependencies(opIdx, ["transform"]);
        }
        if (!(path instanceof Path2D)) {
          const path2d = data[0] = new Path2D();
          for (let i = 0, ii = path.length; i < ii; ) {
            switch (path[i++]) {
              case DrawOPS.moveTo:
                path2d.moveTo(path[i++], path[i++]);
                break;
              case DrawOPS.lineTo:
                path2d.lineTo(path[i++], path[i++]);
                break;
              case DrawOPS.curveTo:
                path2d.bezierCurveTo(path[i++], path[i++], path[i++], path[i++], path[i++], path[i++]);
                break;
              case DrawOPS.closePath:
                path2d.closePath();
                break;
              default:
                warn(`Unrecognized drawing path operator: ${path[i - 1]}`);
                break;
            }
          }
          path = path2d;
        }
        Util.axialAlignedBoundingBox(minMax, getCurrentTransform(this.ctx), this.current.minMax);
        this[op](opIdx, path);
        this._pathStartIdx = opIdx;
      }
      closePath(opIdx) {
        this.ctx.closePath();
      }
      stroke(opIdx, path, consumePath = true) {
        const ctx = this.ctx;
        const strokeColor = this.current.strokeColor;
        ctx.globalAlpha = this.current.strokeAlpha;
        if (this.contentVisible) {
          if (typeof strokeColor === "object" && strokeColor?.getPattern) {
            const baseTransform = strokeColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;
            ctx.save();
            ctx.strokeStyle = strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);
            if (baseTransform) {
              const newPath = new Path2D();
              newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));
              path = newPath;
            }
            this.rescaleAndStroke(path, false);
            ctx.restore();
          } else {
            this.rescaleAndStroke(path, true);
          }
        }
        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.stroke);
        if (consumePath) {
          this.consumePath(opIdx, path, this.current.getClippedPathBoundingBox(PathType.STROKE, getCurrentTransform(this.ctx)));
        }
        ctx.globalAlpha = this.current.fillAlpha;
      }
      closeStroke(opIdx, path) {
        this.stroke(opIdx, path);
      }
      fill(opIdx, path, consumePath = true) {
        const ctx = this.ctx;
        const fillColor = this.current.fillColor;
        const isPatternFill = this.current.patternFill;
        let needRestore = false;
        if (isPatternFill) {
          const baseTransform = fillColor.isModifyingCurrentTransform() ? ctx.getTransform() : null;
          this.dependencyTracker?.save(opIdx);
          ctx.save();
          ctx.fillStyle = fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);
          if (baseTransform) {
            const newPath = new Path2D();
            newPath.addPath(path, ctx.getTransform().invertSelf().multiplySelf(baseTransform));
            path = newPath;
          }
          needRestore = true;
        }
        const intersect = this.current.getClippedPathBoundingBox();
        if (this.contentVisible && intersect !== null) {
          if (this.pendingEOFill) {
            ctx.fill(path, "evenodd");
            this.pendingEOFill = false;
          } else {
            ctx.fill(path);
          }
        }
        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.fill);
        if (needRestore) {
          ctx.restore();
          this.dependencyTracker?.restore(opIdx);
        }
        if (consumePath) {
          this.consumePath(opIdx, path, intersect);
        }
      }
      eoFill(opIdx, path) {
        this.pendingEOFill = true;
        this.fill(opIdx, path);
      }
      fillStroke(opIdx, path) {
        this.fill(opIdx, path, false);
        this.stroke(opIdx, path, false);
        this.consumePath(opIdx, path);
      }
      eoFillStroke(opIdx, path) {
        this.pendingEOFill = true;
        this.fillStroke(opIdx, path);
      }
      closeFillStroke(opIdx, path) {
        this.fillStroke(opIdx, path);
      }
      closeEOFillStroke(opIdx, path) {
        this.pendingEOFill = true;
        this.fillStroke(opIdx, path);
      }
      endPath(opIdx, path) {
        this.consumePath(opIdx, path);
      }
      rawFillPath(opIdx, path) {
        this.ctx.fill(path);
        this.dependencyTracker?.recordDependencies(opIdx, Dependencies.rawFillPath).recordOperation(opIdx);
      }
      clip(opIdx) {
        this.dependencyTracker?.recordFutureForcedDependency("clipMode", opIdx);
        this.pendingClip = NORMAL_CLIP;
      }
      eoClip(opIdx) {
        this.dependencyTracker?.recordFutureForcedDependency("clipMode", opIdx);
        this.pendingClip = EO_CLIP;
      }
      beginText(opIdx) {
        this.current.textMatrix = null;
        this.current.textMatrixScale = 1;
        this.current.x = this.current.lineX = 0;
        this.current.y = this.current.lineY = 0;
        this.dependencyTracker?.recordOpenMarker(opIdx).resetIncrementalData("sameLineText").resetIncrementalData("moveText", opIdx);
      }
      endText(opIdx) {
        const paths = this.pendingTextPaths;
        const ctx = this.ctx;
        if (this.dependencyTracker) {
          const {
            dependencyTracker
          } = this;
          if (paths !== void 0) {
            dependencyTracker.recordFutureForcedDependency("textClip", dependencyTracker.getOpenMarker()).recordFutureForcedDependency("textClip", opIdx);
          }
          dependencyTracker.recordCloseMarker(opIdx);
        }
        if (paths !== void 0) {
          const newPath = new Path2D();
          const invTransf = ctx.getTransform().invertSelf();
          for (const {
            transform,
            x,
            y,
            fontSize,
            path
          } of paths) {
            if (!path) {
              continue;
            }
            newPath.addPath(path, new DOMMatrix(transform).preMultiplySelf(invTransf).translate(x, y).scale(fontSize, -fontSize));
          }
          ctx.clip(newPath);
        }
        delete this.pendingTextPaths;
      }
      setCharSpacing(opIdx, spacing) {
        this.dependencyTracker?.recordSimpleData("charSpacing", opIdx);
        this.current.charSpacing = spacing;
      }
      setWordSpacing(opIdx, spacing) {
        this.dependencyTracker?.recordSimpleData("wordSpacing", opIdx);
        this.current.wordSpacing = spacing;
      }
      setHScale(opIdx, scale) {
        this.dependencyTracker?.recordSimpleData("hScale", opIdx);
        this.current.textHScale = scale / 100;
      }
      setLeading(opIdx, leading) {
        this.dependencyTracker?.recordSimpleData("leading", opIdx);
        this.current.leading = -leading;
      }
      setFont(opIdx, fontRefName, size2) {
        this.dependencyTracker?.recordSimpleData("font", opIdx).recordSimpleDataFromNamed("fontObj", fontRefName, opIdx);
        const fontObj = this.commonObjs.get(fontRefName);
        const current = this.current;
        if (!fontObj) {
          throw new Error(`Can't find font for ${fontRefName}`);
        }
        current.fontMatrix = fontObj.fontMatrix || FONT_IDENTITY_MATRIX;
        if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {
          warn("Invalid font matrix for font " + fontRefName);
        }
        if (size2 < 0) {
          size2 = -size2;
          current.fontDirection = -1;
        } else {
          current.fontDirection = 1;
        }
        this.current.font = fontObj;
        this.current.fontSize = size2;
        if (fontObj.isType3Font) {
          return;
        }
        const name = fontObj.loadedName || "sans-serif";
        const typeface = fontObj.systemFontInfo?.css || `"${name}", ${fontObj.fallbackName}`;
        let bold = "normal";
        if (fontObj.black) {
          bold = "900";
        } else if (fontObj.bold) {
          bold = "bold";
        }
        const italic = fontObj.italic ? "italic" : "normal";
        let browserFontSize = size2;
        if (size2 < MIN_FONT_SIZE) {
          browserFontSize = MIN_FONT_SIZE;
        } else if (size2 > MAX_FONT_SIZE) {
          browserFontSize = MAX_FONT_SIZE;
        }
        this.current.fontSizeScale = size2 / browserFontSize;
        this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;
      }
      setTextRenderingMode(opIdx, mode) {
        this.dependencyTracker?.recordSimpleData("textRenderingMode", opIdx);
        this.current.textRenderingMode = mode;
      }
      setTextRise(opIdx, rise) {
        this.dependencyTracker?.recordSimpleData("textRise", opIdx);
        this.current.textRise = rise;
      }
      moveText(opIdx, x, y) {
        this.dependencyTracker?.resetIncrementalData("sameLineText").recordIncrementalData("moveText", opIdx);
        this.current.x = this.current.lineX += x;
        this.current.y = this.current.lineY += y;
      }
      setLeadingMoveText(opIdx, x, y) {
        this.setLeading(opIdx, -y);
        this.moveText(opIdx, x, y);
      }
      setTextMatrix(opIdx, matrix) {
        this.dependencyTracker?.recordSimpleData("textMatrix", opIdx);
        const {
          current
        } = this;
        current.textMatrix = matrix;
        current.textMatrixScale = Math.hypot(matrix[0], matrix[1]);
        current.x = current.lineX = 0;
        current.y = current.lineY = 0;
      }
      nextLine(opIdx) {
        this.moveText(opIdx, 0, this.current.leading);
        this.dependencyTracker?.recordIncrementalData("moveText", this.dependencyTracker.getSimpleIndex("leading") ?? opIdx);
      }
      #getScaledPath(path, currentTransform, transform) {
        const newPath = new Path2D();
        newPath.addPath(path, new DOMMatrix(transform).invertSelf().multiplySelf(currentTransform));
        return newPath;
      }
      paintChar(opIdx, character, x, y, patternFillTransform, patternStrokeTransform) {
        const ctx = this.ctx;
        const current = this.current;
        const font = current.font;
        const textRenderingMode = current.textRenderingMode;
        const fontSize = current.fontSize / current.fontSizeScale;
        const fillStrokeMode = textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
        const isAddToPathSet = !!(textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG);
        const patternFill = current.patternFill && !font.missingFile;
        const patternStroke = current.patternStroke && !font.missingFile;
        let path;
        if ((font.disableFontFace || isAddToPathSet || patternFill || patternStroke) && !font.missingFile) {
          path = font.getPathGenerator(this.commonObjs, character);
        }
        if (path && (font.disableFontFace || patternFill || patternStroke)) {
          ctx.save();
          ctx.translate(x, y);
          ctx.scale(fontSize, -fontSize);
          this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font);
          let currentTransform;
          if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
            if (patternFillTransform) {
              currentTransform = ctx.getTransform();
              ctx.setTransform(...patternFillTransform);
              const scaledPath = this.#getScaledPath(path, currentTransform, patternFillTransform);
              ctx.fill(scaledPath);
            } else {
              ctx.fill(path);
            }
          }
          if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
            if (patternStrokeTransform) {
              currentTransform ||= ctx.getTransform();
              ctx.setTransform(...patternStrokeTransform);
              const {
                a,
                b,
                c,
                d
              } = currentTransform;
              const invPatternTransform = Util.inverseTransform(patternStrokeTransform);
              const transf = Util.transform([a, b, c, d, 0, 0], invPatternTransform);
              Util.singularValueDecompose2dScale(transf, XY);
              ctx.lineWidth *= Math.max(XY[0], XY[1]) / fontSize;
              ctx.stroke(this.#getScaledPath(path, currentTransform, patternStrokeTransform));
            } else {
              ctx.lineWidth /= fontSize;
              ctx.stroke(path);
            }
          }
          ctx.restore();
        } else {
          if (fillStrokeMode === TextRenderingMode.FILL || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
            ctx.fillText(character, x, y);
            this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character));
          }
          if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
            if (this.dependencyTracker) {
              this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y, () => ctx.measureText(character)).recordDependencies(opIdx, Dependencies.stroke);
            }
            ctx.strokeText(character, x, y);
          }
        }
        if (isAddToPathSet) {
          const paths = this.pendingTextPaths ||= [];
          paths.push({
            transform: getCurrentTransform(ctx),
            x,
            y,
            fontSize,
            path
          });
          this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, font, fontSize, x, y);
        }
      }
      get isFontSubpixelAAEnabled() {
        const {
          context: ctx
        } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10);
        ctx.scale(1.5, 1);
        ctx.fillText("I", 0, 10);
        const data = ctx.getImageData(0, 0, 10, 10).data;
        let enabled = false;
        for (let i = 3; i < data.length; i += 4) {
          if (data[i] > 0 && data[i] < 255) {
            enabled = true;
            break;
          }
        }
        return shadow(this, "isFontSubpixelAAEnabled", enabled);
      }
      showText(opIdx, glyphs) {
        if (this.dependencyTracker) {
          this.dependencyTracker.recordDependencies(opIdx, Dependencies.showText).resetBBox(opIdx);
          if (this.current.textRenderingMode & TextRenderingMode.ADD_TO_PATH_FLAG) {
            this.dependencyTracker.recordFutureForcedDependency("textClip", opIdx).inheritPendingDependenciesAsFutureForcedDependencies();
          }
        }
        const current = this.current;
        const font = current.font;
        if (font.isType3Font) {
          this.showType3Text(opIdx, glyphs);
          this.dependencyTracker?.recordShowTextOperation(opIdx);
          return void 0;
        }
        const fontSize = current.fontSize;
        if (fontSize === 0) {
          this.dependencyTracker?.recordOperation(opIdx);
          return void 0;
        }
        const ctx = this.ctx;
        const fontSizeScale = current.fontSizeScale;
        const charSpacing = current.charSpacing;
        const wordSpacing = current.wordSpacing;
        const fontDirection = current.fontDirection;
        const textHScale = current.textHScale * fontDirection;
        const glyphsLength = glyphs.length;
        const vertical = font.vertical;
        const spacingDir = vertical ? 1 : -1;
        const defaultVMetrics = font.defaultVMetrics;
        const widthAdvanceScale = fontSize * current.fontMatrix[0];
        const simpleFillText = current.textRenderingMode === TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;
        ctx.save();
        if (current.textMatrix) {
          ctx.transform(...current.textMatrix);
        }
        ctx.translate(current.x, current.y + current.textRise);
        if (fontDirection > 0) {
          ctx.scale(textHScale, -1);
        } else {
          ctx.scale(textHScale, 1);
        }
        let patternFillTransform, patternStrokeTransform;
        if (current.patternFill) {
          ctx.save();
          const pattern = current.fillColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx);
          patternFillTransform = getCurrentTransform(ctx);
          ctx.restore();
          ctx.fillStyle = pattern;
        }
        if (current.patternStroke) {
          ctx.save();
          const pattern = current.strokeColor.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.STROKE, opIdx);
          patternStrokeTransform = getCurrentTransform(ctx);
          ctx.restore();
          ctx.strokeStyle = pattern;
        }
        let lineWidth = current.lineWidth;
        const scale = current.textMatrixScale;
        if (scale === 0 || lineWidth === 0) {
          const fillStrokeMode = current.textRenderingMode & TextRenderingMode.FILL_STROKE_MASK;
          if (fillStrokeMode === TextRenderingMode.STROKE || fillStrokeMode === TextRenderingMode.FILL_STROKE) {
            lineWidth = this.getSinglePixelWidth();
          }
        } else {
          lineWidth /= scale;
        }
        if (fontSizeScale !== 1) {
          ctx.scale(fontSizeScale, fontSizeScale);
          lineWidth /= fontSizeScale;
        }
        ctx.lineWidth = lineWidth;
        if (font.isInvalidPDFjsFont) {
          const chars = [];
          let width = 0;
          for (const glyph of glyphs) {
            chars.push(glyph.unicode);
            width += glyph.width;
          }
          const joinedChars = chars.join("");
          ctx.fillText(joinedChars, 0, 0);
          if (this.dependencyTracker !== null) {
            const measure = ctx.measureText(joinedChars);
            this.dependencyTracker.recordBBox(opIdx, this.ctx, -measure.actualBoundingBoxLeft, measure.actualBoundingBoxRight, -measure.actualBoundingBoxAscent, measure.actualBoundingBoxDescent).recordShowTextOperation(opIdx);
          }
          current.x += width * widthAdvanceScale * textHScale;
          ctx.restore();
          this.compose();
          return void 0;
        }
        let x = 0, i;
        for (i = 0; i < glyphsLength; ++i) {
          const glyph = glyphs[i];
          if (typeof glyph === "number") {
            x += spacingDir * glyph * fontSize / 1e3;
            continue;
          }
          let restoreNeeded = false;
          const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
          const character = glyph.fontChar;
          const accent = glyph.accent;
          let scaledX, scaledY;
          let width = glyph.width;
          if (vertical) {
            const vmetric = glyph.vmetric || defaultVMetrics;
            const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;
            const vy = vmetric[2] * widthAdvanceScale;
            width = vmetric ? -vmetric[0] : width;
            scaledX = vx / fontSizeScale;
            scaledY = (x + vy) / fontSizeScale;
          } else {
            scaledX = x / fontSizeScale;
            scaledY = 0;
          }
          let measure;
          if (font.remeasure && width > 0) {
            measure = ctx.measureText(character);
            const measuredWidth = measure.width * 1e3 / fontSize * fontSizeScale;
            if (width < measuredWidth && this.isFontSubpixelAAEnabled) {
              const characterScaleX = width / measuredWidth;
              restoreNeeded = true;
              ctx.save();
              ctx.scale(characterScaleX, 1);
              scaledX /= characterScaleX;
            } else if (width !== measuredWidth) {
              scaledX += (width - measuredWidth) / 2e3 * fontSize / fontSizeScale;
            }
          }
          if (this.contentVisible && (glyph.isInFont || font.missingFile)) {
            if (simpleFillText && !accent) {
              ctx.fillText(character, scaledX, scaledY);
              this.dependencyTracker?.recordCharacterBBox(opIdx, ctx, measure ? {
                bbox: null
              } : font, fontSize / fontSizeScale, scaledX, scaledY, () => measure ?? ctx.measureText(character));
            } else {
              this.paintChar(opIdx, character, scaledX, scaledY, patternFillTransform, patternStrokeTransform);
              if (accent) {
                const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;
                const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;
                this.paintChar(opIdx, accent.fontChar, scaledAccentX, scaledAccentY, patternFillTransform, patternStrokeTransform);
              }
            }
          }
          const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;
          x += charWidth;
          if (restoreNeeded) {
            ctx.restore();
          }
        }
        if (vertical) {
          current.y -= x;
        } else {
          current.x += x * textHScale;
        }
        ctx.restore();
        this.compose();
        this.dependencyTracker?.recordShowTextOperation(opIdx);
        return void 0;
      }
      showType3Text(opIdx, glyphs) {
        const ctx = this.ctx;
        const current = this.current;
        const font = current.font;
        const fontSize = current.fontSize;
        const fontDirection = current.fontDirection;
        const spacingDir = font.vertical ? 1 : -1;
        const charSpacing = current.charSpacing;
        const wordSpacing = current.wordSpacing;
        const textHScale = current.textHScale * fontDirection;
        const fontMatrix = current.fontMatrix || FONT_IDENTITY_MATRIX;
        const glyphsLength = glyphs.length;
        const isTextInvisible = current.textRenderingMode === TextRenderingMode.INVISIBLE;
        let i, glyph, width, spacingLength;
        if (isTextInvisible || fontSize === 0) {
          return;
        }
        this._cachedScaleForStroking[0] = -1;
        this._cachedGetSinglePixelWidth = null;
        ctx.save();
        if (current.textMatrix) {
          ctx.transform(...current.textMatrix);
        }
        ctx.translate(current.x, current.y + current.textRise);
        ctx.scale(textHScale, fontDirection);
        const dependencyTracker = this.dependencyTracker;
        this.dependencyTracker = dependencyTracker ? new CanvasNestedDependencyTracker(dependencyTracker, opIdx) : null;
        for (i = 0; i < glyphsLength; ++i) {
          glyph = glyphs[i];
          if (typeof glyph === "number") {
            spacingLength = spacingDir * glyph * fontSize / 1e3;
            this.ctx.translate(spacingLength, 0);
            current.x += spacingLength * textHScale;
            continue;
          }
          const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;
          const operatorList = font.charProcOperatorList[glyph.operatorListId];
          if (!operatorList) {
            warn(`Type3 character "${glyph.operatorListId}" is not available.`);
          } else if (this.contentVisible) {
            this.save();
            ctx.scale(fontSize, fontSize);
            ctx.transform(...fontMatrix);
            this.executeOperatorList(operatorList);
            this.restore();
          }
          const p = [glyph.width, 0];
          Util.applyTransform(p, fontMatrix);
          width = p[0] * fontSize + spacing;
          ctx.translate(width, 0);
          current.x += width * textHScale;
        }
        ctx.restore();
        if (dependencyTracker) {
          this.dependencyTracker = dependencyTracker;
        }
      }
      setCharWidth(opIdx, xWidth, yWidth) {
      }
      setCharWidthAndBounds(opIdx, xWidth, yWidth, llx, lly, urx, ury) {
        const clip = new Path2D();
        clip.rect(llx, lly, urx - llx, ury - lly);
        this.ctx.clip(clip);
        this.dependencyTracker?.recordBBox(opIdx, this.ctx, llx, urx, lly, ury).recordClipBox(opIdx, this.ctx, llx, urx, lly, ury);
        this.endPath(opIdx);
      }
      getColorN_Pattern(opIdx, IR) {
        let pattern;
        if (IR[0] === "TilingPattern") {
          const baseTransform = this.baseTransform || getCurrentTransform(this.ctx);
          const canvasGraphicsFactory = {
            createCanvasGraphics: (ctx, renderingOpIdx) => new _CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
              optionalContentConfig: this.optionalContentConfig,
              markedContentStack: this.markedContentStack
            }, void 0, void 0, this.dependencyTracker ? new CanvasNestedDependencyTracker(this.dependencyTracker, renderingOpIdx, true) : null)
          };
          pattern = new TilingPattern(IR, this.ctx, canvasGraphicsFactory, baseTransform);
        } else {
          pattern = this._getPattern(opIdx, IR[1], IR[2]);
        }
        return pattern;
      }
      setStrokeColorN(opIdx, ...args) {
        this.dependencyTracker?.recordSimpleData("strokeColor", opIdx);
        this.current.strokeColor = this.getColorN_Pattern(opIdx, args);
        this.current.patternStroke = true;
      }
      setFillColorN(opIdx, ...args) {
        this.dependencyTracker?.recordSimpleData("fillColor", opIdx);
        this.current.fillColor = this.getColorN_Pattern(opIdx, args);
        this.current.patternFill = true;
      }
      setStrokeRGBColor(opIdx, color) {
        this.dependencyTracker?.recordSimpleData("strokeColor", opIdx);
        this.ctx.strokeStyle = this.current.strokeColor = color;
        this.current.patternStroke = false;
      }
      setStrokeTransparent(opIdx) {
        this.dependencyTracker?.recordSimpleData("strokeColor", opIdx);
        this.ctx.strokeStyle = this.current.strokeColor = "transparent";
        this.current.patternStroke = false;
      }
      setFillRGBColor(opIdx, color) {
        this.dependencyTracker?.recordSimpleData("fillColor", opIdx);
        this.ctx.fillStyle = this.current.fillColor = color;
        this.current.patternFill = false;
      }
      setFillTransparent(opIdx) {
        this.dependencyTracker?.recordSimpleData("fillColor", opIdx);
        this.ctx.fillStyle = this.current.fillColor = "transparent";
        this.current.patternFill = false;
      }
      _getPattern(opIdx, objId, matrix = null) {
        let pattern;
        if (this.cachedPatterns.has(objId)) {
          pattern = this.cachedPatterns.get(objId);
        } else {
          pattern = getShadingPattern(this.getObject(opIdx, objId));
          this.cachedPatterns.set(objId, pattern);
        }
        if (matrix) {
          pattern.matrix = matrix;
        }
        return pattern;
      }
      shadingFill(opIdx, objId) {
        if (!this.contentVisible) {
          return;
        }
        const ctx = this.ctx;
        this.save(opIdx);
        const pattern = this._getPattern(opIdx, objId);
        ctx.fillStyle = pattern.getPattern(ctx, this, getCurrentTransformInverse(ctx), PathType.SHADING, opIdx);
        const inv = getCurrentTransformInverse(ctx);
        if (inv) {
          const {
            width,
            height
          } = ctx.canvas;
          const minMax = MIN_MAX_INIT.slice();
          Util.axialAlignedBoundingBox([0, 0, width, height], inv, minMax);
          const [x0, y0, x1, y1] = minMax;
          this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);
        } else {
          this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);
        }
        this.dependencyTracker?.resetBBox(opIdx).recordFullPageBBox(opIdx).recordDependencies(opIdx, Dependencies.transform).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);
        this.compose(this.current.getClippedPathBoundingBox());
        this.restore(opIdx);
      }
      beginInlineImage() {
        unreachable("Should not call beginInlineImage");
      }
      beginImageData() {
        unreachable("Should not call beginImageData");
      }
      paintFormXObjectBegin(opIdx, matrix, bbox) {
        if (!this.contentVisible) {
          return;
        }
        this.save(opIdx);
        this.baseTransformStack.push(this.baseTransform);
        if (matrix) {
          this.transform(opIdx, ...matrix);
        }
        this.baseTransform = getCurrentTransform(this.ctx);
        if (bbox) {
          Util.axialAlignedBoundingBox(bbox, this.baseTransform, this.current.minMax);
          const [x0, y0, x1, y1] = bbox;
          const clip = new Path2D();
          clip.rect(x0, y0, x1 - x0, y1 - y0);
          this.ctx.clip(clip);
          this.dependencyTracker?.recordClipBox(opIdx, this.ctx, x0, x1, y0, y1);
          this.endPath(opIdx);
        }
      }
      paintFormXObjectEnd(opIdx) {
        if (!this.contentVisible) {
          return;
        }
        this.restore(opIdx);
        this.baseTransform = this.baseTransformStack.pop();
      }
      beginGroup(opIdx, group2) {
        if (!this.contentVisible) {
          return;
        }
        this.save(opIdx);
        if (this.inSMaskMode) {
          this.endSMaskMode();
          this.current.activeSMask = null;
        }
        const currentCtx = this.ctx;
        if (!group2.isolated) {
          info("TODO: Support non-isolated groups.");
        }
        if (group2.knockout) {
          warn("Knockout groups not supported.");
        }
        const currentTransform = getCurrentTransform(currentCtx);
        if (group2.matrix) {
          currentCtx.transform(...group2.matrix);
        }
        if (!group2.bbox) {
          throw new Error("Bounding box is required.");
        }
        let bounds = MIN_MAX_INIT.slice();
        Util.axialAlignedBoundingBox(group2.bbox, getCurrentTransform(currentCtx), bounds);
        const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];
        bounds = Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];
        const offsetX = Math.floor(bounds[0]);
        const offsetY = Math.floor(bounds[1]);
        const drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);
        const drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);
        this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);
        let cacheId = "groupAt" + this.groupLevel;
        if (group2.smask) {
          cacheId += "_smask_" + this.smaskCounter++ % 2;
        }
        const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);
        const groupCtx = scratchCanvas.context;
        groupCtx.translate(-offsetX, -offsetY);
        groupCtx.transform(...currentTransform);
        let clip = new Path2D();
        const [x0, y0, x1, y1] = group2.bbox;
        clip.rect(x0, y0, x1 - x0, y1 - y0);
        if (group2.matrix) {
          const path = new Path2D();
          path.addPath(clip, new DOMMatrix(group2.matrix));
          clip = path;
        }
        groupCtx.clip(clip);
        if (group2.smask) {
          this.smaskStack.push({
            canvas: scratchCanvas.canvas,
            context: groupCtx,
            offsetX,
            offsetY,
            subtype: group2.smask.subtype,
            backdrop: group2.smask.backdrop,
            transferMap: group2.smask.transferMap || null,
            startTransformInverse: null
          });
        }
        if (!group2.smask || this.dependencyTracker) {
          currentCtx.setTransform(1, 0, 0, 1, 0, 0);
          currentCtx.translate(offsetX, offsetY);
          currentCtx.save();
        }
        copyCtxState(currentCtx, groupCtx);
        this.ctx = groupCtx;
        this.dependencyTracker?.inheritSimpleDataAsFutureForcedDependencies(["fillAlpha", "strokeAlpha", "globalCompositeOperation"]).pushBaseTransform(currentCtx);
        this.setGState(opIdx, [["BM", "source-over"], ["ca", 1], ["CA", 1]]);
        this.groupStack.push(currentCtx);
        this.groupLevel++;
      }
      endGroup(opIdx, group2) {
        if (!this.contentVisible) {
          return;
        }
        this.groupLevel--;
        const groupCtx = this.ctx;
        const ctx = this.groupStack.pop();
        this.ctx = ctx;
        this.ctx.imageSmoothingEnabled = false;
        this.dependencyTracker?.popBaseTransform();
        if (group2.smask) {
          this.tempSMask = this.smaskStack.pop();
          this.restore(opIdx);
          if (this.dependencyTracker) {
            this.ctx.restore();
          }
        } else {
          this.ctx.restore();
          const currentMtx = getCurrentTransform(this.ctx);
          this.restore(opIdx);
          this.ctx.save();
          this.ctx.setTransform(...currentMtx);
          const dirtyBox = MIN_MAX_INIT.slice();
          Util.axialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx, dirtyBox);
          this.ctx.drawImage(groupCtx.canvas, 0, 0);
          this.ctx.restore();
          this.compose(dirtyBox);
        }
      }
      beginAnnotation(opIdx, id, rect, transform, matrix, hasOwnCanvas) {
        this.#restoreInitialState();
        resetCtxToDefault(this.ctx);
        this.ctx.save();
        this.save(opIdx);
        if (this.baseTransform) {
          this.ctx.setTransform(...this.baseTransform);
        }
        if (rect) {
          const width = rect[2] - rect[0];
          const height = rect[3] - rect[1];
          if (hasOwnCanvas && this.annotationCanvasMap) {
            transform = transform.slice();
            transform[4] -= rect[0];
            transform[5] -= rect[1];
            rect = rect.slice();
            rect[0] = rect[1] = 0;
            rect[2] = width;
            rect[3] = height;
            Util.singularValueDecompose2dScale(getCurrentTransform(this.ctx), XY);
            const {
              viewportScale
            } = this;
            const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);
            const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);
            this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);
            const {
              canvas,
              context
            } = this.annotationCanvas;
            this.annotationCanvasMap.set(id, canvas);
            this.annotationCanvas.savedCtx = this.ctx;
            this.ctx = context;
            this.ctx.save();
            this.ctx.setTransform(XY[0], 0, 0, -XY[1], 0, height * XY[1]);
            resetCtxToDefault(this.ctx);
          } else {
            resetCtxToDefault(this.ctx);
            this.endPath(opIdx);
            const clip = new Path2D();
            clip.rect(rect[0], rect[1], width, height);
            this.ctx.clip(clip);
          }
        }
        this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);
        this.transform(opIdx, ...transform);
        this.transform(opIdx, ...matrix);
      }
      endAnnotation(opIdx) {
        if (this.annotationCanvas) {
          this.ctx.restore();
          this.#drawFilter();
          this.ctx = this.annotationCanvas.savedCtx;
          delete this.annotationCanvas.savedCtx;
          delete this.annotationCanvas;
        }
      }
      paintImageMaskXObject(opIdx, img) {
        if (!this.contentVisible) {
          return;
        }
        const count = img.count;
        img = this.getObject(opIdx, img.data, img);
        img.count = count;
        const ctx = this.ctx;
        const mask = this._createMaskCanvas(opIdx, img);
        const maskCanvas = mask.canvas;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);
        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, mask.offsetX, mask.offsetX + maskCanvas.width, mask.offsetY, mask.offsetY + maskCanvas.height).recordOperation(opIdx);
        ctx.restore();
        this.compose();
      }
      paintImageMaskXObjectRepeat(opIdx, img, scaleX, skewX = 0, skewY = 0, scaleY, positions) {
        if (!this.contentVisible) {
          return;
        }
        img = this.getObject(opIdx, img.data, img);
        const ctx = this.ctx;
        ctx.save();
        const currentTransform = getCurrentTransform(ctx);
        ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);
        const mask = this._createMaskCanvas(opIdx, img);
        ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);
        this.dependencyTracker?.resetBBox(opIdx);
        for (let i = 0, ii = positions.length; i < ii; i += 2) {
          const trans = Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);
          ctx.drawImage(mask.canvas, trans[4], trans[5]);
          this.dependencyTracker?.recordBBox(opIdx, this.ctx, trans[4], trans[4] + mask.canvas.width, trans[5], trans[5] + mask.canvas.height);
        }
        ctx.restore();
        this.compose();
        this.dependencyTracker?.recordOperation(opIdx);
      }
      paintImageMaskXObjectGroup(opIdx, images) {
        if (!this.contentVisible) {
          return;
        }
        const ctx = this.ctx;
        const fillColor = this.current.fillColor;
        const isPatternFill = this.current.patternFill;
        this.dependencyTracker?.resetBBox(opIdx).recordDependencies(opIdx, Dependencies.transformAndFill);
        for (const image of images) {
          const {
            data,
            width,
            height,
            transform
          } = image;
          const maskCanvas = this.cachedCanvases.getCanvas("maskCanvas", width, height);
          const maskCtx = maskCanvas.context;
          maskCtx.save();
          const img = this.getObject(opIdx, data, image);
          putBinaryImageMask(maskCtx, img);
          maskCtx.globalCompositeOperation = "source-in";
          maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, getCurrentTransformInverse(ctx), PathType.FILL, opIdx) : fillColor;
          maskCtx.fillRect(0, 0, width, height);
          maskCtx.restore();
          ctx.save();
          ctx.transform(...transform);
          ctx.scale(1, -1);
          drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);
          this.dependencyTracker?.recordBBox(opIdx, ctx, 0, width, 0, height);
          ctx.restore();
        }
        this.compose();
        this.dependencyTracker?.recordOperation(opIdx);
      }
      paintImageXObject(opIdx, objId) {
        if (!this.contentVisible) {
          return;
        }
        const imgData = this.getObject(opIdx, objId);
        if (!imgData) {
          warn("Dependent image isn't ready yet");
          return;
        }
        this.paintInlineImageXObject(opIdx, imgData);
      }
      paintImageXObjectRepeat(opIdx, objId, scaleX, scaleY, positions) {
        if (!this.contentVisible) {
          return;
        }
        const imgData = this.getObject(opIdx, objId);
        if (!imgData) {
          warn("Dependent image isn't ready yet");
          return;
        }
        const width = imgData.width;
        const height = imgData.height;
        const map2 = [];
        for (let i = 0, ii = positions.length; i < ii; i += 2) {
          map2.push({
            transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],
            x: 0,
            y: 0,
            w: width,
            h: height
          });
        }
        this.paintInlineImageXObjectGroup(opIdx, imgData, map2);
      }
      applyTransferMapsToCanvas(ctx) {
        if (this.current.transferMaps !== "none") {
          ctx.filter = this.current.transferMaps;
          ctx.drawImage(ctx.canvas, 0, 0);
          ctx.filter = "none";
        }
        return ctx.canvas;
      }
      applyTransferMapsToBitmap(imgData) {
        if (this.current.transferMaps === "none") {
          return imgData.bitmap;
        }
        const {
          bitmap,
          width,
          height
        } = imgData;
        const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
        const tmpCtx = tmpCanvas.context;
        tmpCtx.filter = this.current.transferMaps;
        tmpCtx.drawImage(bitmap, 0, 0);
        tmpCtx.filter = "none";
        return tmpCanvas.canvas;
      }
      paintInlineImageXObject(opIdx, imgData) {
        if (!this.contentVisible) {
          return;
        }
        const width = imgData.width;
        const height = imgData.height;
        const ctx = this.ctx;
        this.save(opIdx);
        const {
          filter: filter2
        } = ctx;
        if (filter2 !== "none" && filter2 !== "") {
          ctx.filter = "none";
        }
        ctx.scale(1 / width, -1 / height);
        let imgToPaint;
        if (imgData.bitmap) {
          imgToPaint = this.applyTransferMapsToBitmap(imgData);
        } else if (typeof HTMLElement === "function" && imgData instanceof HTMLElement || !imgData.data) {
          imgToPaint = imgData;
        } else {
          const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", width, height);
          const tmpCtx = tmpCanvas.context;
          putBinaryImageData(tmpCtx, imgData);
          imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
        }
        const scaled = this._scaleImage(imgToPaint, getCurrentTransformInverse(ctx));
        ctx.imageSmoothingEnabled = getImageSmoothingEnabled(getCurrentTransform(ctx), imgData.interpolate);
        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, ctx, 0, width, -height, 0).recordDependencies(opIdx, Dependencies.imageXObject).recordOperation(opIdx);
        drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);
        this.compose();
        this.restore(opIdx);
      }
      paintInlineImageXObjectGroup(opIdx, imgData, map2) {
        if (!this.contentVisible) {
          return;
        }
        const ctx = this.ctx;
        let imgToPaint;
        if (imgData.bitmap) {
          imgToPaint = imgData.bitmap;
        } else {
          const w = imgData.width;
          const h = imgData.height;
          const tmpCanvas = this.cachedCanvases.getCanvas("inlineImage", w, h);
          const tmpCtx = tmpCanvas.context;
          putBinaryImageData(tmpCtx, imgData);
          imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);
        }
        this.dependencyTracker?.resetBBox(opIdx);
        for (const entry of map2) {
          ctx.save();
          ctx.transform(...entry.transform);
          ctx.scale(1, -1);
          drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);
          this.dependencyTracker?.recordBBox(opIdx, ctx, 0, 1, -1, 0);
          ctx.restore();
        }
        this.dependencyTracker?.recordOperation(opIdx);
        this.compose();
      }
      paintSolidColorImageMask(opIdx) {
        if (!this.contentVisible) {
          return;
        }
        this.dependencyTracker?.resetBBox(opIdx).recordBBox(opIdx, this.ctx, 0, 1, 0, 1).recordDependencies(opIdx, Dependencies.fill).recordOperation(opIdx);
        this.ctx.fillRect(0, 0, 1, 1);
        this.compose();
      }
      markPoint(opIdx, tag) {
      }
      markPointProps(opIdx, tag, properties) {
      }
      beginMarkedContent(opIdx, tag) {
        this.dependencyTracker?.beginMarkedContent(opIdx);
        this.markedContentStack.push({
          visible: true
        });
      }
      beginMarkedContentProps(opIdx, tag, properties) {
        this.dependencyTracker?.beginMarkedContent(opIdx);
        if (tag === "OC") {
          this.markedContentStack.push({
            visible: this.optionalContentConfig.isVisible(properties)
          });
        } else {
          this.markedContentStack.push({
            visible: true
          });
        }
        this.contentVisible = this.isContentVisible();
      }
      endMarkedContent(opIdx) {
        this.dependencyTracker?.endMarkedContent(opIdx);
        this.markedContentStack.pop();
        this.contentVisible = this.isContentVisible();
      }
      beginCompat(opIdx) {
      }
      endCompat(opIdx) {
      }
      consumePath(opIdx, path, clipBox) {
        const isEmpty2 = this.current.isEmptyClip();
        if (this.pendingClip) {
          this.current.updateClipFromPath();
        }
        if (!this.pendingClip) {
          this.compose(clipBox);
        }
        const ctx = this.ctx;
        if (this.pendingClip) {
          if (!isEmpty2) {
            if (this.pendingClip === EO_CLIP) {
              ctx.clip(path, "evenodd");
            } else {
              ctx.clip(path);
            }
          }
          this.pendingClip = null;
          this.dependencyTracker?.bboxToClipBoxDropOperation(opIdx).recordFutureForcedDependency("clipPath", opIdx);
        } else {
          this.dependencyTracker?.recordOperation(opIdx);
        }
        this.current.startNewPathAndClipBox(this.current.clipBox);
      }
      getSinglePixelWidth() {
        if (!this._cachedGetSinglePixelWidth) {
          const m = getCurrentTransform(this.ctx);
          if (m[1] === 0 && m[2] === 0) {
            this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));
          } else {
            const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);
            const normX = Math.hypot(m[0], m[2]);
            const normY = Math.hypot(m[1], m[3]);
            this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;
          }
        }
        return this._cachedGetSinglePixelWidth;
      }
      getScaleForStroking() {
        if (this._cachedScaleForStroking[0] === -1) {
          const {
            lineWidth
          } = this.current;
          const {
            a,
            b,
            c,
            d
          } = this.ctx.getTransform();
          let scaleX, scaleY;
          if (b === 0 && c === 0) {
            const normX = Math.abs(a);
            const normY = Math.abs(d);
            if (normX === normY) {
              if (lineWidth === 0) {
                scaleX = scaleY = 1 / normX;
              } else {
                const scaledLineWidth = normX * lineWidth;
                scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;
              }
            } else if (lineWidth === 0) {
              scaleX = 1 / normX;
              scaleY = 1 / normY;
            } else {
              const scaledXLineWidth = normX * lineWidth;
              const scaledYLineWidth = normY * lineWidth;
              scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;
              scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;
            }
          } else {
            const absDet = Math.abs(a * d - b * c);
            const normX = Math.hypot(a, b);
            const normY = Math.hypot(c, d);
            if (lineWidth === 0) {
              scaleX = normY / absDet;
              scaleY = normX / absDet;
            } else {
              const baseArea = lineWidth * absDet;
              scaleX = normY > baseArea ? normY / baseArea : 1;
              scaleY = normX > baseArea ? normX / baseArea : 1;
            }
          }
          this._cachedScaleForStroking[0] = scaleX;
          this._cachedScaleForStroking[1] = scaleY;
        }
        return this._cachedScaleForStroking;
      }
      rescaleAndStroke(path, saveRestore) {
        const {
          ctx,
          current: {
            lineWidth
          }
        } = this;
        const [scaleX, scaleY] = this.getScaleForStroking();
        if (scaleX === scaleY) {
          ctx.lineWidth = (lineWidth || 1) * scaleX;
          ctx.stroke(path);
          return;
        }
        const dashes = ctx.getLineDash();
        if (saveRestore) {
          ctx.save();
        }
        ctx.scale(scaleX, scaleY);
        SCALE_MATRIX.a = 1 / scaleX;
        SCALE_MATRIX.d = 1 / scaleY;
        const newPath = new Path2D();
        newPath.addPath(path, SCALE_MATRIX);
        if (dashes.length > 0) {
          const scale = Math.max(scaleX, scaleY);
          ctx.setLineDash(dashes.map((x) => x / scale));
          ctx.lineDashOffset /= scale;
        }
        ctx.lineWidth = lineWidth || 1;
        ctx.stroke(newPath);
        if (saveRestore) {
          ctx.restore();
        }
      }
      isContentVisible() {
        for (let i = this.markedContentStack.length - 1; i >= 0; i--) {
          if (!this.markedContentStack[i].visible) {
            return false;
          }
        }
        return true;
      }
    };
    for (const op in OPS) {
      if (CanvasGraphics.prototype[op] !== void 0) {
        CanvasGraphics.prototype[OPS[op]] = CanvasGraphics.prototype[op];
      }
    }
    CssFontInfo = class _CssFontInfo {
      #buffer;
      #view;
      #decoder;
      static strings = ["fontFamily", "fontWeight", "italicAngle"];
      static write(info2) {
        const encoder = new TextEncoder();
        const encodedStrings = {};
        let stringsLength = 0;
        for (const prop of _CssFontInfo.strings) {
          const encoded = encoder.encode(info2[prop]);
          encodedStrings[prop] = encoded;
          stringsLength += 4 + encoded.length;
        }
        const buffer = new ArrayBuffer(stringsLength);
        const data = new Uint8Array(buffer);
        const view = new DataView(buffer);
        let offset = 0;
        for (const prop of _CssFontInfo.strings) {
          const encoded = encodedStrings[prop];
          const length = encoded.length;
          view.setUint32(offset, length);
          data.set(encoded, offset + 4);
          offset += 4 + length;
        }
        assert(offset === buffer.byteLength, "CssFontInfo.write: Buffer overflow");
        return buffer;
      }
      constructor(buffer) {
        this.#buffer = buffer;
        this.#view = new DataView(this.#buffer);
        this.#decoder = new TextDecoder();
      }
      #readString(index) {
        assert(index < _CssFontInfo.strings.length, "Invalid string index");
        let offset = 0;
        for (let i = 0; i < index; i++) {
          offset += this.#view.getUint32(offset) + 4;
        }
        const length = this.#view.getUint32(offset);
        return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));
      }
      get fontFamily() {
        return this.#readString(0);
      }
      get fontWeight() {
        return this.#readString(1);
      }
      get italicAngle() {
        return this.#readString(2);
      }
    };
    SystemFontInfo = class _SystemFontInfo {
      #buffer;
      #view;
      #decoder;
      static strings = ["css", "loadedName", "baseFontName", "src"];
      static write(info2) {
        const encoder = new TextEncoder();
        const encodedStrings = {};
        let stringsLength = 0;
        for (const prop of _SystemFontInfo.strings) {
          const encoded = encoder.encode(info2[prop]);
          encodedStrings[prop] = encoded;
          stringsLength += 4 + encoded.length;
        }
        stringsLength += 4;
        let encodedStyleStyle, encodedStyleWeight, lengthEstimate = 1 + stringsLength;
        if (info2.style) {
          encodedStyleStyle = encoder.encode(info2.style.style);
          encodedStyleWeight = encoder.encode(info2.style.weight);
          lengthEstimate += 4 + encodedStyleStyle.length + 4 + encodedStyleWeight.length;
        }
        const buffer = new ArrayBuffer(lengthEstimate);
        const data = new Uint8Array(buffer);
        const view = new DataView(buffer);
        let offset = 0;
        view.setUint8(offset++, info2.guessFallback ? 1 : 0);
        view.setUint32(offset, 0);
        offset += 4;
        stringsLength = 0;
        for (const prop of _SystemFontInfo.strings) {
          const encoded = encodedStrings[prop];
          const length = encoded.length;
          stringsLength += 4 + length;
          view.setUint32(offset, length);
          data.set(encoded, offset + 4);
          offset += 4 + length;
        }
        view.setUint32(offset - stringsLength - 4, stringsLength);
        if (info2.style) {
          view.setUint32(offset, encodedStyleStyle.length);
          data.set(encodedStyleStyle, offset + 4);
          offset += 4 + encodedStyleStyle.length;
          view.setUint32(offset, encodedStyleWeight.length);
          data.set(encodedStyleWeight, offset + 4);
          offset += 4 + encodedStyleWeight.length;
        }
        assert(offset <= buffer.byteLength, "SubstitionInfo.write: Buffer overflow");
        return buffer.transferToFixedLength(offset);
      }
      constructor(buffer) {
        this.#buffer = buffer;
        this.#view = new DataView(this.#buffer);
        this.#decoder = new TextDecoder();
      }
      get guessFallback() {
        return this.#view.getUint8(0) !== 0;
      }
      #readString(index) {
        assert(index < _SystemFontInfo.strings.length, "Invalid string index");
        let offset = 5;
        for (let i = 0; i < index; i++) {
          offset += this.#view.getUint32(offset) + 4;
        }
        const length = this.#view.getUint32(offset);
        return this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, length));
      }
      get css() {
        return this.#readString(0);
      }
      get loadedName() {
        return this.#readString(1);
      }
      get baseFontName() {
        return this.#readString(2);
      }
      get src() {
        return this.#readString(3);
      }
      get style() {
        let offset = 1;
        offset += 4 + this.#view.getUint32(offset);
        const styleLength = this.#view.getUint32(offset);
        const style = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, styleLength));
        offset += 4 + styleLength;
        const weightLength = this.#view.getUint32(offset);
        const weight = this.#decoder.decode(new Uint8Array(this.#buffer, offset + 4, weightLength));
        return {
          style,
          weight
        };
      }
    };
    FontInfo = class _FontInfo {
      static bools = ["black", "bold", "disableFontFace", "fontExtraProperties", "isInvalidPDFjsFont", "isType3Font", "italic", "missingFile", "remeasure", "vertical"];
      static numbers = ["ascent", "defaultWidth", "descent"];
      static strings = ["fallbackName", "loadedName", "mimetype", "name"];
      static #OFFSET_NUMBERS = Math.ceil(this.bools.length * 2 / 8);
      static #OFFSET_BBOX = this.#OFFSET_NUMBERS + this.numbers.length * 8;
      static #OFFSET_FONT_MATRIX = this.#OFFSET_BBOX + 1 + 2 * 4;
      static #OFFSET_DEFAULT_VMETRICS = this.#OFFSET_FONT_MATRIX + 1 + 8 * 6;
      static #OFFSET_STRINGS = this.#OFFSET_DEFAULT_VMETRICS + 1 + 2 * 3;
      #buffer;
      #decoder;
      #view;
      constructor({
        data,
        extra
      }) {
        this.#buffer = data;
        this.#decoder = new TextDecoder();
        this.#view = new DataView(this.#buffer);
        if (extra) {
          Object.assign(this, extra);
        }
      }
      #readBoolean(index) {
        assert(index < _FontInfo.bools.length, "Invalid boolean index");
        const byteOffset = Math.floor(index / 4);
        const bitOffset = index * 2 % 8;
        const value = this.#view.getUint8(byteOffset) >> bitOffset & 3;
        return value === 0 ? void 0 : value === 2;
      }
      get black() {
        return this.#readBoolean(0);
      }
      get bold() {
        return this.#readBoolean(1);
      }
      get disableFontFace() {
        return this.#readBoolean(2);
      }
      get fontExtraProperties() {
        return this.#readBoolean(3);
      }
      get isInvalidPDFjsFont() {
        return this.#readBoolean(4);
      }
      get isType3Font() {
        return this.#readBoolean(5);
      }
      get italic() {
        return this.#readBoolean(6);
      }
      get missingFile() {
        return this.#readBoolean(7);
      }
      get remeasure() {
        return this.#readBoolean(8);
      }
      get vertical() {
        return this.#readBoolean(9);
      }
      #readNumber(index) {
        assert(index < _FontInfo.numbers.length, "Invalid number index");
        return this.#view.getFloat64(_FontInfo.#OFFSET_NUMBERS + index * 8);
      }
      get ascent() {
        return this.#readNumber(0);
      }
      get defaultWidth() {
        return this.#readNumber(1);
      }
      get descent() {
        return this.#readNumber(2);
      }
      get bbox() {
        let offset = _FontInfo.#OFFSET_BBOX;
        const numCoords = this.#view.getUint8(offset);
        if (numCoords === 0) {
          return void 0;
        }
        offset += 1;
        const bbox = [];
        for (let i = 0; i < 4; i++) {
          bbox.push(this.#view.getInt16(offset, true));
          offset += 2;
        }
        return bbox;
      }
      get fontMatrix() {
        let offset = _FontInfo.#OFFSET_FONT_MATRIX;
        const numPoints = this.#view.getUint8(offset);
        if (numPoints === 0) {
          return void 0;
        }
        offset += 1;
        const fontMatrix = [];
        for (let i = 0; i < 6; i++) {
          fontMatrix.push(this.#view.getFloat64(offset, true));
          offset += 8;
        }
        return fontMatrix;
      }
      get defaultVMetrics() {
        let offset = _FontInfo.#OFFSET_DEFAULT_VMETRICS;
        const numMetrics = this.#view.getUint8(offset);
        if (numMetrics === 0) {
          return void 0;
        }
        offset += 1;
        const defaultVMetrics = [];
        for (let i = 0; i < 3; i++) {
          defaultVMetrics.push(this.#view.getInt16(offset, true));
          offset += 2;
        }
        return defaultVMetrics;
      }
      #readString(index) {
        assert(index < _FontInfo.strings.length, "Invalid string index");
        let offset = _FontInfo.#OFFSET_STRINGS + 4;
        for (let i = 0; i < index; i++) {
          offset += this.#view.getUint32(offset) + 4;
        }
        const length = this.#view.getUint32(offset);
        const stringData = new Uint8Array(length);
        stringData.set(new Uint8Array(this.#buffer, offset + 4, length));
        return this.#decoder.decode(stringData);
      }
      get fallbackName() {
        return this.#readString(0);
      }
      get loadedName() {
        return this.#readString(1);
      }
      get mimetype() {
        return this.#readString(2);
      }
      get name() {
        return this.#readString(3);
      }
      get data() {
        let offset = _FontInfo.#OFFSET_STRINGS;
        const stringsLength = this.#view.getUint32(offset);
        offset += 4 + stringsLength;
        const systemFontInfoLength = this.#view.getUint32(offset);
        offset += 4 + systemFontInfoLength;
        const cssFontInfoLength = this.#view.getUint32(offset);
        offset += 4 + cssFontInfoLength;
        const length = this.#view.getUint32(offset);
        if (length === 0) {
          return void 0;
        }
        return new Uint8Array(this.#buffer, offset + 4, length);
      }
      clearData() {
        let offset = _FontInfo.#OFFSET_STRINGS;
        const stringsLength = this.#view.getUint32(offset);
        offset += 4 + stringsLength;
        const systemFontInfoLength = this.#view.getUint32(offset);
        offset += 4 + systemFontInfoLength;
        const cssFontInfoLength = this.#view.getUint32(offset);
        offset += 4 + cssFontInfoLength;
        const length = this.#view.getUint32(offset);
        const data = new Uint8Array(this.#buffer, offset + 4, length);
        data.fill(0);
        this.#view.setUint32(offset, 0);
      }
      get cssFontInfo() {
        let offset = _FontInfo.#OFFSET_STRINGS;
        const stringsLength = this.#view.getUint32(offset);
        offset += 4 + stringsLength;
        const systemFontInfoLength = this.#view.getUint32(offset);
        offset += 4 + systemFontInfoLength;
        const cssFontInfoLength = this.#view.getUint32(offset);
        if (cssFontInfoLength === 0) {
          return null;
        }
        const cssFontInfoData = new Uint8Array(cssFontInfoLength);
        cssFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, cssFontInfoLength));
        return new CssFontInfo(cssFontInfoData.buffer);
      }
      get systemFontInfo() {
        let offset = _FontInfo.#OFFSET_STRINGS;
        const stringsLength = this.#view.getUint32(offset);
        offset += 4 + stringsLength;
        const systemFontInfoLength = this.#view.getUint32(offset);
        if (systemFontInfoLength === 0) {
          return null;
        }
        const systemFontInfoData = new Uint8Array(systemFontInfoLength);
        systemFontInfoData.set(new Uint8Array(this.#buffer, offset + 4, systemFontInfoLength));
        return new SystemFontInfo(systemFontInfoData.buffer);
      }
      static write(font) {
        const systemFontInfoBuffer = font.systemFontInfo ? SystemFontInfo.write(font.systemFontInfo) : null;
        const cssFontInfoBuffer = font.cssFontInfo ? CssFontInfo.write(font.cssFontInfo) : null;
        const encoder = new TextEncoder();
        const encodedStrings = {};
        let stringsLength = 0;
        for (const prop of _FontInfo.strings) {
          encodedStrings[prop] = encoder.encode(font[prop]);
          stringsLength += 4 + encodedStrings[prop].length;
        }
        const lengthEstimate = _FontInfo.#OFFSET_STRINGS + 4 + stringsLength + 4 + (systemFontInfoBuffer ? systemFontInfoBuffer.byteLength : 0) + 4 + (cssFontInfoBuffer ? cssFontInfoBuffer.byteLength : 0) + 4 + (font.data ? font.data.length : 0);
        const buffer = new ArrayBuffer(lengthEstimate);
        const data = new Uint8Array(buffer);
        const view = new DataView(buffer);
        let offset = 0;
        const numBools = _FontInfo.bools.length;
        let boolByte = 0, boolBit = 0;
        for (let i = 0; i < numBools; i++) {
          const value = font[_FontInfo.bools[i]];
          const bits = value === void 0 ? 0 : value ? 2 : 1;
          boolByte |= bits << boolBit;
          boolBit += 2;
          if (boolBit === 8 || i === numBools - 1) {
            view.setUint8(offset++, boolByte);
            boolByte = 0;
            boolBit = 0;
          }
        }
        assert(offset === _FontInfo.#OFFSET_NUMBERS, "FontInfo.write: Boolean properties offset mismatch");
        for (const prop of _FontInfo.numbers) {
          view.setFloat64(offset, font[prop]);
          offset += 8;
        }
        assert(offset === _FontInfo.#OFFSET_BBOX, "FontInfo.write: Number properties offset mismatch");
        if (font.bbox) {
          view.setUint8(offset++, 4);
          for (const coord of font.bbox) {
            view.setInt16(offset, coord, true);
            offset += 2;
          }
        } else {
          view.setUint8(offset++, 0);
          offset += 2 * 4;
        }
        assert(offset === _FontInfo.#OFFSET_FONT_MATRIX, "FontInfo.write: BBox properties offset mismatch");
        if (font.fontMatrix) {
          view.setUint8(offset++, 6);
          for (const point of font.fontMatrix) {
            view.setFloat64(offset, point, true);
            offset += 8;
          }
        } else {
          view.setUint8(offset++, 0);
          offset += 8 * 6;
        }
        assert(offset === _FontInfo.#OFFSET_DEFAULT_VMETRICS, "FontInfo.write: FontMatrix properties offset mismatch");
        if (font.defaultVMetrics) {
          view.setUint8(offset++, 1);
          for (const metric of font.defaultVMetrics) {
            view.setInt16(offset, metric, true);
            offset += 2;
          }
        } else {
          view.setUint8(offset++, 0);
          offset += 3 * 2;
        }
        assert(offset === _FontInfo.#OFFSET_STRINGS, "FontInfo.write: DefaultVMetrics properties offset mismatch");
        view.setUint32(_FontInfo.#OFFSET_STRINGS, 0);
        offset += 4;
        for (const prop of _FontInfo.strings) {
          const encoded = encodedStrings[prop];
          const length = encoded.length;
          view.setUint32(offset, length);
          data.set(encoded, offset + 4);
          offset += 4 + length;
        }
        view.setUint32(_FontInfo.#OFFSET_STRINGS, offset - _FontInfo.#OFFSET_STRINGS - 4);
        if (!systemFontInfoBuffer) {
          view.setUint32(offset, 0);
          offset += 4;
        } else {
          const length = systemFontInfoBuffer.byteLength;
          view.setUint32(offset, length);
          assert(offset + 4 + length <= buffer.byteLength, "FontInfo.write: Buffer overflow at systemFontInfo");
          data.set(new Uint8Array(systemFontInfoBuffer), offset + 4);
          offset += 4 + length;
        }
        if (!cssFontInfoBuffer) {
          view.setUint32(offset, 0);
          offset += 4;
        } else {
          const length = cssFontInfoBuffer.byteLength;
          view.setUint32(offset, length);
          assert(offset + 4 + length <= buffer.byteLength, "FontInfo.write: Buffer overflow at cssFontInfo");
          data.set(new Uint8Array(cssFontInfoBuffer), offset + 4);
          offset += 4 + length;
        }
        if (font.data === void 0) {
          view.setUint32(offset, 0);
          offset += 4;
        } else {
          view.setUint32(offset, font.data.length);
          data.set(font.data, offset + 4);
          offset += 4 + font.data.length;
        }
        assert(offset <= buffer.byteLength, "FontInfo.write: Buffer overflow");
        return buffer.transferToFixedLength(offset);
      }
    };
    GlobalWorkerOptions = class {
      static #port = null;
      static #src = "";
      static get workerPort() {
        return this.#port;
      }
      static set workerPort(val) {
        if (!(typeof Worker !== "undefined" && val instanceof Worker) && val !== null) {
          throw new Error("Invalid `workerPort` type.");
        }
        this.#port = val;
      }
      static get workerSrc() {
        return this.#src;
      }
      static set workerSrc(val) {
        if (typeof val !== "string") {
          throw new Error("Invalid `workerSrc` type.");
        }
        this.#src = val;
      }
    };
    Metadata = class {
      #map;
      #data;
      constructor({
        parsedData,
        rawData
      }) {
        this.#map = parsedData;
        this.#data = rawData;
      }
      getRaw() {
        return this.#data;
      }
      get(name) {
        return this.#map.get(name) ?? null;
      }
      [Symbol.iterator]() {
        return this.#map.entries();
      }
    };
    INTERNAL = Symbol("INTERNAL");
    OptionalContentGroup = class {
      #isDisplay = false;
      #isPrint = false;
      #userSet = false;
      #visible = true;
      constructor(renderingIntent, {
        name,
        intent,
        usage,
        rbGroups
      }) {
        this.#isDisplay = !!(renderingIntent & RenderingIntentFlag.DISPLAY);
        this.#isPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
        this.name = name;
        this.intent = intent;
        this.usage = usage;
        this.rbGroups = rbGroups;
      }
      get visible() {
        if (this.#userSet) {
          return this.#visible;
        }
        if (!this.#visible) {
          return false;
        }
        const {
          print,
          view
        } = this.usage;
        if (this.#isDisplay) {
          return view?.viewState !== "OFF";
        } else if (this.#isPrint) {
          return print?.printState !== "OFF";
        }
        return true;
      }
      _setVisible(internal, visible, userSet = false) {
        if (internal !== INTERNAL) {
          unreachable("Internal method `_setVisible` called.");
        }
        this.#userSet = userSet;
        this.#visible = visible;
      }
    };
    OptionalContentConfig = class {
      #cachedGetHash = null;
      #groups = /* @__PURE__ */ new Map();
      #initialHash = null;
      #order = null;
      constructor(data, renderingIntent = RenderingIntentFlag.DISPLAY) {
        this.renderingIntent = renderingIntent;
        this.name = null;
        this.creator = null;
        if (data === null) {
          return;
        }
        this.name = data.name;
        this.creator = data.creator;
        this.#order = data.order;
        for (const group2 of data.groups) {
          this.#groups.set(group2.id, new OptionalContentGroup(renderingIntent, group2));
        }
        if (data.baseState === "OFF") {
          for (const group2 of this.#groups.values()) {
            group2._setVisible(INTERNAL, false);
          }
        }
        for (const on of data.on) {
          this.#groups.get(on)._setVisible(INTERNAL, true);
        }
        for (const off of data.off) {
          this.#groups.get(off)._setVisible(INTERNAL, false);
        }
        this.#initialHash = this.getHash();
      }
      #evaluateVisibilityExpression(array) {
        const length = array.length;
        if (length < 2) {
          return true;
        }
        const operator = array[0];
        for (let i = 1; i < length; i++) {
          const element = array[i];
          let state;
          if (Array.isArray(element)) {
            state = this.#evaluateVisibilityExpression(element);
          } else if (this.#groups.has(element)) {
            state = this.#groups.get(element).visible;
          } else {
            warn(`Optional content group not found: ${element}`);
            return true;
          }
          switch (operator) {
            case "And":
              if (!state) {
                return false;
              }
              break;
            case "Or":
              if (state) {
                return true;
              }
              break;
            case "Not":
              return !state;
            default:
              return true;
          }
        }
        return operator === "And";
      }
      isVisible(group2) {
        if (this.#groups.size === 0) {
          return true;
        }
        if (!group2) {
          info("Optional content group not defined.");
          return true;
        }
        if (group2.type === "OCG") {
          if (!this.#groups.has(group2.id)) {
            warn(`Optional content group not found: ${group2.id}`);
            return true;
          }
          return this.#groups.get(group2.id).visible;
        } else if (group2.type === "OCMD") {
          if (group2.expression) {
            return this.#evaluateVisibilityExpression(group2.expression);
          }
          if (!group2.policy || group2.policy === "AnyOn") {
            for (const id of group2.ids) {
              if (!this.#groups.has(id)) {
                warn(`Optional content group not found: ${id}`);
                return true;
              }
              if (this.#groups.get(id).visible) {
                return true;
              }
            }
            return false;
          } else if (group2.policy === "AllOn") {
            for (const id of group2.ids) {
              if (!this.#groups.has(id)) {
                warn(`Optional content group not found: ${id}`);
                return true;
              }
              if (!this.#groups.get(id).visible) {
                return false;
              }
            }
            return true;
          } else if (group2.policy === "AnyOff") {
            for (const id of group2.ids) {
              if (!this.#groups.has(id)) {
                warn(`Optional content group not found: ${id}`);
                return true;
              }
              if (!this.#groups.get(id).visible) {
                return true;
              }
            }
            return false;
          } else if (group2.policy === "AllOff") {
            for (const id of group2.ids) {
              if (!this.#groups.has(id)) {
                warn(`Optional content group not found: ${id}`);
                return true;
              }
              if (this.#groups.get(id).visible) {
                return false;
              }
            }
            return true;
          }
          warn(`Unknown optional content policy ${group2.policy}.`);
          return true;
        }
        warn(`Unknown group type ${group2.type}.`);
        return true;
      }
      setVisibility(id, visible = true, preserveRB = true) {
        const group2 = this.#groups.get(id);
        if (!group2) {
          warn(`Optional content group not found: ${id}`);
          return;
        }
        if (preserveRB && visible && group2.rbGroups.length) {
          for (const rbGroup of group2.rbGroups) {
            for (const otherId of rbGroup) {
              if (otherId !== id) {
                this.#groups.get(otherId)?._setVisible(INTERNAL, false, true);
              }
            }
          }
        }
        group2._setVisible(INTERNAL, !!visible, true);
        this.#cachedGetHash = null;
      }
      setOCGState({
        state,
        preserveRB
      }) {
        let operator;
        for (const elem of state) {
          switch (elem) {
            case "ON":
            case "OFF":
            case "Toggle":
              operator = elem;
              continue;
          }
          const group2 = this.#groups.get(elem);
          if (!group2) {
            continue;
          }
          switch (operator) {
            case "ON":
              this.setVisibility(elem, true, preserveRB);
              break;
            case "OFF":
              this.setVisibility(elem, false, preserveRB);
              break;
            case "Toggle":
              this.setVisibility(elem, !group2.visible, preserveRB);
              break;
          }
        }
        this.#cachedGetHash = null;
      }
      get hasInitialVisibility() {
        return this.#initialHash === null || this.getHash() === this.#initialHash;
      }
      getOrder() {
        if (!this.#groups.size) {
          return null;
        }
        if (this.#order) {
          return this.#order.slice();
        }
        return [...this.#groups.keys()];
      }
      getGroup(id) {
        return this.#groups.get(id) || null;
      }
      getHash() {
        if (this.#cachedGetHash !== null) {
          return this.#cachedGetHash;
        }
        const hash = new MurmurHash3_64();
        for (const [id, group2] of this.#groups) {
          hash.update(`${id}:${group2.visible}`);
        }
        return this.#cachedGetHash = hash.hexdigest();
      }
      [Symbol.iterator]() {
        return this.#groups.entries();
      }
    };
    PDFDataTransportStream = class {
      constructor(pdfDataRangeTransport, {
        disableRange = false,
        disableStream = false
      }) {
        assert(pdfDataRangeTransport, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.');
        const {
          length,
          initialData,
          progressiveDone,
          contentDispositionFilename
        } = pdfDataRangeTransport;
        this._queuedChunks = [];
        this._progressiveDone = progressiveDone;
        this._contentDispositionFilename = contentDispositionFilename;
        if (initialData?.length > 0) {
          const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;
          this._queuedChunks.push(buffer);
        }
        this._pdfDataRangeTransport = pdfDataRangeTransport;
        this._isStreamingSupported = !disableStream;
        this._isRangeSupported = !disableRange;
        this._contentLength = length;
        this._fullRequestReader = null;
        this._rangeReaders = [];
        pdfDataRangeTransport.addRangeListener((begin, chunk2) => {
          this._onReceiveData({
            begin,
            chunk: chunk2
          });
        });
        pdfDataRangeTransport.addProgressListener((loaded, total) => {
          this._onProgress({
            loaded,
            total
          });
        });
        pdfDataRangeTransport.addProgressiveReadListener((chunk2) => {
          this._onReceiveData({
            chunk: chunk2
          });
        });
        pdfDataRangeTransport.addProgressiveDoneListener(() => {
          this._onProgressiveDone();
        });
        pdfDataRangeTransport.transportReady();
      }
      _onReceiveData({
        begin,
        chunk: chunk2
      }) {
        const buffer = chunk2 instanceof Uint8Array && chunk2.byteLength === chunk2.buffer.byteLength ? chunk2.buffer : new Uint8Array(chunk2).buffer;
        if (begin === void 0) {
          if (this._fullRequestReader) {
            this._fullRequestReader._enqueue(buffer);
          } else {
            this._queuedChunks.push(buffer);
          }
        } else {
          const found = this._rangeReaders.some(function(rangeReader) {
            if (rangeReader._begin !== begin) {
              return false;
            }
            rangeReader._enqueue(buffer);
            return true;
          });
          assert(found, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.");
        }
      }
      get _progressiveDataLength() {
        return this._fullRequestReader?._loaded ?? 0;
      }
      _onProgress(evt) {
        if (evt.total === void 0) {
          this._rangeReaders[0]?.onProgress?.({
            loaded: evt.loaded
          });
        } else {
          this._fullRequestReader?.onProgress?.({
            loaded: evt.loaded,
            total: evt.total
          });
        }
      }
      _onProgressiveDone() {
        this._fullRequestReader?.progressiveDone();
        this._progressiveDone = true;
      }
      _removeRangeReader(reader) {
        const i = this._rangeReaders.indexOf(reader);
        if (i >= 0) {
          this._rangeReaders.splice(i, 1);
        }
      }
      getFullReader() {
        assert(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once.");
        const queuedChunks = this._queuedChunks;
        this._queuedChunks = null;
        return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);
      }
      getRangeReader(begin, end) {
        if (end <= this._progressiveDataLength) {
          return null;
        }
        const reader = new PDFDataTransportStreamRangeReader(this, begin, end);
        this._pdfDataRangeTransport.requestDataRange(begin, end);
        this._rangeReaders.push(reader);
        return reader;
      }
      cancelAllRequests(reason) {
        this._fullRequestReader?.cancel(reason);
        for (const reader of this._rangeReaders.slice(0)) {
          reader.cancel(reason);
        }
        this._pdfDataRangeTransport.abort();
      }
    };
    PDFDataTransportStreamReader = class {
      constructor(stream, queuedChunks, progressiveDone = false, contentDispositionFilename = null) {
        this._stream = stream;
        this._done = progressiveDone || false;
        this._filename = isPdfFile(contentDispositionFilename) ? contentDispositionFilename : null;
        this._queuedChunks = queuedChunks || [];
        this._loaded = 0;
        for (const chunk2 of this._queuedChunks) {
          this._loaded += chunk2.byteLength;
        }
        this._requests = [];
        this._headersReady = Promise.resolve();
        stream._fullRequestReader = this;
        this.onProgress = null;
      }
      _enqueue(chunk2) {
        if (this._done) {
          return;
        }
        if (this._requests.length > 0) {
          const requestCapability = this._requests.shift();
          requestCapability.resolve({
            value: chunk2,
            done: false
          });
        } else {
          this._queuedChunks.push(chunk2);
        }
        this._loaded += chunk2.byteLength;
      }
      get headersReady() {
        return this._headersReady;
      }
      get filename() {
        return this._filename;
      }
      get isRangeSupported() {
        return this._stream._isRangeSupported;
      }
      get isStreamingSupported() {
        return this._stream._isStreamingSupported;
      }
      get contentLength() {
        return this._stream._contentLength;
      }
      async read() {
        if (this._queuedChunks.length > 0) {
          const chunk2 = this._queuedChunks.shift();
          return {
            value: chunk2,
            done: false
          };
        }
        if (this._done) {
          return {
            value: void 0,
            done: true
          };
        }
        const requestCapability = Promise.withResolvers();
        this._requests.push(requestCapability);
        return requestCapability.promise;
      }
      cancel(reason) {
        this._done = true;
        for (const requestCapability of this._requests) {
          requestCapability.resolve({
            value: void 0,
            done: true
          });
        }
        this._requests.length = 0;
      }
      progressiveDone() {
        if (this._done) {
          return;
        }
        this._done = true;
      }
    };
    PDFDataTransportStreamRangeReader = class {
      constructor(stream, begin, end) {
        this._stream = stream;
        this._begin = begin;
        this._end = end;
        this._queuedChunk = null;
        this._requests = [];
        this._done = false;
        this.onProgress = null;
      }
      _enqueue(chunk2) {
        if (this._done) {
          return;
        }
        if (this._requests.length === 0) {
          this._queuedChunk = chunk2;
        } else {
          const requestsCapability = this._requests.shift();
          requestsCapability.resolve({
            value: chunk2,
            done: false
          });
          for (const requestCapability of this._requests) {
            requestCapability.resolve({
              value: void 0,
              done: true
            });
          }
          this._requests.length = 0;
        }
        this._done = true;
        this._stream._removeRangeReader(this);
      }
      get isStreamingSupported() {
        return false;
      }
      async read() {
        if (this._queuedChunk) {
          const chunk2 = this._queuedChunk;
          this._queuedChunk = null;
          return {
            value: chunk2,
            done: false
          };
        }
        if (this._done) {
          return {
            value: void 0,
            done: true
          };
        }
        const requestCapability = Promise.withResolvers();
        this._requests.push(requestCapability);
        return requestCapability.promise;
      }
      cancel(reason) {
        this._done = true;
        for (const requestCapability of this._requests) {
          requestCapability.resolve({
            value: void 0,
            done: true
          });
        }
        this._requests.length = 0;
        this._stream._removeRangeReader(this);
      }
    };
    PDFFetchStream = class {
      _responseOrigin = null;
      constructor(source) {
        this.source = source;
        this.isHttp = /^https?:/i.test(source.url);
        this.headers = createHeaders(this.isHttp, source.httpHeaders);
        this._fullRequestReader = null;
        this._rangeRequestReaders = [];
      }
      get _progressiveDataLength() {
        return this._fullRequestReader?._loaded ?? 0;
      }
      getFullReader() {
        assert(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once.");
        this._fullRequestReader = new PDFFetchStreamReader(this);
        return this._fullRequestReader;
      }
      getRangeReader(begin, end) {
        if (end <= this._progressiveDataLength) {
          return null;
        }
        const reader = new PDFFetchStreamRangeReader(this, begin, end);
        this._rangeRequestReaders.push(reader);
        return reader;
      }
      cancelAllRequests(reason) {
        this._fullRequestReader?.cancel(reason);
        for (const reader of this._rangeRequestReaders.slice(0)) {
          reader.cancel(reason);
        }
      }
    };
    PDFFetchStreamReader = class {
      constructor(stream) {
        this._stream = stream;
        this._reader = null;
        this._loaded = 0;
        this._filename = null;
        const source = stream.source;
        this._withCredentials = source.withCredentials || false;
        this._contentLength = source.length;
        this._headersCapability = Promise.withResolvers();
        this._disableRange = source.disableRange || false;
        this._rangeChunkSize = source.rangeChunkSize;
        if (!this._rangeChunkSize && !this._disableRange) {
          this._disableRange = true;
        }
        this._abortController = new AbortController();
        this._isStreamingSupported = !source.disableStream;
        this._isRangeSupported = !source.disableRange;
        const headers = new Headers(stream.headers);
        const url = source.url;
        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response) => {
          stream._responseOrigin = getResponseOrigin(response.url);
          if (!validateResponseStatus(response.status)) {
            throw createResponseError(response.status, url);
          }
          this._reader = response.body.getReader();
          this._headersCapability.resolve();
          const responseHeaders = response.headers;
          const {
            allowRangeRequests,
            suggestedLength
          } = validateRangeRequestCapabilities({
            responseHeaders,
            isHttp: stream.isHttp,
            rangeChunkSize: this._rangeChunkSize,
            disableRange: this._disableRange
          });
          this._isRangeSupported = allowRangeRequests;
          this._contentLength = suggestedLength || this._contentLength;
          this._filename = extractFilenameFromHeader(responseHeaders);
          if (!this._isStreamingSupported && this._isRangeSupported) {
            this.cancel(new AbortException("Streaming is disabled."));
          }
        }).catch(this._headersCapability.reject);
        this.onProgress = null;
      }
      get headersReady() {
        return this._headersCapability.promise;
      }
      get filename() {
        return this._filename;
      }
      get contentLength() {
        return this._contentLength;
      }
      get isRangeSupported() {
        return this._isRangeSupported;
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      async read() {
        await this._headersCapability.promise;
        const {
          value,
          done
        } = await this._reader.read();
        if (done) {
          return {
            value,
            done
          };
        }
        this._loaded += value.byteLength;
        this.onProgress?.({
          loaded: this._loaded,
          total: this._contentLength
        });
        return {
          value: getArrayBuffer(value),
          done: false
        };
      }
      cancel(reason) {
        this._reader?.cancel(reason);
        this._abortController.abort();
      }
    };
    PDFFetchStreamRangeReader = class {
      constructor(stream, begin, end) {
        this._stream = stream;
        this._reader = null;
        this._loaded = 0;
        const source = stream.source;
        this._withCredentials = source.withCredentials || false;
        this._readCapability = Promise.withResolvers();
        this._isStreamingSupported = !source.disableStream;
        this._abortController = new AbortController();
        const headers = new Headers(stream.headers);
        headers.append("Range", `bytes=${begin}-${end - 1}`);
        const url = source.url;
        fetch(url, createFetchOptions(headers, this._withCredentials, this._abortController)).then((response) => {
          const responseOrigin = getResponseOrigin(response.url);
          if (responseOrigin !== stream._responseOrigin) {
            throw new Error(`Expected range response-origin "${responseOrigin}" to match "${stream._responseOrigin}".`);
          }
          if (!validateResponseStatus(response.status)) {
            throw createResponseError(response.status, url);
          }
          this._readCapability.resolve();
          this._reader = response.body.getReader();
        }).catch(this._readCapability.reject);
        this.onProgress = null;
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      async read() {
        await this._readCapability.promise;
        const {
          value,
          done
        } = await this._reader.read();
        if (done) {
          return {
            value,
            done
          };
        }
        this._loaded += value.byteLength;
        this.onProgress?.({
          loaded: this._loaded
        });
        return {
          value: getArrayBuffer(value),
          done: false
        };
      }
      cancel(reason) {
        this._reader?.cancel(reason);
        this._abortController.abort();
      }
    };
    OK_RESPONSE = 200;
    PARTIAL_CONTENT_RESPONSE = 206;
    NetworkManager = class {
      _responseOrigin = null;
      constructor({
        url,
        httpHeaders,
        withCredentials
      }) {
        this.url = url;
        this.isHttp = /^https?:/i.test(url);
        this.headers = createHeaders(this.isHttp, httpHeaders);
        this.withCredentials = withCredentials || false;
        this.currXhrId = 0;
        this.pendingRequests = /* @__PURE__ */ Object.create(null);
      }
      request(args) {
        const xhr = new XMLHttpRequest();
        const xhrId = this.currXhrId++;
        const pendingRequest = this.pendingRequests[xhrId] = {
          xhr
        };
        xhr.open("GET", this.url);
        xhr.withCredentials = this.withCredentials;
        for (const [key, val] of this.headers) {
          xhr.setRequestHeader(key, val);
        }
        if (this.isHttp && "begin" in args && "end" in args) {
          xhr.setRequestHeader("Range", `bytes=${args.begin}-${args.end - 1}`);
          pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;
        } else {
          pendingRequest.expectedStatus = OK_RESPONSE;
        }
        xhr.responseType = "arraybuffer";
        assert(args.onError, "Expected `onError` callback to be provided.");
        xhr.onerror = () => {
          args.onError(xhr.status);
        };
        xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);
        xhr.onprogress = this.onProgress.bind(this, xhrId);
        pendingRequest.onHeadersReceived = args.onHeadersReceived;
        pendingRequest.onDone = args.onDone;
        pendingRequest.onError = args.onError;
        pendingRequest.onProgress = args.onProgress;
        xhr.send(null);
        return xhrId;
      }
      onProgress(xhrId, evt) {
        const pendingRequest = this.pendingRequests[xhrId];
        if (!pendingRequest) {
          return;
        }
        pendingRequest.onProgress?.(evt);
      }
      onStateChange(xhrId, evt) {
        const pendingRequest = this.pendingRequests[xhrId];
        if (!pendingRequest) {
          return;
        }
        const xhr = pendingRequest.xhr;
        if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {
          pendingRequest.onHeadersReceived();
          delete pendingRequest.onHeadersReceived;
        }
        if (xhr.readyState !== 4) {
          return;
        }
        if (!(xhrId in this.pendingRequests)) {
          return;
        }
        delete this.pendingRequests[xhrId];
        if (xhr.status === 0 && this.isHttp) {
          pendingRequest.onError(xhr.status);
          return;
        }
        const xhrStatus = xhr.status || OK_RESPONSE;
        const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;
        if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {
          pendingRequest.onError(xhr.status);
          return;
        }
        const chunk2 = network_getArrayBuffer(xhr);
        if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {
          const rangeHeader = xhr.getResponseHeader("Content-Range");
          const matches = /bytes (\d+)-(\d+)\/(\d+)/.exec(rangeHeader);
          if (matches) {
            pendingRequest.onDone({
              begin: parseInt(matches[1], 10),
              chunk: chunk2
            });
          } else {
            warn(`Missing or invalid "Content-Range" header.`);
            pendingRequest.onError(0);
          }
        } else if (chunk2) {
          pendingRequest.onDone({
            begin: 0,
            chunk: chunk2
          });
        } else {
          pendingRequest.onError(xhr.status);
        }
      }
      getRequestXhr(xhrId) {
        return this.pendingRequests[xhrId].xhr;
      }
      isPendingRequest(xhrId) {
        return xhrId in this.pendingRequests;
      }
      abortRequest(xhrId) {
        const xhr = this.pendingRequests[xhrId].xhr;
        delete this.pendingRequests[xhrId];
        xhr.abort();
      }
    };
    PDFNetworkStream = class {
      constructor(source) {
        this._source = source;
        this._manager = new NetworkManager(source);
        this._rangeChunkSize = source.rangeChunkSize;
        this._fullRequestReader = null;
        this._rangeRequestReaders = [];
      }
      _onRangeRequestReaderClosed(reader) {
        const i = this._rangeRequestReaders.indexOf(reader);
        if (i >= 0) {
          this._rangeRequestReaders.splice(i, 1);
        }
      }
      getFullReader() {
        assert(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once.");
        this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);
        return this._fullRequestReader;
      }
      getRangeReader(begin, end) {
        const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);
        reader.onClosed = this._onRangeRequestReaderClosed.bind(this);
        this._rangeRequestReaders.push(reader);
        return reader;
      }
      cancelAllRequests(reason) {
        this._fullRequestReader?.cancel(reason);
        for (const reader of this._rangeRequestReaders.slice(0)) {
          reader.cancel(reason);
        }
      }
    };
    PDFNetworkStreamFullRequestReader = class {
      constructor(manager, source) {
        this._manager = manager;
        this._url = source.url;
        this._fullRequestId = manager.request({
          onHeadersReceived: this._onHeadersReceived.bind(this),
          onDone: this._onDone.bind(this),
          onError: this._onError.bind(this),
          onProgress: this._onProgress.bind(this)
        });
        this._headersCapability = Promise.withResolvers();
        this._disableRange = source.disableRange || false;
        this._contentLength = source.length;
        this._rangeChunkSize = source.rangeChunkSize;
        if (!this._rangeChunkSize && !this._disableRange) {
          this._disableRange = true;
        }
        this._isStreamingSupported = false;
        this._isRangeSupported = false;
        this._cachedChunks = [];
        this._requests = [];
        this._done = false;
        this._storedError = void 0;
        this._filename = null;
        this.onProgress = null;
      }
      _onHeadersReceived() {
        const fullRequestXhrId = this._fullRequestId;
        const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);
        this._manager._responseOrigin = getResponseOrigin(fullRequestXhr.responseURL);
        const rawResponseHeaders = fullRequestXhr.getAllResponseHeaders();
        const responseHeaders = new Headers(rawResponseHeaders ? rawResponseHeaders.trimStart().replace(/[^\S ]+$/, "").split(/[\r\n]+/).map((x) => {
          const [key, ...val] = x.split(": ");
          return [key, val.join(": ")];
        }) : []);
        const {
          allowRangeRequests,
          suggestedLength
        } = validateRangeRequestCapabilities({
          responseHeaders,
          isHttp: this._manager.isHttp,
          rangeChunkSize: this._rangeChunkSize,
          disableRange: this._disableRange
        });
        if (allowRangeRequests) {
          this._isRangeSupported = true;
        }
        this._contentLength = suggestedLength || this._contentLength;
        this._filename = extractFilenameFromHeader(responseHeaders);
        if (this._isRangeSupported) {
          this._manager.abortRequest(fullRequestXhrId);
        }
        this._headersCapability.resolve();
      }
      _onDone(data) {
        if (data) {
          if (this._requests.length > 0) {
            const requestCapability = this._requests.shift();
            requestCapability.resolve({
              value: data.chunk,
              done: false
            });
          } else {
            this._cachedChunks.push(data.chunk);
          }
        }
        this._done = true;
        if (this._cachedChunks.length > 0) {
          return;
        }
        for (const requestCapability of this._requests) {
          requestCapability.resolve({
            value: void 0,
            done: true
          });
        }
        this._requests.length = 0;
      }
      _onError(status) {
        this._storedError = createResponseError(status, this._url);
        this._headersCapability.reject(this._storedError);
        for (const requestCapability of this._requests) {
          requestCapability.reject(this._storedError);
        }
        this._requests.length = 0;
        this._cachedChunks.length = 0;
      }
      _onProgress(evt) {
        this.onProgress?.({
          loaded: evt.loaded,
          total: evt.lengthComputable ? evt.total : this._contentLength
        });
      }
      get filename() {
        return this._filename;
      }
      get isRangeSupported() {
        return this._isRangeSupported;
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      get contentLength() {
        return this._contentLength;
      }
      get headersReady() {
        return this._headersCapability.promise;
      }
      async read() {
        await this._headersCapability.promise;
        if (this._storedError) {
          throw this._storedError;
        }
        if (this._cachedChunks.length > 0) {
          const chunk2 = this._cachedChunks.shift();
          return {
            value: chunk2,
            done: false
          };
        }
        if (this._done) {
          return {
            value: void 0,
            done: true
          };
        }
        const requestCapability = Promise.withResolvers();
        this._requests.push(requestCapability);
        return requestCapability.promise;
      }
      cancel(reason) {
        this._done = true;
        this._headersCapability.reject(reason);
        for (const requestCapability of this._requests) {
          requestCapability.resolve({
            value: void 0,
            done: true
          });
        }
        this._requests.length = 0;
        if (this._manager.isPendingRequest(this._fullRequestId)) {
          this._manager.abortRequest(this._fullRequestId);
        }
        this._fullRequestReader = null;
      }
    };
    PDFNetworkStreamRangeRequestReader = class {
      constructor(manager, begin, end) {
        this._manager = manager;
        this._url = manager.url;
        this._requestId = manager.request({
          begin,
          end,
          onHeadersReceived: this._onHeadersReceived.bind(this),
          onDone: this._onDone.bind(this),
          onError: this._onError.bind(this),
          onProgress: this._onProgress.bind(this)
        });
        this._requests = [];
        this._queuedChunk = null;
        this._done = false;
        this._storedError = void 0;
        this.onProgress = null;
        this.onClosed = null;
      }
      _onHeadersReceived() {
        const responseOrigin = getResponseOrigin(this._manager.getRequestXhr(this._requestId)?.responseURL);
        if (responseOrigin !== this._manager._responseOrigin) {
          this._storedError = new Error(`Expected range response-origin "${responseOrigin}" to match "${this._manager._responseOrigin}".`);
          this._onError(0);
        }
      }
      _close() {
        this.onClosed?.(this);
      }
      _onDone(data) {
        const chunk2 = data.chunk;
        if (this._requests.length > 0) {
          const requestCapability = this._requests.shift();
          requestCapability.resolve({
            value: chunk2,
            done: false
          });
        } else {
          this._queuedChunk = chunk2;
        }
        this._done = true;
        for (const requestCapability of this._requests) {
          requestCapability.resolve({
            value: void 0,
            done: true
          });
        }
        this._requests.length = 0;
        this._close();
      }
      _onError(status) {
        this._storedError ??= createResponseError(status, this._url);
        for (const requestCapability of this._requests) {
          requestCapability.reject(this._storedError);
        }
        this._requests.length = 0;
        this._queuedChunk = null;
      }
      _onProgress(evt) {
        if (!this.isStreamingSupported) {
          this.onProgress?.({
            loaded: evt.loaded
          });
        }
      }
      get isStreamingSupported() {
        return false;
      }
      async read() {
        if (this._storedError) {
          throw this._storedError;
        }
        if (this._queuedChunk !== null) {
          const chunk2 = this._queuedChunk;
          this._queuedChunk = null;
          return {
            value: chunk2,
            done: false
          };
        }
        if (this._done) {
          return {
            value: void 0,
            done: true
          };
        }
        const requestCapability = Promise.withResolvers();
        this._requests.push(requestCapability);
        return requestCapability.promise;
      }
      cancel(reason) {
        this._done = true;
        for (const requestCapability of this._requests) {
          requestCapability.resolve({
            value: void 0,
            done: true
          });
        }
        this._requests.length = 0;
        if (this._manager.isPendingRequest(this._requestId)) {
          this._manager.abortRequest(this._requestId);
        }
        this._close();
      }
    };
    urlRegex = /^[a-z][a-z0-9\-+.]+:/i;
    PDFNodeStream = class {
      constructor(source) {
        this.source = source;
        this.url = parseUrlOrPath(source.url);
        assert(this.url.protocol === "file:", "PDFNodeStream only supports file:// URLs.");
        this._fullRequestReader = null;
        this._rangeRequestReaders = [];
      }
      get _progressiveDataLength() {
        return this._fullRequestReader?._loaded ?? 0;
      }
      getFullReader() {
        assert(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once.");
        this._fullRequestReader = new PDFNodeStreamFsFullReader(this);
        return this._fullRequestReader;
      }
      getRangeReader(start, end) {
        if (end <= this._progressiveDataLength) {
          return null;
        }
        const rangeReader = new PDFNodeStreamFsRangeReader(this, start, end);
        this._rangeRequestReaders.push(rangeReader);
        return rangeReader;
      }
      cancelAllRequests(reason) {
        this._fullRequestReader?.cancel(reason);
        for (const reader of this._rangeRequestReaders.slice(0)) {
          reader.cancel(reason);
        }
      }
    };
    PDFNodeStreamFsFullReader = class {
      constructor(stream) {
        this._url = stream.url;
        this._done = false;
        this._storedError = null;
        this.onProgress = null;
        const source = stream.source;
        this._contentLength = source.length;
        this._loaded = 0;
        this._filename = null;
        this._disableRange = source.disableRange || false;
        this._rangeChunkSize = source.rangeChunkSize;
        if (!this._rangeChunkSize && !this._disableRange) {
          this._disableRange = true;
        }
        this._isStreamingSupported = !source.disableStream;
        this._isRangeSupported = !source.disableRange;
        this._readableStream = null;
        this._readCapability = Promise.withResolvers();
        this._headersCapability = Promise.withResolvers();
        const fs2 = process.getBuiltinModule("fs");
        fs2.promises.lstat(this._url).then((stat) => {
          this._contentLength = stat.size;
          this._setReadableStream(fs2.createReadStream(this._url));
          this._headersCapability.resolve();
        }, (error) => {
          if (error.code === "ENOENT") {
            error = createResponseError(0, this._url.href);
          }
          this._storedError = error;
          this._headersCapability.reject(error);
        });
      }
      get headersReady() {
        return this._headersCapability.promise;
      }
      get filename() {
        return this._filename;
      }
      get contentLength() {
        return this._contentLength;
      }
      get isRangeSupported() {
        return this._isRangeSupported;
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      async read() {
        await this._readCapability.promise;
        if (this._done) {
          return {
            value: void 0,
            done: true
          };
        }
        if (this._storedError) {
          throw this._storedError;
        }
        const chunk2 = this._readableStream.read();
        if (chunk2 === null) {
          this._readCapability = Promise.withResolvers();
          return this.read();
        }
        this._loaded += chunk2.length;
        this.onProgress?.({
          loaded: this._loaded,
          total: this._contentLength
        });
        const buffer = new Uint8Array(chunk2).buffer;
        return {
          value: buffer,
          done: false
        };
      }
      cancel(reason) {
        if (!this._readableStream) {
          this._error(reason);
          return;
        }
        this._readableStream.destroy(reason);
      }
      _error(reason) {
        this._storedError = reason;
        this._readCapability.resolve();
      }
      _setReadableStream(readableStream) {
        this._readableStream = readableStream;
        readableStream.on("readable", () => {
          this._readCapability.resolve();
        });
        readableStream.on("end", () => {
          readableStream.destroy();
          this._done = true;
          this._readCapability.resolve();
        });
        readableStream.on("error", (reason) => {
          this._error(reason);
        });
        if (!this._isStreamingSupported && this._isRangeSupported) {
          this._error(new AbortException("streaming is disabled"));
        }
        if (this._storedError) {
          this._readableStream.destroy(this._storedError);
        }
      }
    };
    PDFNodeStreamFsRangeReader = class {
      constructor(stream, start, end) {
        this._url = stream.url;
        this._done = false;
        this._storedError = null;
        this.onProgress = null;
        this._loaded = 0;
        this._readableStream = null;
        this._readCapability = Promise.withResolvers();
        const source = stream.source;
        this._isStreamingSupported = !source.disableStream;
        const fs2 = process.getBuiltinModule("fs");
        this._setReadableStream(fs2.createReadStream(this._url, {
          start,
          end: end - 1
        }));
      }
      get isStreamingSupported() {
        return this._isStreamingSupported;
      }
      async read() {
        await this._readCapability.promise;
        if (this._done) {
          return {
            value: void 0,
            done: true
          };
        }
        if (this._storedError) {
          throw this._storedError;
        }
        const chunk2 = this._readableStream.read();
        if (chunk2 === null) {
          this._readCapability = Promise.withResolvers();
          return this.read();
        }
        this._loaded += chunk2.length;
        this.onProgress?.({
          loaded: this._loaded
        });
        const buffer = new Uint8Array(chunk2).buffer;
        return {
          value: buffer,
          done: false
        };
      }
      cancel(reason) {
        if (!this._readableStream) {
          this._error(reason);
          return;
        }
        this._readableStream.destroy(reason);
      }
      _error(reason) {
        this._storedError = reason;
        this._readCapability.resolve();
      }
      _setReadableStream(readableStream) {
        this._readableStream = readableStream;
        readableStream.on("readable", () => {
          this._readCapability.resolve();
        });
        readableStream.on("end", () => {
          readableStream.destroy();
          this._done = true;
          this._readCapability.resolve();
        });
        readableStream.on("error", (reason) => {
          this._error(reason);
        });
        if (this._storedError) {
          this._readableStream.destroy(this._storedError);
        }
      }
    };
    INITIAL_DATA = Symbol("INITIAL_DATA");
    PDFObjects = class {
      #objs = /* @__PURE__ */ Object.create(null);
      #ensureObj(objId) {
        return this.#objs[objId] ||= {
          ...Promise.withResolvers(),
          data: INITIAL_DATA
        };
      }
      get(objId, callback = null) {
        if (callback) {
          const obj3 = this.#ensureObj(objId);
          obj3.promise.then(() => callback(obj3.data));
          return null;
        }
        const obj2 = this.#objs[objId];
        if (!obj2 || obj2.data === INITIAL_DATA) {
          throw new Error(`Requesting object that isn't resolved yet ${objId}.`);
        }
        return obj2.data;
      }
      has(objId) {
        const obj2 = this.#objs[objId];
        return !!obj2 && obj2.data !== INITIAL_DATA;
      }
      delete(objId) {
        const obj2 = this.#objs[objId];
        if (!obj2 || obj2.data === INITIAL_DATA) {
          return false;
        }
        delete this.#objs[objId];
        return true;
      }
      resolve(objId, data = null) {
        const obj2 = this.#ensureObj(objId);
        obj2.data = data;
        obj2.resolve();
      }
      clear() {
        for (const objId in this.#objs) {
          const {
            data
          } = this.#objs[objId];
          data?.bitmap?.close();
        }
        this.#objs = /* @__PURE__ */ Object.create(null);
      }
      *[Symbol.iterator]() {
        for (const objId in this.#objs) {
          const {
            data
          } = this.#objs[objId];
          if (data === INITIAL_DATA) {
            continue;
          }
          yield [objId, data];
        }
      }
    };
    MAX_TEXT_DIVS_TO_RENDER = 1e5;
    DEFAULT_FONT_SIZE = 30;
    TextLayer = class _TextLayer {
      #capability = Promise.withResolvers();
      #container = null;
      #disableProcessItems = false;
      #fontInspectorEnabled = !!globalThis.FontInspector?.enabled;
      #lang = null;
      #layoutTextParams = null;
      #pageHeight = 0;
      #pageWidth = 0;
      #reader = null;
      #rootContainer = null;
      #rotation = 0;
      #scale = 0;
      #styleCache = /* @__PURE__ */ Object.create(null);
      #textContentItemsStr = [];
      #textContentSource = null;
      #textDivs = [];
      #textDivProperties = /* @__PURE__ */ new WeakMap();
      #transform = null;
      static #ascentCache = /* @__PURE__ */ new Map();
      static #canvasContexts = /* @__PURE__ */ new Map();
      static #canvasCtxFonts = /* @__PURE__ */ new WeakMap();
      static #minFontSize = null;
      static #pendingTextLayers = /* @__PURE__ */ new Set();
      constructor({
        textContentSource,
        container,
        viewport
      }) {
        if (textContentSource instanceof ReadableStream) {
          this.#textContentSource = textContentSource;
        } else if (typeof textContentSource === "object") {
          this.#textContentSource = new ReadableStream({
            start(controller) {
              controller.enqueue(textContentSource);
              controller.close();
            }
          });
        } else {
          throw new Error('No "textContentSource" parameter specified.');
        }
        this.#container = this.#rootContainer = container;
        this.#scale = viewport.scale * OutputScale.pixelRatio;
        this.#rotation = viewport.rotation;
        this.#layoutTextParams = {
          div: null,
          properties: null,
          ctx: null
        };
        const {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        } = viewport.rawDims;
        this.#transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];
        this.#pageWidth = pageWidth;
        this.#pageHeight = pageHeight;
        _TextLayer.#ensureMinFontSizeComputed();
        setLayerDimensions(container, viewport);
        this.#capability.promise.finally(() => {
          _TextLayer.#pendingTextLayers.delete(this);
          this.#layoutTextParams = null;
          this.#styleCache = null;
        }).catch(() => {
        });
      }
      static get fontFamilyMap() {
        const {
          isWindows,
          isFirefox
        } = util_FeatureTest.platform;
        return shadow(this, "fontFamilyMap", /* @__PURE__ */ new Map([["sans-serif", `${isWindows && isFirefox ? "Calibri, " : ""}sans-serif`], ["monospace", `${isWindows && isFirefox ? "Lucida Console, " : ""}monospace`]]));
      }
      render() {
        const pump = () => {
          this.#reader.read().then(({
            value,
            done
          }) => {
            if (done) {
              this.#capability.resolve();
              return;
            }
            this.#lang ??= value.lang;
            Object.assign(this.#styleCache, value.styles);
            this.#processItems(value.items);
            pump();
          }, this.#capability.reject);
        };
        this.#reader = this.#textContentSource.getReader();
        _TextLayer.#pendingTextLayers.add(this);
        pump();
        return this.#capability.promise;
      }
      update({
        viewport,
        onBefore = null
      }) {
        const scale = viewport.scale * OutputScale.pixelRatio;
        const rotation = viewport.rotation;
        if (rotation !== this.#rotation) {
          onBefore?.();
          this.#rotation = rotation;
          setLayerDimensions(this.#rootContainer, {
            rotation
          });
        }
        if (scale !== this.#scale) {
          onBefore?.();
          this.#scale = scale;
          const params = {
            div: null,
            properties: null,
            ctx: _TextLayer.#getCtx(this.#lang)
          };
          for (const div of this.#textDivs) {
            params.properties = this.#textDivProperties.get(div);
            params.div = div;
            this.#layout(params);
          }
        }
      }
      cancel() {
        const abortEx = new AbortException("TextLayer task cancelled.");
        this.#reader?.cancel(abortEx).catch(() => {
        });
        this.#reader = null;
        this.#capability.reject(abortEx);
      }
      get textDivs() {
        return this.#textDivs;
      }
      get textContentItemsStr() {
        return this.#textContentItemsStr;
      }
      #processItems(items) {
        if (this.#disableProcessItems) {
          return;
        }
        this.#layoutTextParams.ctx ??= _TextLayer.#getCtx(this.#lang);
        const textDivs = this.#textDivs, textContentItemsStr = this.#textContentItemsStr;
        for (const item of items) {
          if (textDivs.length > MAX_TEXT_DIVS_TO_RENDER) {
            warn("Ignoring additional textDivs for performance reasons.");
            this.#disableProcessItems = true;
            return;
          }
          if (item.str === void 0) {
            if (item.type === "beginMarkedContentProps" || item.type === "beginMarkedContent") {
              const parent = this.#container;
              this.#container = document.createElement("span");
              this.#container.classList.add("markedContent");
              if (item.id) {
                this.#container.setAttribute("id", `${item.id}`);
              }
              parent.append(this.#container);
            } else if (item.type === "endMarkedContent") {
              this.#container = this.#container.parentNode;
            }
            continue;
          }
          textContentItemsStr.push(item.str);
          this.#appendText(item);
        }
      }
      #appendText(geom) {
        const textDiv = document.createElement("span");
        const textDivProperties = {
          angle: 0,
          canvasWidth: 0,
          hasText: geom.str !== "",
          hasEOL: geom.hasEOL,
          fontSize: 0
        };
        this.#textDivs.push(textDiv);
        const tx = Util.transform(this.#transform, geom.transform);
        let angle = Math.atan2(tx[1], tx[0]);
        const style = this.#styleCache[geom.fontName];
        if (style.vertical) {
          angle += Math.PI / 2;
        }
        let fontFamily = this.#fontInspectorEnabled && style.fontSubstitution || style.fontFamily;
        fontFamily = _TextLayer.fontFamilyMap.get(fontFamily) || fontFamily;
        const fontHeight = Math.hypot(tx[2], tx[3]);
        const fontAscent = fontHeight * _TextLayer.#getAscent(fontFamily, style, this.#lang);
        let left, top;
        if (angle === 0) {
          left = tx[4];
          top = tx[5] - fontAscent;
        } else {
          left = tx[4] + fontAscent * Math.sin(angle);
          top = tx[5] - fontAscent * Math.cos(angle);
        }
        const scaleFactorStr = "calc(var(--total-scale-factor) *";
        const divStyle = textDiv.style;
        if (this.#container === this.#rootContainer) {
          divStyle.left = `${(100 * left / this.#pageWidth).toFixed(2)}%`;
          divStyle.top = `${(100 * top / this.#pageHeight).toFixed(2)}%`;
        } else {
          divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;
          divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;
        }
        divStyle.fontSize = `${scaleFactorStr}${(_TextLayer.#minFontSize * fontHeight).toFixed(2)}px)`;
        divStyle.fontFamily = fontFamily;
        textDivProperties.fontSize = fontHeight;
        textDiv.setAttribute("role", "presentation");
        textDiv.textContent = geom.str;
        textDiv.dir = geom.dir;
        if (this.#fontInspectorEnabled) {
          textDiv.dataset.fontName = style.fontSubstitutionLoadedName || geom.fontName;
        }
        if (angle !== 0) {
          textDivProperties.angle = angle * (180 / Math.PI);
        }
        let shouldScaleText = false;
        if (geom.str.length > 1) {
          shouldScaleText = true;
        } else if (geom.str !== " " && geom.transform[0] !== geom.transform[3]) {
          const absScaleX = Math.abs(geom.transform[0]), absScaleY = Math.abs(geom.transform[3]);
          if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {
            shouldScaleText = true;
          }
        }
        if (shouldScaleText) {
          textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;
        }
        this.#textDivProperties.set(textDiv, textDivProperties);
        this.#layoutTextParams.div = textDiv;
        this.#layoutTextParams.properties = textDivProperties;
        this.#layout(this.#layoutTextParams);
        if (textDivProperties.hasText) {
          this.#container.append(textDiv);
        }
        if (textDivProperties.hasEOL) {
          const br = document.createElement("br");
          br.setAttribute("role", "presentation");
          this.#container.append(br);
        }
      }
      #layout(params) {
        const {
          div,
          properties,
          ctx
        } = params;
        const {
          style
        } = div;
        let transform = "";
        if (_TextLayer.#minFontSize > 1) {
          transform = `scale(${1 / _TextLayer.#minFontSize})`;
        }
        if (properties.canvasWidth !== 0 && properties.hasText) {
          const {
            fontFamily
          } = style;
          const {
            canvasWidth,
            fontSize
          } = properties;
          _TextLayer.#ensureCtxFont(ctx, fontSize * this.#scale, fontFamily);
          const {
            width
          } = ctx.measureText(div.textContent);
          if (width > 0) {
            transform = `scaleX(${canvasWidth * this.#scale / width}) ${transform}`;
          }
        }
        if (properties.angle !== 0) {
          transform = `rotate(${properties.angle}deg) ${transform}`;
        }
        if (transform.length > 0) {
          style.transform = transform;
        }
      }
      static cleanup() {
        if (this.#pendingTextLayers.size > 0) {
          return;
        }
        this.#ascentCache.clear();
        for (const {
          canvas
        } of this.#canvasContexts.values()) {
          canvas.remove();
        }
        this.#canvasContexts.clear();
      }
      static #getCtx(lang = null) {
        let ctx = this.#canvasContexts.get(lang ||= "");
        if (!ctx) {
          const canvas = document.createElement("canvas");
          canvas.className = "hiddenCanvasElement";
          canvas.lang = lang;
          document.body.append(canvas);
          ctx = canvas.getContext("2d", {
            alpha: false,
            willReadFrequently: true
          });
          this.#canvasContexts.set(lang, ctx);
          this.#canvasCtxFonts.set(ctx, {
            size: 0,
            family: ""
          });
        }
        return ctx;
      }
      static #ensureCtxFont(ctx, size2, family) {
        const cached = this.#canvasCtxFonts.get(ctx);
        if (size2 === cached.size && family === cached.family) {
          return;
        }
        ctx.font = `${size2}px ${family}`;
        cached.size = size2;
        cached.family = family;
      }
      static #ensureMinFontSizeComputed() {
        if (this.#minFontSize !== null) {
          return;
        }
        const div = document.createElement("div");
        div.style.opacity = 0;
        div.style.lineHeight = 1;
        div.style.fontSize = "1px";
        div.style.position = "absolute";
        div.textContent = "X";
        document.body.append(div);
        this.#minFontSize = div.getBoundingClientRect().height;
        div.remove();
      }
      static #getAscent(fontFamily, style, lang) {
        const cachedAscent = this.#ascentCache.get(fontFamily);
        if (cachedAscent) {
          return cachedAscent;
        }
        const ctx = this.#getCtx(lang);
        ctx.canvas.width = ctx.canvas.height = DEFAULT_FONT_SIZE;
        this.#ensureCtxFont(ctx, DEFAULT_FONT_SIZE, fontFamily);
        const metrics = ctx.measureText("");
        const ascent = metrics.fontBoundingBoxAscent;
        const descent = Math.abs(metrics.fontBoundingBoxDescent);
        ctx.canvas.width = ctx.canvas.height = 0;
        let ratio = 0.8;
        if (ascent) {
          ratio = ascent / (ascent + descent);
        } else {
          if (util_FeatureTest.platform.isFirefox) {
            warn("Enable the `dom.textMetrics.fontBoundingBox.enabled` preference in `about:config` to improve TextLayer rendering.");
          }
          if (style.ascent) {
            ratio = style.ascent;
          } else if (style.descent) {
            ratio = 1 + style.descent;
          }
        }
        this.#ascentCache.set(fontFamily, ratio);
        return ratio;
      }
    };
    RENDERING_CANCELLED_TIMEOUT = 100;
    PDFDocumentLoadingTask = class _PDFDocumentLoadingTask {
      static #docId = 0;
      _capability = Promise.withResolvers();
      _transport = null;
      _worker = null;
      docId = `d${_PDFDocumentLoadingTask.#docId++}`;
      destroyed = false;
      onPassword = null;
      onProgress = null;
      get promise() {
        return this._capability.promise;
      }
      async destroy() {
        this.destroyed = true;
        try {
          if (this._worker?.port) {
            this._worker._pendingDestroy = true;
          }
          await this._transport?.destroy();
        } catch (ex) {
          if (this._worker?.port) {
            delete this._worker._pendingDestroy;
          }
          throw ex;
        }
        this._transport = null;
        this._worker?.destroy();
        this._worker = null;
      }
      async getData() {
        return this._transport.getData();
      }
    };
    PDFDataRangeTransport = class {
      #capability = Promise.withResolvers();
      #progressiveDoneListeners = [];
      #progressiveReadListeners = [];
      #progressListeners = [];
      #rangeListeners = [];
      constructor(length, initialData, progressiveDone = false, contentDispositionFilename = null) {
        this.length = length;
        this.initialData = initialData;
        this.progressiveDone = progressiveDone;
        this.contentDispositionFilename = contentDispositionFilename;
      }
      addRangeListener(listener) {
        this.#rangeListeners.push(listener);
      }
      addProgressListener(listener) {
        this.#progressListeners.push(listener);
      }
      addProgressiveReadListener(listener) {
        this.#progressiveReadListeners.push(listener);
      }
      addProgressiveDoneListener(listener) {
        this.#progressiveDoneListeners.push(listener);
      }
      onDataRange(begin, chunk2) {
        for (const listener of this.#rangeListeners) {
          listener(begin, chunk2);
        }
      }
      onDataProgress(loaded, total) {
        this.#capability.promise.then(() => {
          for (const listener of this.#progressListeners) {
            listener(loaded, total);
          }
        });
      }
      onDataProgressiveRead(chunk2) {
        this.#capability.promise.then(() => {
          for (const listener of this.#progressiveReadListeners) {
            listener(chunk2);
          }
        });
      }
      onDataProgressiveDone() {
        this.#capability.promise.then(() => {
          for (const listener of this.#progressiveDoneListeners) {
            listener();
          }
        });
      }
      transportReady() {
        this.#capability.resolve();
      }
      requestDataRange(begin, end) {
        unreachable("Abstract method PDFDataRangeTransport.requestDataRange");
      }
      abort() {
      }
    };
    PDFDocumentProxy = class {
      constructor(pdfInfo, transport) {
        this._pdfInfo = pdfInfo;
        this._transport = transport;
      }
      get annotationStorage() {
        return this._transport.annotationStorage;
      }
      get canvasFactory() {
        return this._transport.canvasFactory;
      }
      get filterFactory() {
        return this._transport.filterFactory;
      }
      get numPages() {
        return this._pdfInfo.numPages;
      }
      get fingerprints() {
        return this._pdfInfo.fingerprints;
      }
      get isPureXfa() {
        return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
      }
      get allXfaHtml() {
        return this._transport._htmlForXfa;
      }
      getPage(pageNumber) {
        return this._transport.getPage(pageNumber);
      }
      getPageIndex(ref) {
        return this._transport.getPageIndex(ref);
      }
      getDestinations() {
        return this._transport.getDestinations();
      }
      getDestination(id) {
        return this._transport.getDestination(id);
      }
      getPageLabels() {
        return this._transport.getPageLabels();
      }
      getPageLayout() {
        return this._transport.getPageLayout();
      }
      getPageMode() {
        return this._transport.getPageMode();
      }
      getViewerPreferences() {
        return this._transport.getViewerPreferences();
      }
      getOpenAction() {
        return this._transport.getOpenAction();
      }
      getAttachments() {
        return this._transport.getAttachments();
      }
      getAnnotationsByType(types, pageIndexesToSkip) {
        return this._transport.getAnnotationsByType(types, pageIndexesToSkip);
      }
      getJSActions() {
        return this._transport.getDocJSActions();
      }
      getOutline() {
        return this._transport.getOutline();
      }
      getOptionalContentConfig({
        intent = "display"
      } = {}) {
        const {
          renderingIntent
        } = this._transport.getRenderingIntent(intent);
        return this._transport.getOptionalContentConfig(renderingIntent);
      }
      getPermissions() {
        return this._transport.getPermissions();
      }
      getMetadata() {
        return this._transport.getMetadata();
      }
      getMarkInfo() {
        return this._transport.getMarkInfo();
      }
      getData() {
        return this._transport.getData();
      }
      saveDocument() {
        return this._transport.saveDocument();
      }
      getDownloadInfo() {
        return this._transport.downloadInfoCapability.promise;
      }
      cleanup(keepLoadedFonts = false) {
        return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);
      }
      destroy() {
        return this.loadingTask.destroy();
      }
      cachedPageNumber(ref) {
        return this._transport.cachedPageNumber(ref);
      }
      get loadingParams() {
        return this._transport.loadingParams;
      }
      get loadingTask() {
        return this._transport.loadingTask;
      }
      getFieldObjects() {
        return this._transport.getFieldObjects();
      }
      hasJSActions() {
        return this._transport.hasJSActions();
      }
      getCalculationOrderIds() {
        return this._transport.getCalculationOrderIds();
      }
    };
    PDFPageProxy = class {
      #pendingCleanup = false;
      constructor(pageIndex, pageInfo, transport, pdfBug = false) {
        this._pageIndex = pageIndex;
        this._pageInfo = pageInfo;
        this._transport = transport;
        this._stats = pdfBug ? new StatTimer() : null;
        this._pdfBug = pdfBug;
        this.commonObjs = transport.commonObjs;
        this.objs = new PDFObjects();
        this._intentStates = /* @__PURE__ */ new Map();
        this.destroyed = false;
        this.recordedBBoxes = null;
      }
      get pageNumber() {
        return this._pageIndex + 1;
      }
      get rotate() {
        return this._pageInfo.rotate;
      }
      get ref() {
        return this._pageInfo.ref;
      }
      get userUnit() {
        return this._pageInfo.userUnit;
      }
      get view() {
        return this._pageInfo.view;
      }
      getViewport({
        scale,
        rotation = this.rotate,
        offsetX = 0,
        offsetY = 0,
        dontFlip = false
      } = {}) {
        return new PageViewport({
          viewBox: this.view,
          userUnit: this.userUnit,
          scale,
          rotation,
          offsetX,
          offsetY,
          dontFlip
        });
      }
      getAnnotations({
        intent = "display"
      } = {}) {
        const {
          renderingIntent
        } = this._transport.getRenderingIntent(intent);
        return this._transport.getAnnotations(this._pageIndex, renderingIntent);
      }
      getJSActions() {
        return this._transport.getPageJSActions(this._pageIndex);
      }
      get filterFactory() {
        return this._transport.filterFactory;
      }
      get isPureXfa() {
        return shadow(this, "isPureXfa", !!this._transport._htmlForXfa);
      }
      async getXfa() {
        return this._transport._htmlForXfa?.children[this._pageIndex] || null;
      }
      render({
        canvasContext,
        canvas = canvasContext.canvas,
        viewport,
        intent = "display",
        annotationMode = AnnotationMode.ENABLE,
        transform = null,
        background = null,
        optionalContentConfigPromise = null,
        annotationCanvasMap = null,
        pageColors = null,
        printAnnotationStorage = null,
        isEditing = false,
        recordOperations = false,
        operationsFilter = null
      }) {
        this._stats?.time("Overall");
        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing);
        const {
          renderingIntent,
          cacheKey
        } = intentArgs;
        this.#pendingCleanup = false;
        optionalContentConfigPromise ||= this._transport.getOptionalContentConfig(renderingIntent);
        let intentState = this._intentStates.get(cacheKey);
        if (!intentState) {
          intentState = /* @__PURE__ */ Object.create(null);
          this._intentStates.set(cacheKey, intentState);
        }
        if (intentState.streamReaderCancelTimeout) {
          clearTimeout(intentState.streamReaderCancelTimeout);
          intentState.streamReaderCancelTimeout = null;
        }
        const intentPrint = !!(renderingIntent & RenderingIntentFlag.PRINT);
        if (!intentState.displayReadyCapability) {
          intentState.displayReadyCapability = Promise.withResolvers();
          intentState.operatorList = {
            fnArray: [],
            argsArray: [],
            lastChunk: false,
            separateAnnots: null
          };
          this._stats?.time("Page Request");
          this._pumpOperatorList(intentArgs);
        }
        const recordForDebugger = Boolean(this._pdfBug && globalThis.StepperManager?.enabled);
        const shouldRecordOperations = !this.recordedBBoxes && (recordOperations || recordForDebugger);
        const complete = (error) => {
          intentState.renderTasks.delete(internalRenderTask);
          if (shouldRecordOperations) {
            const recordedBBoxes = internalRenderTask.gfx?.dependencyTracker.take();
            if (recordedBBoxes) {
              if (internalRenderTask.stepper) {
                internalRenderTask.stepper.setOperatorBBoxes(recordedBBoxes, internalRenderTask.gfx.dependencyTracker.takeDebugMetadata());
              }
              if (recordOperations) {
                this.recordedBBoxes = recordedBBoxes;
              }
            }
          }
          if (intentPrint) {
            this.#pendingCleanup = true;
          }
          this.#tryCleanup();
          if (error) {
            internalRenderTask.capability.reject(error);
            this._abortOperatorList({
              intentState,
              reason: error instanceof Error ? error : new Error(error)
            });
          } else {
            internalRenderTask.capability.resolve();
          }
          if (this._stats) {
            this._stats.timeEnd("Rendering");
            this._stats.timeEnd("Overall");
            if (globalThis.Stats?.enabled) {
              globalThis.Stats.add(this.pageNumber, this._stats);
            }
          }
        };
        const internalRenderTask = new InternalRenderTask({
          callback: complete,
          params: {
            canvas,
            canvasContext,
            dependencyTracker: shouldRecordOperations ? new CanvasDependencyTracker(canvas, intentState.operatorList.length, recordForDebugger) : null,
            viewport,
            transform,
            background
          },
          objs: this.objs,
          commonObjs: this.commonObjs,
          annotationCanvasMap,
          operatorList: intentState.operatorList,
          pageIndex: this._pageIndex,
          canvasFactory: this._transport.canvasFactory,
          filterFactory: this._transport.filterFactory,
          useRequestAnimationFrame: !intentPrint,
          pdfBug: this._pdfBug,
          pageColors,
          enableHWA: this._transport.enableHWA,
          operationsFilter
        });
        (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(internalRenderTask);
        const renderTask = internalRenderTask.task;
        Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(([transparency, optionalContentConfig]) => {
          if (this.destroyed) {
            complete();
            return;
          }
          this._stats?.time("Rendering");
          if (!(optionalContentConfig.renderingIntent & renderingIntent)) {
            throw new Error("Must use the same `intent`-argument when calling the `PDFPageProxy.render` and `PDFDocumentProxy.getOptionalContentConfig` methods.");
          }
          internalRenderTask.initializeGraphics({
            transparency,
            optionalContentConfig
          });
          internalRenderTask.operatorListChanged();
        }).catch(complete);
        return renderTask;
      }
      getOperatorList({
        intent = "display",
        annotationMode = AnnotationMode.ENABLE,
        printAnnotationStorage = null,
        isEditing = false
      } = {}) {
        function operatorListChanged() {
          if (intentState.operatorList.lastChunk) {
            intentState.opListReadCapability.resolve(intentState.operatorList);
            intentState.renderTasks.delete(opListTask);
          }
        }
        const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, isEditing, true);
        let intentState = this._intentStates.get(intentArgs.cacheKey);
        if (!intentState) {
          intentState = /* @__PURE__ */ Object.create(null);
          this._intentStates.set(intentArgs.cacheKey, intentState);
        }
        let opListTask;
        if (!intentState.opListReadCapability) {
          opListTask = /* @__PURE__ */ Object.create(null);
          opListTask.operatorListChanged = operatorListChanged;
          intentState.opListReadCapability = Promise.withResolvers();
          (intentState.renderTasks ||= /* @__PURE__ */ new Set()).add(opListTask);
          intentState.operatorList = {
            fnArray: [],
            argsArray: [],
            lastChunk: false,
            separateAnnots: null
          };
          this._stats?.time("Page Request");
          this._pumpOperatorList(intentArgs);
        }
        return intentState.opListReadCapability.promise;
      }
      streamTextContent({
        includeMarkedContent = false,
        disableNormalization = false
      } = {}) {
        const TEXT_CONTENT_CHUNK_SIZE = 100;
        return this._transport.messageHandler.sendWithStream("GetTextContent", {
          pageIndex: this._pageIndex,
          includeMarkedContent: includeMarkedContent === true,
          disableNormalization: disableNormalization === true
        }, {
          highWaterMark: TEXT_CONTENT_CHUNK_SIZE,
          size(textContent) {
            return textContent.items.length;
          }
        });
      }
      getTextContent(params = {}) {
        if (this._transport._htmlForXfa) {
          return this.getXfa().then((xfa) => XfaText.textContent(xfa));
        }
        const readableStream = this.streamTextContent(params);
        return new Promise(function(resolve, reject2) {
          function pump() {
            reader.read().then(function({
              value,
              done
            }) {
              if (done) {
                resolve(textContent);
                return;
              }
              textContent.lang ??= value.lang;
              Object.assign(textContent.styles, value.styles);
              textContent.items.push(...value.items);
              pump();
            }, reject2);
          }
          const reader = readableStream.getReader();
          const textContent = {
            items: [],
            styles: /* @__PURE__ */ Object.create(null),
            lang: null
          };
          pump();
        });
      }
      getStructTree() {
        return this._transport.getStructTree(this._pageIndex);
      }
      _destroy() {
        this.destroyed = true;
        const waitOn = [];
        for (const intentState of this._intentStates.values()) {
          this._abortOperatorList({
            intentState,
            reason: new Error("Page was destroyed."),
            force: true
          });
          if (intentState.opListReadCapability) {
            continue;
          }
          for (const internalRenderTask of intentState.renderTasks) {
            waitOn.push(internalRenderTask.completed);
            internalRenderTask.cancel();
          }
        }
        this.objs.clear();
        this.#pendingCleanup = false;
        return Promise.all(waitOn);
      }
      cleanup(resetStats = false) {
        this.#pendingCleanup = true;
        const success = this.#tryCleanup();
        if (resetStats && success) {
          this._stats &&= new StatTimer();
        }
        return success;
      }
      #tryCleanup() {
        if (!this.#pendingCleanup || this.destroyed) {
          return false;
        }
        for (const {
          renderTasks,
          operatorList
        } of this._intentStates.values()) {
          if (renderTasks.size > 0 || !operatorList.lastChunk) {
            return false;
          }
        }
        this._intentStates.clear();
        this.objs.clear();
        this.#pendingCleanup = false;
        return true;
      }
      _startRenderPage(transparency, cacheKey) {
        const intentState = this._intentStates.get(cacheKey);
        if (!intentState) {
          return;
        }
        this._stats?.timeEnd("Page Request");
        intentState.displayReadyCapability?.resolve(transparency);
      }
      _renderPageChunk(operatorListChunk, intentState) {
        for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {
          intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);
          intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);
        }
        intentState.operatorList.lastChunk = operatorListChunk.lastChunk;
        intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;
        for (const internalRenderTask of intentState.renderTasks) {
          internalRenderTask.operatorListChanged();
        }
        if (operatorListChunk.lastChunk) {
          this.#tryCleanup();
        }
      }
      _pumpOperatorList({
        renderingIntent,
        cacheKey,
        annotationStorageSerializable,
        modifiedIds
      }) {
        const {
          map: map2,
          transfer
        } = annotationStorageSerializable;
        const readableStream = this._transport.messageHandler.sendWithStream("GetOperatorList", {
          pageIndex: this._pageIndex,
          intent: renderingIntent,
          cacheKey,
          annotationStorage: map2,
          modifiedIds
        }, transfer);
        const reader = readableStream.getReader();
        const intentState = this._intentStates.get(cacheKey);
        intentState.streamReader = reader;
        const pump = () => {
          reader.read().then(({
            value,
            done
          }) => {
            if (done) {
              intentState.streamReader = null;
              return;
            }
            if (this._transport.destroyed) {
              return;
            }
            this._renderPageChunk(value, intentState);
            pump();
          }, (reason) => {
            intentState.streamReader = null;
            if (this._transport.destroyed) {
              return;
            }
            if (intentState.operatorList) {
              intentState.operatorList.lastChunk = true;
              for (const internalRenderTask of intentState.renderTasks) {
                internalRenderTask.operatorListChanged();
              }
              this.#tryCleanup();
            }
            if (intentState.displayReadyCapability) {
              intentState.displayReadyCapability.reject(reason);
            } else if (intentState.opListReadCapability) {
              intentState.opListReadCapability.reject(reason);
            } else {
              throw reason;
            }
          });
        };
        pump();
      }
      _abortOperatorList({
        intentState,
        reason,
        force = false
      }) {
        if (!intentState.streamReader) {
          return;
        }
        if (intentState.streamReaderCancelTimeout) {
          clearTimeout(intentState.streamReaderCancelTimeout);
          intentState.streamReaderCancelTimeout = null;
        }
        if (!force) {
          if (intentState.renderTasks.size > 0) {
            return;
          }
          if (reason instanceof RenderingCancelledException) {
            let delay = RENDERING_CANCELLED_TIMEOUT;
            if (reason.extraDelay > 0 && reason.extraDelay < 1e3) {
              delay += reason.extraDelay;
            }
            intentState.streamReaderCancelTimeout = setTimeout(() => {
              intentState.streamReaderCancelTimeout = null;
              this._abortOperatorList({
                intentState,
                reason,
                force: true
              });
            }, delay);
            return;
          }
        }
        intentState.streamReader.cancel(new AbortException(reason.message)).catch(() => {
        });
        intentState.streamReader = null;
        if (this._transport.destroyed) {
          return;
        }
        for (const [curCacheKey, curIntentState] of this._intentStates) {
          if (curIntentState === intentState) {
            this._intentStates.delete(curCacheKey);
            break;
          }
        }
        this.cleanup();
      }
      get stats() {
        return this._stats;
      }
    };
    PDFWorker = class _PDFWorker {
      #capability = Promise.withResolvers();
      #messageHandler = null;
      #port = null;
      #webWorker = null;
      static #fakeWorkerId = 0;
      static #isWorkerDisabled = false;
      static #workerPorts = /* @__PURE__ */ new WeakMap();
      static {
        if (isNodeJS) {
          this.#isWorkerDisabled = true;
          GlobalWorkerOptions.workerSrc ||= "./pdf.worker.mjs";
        }
        this._isSameOrigin = (baseUrl, otherUrl) => {
          const base = URL.parse(baseUrl);
          if (!base?.origin || base.origin === "null") {
            return false;
          }
          const other = new URL(otherUrl, base);
          return base.origin === other.origin;
        };
        this._createCDNWrapper = (url) => {
          const wrapper = `await import("${url}");`;
          return URL.createObjectURL(new Blob([wrapper], {
            type: "text/javascript"
          }));
        };
        this.fromPort = (params) => {
          deprecated("`PDFWorker.fromPort` - please use `PDFWorker.create` instead.");
          if (!params?.port) {
            throw new Error("PDFWorker.fromPort - invalid method signature.");
          }
          return this.create(params);
        };
      }
      constructor({
        name = null,
        port = null,
        verbosity: verbosity2 = getVerbosityLevel()
      } = {}) {
        this.name = name;
        this.destroyed = false;
        this.verbosity = verbosity2;
        if (port) {
          if (_PDFWorker.#workerPorts.has(port)) {
            throw new Error("Cannot use more than one PDFWorker per port.");
          }
          _PDFWorker.#workerPorts.set(port, this);
          this.#initializeFromPort(port);
        } else {
          this.#initialize();
        }
      }
      get promise() {
        return this.#capability.promise;
      }
      #resolve() {
        this.#capability.resolve();
        this.#messageHandler.send("configure", {
          verbosity: this.verbosity
        });
      }
      get port() {
        return this.#port;
      }
      get messageHandler() {
        return this.#messageHandler;
      }
      #initializeFromPort(port) {
        this.#port = port;
        this.#messageHandler = new MessageHandler("main", "worker", port);
        this.#messageHandler.on("ready", () => {
        });
        this.#resolve();
      }
      #initialize() {
        if (_PDFWorker.#isWorkerDisabled || _PDFWorker.#mainThreadWorkerMessageHandler) {
          this.#setupFakeWorker();
          return;
        }
        let {
          workerSrc
        } = _PDFWorker;
        try {
          if (!_PDFWorker._isSameOrigin(window.location, workerSrc)) {
            workerSrc = _PDFWorker._createCDNWrapper(new URL(workerSrc, window.location).href);
          }
          const worker = new Worker(workerSrc, {
            type: "module"
          });
          const messageHandler = new MessageHandler("main", "worker", worker);
          const terminateEarly = () => {
            ac.abort();
            messageHandler.destroy();
            worker.terminate();
            if (this.destroyed) {
              this.#capability.reject(new Error("Worker was destroyed"));
            } else {
              this.#setupFakeWorker();
            }
          };
          const ac = new AbortController();
          worker.addEventListener("error", () => {
            if (!this.#webWorker) {
              terminateEarly();
            }
          }, {
            signal: ac.signal
          });
          messageHandler.on("test", (data) => {
            ac.abort();
            if (this.destroyed || !data) {
              terminateEarly();
              return;
            }
            this.#messageHandler = messageHandler;
            this.#port = worker;
            this.#webWorker = worker;
            this.#resolve();
          });
          messageHandler.on("ready", (data) => {
            ac.abort();
            if (this.destroyed) {
              terminateEarly();
              return;
            }
            try {
              sendTest();
            } catch {
              this.#setupFakeWorker();
            }
          });
          const sendTest = () => {
            const testObj = new Uint8Array();
            messageHandler.send("test", testObj, [testObj.buffer]);
          };
          sendTest();
          return;
        } catch {
          info("The worker has been disabled.");
        }
        this.#setupFakeWorker();
      }
      #setupFakeWorker() {
        if (!_PDFWorker.#isWorkerDisabled) {
          warn("Setting up fake worker.");
          _PDFWorker.#isWorkerDisabled = true;
        }
        _PDFWorker._setupFakeWorkerGlobal.then((WorkerMessageHandler) => {
          if (this.destroyed) {
            this.#capability.reject(new Error("Worker was destroyed"));
            return;
          }
          const port = new LoopbackPort();
          this.#port = port;
          const id = `fake${_PDFWorker.#fakeWorkerId++}`;
          const workerHandler = new MessageHandler(id + "_worker", id, port);
          WorkerMessageHandler.setup(workerHandler, port);
          this.#messageHandler = new MessageHandler(id, id + "_worker", port);
          this.#resolve();
        }).catch((reason) => {
          this.#capability.reject(new Error(`Setting up fake worker failed: "${reason.message}".`));
        });
      }
      destroy() {
        this.destroyed = true;
        this.#webWorker?.terminate();
        this.#webWorker = null;
        _PDFWorker.#workerPorts.delete(this.#port);
        this.#port = null;
        this.#messageHandler?.destroy();
        this.#messageHandler = null;
      }
      static create(params) {
        const cachedPort = this.#workerPorts.get(params?.port);
        if (cachedPort) {
          if (cachedPort._pendingDestroy) {
            throw new Error("PDFWorker.create - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls.");
          }
          return cachedPort;
        }
        return new _PDFWorker(params);
      }
      static get workerSrc() {
        if (GlobalWorkerOptions.workerSrc) {
          return GlobalWorkerOptions.workerSrc;
        }
        throw new Error('No "GlobalWorkerOptions.workerSrc" specified.');
      }
      static get #mainThreadWorkerMessageHandler() {
        try {
          return globalThis.pdfjsWorker?.WorkerMessageHandler || null;
        } catch {
          return null;
        }
      }
      static get _setupFakeWorkerGlobal() {
        const loader = async () => {
          if (this.#mainThreadWorkerMessageHandler) {
            return this.#mainThreadWorkerMessageHandler;
          }
          const worker = await import(
            /*webpackIgnore: true*/
            /*@vite-ignore*/
            this.workerSrc
          );
          return worker.WorkerMessageHandler;
        };
        return shadow(this, "_setupFakeWorkerGlobal", loader());
      }
    };
    WorkerTransport = class {
      #methodPromises = /* @__PURE__ */ new Map();
      #pageCache = /* @__PURE__ */ new Map();
      #pagePromises = /* @__PURE__ */ new Map();
      #pageRefCache = /* @__PURE__ */ new Map();
      #passwordCapability = null;
      constructor(messageHandler, loadingTask, networkStream, params, factory, enableHWA) {
        this.messageHandler = messageHandler;
        this.loadingTask = loadingTask;
        this.commonObjs = new PDFObjects();
        this.fontLoader = new FontLoader({
          ownerDocument: params.ownerDocument,
          styleElement: params.styleElement
        });
        this.loadingParams = params.loadingParams;
        this._params = params;
        this.canvasFactory = factory.canvasFactory;
        this.filterFactory = factory.filterFactory;
        this.cMapReaderFactory = factory.cMapReaderFactory;
        this.standardFontDataFactory = factory.standardFontDataFactory;
        this.wasmFactory = factory.wasmFactory;
        this.destroyed = false;
        this.destroyCapability = null;
        this._networkStream = networkStream;
        this._fullReader = null;
        this._lastProgress = null;
        this.downloadInfoCapability = Promise.withResolvers();
        this.enableHWA = enableHWA;
        this.setupMessageHandler();
      }
      #cacheSimpleMethod(name, data = null) {
        const cachedPromise = this.#methodPromises.get(name);
        if (cachedPromise) {
          return cachedPromise;
        }
        const promise = this.messageHandler.sendWithPromise(name, data);
        this.#methodPromises.set(name, promise);
        return promise;
      }
      get annotationStorage() {
        return shadow(this, "annotationStorage", new AnnotationStorage());
      }
      getRenderingIntent(intent, annotationMode = AnnotationMode.ENABLE, printAnnotationStorage = null, isEditing = false, isOpList = false) {
        let renderingIntent = RenderingIntentFlag.DISPLAY;
        let annotationStorageSerializable = SerializableEmpty;
        switch (intent) {
          case "any":
            renderingIntent = RenderingIntentFlag.ANY;
            break;
          case "display":
            break;
          case "print":
            renderingIntent = RenderingIntentFlag.PRINT;
            break;
          default:
            warn(`getRenderingIntent - invalid intent: ${intent}`);
        }
        const annotationStorage = renderingIntent & RenderingIntentFlag.PRINT && printAnnotationStorage instanceof PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;
        switch (annotationMode) {
          case AnnotationMode.DISABLE:
            renderingIntent += RenderingIntentFlag.ANNOTATIONS_DISABLE;
            break;
          case AnnotationMode.ENABLE:
            break;
          case AnnotationMode.ENABLE_FORMS:
            renderingIntent += RenderingIntentFlag.ANNOTATIONS_FORMS;
            break;
          case AnnotationMode.ENABLE_STORAGE:
            renderingIntent += RenderingIntentFlag.ANNOTATIONS_STORAGE;
            annotationStorageSerializable = annotationStorage.serializable;
            break;
          default:
            warn(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);
        }
        if (isEditing) {
          renderingIntent += RenderingIntentFlag.IS_EDITING;
        }
        if (isOpList) {
          renderingIntent += RenderingIntentFlag.OPLIST;
        }
        const {
          ids: modifiedIds,
          hash: modifiedIdsHash
        } = annotationStorage.modifiedIds;
        const cacheKeyBuf = [renderingIntent, annotationStorageSerializable.hash, modifiedIdsHash];
        return {
          renderingIntent,
          cacheKey: cacheKeyBuf.join("_"),
          annotationStorageSerializable,
          modifiedIds
        };
      }
      destroy() {
        if (this.destroyCapability) {
          return this.destroyCapability.promise;
        }
        this.destroyed = true;
        this.destroyCapability = Promise.withResolvers();
        this.#passwordCapability?.reject(new Error("Worker was destroyed during onPassword callback"));
        const waitOn = [];
        for (const page of this.#pageCache.values()) {
          waitOn.push(page._destroy());
        }
        this.#pageCache.clear();
        this.#pagePromises.clear();
        this.#pageRefCache.clear();
        if (this.hasOwnProperty("annotationStorage")) {
          this.annotationStorage.resetModified();
        }
        const terminated = this.messageHandler.sendWithPromise("Terminate", null);
        waitOn.push(terminated);
        Promise.all(waitOn).then(() => {
          this.commonObjs.clear();
          this.fontLoader.clear();
          this.#methodPromises.clear();
          this.filterFactory.destroy();
          TextLayer.cleanup();
          this._networkStream?.cancelAllRequests(new AbortException("Worker was terminated."));
          this.messageHandler?.destroy();
          this.messageHandler = null;
          this.destroyCapability.resolve();
        }, this.destroyCapability.reject);
        return this.destroyCapability.promise;
      }
      setupMessageHandler() {
        const {
          messageHandler,
          loadingTask
        } = this;
        messageHandler.on("GetReader", (data, sink) => {
          assert(this._networkStream, "GetReader - no `IPDFStream` instance available.");
          this._fullReader = this._networkStream.getFullReader();
          this._fullReader.onProgress = (evt) => {
            this._lastProgress = {
              loaded: evt.loaded,
              total: evt.total
            };
          };
          sink.onPull = () => {
            this._fullReader.read().then(function({
              value,
              done
            }) {
              if (done) {
                sink.close();
                return;
              }
              assert(value instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer.");
              sink.enqueue(new Uint8Array(value), 1, [value]);
            }).catch((reason) => {
              sink.error(reason);
            });
          };
          sink.onCancel = (reason) => {
            this._fullReader.cancel(reason);
            sink.ready.catch((readyReason) => {
              if (this.destroyed) {
                return;
              }
              throw readyReason;
            });
          };
        });
        messageHandler.on("ReaderHeadersReady", async (data) => {
          await this._fullReader.headersReady;
          const {
            isStreamingSupported,
            isRangeSupported,
            contentLength
          } = this._fullReader;
          if (!isStreamingSupported || !isRangeSupported) {
            if (this._lastProgress) {
              loadingTask.onProgress?.(this._lastProgress);
            }
            this._fullReader.onProgress = (evt) => {
              loadingTask.onProgress?.({
                loaded: evt.loaded,
                total: evt.total
              });
            };
          }
          return {
            isStreamingSupported,
            isRangeSupported,
            contentLength
          };
        });
        messageHandler.on("GetRangeReader", (data, sink) => {
          assert(this._networkStream, "GetRangeReader - no `IPDFStream` instance available.");
          const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);
          if (!rangeReader) {
            sink.close();
            return;
          }
          sink.onPull = () => {
            rangeReader.read().then(function({
              value,
              done
            }) {
              if (done) {
                sink.close();
                return;
              }
              assert(value instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer.");
              sink.enqueue(new Uint8Array(value), 1, [value]);
            }).catch((reason) => {
              sink.error(reason);
            });
          };
          sink.onCancel = (reason) => {
            rangeReader.cancel(reason);
            sink.ready.catch((readyReason) => {
              if (this.destroyed) {
                return;
              }
              throw readyReason;
            });
          };
        });
        messageHandler.on("GetDoc", ({
          pdfInfo
        }) => {
          this._numPages = pdfInfo.numPages;
          this._htmlForXfa = pdfInfo.htmlForXfa;
          delete pdfInfo.htmlForXfa;
          loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));
        });
        messageHandler.on("DocException", (ex) => {
          loadingTask._capability.reject(wrapReason(ex));
        });
        messageHandler.on("PasswordRequest", (ex) => {
          this.#passwordCapability = Promise.withResolvers();
          try {
            if (!loadingTask.onPassword) {
              throw wrapReason(ex);
            }
            const updatePassword = (password) => {
              if (password instanceof Error) {
                this.#passwordCapability.reject(password);
              } else {
                this.#passwordCapability.resolve({
                  password
                });
              }
            };
            loadingTask.onPassword(updatePassword, ex.code);
          } catch (err) {
            this.#passwordCapability.reject(err);
          }
          return this.#passwordCapability.promise;
        });
        messageHandler.on("DataLoaded", (data) => {
          loadingTask.onProgress?.({
            loaded: data.length,
            total: data.length
          });
          this.downloadInfoCapability.resolve(data);
        });
        messageHandler.on("StartRenderPage", (data) => {
          if (this.destroyed) {
            return;
          }
          const page = this.#pageCache.get(data.pageIndex);
          page._startRenderPage(data.transparency, data.cacheKey);
        });
        messageHandler.on("commonobj", ([id, type, exportedData]) => {
          if (this.destroyed) {
            return null;
          }
          if (this.commonObjs.has(id)) {
            return null;
          }
          switch (type) {
            case "Font":
              if ("error" in exportedData) {
                const exportedError = exportedData.error;
                warn(`Error during font loading: ${exportedError}`);
                this.commonObjs.resolve(id, exportedError);
                break;
              }
              const fontData = new FontInfo(exportedData);
              const inspectFont = this._params.pdfBug && globalThis.FontInspector?.enabled ? (font2, url) => globalThis.FontInspector.fontAdded(font2, url) : null;
              const font = new FontFaceObject(fontData, inspectFont, exportedData.extra, exportedData.charProcOperatorList);
              this.fontLoader.bind(font).catch(() => messageHandler.sendWithPromise("FontFallback", {
                id
              })).finally(() => {
                if (!font.fontExtraProperties && font.data) {
                  font.clearData();
                }
                this.commonObjs.resolve(id, font);
              });
              break;
            case "CopyLocalImage":
              const {
                imageRef
              } = exportedData;
              assert(imageRef, "The imageRef must be defined.");
              for (const pageProxy of this.#pageCache.values()) {
                for (const [, data] of pageProxy.objs) {
                  if (data?.ref !== imageRef) {
                    continue;
                  }
                  if (!data.dataLen) {
                    return null;
                  }
                  this.commonObjs.resolve(id, structuredClone(data));
                  return data.dataLen;
                }
              }
              break;
            case "FontPath":
            case "Image":
            case "Pattern":
              this.commonObjs.resolve(id, exportedData);
              break;
            default:
              throw new Error(`Got unknown common object type ${type}`);
          }
          return null;
        });
        messageHandler.on("obj", ([id, pageIndex, type, imageData]) => {
          if (this.destroyed) {
            return;
          }
          const pageProxy = this.#pageCache.get(pageIndex);
          if (pageProxy.objs.has(id)) {
            return;
          }
          if (pageProxy._intentStates.size === 0) {
            imageData?.bitmap?.close();
            return;
          }
          switch (type) {
            case "Image":
            case "Pattern":
              pageProxy.objs.resolve(id, imageData);
              break;
            default:
              throw new Error(`Got unknown object type ${type}`);
          }
        });
        messageHandler.on("DocProgress", (data) => {
          if (this.destroyed) {
            return;
          }
          loadingTask.onProgress?.({
            loaded: data.loaded,
            total: data.total
          });
        });
        messageHandler.on("FetchBinaryData", async (data) => {
          if (this.destroyed) {
            throw new Error("Worker was destroyed.");
          }
          const factory = this[data.type];
          if (!factory) {
            throw new Error(`${data.type} not initialized, see the \`useWorkerFetch\` parameter.`);
          }
          return factory.fetch(data);
        });
      }
      getData() {
        return this.messageHandler.sendWithPromise("GetData", null);
      }
      saveDocument() {
        if (this.annotationStorage.size <= 0) {
          warn("saveDocument called while `annotationStorage` is empty, please use the getData-method instead.");
        }
        const {
          map: map2,
          transfer
        } = this.annotationStorage.serializable;
        return this.messageHandler.sendWithPromise("SaveDocument", {
          isPureXfa: !!this._htmlForXfa,
          numPages: this._numPages,
          annotationStorage: map2,
          filename: this._fullReader?.filename ?? null
        }, transfer).finally(() => {
          this.annotationStorage.resetModified();
        });
      }
      getPage(pageNumber) {
        if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {
          return Promise.reject(new Error("Invalid page request."));
        }
        const pageIndex = pageNumber - 1, cachedPromise = this.#pagePromises.get(pageIndex);
        if (cachedPromise) {
          return cachedPromise;
        }
        const promise = this.messageHandler.sendWithPromise("GetPage", {
          pageIndex
        }).then((pageInfo) => {
          if (this.destroyed) {
            throw new Error("Transport destroyed");
          }
          if (pageInfo.refStr) {
            this.#pageRefCache.set(pageInfo.refStr, pageNumber);
          }
          const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);
          this.#pageCache.set(pageIndex, page);
          return page;
        });
        this.#pagePromises.set(pageIndex, promise);
        return promise;
      }
      getPageIndex(ref) {
        if (!isRefProxy(ref)) {
          return Promise.reject(new Error("Invalid pageIndex request."));
        }
        return this.messageHandler.sendWithPromise("GetPageIndex", {
          num: ref.num,
          gen: ref.gen
        });
      }
      getAnnotations(pageIndex, intent) {
        return this.messageHandler.sendWithPromise("GetAnnotations", {
          pageIndex,
          intent
        });
      }
      getFieldObjects() {
        return this.#cacheSimpleMethod("GetFieldObjects");
      }
      hasJSActions() {
        return this.#cacheSimpleMethod("HasJSActions");
      }
      getCalculationOrderIds() {
        return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null);
      }
      getDestinations() {
        return this.messageHandler.sendWithPromise("GetDestinations", null);
      }
      getDestination(id) {
        if (typeof id !== "string") {
          return Promise.reject(new Error("Invalid destination request."));
        }
        return this.messageHandler.sendWithPromise("GetDestination", {
          id
        });
      }
      getPageLabels() {
        return this.messageHandler.sendWithPromise("GetPageLabels", null);
      }
      getPageLayout() {
        return this.messageHandler.sendWithPromise("GetPageLayout", null);
      }
      getPageMode() {
        return this.messageHandler.sendWithPromise("GetPageMode", null);
      }
      getViewerPreferences() {
        return this.messageHandler.sendWithPromise("GetViewerPreferences", null);
      }
      getOpenAction() {
        return this.messageHandler.sendWithPromise("GetOpenAction", null);
      }
      getAttachments() {
        return this.messageHandler.sendWithPromise("GetAttachments", null);
      }
      getAnnotationsByType(types, pageIndexesToSkip) {
        return this.messageHandler.sendWithPromise("GetAnnotationsByType", {
          types,
          pageIndexesToSkip
        });
      }
      getDocJSActions() {
        return this.#cacheSimpleMethod("GetDocJSActions");
      }
      getPageJSActions(pageIndex) {
        return this.messageHandler.sendWithPromise("GetPageJSActions", {
          pageIndex
        });
      }
      getStructTree(pageIndex) {
        return this.messageHandler.sendWithPromise("GetStructTree", {
          pageIndex
        });
      }
      getOutline() {
        return this.messageHandler.sendWithPromise("GetOutline", null);
      }
      getOptionalContentConfig(renderingIntent) {
        return this.#cacheSimpleMethod("GetOptionalContentConfig").then((data) => new OptionalContentConfig(data, renderingIntent));
      }
      getPermissions() {
        return this.messageHandler.sendWithPromise("GetPermissions", null);
      }
      getMetadata() {
        const name = "GetMetadata", cachedPromise = this.#methodPromises.get(name);
        if (cachedPromise) {
          return cachedPromise;
        }
        const promise = this.messageHandler.sendWithPromise(name, null).then((results) => ({
          info: results[0],
          metadata: results[1] ? new Metadata(results[1]) : null,
          contentDispositionFilename: this._fullReader?.filename ?? null,
          contentLength: this._fullReader?.contentLength ?? null
        }));
        this.#methodPromises.set(name, promise);
        return promise;
      }
      getMarkInfo() {
        return this.messageHandler.sendWithPromise("GetMarkInfo", null);
      }
      async startCleanup(keepLoadedFonts = false) {
        if (this.destroyed) {
          return;
        }
        await this.messageHandler.sendWithPromise("Cleanup", null);
        for (const page of this.#pageCache.values()) {
          const cleanupSuccessful = page.cleanup();
          if (!cleanupSuccessful) {
            throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);
          }
        }
        this.commonObjs.clear();
        if (!keepLoadedFonts) {
          this.fontLoader.clear();
        }
        this.#methodPromises.clear();
        this.filterFactory.destroy(true);
        TextLayer.cleanup();
      }
      cachedPageNumber(ref) {
        if (!isRefProxy(ref)) {
          return null;
        }
        const refStr = ref.gen === 0 ? `${ref.num}R` : `${ref.num}R${ref.gen}`;
        return this.#pageRefCache.get(refStr) ?? null;
      }
    };
    RenderTask = class {
      #internalRenderTask = null;
      onContinue = null;
      onError = null;
      constructor(internalRenderTask) {
        this.#internalRenderTask = internalRenderTask;
      }
      get promise() {
        return this.#internalRenderTask.capability.promise;
      }
      cancel(extraDelay = 0) {
        this.#internalRenderTask.cancel(null, extraDelay);
      }
      get separateAnnots() {
        const {
          separateAnnots
        } = this.#internalRenderTask.operatorList;
        if (!separateAnnots) {
          return false;
        }
        const {
          annotationCanvasMap
        } = this.#internalRenderTask;
        return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;
      }
    };
    InternalRenderTask = class _InternalRenderTask {
      #rAF = null;
      static #canvasInUse = /* @__PURE__ */ new WeakSet();
      constructor({
        callback,
        params,
        objs,
        commonObjs,
        annotationCanvasMap,
        operatorList,
        pageIndex,
        canvasFactory,
        filterFactory,
        useRequestAnimationFrame = false,
        pdfBug = false,
        pageColors = null,
        enableHWA = false,
        operationsFilter = null
      }) {
        this.callback = callback;
        this.params = params;
        this.objs = objs;
        this.commonObjs = commonObjs;
        this.annotationCanvasMap = annotationCanvasMap;
        this.operatorListIdx = null;
        this.operatorList = operatorList;
        this._pageIndex = pageIndex;
        this.canvasFactory = canvasFactory;
        this.filterFactory = filterFactory;
        this._pdfBug = pdfBug;
        this.pageColors = pageColors;
        this.running = false;
        this.graphicsReadyCallback = null;
        this.graphicsReady = false;
        this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== "undefined";
        this.cancelled = false;
        this.capability = Promise.withResolvers();
        this.task = new RenderTask(this);
        this._cancelBound = this.cancel.bind(this);
        this._continueBound = this._continue.bind(this);
        this._scheduleNextBound = this._scheduleNext.bind(this);
        this._nextBound = this._next.bind(this);
        this._canvas = params.canvas;
        this._canvasContext = params.canvas ? null : params.canvasContext;
        this._enableHWA = enableHWA;
        this._dependencyTracker = params.dependencyTracker;
        this._operationsFilter = operationsFilter;
      }
      get completed() {
        return this.capability.promise.catch(function() {
        });
      }
      initializeGraphics({
        transparency = false,
        optionalContentConfig
      }) {
        if (this.cancelled) {
          return;
        }
        if (this._canvas) {
          if (_InternalRenderTask.#canvasInUse.has(this._canvas)) {
            throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed.");
          }
          _InternalRenderTask.#canvasInUse.add(this._canvas);
        }
        if (this._pdfBug && globalThis.StepperManager?.enabled) {
          this.stepper = globalThis.StepperManager.create(this._pageIndex);
          this.stepper.init(this.operatorList);
          this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();
        }
        const {
          viewport,
          transform,
          background,
          dependencyTracker
        } = this.params;
        const canvasContext = this._canvasContext || this._canvas.getContext("2d", {
          alpha: false,
          willReadFrequently: !this._enableHWA
        });
        this.gfx = new CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {
          optionalContentConfig
        }, this.annotationCanvasMap, this.pageColors, dependencyTracker);
        this.gfx.beginDrawing({
          transform,
          viewport,
          transparency,
          background
        });
        this.operatorListIdx = 0;
        this.graphicsReady = true;
        this.graphicsReadyCallback?.();
      }
      cancel(error = null, extraDelay = 0) {
        this.running = false;
        this.cancelled = true;
        this.gfx?.endDrawing();
        if (this.#rAF) {
          window.cancelAnimationFrame(this.#rAF);
          this.#rAF = null;
        }
        _InternalRenderTask.#canvasInUse.delete(this._canvas);
        error ||= new RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay);
        this.callback(error);
        this.task.onError?.(error);
      }
      operatorListChanged() {
        if (!this.graphicsReady) {
          this.graphicsReadyCallback ||= this._continueBound;
          return;
        }
        this.gfx.dependencyTracker?.growOperationsCount(this.operatorList.fnArray.length);
        this.stepper?.updateOperatorList(this.operatorList);
        if (this.running) {
          return;
        }
        this._continue();
      }
      _continue() {
        this.running = true;
        if (this.cancelled) {
          return;
        }
        if (this.task.onContinue) {
          this.task.onContinue(this._scheduleNextBound);
        } else {
          this._scheduleNext();
        }
      }
      _scheduleNext() {
        if (this._useRequestAnimationFrame) {
          this.#rAF = window.requestAnimationFrame(() => {
            this.#rAF = null;
            this._nextBound().catch(this._cancelBound);
          });
        } else {
          Promise.resolve().then(this._nextBound).catch(this._cancelBound);
        }
      }
      async _next() {
        if (this.cancelled) {
          return;
        }
        this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper, this._operationsFilter);
        if (this.operatorListIdx === this.operatorList.argsArray.length) {
          this.running = false;
          if (this.operatorList.lastChunk) {
            this.gfx.endDrawing();
            _InternalRenderTask.#canvasInUse.delete(this._canvas);
            this.callback();
          }
        }
      }
    };
    version = "5.4.296";
    build = "f56dc8601";
    ColorPicker = class _ColorPicker {
      #button = null;
      #buttonSwatch = null;
      #defaultColor;
      #dropdown = null;
      #dropdownWasFromKeyboard = false;
      #isMainColorPicker = false;
      #editor = null;
      #eventBus;
      #openDropdownAC = null;
      #uiManager = null;
      static #l10nColor = null;
      static get _keyboardManager() {
        return shadow(this, "_keyboardManager", new KeyboardManager([[["Escape", "mac+Escape"], _ColorPicker.prototype._hideDropdownFromKeyboard], [[" ", "mac+ "], _ColorPicker.prototype._colorSelectFromKeyboard], [["ArrowDown", "ArrowRight", "mac+ArrowDown", "mac+ArrowRight"], _ColorPicker.prototype._moveToNext], [["ArrowUp", "ArrowLeft", "mac+ArrowUp", "mac+ArrowLeft"], _ColorPicker.prototype._moveToPrevious], [["Home", "mac+Home"], _ColorPicker.prototype._moveToBeginning], [["End", "mac+End"], _ColorPicker.prototype._moveToEnd]]));
      }
      constructor({
        editor = null,
        uiManager = null
      }) {
        if (editor) {
          this.#isMainColorPicker = false;
          this.#editor = editor;
        } else {
          this.#isMainColorPicker = true;
        }
        this.#uiManager = editor?._uiManager || uiManager;
        this.#eventBus = this.#uiManager._eventBus;
        this.#defaultColor = editor?.color?.toUpperCase() || this.#uiManager?.highlightColors.values().next().value || "#FFFF98";
        _ColorPicker.#l10nColor ||= Object.freeze({
          blue: "pdfjs-editor-colorpicker-blue",
          green: "pdfjs-editor-colorpicker-green",
          pink: "pdfjs-editor-colorpicker-pink",
          red: "pdfjs-editor-colorpicker-red",
          yellow: "pdfjs-editor-colorpicker-yellow"
        });
      }
      renderButton() {
        const button = this.#button = document.createElement("button");
        button.className = "colorPicker";
        button.tabIndex = "0";
        button.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-button");
        button.ariaHasPopup = "true";
        if (this.#editor) {
          button.ariaControls = `${this.#editor.id}_colorpicker_dropdown`;
        }
        const signal = this.#uiManager._signal;
        button.addEventListener("click", this.#openDropdown.bind(this), {
          signal
        });
        button.addEventListener("keydown", this.#keyDown.bind(this), {
          signal
        });
        const swatch = this.#buttonSwatch = document.createElement("span");
        swatch.className = "swatch";
        swatch.ariaHidden = "true";
        swatch.style.backgroundColor = this.#defaultColor;
        button.append(swatch);
        return button;
      }
      renderMainDropdown() {
        const dropdown = this.#dropdown = this.#getDropdownRoot();
        dropdown.ariaOrientation = "horizontal";
        dropdown.ariaLabelledBy = "highlightColorPickerLabel";
        return dropdown;
      }
      #getDropdownRoot() {
        const div = document.createElement("div");
        const signal = this.#uiManager._signal;
        div.addEventListener("contextmenu", noContextMenu, {
          signal
        });
        div.className = "dropdown";
        div.role = "listbox";
        div.ariaMultiSelectable = "false";
        div.ariaOrientation = "vertical";
        div.setAttribute("data-l10n-id", "pdfjs-editor-colorpicker-dropdown");
        if (this.#editor) {
          div.id = `${this.#editor.id}_colorpicker_dropdown`;
        }
        for (const [name, color] of this.#uiManager.highlightColors) {
          const button = document.createElement("button");
          button.tabIndex = "0";
          button.role = "option";
          button.setAttribute("data-color", color);
          button.title = name;
          button.setAttribute("data-l10n-id", _ColorPicker.#l10nColor[name]);
          const swatch = document.createElement("span");
          button.append(swatch);
          swatch.className = "swatch";
          swatch.style.backgroundColor = color;
          button.ariaSelected = color === this.#defaultColor;
          button.addEventListener("click", this.#colorSelect.bind(this, color), {
            signal
          });
          div.append(button);
        }
        div.addEventListener("keydown", this.#keyDown.bind(this), {
          signal
        });
        return div;
      }
      #colorSelect(color, event) {
        event.stopPropagation();
        this.#eventBus.dispatch("switchannotationeditorparams", {
          source: this,
          type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
          value: color
        });
        this.updateColor(color);
      }
      _colorSelectFromKeyboard(event) {
        if (event.target === this.#button) {
          this.#openDropdown(event);
          return;
        }
        const color = event.target.getAttribute("data-color");
        if (!color) {
          return;
        }
        this.#colorSelect(color, event);
      }
      _moveToNext(event) {
        if (!this.#isDropdownVisible) {
          this.#openDropdown(event);
          return;
        }
        if (event.target === this.#button) {
          this.#dropdown.firstChild?.focus();
          return;
        }
        event.target.nextSibling?.focus();
      }
      _moveToPrevious(event) {
        if (event.target === this.#dropdown?.firstChild || event.target === this.#button) {
          if (this.#isDropdownVisible) {
            this._hideDropdownFromKeyboard();
          }
          return;
        }
        if (!this.#isDropdownVisible) {
          this.#openDropdown(event);
        }
        event.target.previousSibling?.focus();
      }
      _moveToBeginning(event) {
        if (!this.#isDropdownVisible) {
          this.#openDropdown(event);
          return;
        }
        this.#dropdown.firstChild?.focus();
      }
      _moveToEnd(event) {
        if (!this.#isDropdownVisible) {
          this.#openDropdown(event);
          return;
        }
        this.#dropdown.lastChild?.focus();
      }
      #keyDown(event) {
        _ColorPicker._keyboardManager.exec(this, event);
      }
      #openDropdown(event) {
        if (this.#isDropdownVisible) {
          this.hideDropdown();
          return;
        }
        this.#dropdownWasFromKeyboard = event.detail === 0;
        if (!this.#openDropdownAC) {
          this.#openDropdownAC = new AbortController();
          window.addEventListener("pointerdown", this.#pointerDown.bind(this), {
            signal: this.#uiManager.combinedSignal(this.#openDropdownAC)
          });
        }
        this.#button.ariaExpanded = "true";
        if (this.#dropdown) {
          this.#dropdown.classList.remove("hidden");
          return;
        }
        const root2 = this.#dropdown = this.#getDropdownRoot();
        this.#button.append(root2);
      }
      #pointerDown(event) {
        if (this.#dropdown?.contains(event.target)) {
          return;
        }
        this.hideDropdown();
      }
      hideDropdown() {
        this.#dropdown?.classList.add("hidden");
        this.#button.ariaExpanded = "false";
        this.#openDropdownAC?.abort();
        this.#openDropdownAC = null;
      }
      get #isDropdownVisible() {
        return this.#dropdown && !this.#dropdown.classList.contains("hidden");
      }
      _hideDropdownFromKeyboard() {
        if (this.#isMainColorPicker) {
          return;
        }
        if (!this.#isDropdownVisible) {
          this.#editor?.unselect();
          return;
        }
        this.hideDropdown();
        this.#button.focus({
          preventScroll: true,
          focusVisible: this.#dropdownWasFromKeyboard
        });
      }
      updateColor(color) {
        if (this.#buttonSwatch) {
          this.#buttonSwatch.style.backgroundColor = color;
        }
        if (!this.#dropdown) {
          return;
        }
        const i = this.#uiManager.highlightColors.values();
        for (const child of this.#dropdown.children) {
          child.ariaSelected = i.next().value === color.toUpperCase();
        }
      }
      destroy() {
        this.#button?.remove();
        this.#button = null;
        this.#buttonSwatch = null;
        this.#dropdown?.remove();
        this.#dropdown = null;
      }
    };
    BasicColorPicker = class _BasicColorPicker {
      #input = null;
      #editor = null;
      #uiManager = null;
      static #l10nColor = null;
      constructor(editor) {
        this.#editor = editor;
        this.#uiManager = editor._uiManager;
        _BasicColorPicker.#l10nColor ||= Object.freeze({
          freetext: "pdfjs-editor-color-picker-free-text-input",
          ink: "pdfjs-editor-color-picker-ink-input"
        });
      }
      renderButton() {
        if (this.#input) {
          return this.#input;
        }
        const {
          editorType,
          colorType,
          colorValue
        } = this.#editor;
        const input = this.#input = document.createElement("input");
        input.type = "color";
        input.value = colorValue || "#000000";
        input.className = "basicColorPicker";
        input.tabIndex = 0;
        input.setAttribute("data-l10n-id", _BasicColorPicker.#l10nColor[editorType]);
        input.addEventListener("input", () => {
          this.#uiManager.updateParams(colorType, input.value);
        }, {
          signal: this.#uiManager._signal
        });
        return input;
      }
      update(value) {
        if (!this.#input) {
          return;
        }
        this.#input.value = value;
      }
      destroy() {
        this.#input?.remove();
        this.#input = null;
      }
      hideDropdown() {
      }
    };
    es_iterator_find = __webpack_require__(116);
    es_iterator_flat_map = __webpack_require__(531);
    ColorConverters = class {
      static CMYK_G([c, y, m, k]) {
        return ["G", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];
      }
      static G_CMYK([g]) {
        return ["CMYK", 0, 0, 0, 1 - g];
      }
      static G_RGB([g]) {
        return ["RGB", g, g, g];
      }
      static G_rgb([g]) {
        g = scaleAndClamp(g);
        return [g, g, g];
      }
      static G_HTML([g]) {
        const G = makeColorComp(g);
        return `#${G}${G}${G}`;
      }
      static RGB_G([r, g, b]) {
        return ["G", 0.3 * r + 0.59 * g + 0.11 * b];
      }
      static RGB_rgb(color) {
        return color.map(scaleAndClamp);
      }
      static RGB_HTML(color) {
        return `#${color.map(makeColorComp).join("")}`;
      }
      static T_HTML() {
        return "#00000000";
      }
      static T_rgb() {
        return [null];
      }
      static CMYK_RGB([c, y, m, k]) {
        return ["RGB", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];
      }
      static CMYK_rgb([c, y, m, k]) {
        return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];
      }
      static CMYK_HTML(components) {
        const rgb = this.CMYK_RGB(components).slice(1);
        return this.RGB_HTML(rgb);
      }
      static RGB_CMYK([r, g, b]) {
        const c = 1 - r;
        const m = 1 - g;
        const y = 1 - b;
        const k = Math.min(c, m, y);
        return ["CMYK", c, m, y, k];
      }
    };
    BaseSVGFactory = class {
      create(width, height, skipDimensions = false) {
        if (width <= 0 || height <= 0) {
          throw new Error("Invalid SVG dimensions");
        }
        const svg = this._createSVG("svg:svg");
        svg.setAttribute("version", "1.1");
        if (!skipDimensions) {
          svg.setAttribute("width", `${width}px`);
          svg.setAttribute("height", `${height}px`);
        }
        svg.setAttribute("preserveAspectRatio", "none");
        svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        return svg;
      }
      createElement(type) {
        if (typeof type !== "string") {
          throw new Error("Invalid SVG element type");
        }
        return this._createSVG(type);
      }
      _createSVG(type) {
        unreachable("Abstract method `_createSVG` called.");
      }
    };
    DOMSVGFactory = class extends BaseSVGFactory {
      _createSVG(type) {
        return document.createElementNS(SVG_NS, type);
      }
    };
    annotation_layer_DEFAULT_FONT_SIZE = 9;
    GetElementsByNameSet = /* @__PURE__ */ new WeakSet();
    TIMEZONE_OFFSET = (/* @__PURE__ */ new Date()).getTimezoneOffset() * 60 * 1e3;
    AnnotationElementFactory = class {
      static create(parameters) {
        const subtype = parameters.data.annotationType;
        switch (subtype) {
          case AnnotationType.LINK:
            return new LinkAnnotationElement(parameters);
          case AnnotationType.TEXT:
            return new TextAnnotationElement(parameters);
          case AnnotationType.WIDGET:
            const fieldType = parameters.data.fieldType;
            switch (fieldType) {
              case "Tx":
                return new TextWidgetAnnotationElement(parameters);
              case "Btn":
                if (parameters.data.radioButton) {
                  return new RadioButtonWidgetAnnotationElement(parameters);
                } else if (parameters.data.checkBox) {
                  return new CheckboxWidgetAnnotationElement(parameters);
                }
                return new PushButtonWidgetAnnotationElement(parameters);
              case "Ch":
                return new ChoiceWidgetAnnotationElement(parameters);
              case "Sig":
                return new SignatureWidgetAnnotationElement(parameters);
            }
            return new WidgetAnnotationElement(parameters);
          case AnnotationType.POPUP:
            return new PopupAnnotationElement(parameters);
          case AnnotationType.FREETEXT:
            return new FreeTextAnnotationElement(parameters);
          case AnnotationType.LINE:
            return new LineAnnotationElement(parameters);
          case AnnotationType.SQUARE:
            return new SquareAnnotationElement(parameters);
          case AnnotationType.CIRCLE:
            return new CircleAnnotationElement(parameters);
          case AnnotationType.POLYLINE:
            return new PolylineAnnotationElement(parameters);
          case AnnotationType.CARET:
            return new CaretAnnotationElement(parameters);
          case AnnotationType.INK:
            return new InkAnnotationElement(parameters);
          case AnnotationType.POLYGON:
            return new PolygonAnnotationElement(parameters);
          case AnnotationType.HIGHLIGHT:
            return new HighlightAnnotationElement(parameters);
          case AnnotationType.UNDERLINE:
            return new UnderlineAnnotationElement(parameters);
          case AnnotationType.SQUIGGLY:
            return new SquigglyAnnotationElement(parameters);
          case AnnotationType.STRIKEOUT:
            return new StrikeOutAnnotationElement(parameters);
          case AnnotationType.STAMP:
            return new StampAnnotationElement(parameters);
          case AnnotationType.FILEATTACHMENT:
            return new FileAttachmentAnnotationElement(parameters);
          default:
            return new AnnotationElement(parameters);
        }
      }
    };
    AnnotationElement = class _AnnotationElement {
      #updates = null;
      #hasBorder = false;
      #popupElement = null;
      constructor(parameters, {
        isRenderable = false,
        ignoreBorder = false,
        createQuadrilaterals = false
      } = {}) {
        this.isRenderable = isRenderable;
        this.data = parameters.data;
        this.layer = parameters.layer;
        this.linkService = parameters.linkService;
        this.downloadManager = parameters.downloadManager;
        this.imageResourcesPath = parameters.imageResourcesPath;
        this.renderForms = parameters.renderForms;
        this.svgFactory = parameters.svgFactory;
        this.annotationStorage = parameters.annotationStorage;
        this.enableComment = parameters.enableComment;
        this.enableScripting = parameters.enableScripting;
        this.hasJSActions = parameters.hasJSActions;
        this._fieldObjects = parameters.fieldObjects;
        this.parent = parameters.parent;
        if (isRenderable) {
          this.container = this._createContainer(ignoreBorder);
        }
        if (createQuadrilaterals) {
          this._createQuadrilaterals();
        }
      }
      static _hasPopupData({
        contentsObj,
        richText
      }) {
        return !!(contentsObj?.str || richText?.str);
      }
      get _isEditable() {
        return this.data.isEditable;
      }
      get hasPopupData() {
        return _AnnotationElement._hasPopupData(this.data) || this.enableComment && !!this.commentText;
      }
      get commentData() {
        const {
          data
        } = this;
        const editor = this.annotationStorage?.getEditor(data.id);
        if (editor) {
          return editor.getData();
        }
        return data;
      }
      get hasCommentButton() {
        return this.enableComment && this.hasPopupElement;
      }
      get commentButtonPosition() {
        const editor = this.annotationStorage?.getEditor(this.data.id);
        if (editor) {
          return editor.commentButtonPositionInPage;
        }
        const {
          quadPoints,
          inkLists,
          rect
        } = this.data;
        let maxX = -Infinity;
        let maxY = -Infinity;
        if (quadPoints?.length >= 8) {
          for (let i = 0; i < quadPoints.length; i += 8) {
            if (quadPoints[i + 1] > maxY) {
              maxY = quadPoints[i + 1];
              maxX = quadPoints[i + 2];
            } else if (quadPoints[i + 1] === maxY) {
              maxX = Math.max(maxX, quadPoints[i + 2]);
            }
          }
          return [maxX, maxY];
        }
        if (inkLists?.length >= 1) {
          for (const inkList of inkLists) {
            for (let i = 0, ii = inkList.length; i < ii; i += 2) {
              if (inkList[i + 1] > maxY) {
                maxY = inkList[i + 1];
                maxX = inkList[i];
              } else if (inkList[i + 1] === maxY) {
                maxX = Math.max(maxX, inkList[i]);
              }
            }
          }
          if (maxX !== Infinity) {
            return [maxX, maxY];
          }
        }
        if (rect) {
          return [rect[2], rect[3]];
        }
        return null;
      }
      _normalizePoint(point) {
        const {
          page: {
            view
          },
          viewport: {
            rawDims: {
              pageWidth,
              pageHeight,
              pageX,
              pageY
            }
          }
        } = this.parent;
        point[1] = view[3] - point[1] + view[1];
        point[0] = 100 * (point[0] - pageX) / pageWidth;
        point[1] = 100 * (point[1] - pageY) / pageHeight;
        return point;
      }
      get commentText() {
        const {
          data
        } = this;
        return this.annotationStorage.getRawValue(`${AnnotationEditorPrefix}${data.id}`)?.popup?.contents || data.contentsObj?.str || "";
      }
      set commentText(text) {
        const {
          data
        } = this;
        const popup = {
          deleted: !text,
          contents: text || ""
        };
        if (!this.annotationStorage.updateEditor(data.id, {
          popup
        })) {
          this.annotationStorage.setValue(`${AnnotationEditorPrefix}${data.id}`, {
            id: data.id,
            annotationType: data.annotationType,
            pageIndex: this.parent.page._pageIndex,
            popup,
            popupRef: data.popupRef,
            modificationDate: /* @__PURE__ */ new Date()
          });
        }
        if (!text) {
          this.removePopup();
        }
      }
      removePopup() {
        (this.#popupElement?.popup || this.popup)?.remove();
        this.#popupElement = this.popup = null;
      }
      updateEdited(params) {
        if (!this.container) {
          return;
        }
        if (params.rect) {
          this.#updates ||= {
            rect: this.data.rect.slice(0)
          };
        }
        const {
          rect,
          popup: newPopup
        } = params;
        if (rect) {
          this.#setRectEdited(rect);
        }
        let popup = this.#popupElement?.popup || this.popup;
        if (!popup && newPopup?.text) {
          this._createPopup(newPopup);
          popup = this.#popupElement.popup;
        }
        if (!popup) {
          return;
        }
        popup.updateEdited(params);
        if (newPopup?.deleted) {
          popup.remove();
          this.#popupElement = null;
          this.popup = null;
        }
      }
      resetEdited() {
        if (!this.#updates) {
          return;
        }
        this.#setRectEdited(this.#updates.rect);
        this.#popupElement?.popup.resetEdited();
        this.#updates = null;
      }
      #setRectEdited(rect) {
        const {
          container: {
            style
          },
          data: {
            rect: currentRect,
            rotation
          },
          parent: {
            viewport: {
              rawDims: {
                pageWidth,
                pageHeight,
                pageX,
                pageY
              }
            }
          }
        } = this;
        currentRect?.splice(0, 4, ...rect);
        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
        style.top = `${100 * (pageHeight - rect[3] + pageY) / pageHeight}%`;
        if (rotation === 0) {
          style.width = `${100 * (rect[2] - rect[0]) / pageWidth}%`;
          style.height = `${100 * (rect[3] - rect[1]) / pageHeight}%`;
        } else {
          this.setRotation(rotation);
        }
      }
      _createContainer(ignoreBorder) {
        const {
          data,
          parent: {
            page,
            viewport
          }
        } = this;
        const container = document.createElement("section");
        container.setAttribute("data-annotation-id", data.id);
        if (!(this instanceof WidgetAnnotationElement) && !(this instanceof LinkAnnotationElement)) {
          container.tabIndex = 0;
        }
        const {
          style
        } = container;
        style.zIndex = this.parent.zIndex;
        this.parent.zIndex += 2;
        if (data.alternativeText) {
          container.title = data.alternativeText;
        }
        if (data.noRotate) {
          container.classList.add("norotate");
        }
        if (!data.rect || this instanceof PopupAnnotationElement) {
          const {
            rotation: rotation2
          } = data;
          if (!data.hasOwnCanvas && rotation2 !== 0) {
            this.setRotation(rotation2, container);
          }
          return container;
        }
        const {
          width,
          height
        } = this;
        if (!ignoreBorder && data.borderStyle.width > 0) {
          style.borderWidth = `${data.borderStyle.width}px`;
          const horizontalRadius = data.borderStyle.horizontalCornerRadius;
          const verticalRadius = data.borderStyle.verticalCornerRadius;
          if (horizontalRadius > 0 || verticalRadius > 0) {
            const radius = `calc(${horizontalRadius}px * var(--total-scale-factor)) / calc(${verticalRadius}px * var(--total-scale-factor))`;
            style.borderRadius = radius;
          } else if (this instanceof RadioButtonWidgetAnnotationElement) {
            const radius = `calc(${width}px * var(--total-scale-factor)) / calc(${height}px * var(--total-scale-factor))`;
            style.borderRadius = radius;
          }
          switch (data.borderStyle.style) {
            case AnnotationBorderStyleType.SOLID:
              style.borderStyle = "solid";
              break;
            case AnnotationBorderStyleType.DASHED:
              style.borderStyle = "dashed";
              break;
            case AnnotationBorderStyleType.BEVELED:
              warn("Unimplemented border style: beveled");
              break;
            case AnnotationBorderStyleType.INSET:
              warn("Unimplemented border style: inset");
              break;
            case AnnotationBorderStyleType.UNDERLINE:
              style.borderBottomStyle = "solid";
              break;
            default:
              break;
          }
          const borderColor = data.borderColor || null;
          if (borderColor) {
            this.#hasBorder = true;
            style.borderColor = Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);
          } else {
            style.borderWidth = 0;
          }
        }
        const rect = Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);
        const {
          pageWidth,
          pageHeight,
          pageX,
          pageY
        } = viewport.rawDims;
        style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;
        style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;
        const {
          rotation
        } = data;
        if (data.hasOwnCanvas || rotation === 0) {
          style.width = `${100 * width / pageWidth}%`;
          style.height = `${100 * height / pageHeight}%`;
        } else {
          this.setRotation(rotation, container);
        }
        return container;
      }
      setRotation(angle, container = this.container) {
        if (!this.data.rect) {
          return;
        }
        const {
          pageWidth,
          pageHeight
        } = this.parent.viewport.rawDims;
        let {
          width,
          height
        } = this;
        if (angle % 180 !== 0) {
          [width, height] = [height, width];
        }
        container.style.width = `${100 * width / pageWidth}%`;
        container.style.height = `${100 * height / pageHeight}%`;
        container.setAttribute("data-main-rotation", (360 - angle) % 360);
      }
      get _commonActions() {
        const setColor = (jsName, styleName, event) => {
          const color = event.detail[jsName];
          const colorType = color[0];
          const colorArray = color.slice(1);
          event.target.style[styleName] = ColorConverters[`${colorType}_HTML`](colorArray);
          this.annotationStorage.setValue(this.data.id, {
            [styleName]: ColorConverters[`${colorType}_rgb`](colorArray)
          });
        };
        return shadow(this, "_commonActions", {
          display: (event) => {
            const {
              display
            } = event.detail;
            const hidden = display % 2 === 1;
            this.container.style.visibility = hidden ? "hidden" : "visible";
            this.annotationStorage.setValue(this.data.id, {
              noView: hidden,
              noPrint: display === 1 || display === 2
            });
          },
          print: (event) => {
            this.annotationStorage.setValue(this.data.id, {
              noPrint: !event.detail.print
            });
          },
          hidden: (event) => {
            const {
              hidden
            } = event.detail;
            this.container.style.visibility = hidden ? "hidden" : "visible";
            this.annotationStorage.setValue(this.data.id, {
              noPrint: hidden,
              noView: hidden
            });
          },
          focus: (event) => {
            setTimeout(() => event.target.focus({
              preventScroll: false
            }), 0);
          },
          userName: (event) => {
            event.target.title = event.detail.userName;
          },
          readonly: (event) => {
            event.target.disabled = event.detail.readonly;
          },
          required: (event) => {
            this._setRequired(event.target, event.detail.required);
          },
          bgColor: (event) => {
            setColor("bgColor", "backgroundColor", event);
          },
          fillColor: (event) => {
            setColor("fillColor", "backgroundColor", event);
          },
          fgColor: (event) => {
            setColor("fgColor", "color", event);
          },
          textColor: (event) => {
            setColor("textColor", "color", event);
          },
          borderColor: (event) => {
            setColor("borderColor", "borderColor", event);
          },
          strokeColor: (event) => {
            setColor("strokeColor", "borderColor", event);
          },
          rotation: (event) => {
            const angle = event.detail.rotation;
            this.setRotation(angle);
            this.annotationStorage.setValue(this.data.id, {
              rotation: angle
            });
          }
        });
      }
      _dispatchEventFromSandbox(actions, jsEvent) {
        const commonActions = this._commonActions;
        for (const name of Object.keys(jsEvent.detail)) {
          const action = actions[name] || commonActions[name];
          action?.(jsEvent);
        }
      }
      _setDefaultPropertiesFromJS(element) {
        if (!this.enableScripting) {
          return;
        }
        const storedData = this.annotationStorage.getRawValue(this.data.id);
        if (!storedData) {
          return;
        }
        const commonActions = this._commonActions;
        for (const [actionName, detail] of Object.entries(storedData)) {
          const action = commonActions[actionName];
          if (action) {
            const eventProxy = {
              detail: {
                [actionName]: detail
              },
              target: element
            };
            action(eventProxy);
            delete storedData[actionName];
          }
        }
      }
      _createQuadrilaterals() {
        if (!this.container) {
          return;
        }
        const {
          quadPoints
        } = this.data;
        if (!quadPoints) {
          return;
        }
        const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect.map((x) => Math.fround(x));
        if (quadPoints.length === 8) {
          const [trX, trY, blX, blY] = quadPoints.subarray(2, 6);
          if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {
            return;
          }
        }
        const {
          style
        } = this.container;
        let svgBuffer;
        if (this.#hasBorder) {
          const {
            borderColor,
            borderWidth
          } = style;
          style.borderWidth = 0;
          svgBuffer = ["url('data:image/svg+xml;utf8,", `<svg xmlns="http://www.w3.org/2000/svg"`, ` preserveAspectRatio="none" viewBox="0 0 1 1">`, `<g fill="transparent" stroke="${borderColor}" stroke-width="${borderWidth}">`];
          this.container.classList.add("hasBorder");
        }
        const width = rectTrX - rectBlX;
        const height = rectTrY - rectBlY;
        const {
          svgFactory
        } = this;
        const svg = svgFactory.createElement("svg");
        svg.classList.add("quadrilateralsContainer");
        svg.setAttribute("width", 0);
        svg.setAttribute("height", 0);
        svg.role = "none";
        const defs = svgFactory.createElement("defs");
        svg.append(defs);
        const clipPath = svgFactory.createElement("clipPath");
        const id = `clippath_${this.data.id}`;
        clipPath.setAttribute("id", id);
        clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
        defs.append(clipPath);
        for (let i = 2, ii = quadPoints.length; i < ii; i += 8) {
          const trX = quadPoints[i];
          const trY = quadPoints[i + 1];
          const blX = quadPoints[i + 2];
          const blY = quadPoints[i + 3];
          const rect = svgFactory.createElement("rect");
          const x = (blX - rectBlX) / width;
          const y = (rectTrY - trY) / height;
          const rectWidth = (trX - blX) / width;
          const rectHeight = (trY - blY) / height;
          rect.setAttribute("x", x);
          rect.setAttribute("y", y);
          rect.setAttribute("width", rectWidth);
          rect.setAttribute("height", rectHeight);
          clipPath.append(rect);
          svgBuffer?.push(`<rect vector-effect="non-scaling-stroke" x="${x}" y="${y}" width="${rectWidth}" height="${rectHeight}"/>`);
        }
        if (this.#hasBorder) {
          svgBuffer.push(`</g></svg>')`);
          style.backgroundImage = svgBuffer.join("");
        }
        this.container.append(svg);
        this.container.style.clipPath = `url(#${id})`;
      }
      _createPopup(popupData = null) {
        const {
          data
        } = this;
        let contentsObj, modificationDate;
        if (popupData) {
          contentsObj = {
            str: popupData.text
          };
          modificationDate = popupData.date;
        } else {
          contentsObj = data.contentsObj;
          modificationDate = data.modificationDate;
        }
        const popup = this.#popupElement = new PopupAnnotationElement({
          data: {
            color: data.color,
            titleObj: data.titleObj,
            modificationDate,
            contentsObj,
            richText: data.richText,
            parentRect: data.rect,
            borderStyle: 0,
            id: `popup_${data.id}`,
            rotation: data.rotation,
            noRotate: true
          },
          linkService: this.linkService,
          parent: this.parent,
          elements: [this]
        });
        if (!this.parent._commentManager) {
          this.parent.div.append(popup.render());
        }
      }
      get hasPopupElement() {
        return !!(this.#popupElement || this.popup || this.data.popupRef);
      }
      get extraPopupElement() {
        return this.#popupElement;
      }
      render() {
        unreachable("Abstract method `AnnotationElement.render` called");
      }
      _getElementsByName(name, skipId = null) {
        const fields = [];
        if (this._fieldObjects) {
          const fieldObj = this._fieldObjects[name];
          if (fieldObj) {
            for (const {
              page,
              id,
              exportValues
            } of fieldObj) {
              if (page === -1) {
                continue;
              }
              if (id === skipId) {
                continue;
              }
              const exportValue = typeof exportValues === "string" ? exportValues : null;
              const domElement = document.querySelector(`[data-element-id="${id}"]`);
              if (domElement && !GetElementsByNameSet.has(domElement)) {
                warn(`_getElementsByName - element not allowed: ${id}`);
                continue;
              }
              fields.push({
                id,
                exportValue,
                domElement
              });
            }
          }
          return fields;
        }
        for (const domElement of document.getElementsByName(name)) {
          const {
            exportValue
          } = domElement;
          const id = domElement.getAttribute("data-element-id");
          if (id === skipId) {
            continue;
          }
          if (!GetElementsByNameSet.has(domElement)) {
            continue;
          }
          fields.push({
            id,
            exportValue,
            domElement
          });
        }
        return fields;
      }
      show() {
        if (this.container) {
          this.container.hidden = false;
        }
        this.popup?.maybeShow();
      }
      hide() {
        if (this.container) {
          this.container.hidden = true;
        }
        this.popup?.forceHide();
      }
      getElementsToTriggerPopup() {
        return this.container;
      }
      addHighlightArea() {
        const triggers = this.getElementsToTriggerPopup();
        if (Array.isArray(triggers)) {
          for (const element of triggers) {
            element.classList.add("highlightArea");
          }
        } else {
          triggers.classList.add("highlightArea");
        }
      }
      _editOnDoubleClick() {
        if (!this._isEditable) {
          return;
        }
        const {
          annotationEditorType: mode,
          data: {
            id: editId
          }
        } = this;
        this.container.addEventListener("dblclick", () => {
          this.linkService.eventBus?.dispatch("switchannotationeditormode", {
            source: this,
            mode,
            editId,
            mustEnterInEditMode: true
          });
        });
      }
      get width() {
        return this.data.rect[2] - this.data.rect[0];
      }
      get height() {
        return this.data.rect[3] - this.data.rect[1];
      }
    };
    EditorAnnotationElement = class extends AnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true
        });
        this.editor = parameters.editor;
      }
      render() {
        this.container.className = "editorAnnotation";
        return this.container;
      }
      createOrUpdatePopup() {
        const {
          editor
        } = this;
        if (!editor.hasComment) {
          return;
        }
        this._createPopup(editor.comment);
        this.extraPopupElement.popup.renderCommentButton();
      }
      get hasCommentButton() {
        return this.enableComment && this.editor.hasComment;
      }
      get commentButtonPosition() {
        return this.editor.commentButtonPositionInPage;
      }
      get commentText() {
        return this.editor.comment.text;
      }
      set commentText(text) {
        this.editor.comment = text;
        if (!text) {
          this.removePopup();
        }
      }
      get commentData() {
        return this.editor.getData();
      }
      remove() {
        this.container.remove();
        this.container = null;
        this.removePopup();
      }
    };
    LinkAnnotationElement = class extends AnnotationElement {
      constructor(parameters, options = null) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: !!options?.ignoreBorder,
          createQuadrilaterals: true
        });
        this.isTooltipOnly = parameters.data.isTooltipOnly;
      }
      render() {
        const {
          data,
          linkService
        } = this;
        const link = document.createElement("a");
        link.setAttribute("data-element-id", data.id);
        let isBound = false;
        if (data.url) {
          linkService.addLinkAttributes(link, data.url, data.newWindow);
          isBound = true;
        } else if (data.action) {
          this._bindNamedAction(link, data.action, data.overlaidText);
          isBound = true;
        } else if (data.attachment) {
          this.#bindAttachment(link, data.attachment, data.overlaidText, data.attachmentDest);
          isBound = true;
        } else if (data.setOCGState) {
          this.#bindSetOCGState(link, data.setOCGState, data.overlaidText);
          isBound = true;
        } else if (data.dest) {
          this._bindLink(link, data.dest, data.overlaidText);
          isBound = true;
        } else {
          if (data.actions && (data.actions.Action || data.actions["Mouse Up"] || data.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions) {
            this._bindJSAction(link, data);
            isBound = true;
          }
          if (data.resetForm) {
            this._bindResetFormAction(link, data.resetForm);
            isBound = true;
          } else if (this.isTooltipOnly && !isBound) {
            this._bindLink(link, "");
            isBound = true;
          }
        }
        this.container.classList.add("linkAnnotation");
        if (isBound) {
          this.container.append(link);
        }
        return this.container;
      }
      #setInternalLink() {
        this.container.setAttribute("data-internal-link", "");
      }
      _bindLink(link, destination, overlaidText = "") {
        link.href = this.linkService.getDestinationHash(destination);
        link.onclick = () => {
          if (destination) {
            this.linkService.goToDestination(destination);
          }
          return false;
        };
        if (destination || destination === "") {
          this.#setInternalLink();
        }
        if (overlaidText) {
          link.title = overlaidText;
        }
      }
      _bindNamedAction(link, action, overlaidText = "") {
        link.href = this.linkService.getAnchorUrl("");
        link.onclick = () => {
          this.linkService.executeNamedAction(action);
          return false;
        };
        if (overlaidText) {
          link.title = overlaidText;
        }
        this.#setInternalLink();
      }
      #bindAttachment(link, attachment, overlaidText = "", dest = null) {
        link.href = this.linkService.getAnchorUrl("");
        if (attachment.description) {
          link.title = attachment.description;
        } else if (overlaidText) {
          link.title = overlaidText;
        }
        link.onclick = () => {
          this.downloadManager?.openOrDownloadData(attachment.content, attachment.filename, dest);
          return false;
        };
        this.#setInternalLink();
      }
      #bindSetOCGState(link, action, overlaidText = "") {
        link.href = this.linkService.getAnchorUrl("");
        link.onclick = () => {
          this.linkService.executeSetOCGState(action);
          return false;
        };
        if (overlaidText) {
          link.title = overlaidText;
        }
        this.#setInternalLink();
      }
      _bindJSAction(link, data) {
        link.href = this.linkService.getAnchorUrl("");
        const map2 = /* @__PURE__ */ new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]);
        for (const name of Object.keys(data.actions)) {
          const jsName = map2.get(name);
          if (!jsName) {
            continue;
          }
          link[jsName] = () => {
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: data.id,
                name
              }
            });
            return false;
          };
        }
        if (data.overlaidText) {
          link.title = data.overlaidText;
        }
        if (!link.onclick) {
          link.onclick = () => false;
        }
        this.#setInternalLink();
      }
      _bindResetFormAction(link, resetForm) {
        const otherClickAction = link.onclick;
        if (!otherClickAction) {
          link.href = this.linkService.getAnchorUrl("");
        }
        this.#setInternalLink();
        if (!this._fieldObjects) {
          warn(`_bindResetFormAction - "resetForm" action not supported, ensure that the \`fieldObjects\` parameter is provided.`);
          if (!otherClickAction) {
            link.onclick = () => false;
          }
          return;
        }
        link.onclick = () => {
          otherClickAction?.();
          const {
            fields: resetFormFields,
            refs: resetFormRefs,
            include
          } = resetForm;
          const allFields = [];
          if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {
            const fieldIds = new Set(resetFormRefs);
            for (const fieldName of resetFormFields) {
              const fields = this._fieldObjects[fieldName] || [];
              for (const {
                id
              } of fields) {
                fieldIds.add(id);
              }
            }
            for (const fields of Object.values(this._fieldObjects)) {
              for (const field of fields) {
                if (fieldIds.has(field.id) === include) {
                  allFields.push(field);
                }
              }
            }
          } else {
            for (const fields of Object.values(this._fieldObjects)) {
              allFields.push(...fields);
            }
          }
          const storage = this.annotationStorage;
          const allIds = [];
          for (const field of allFields) {
            const {
              id
            } = field;
            allIds.push(id);
            switch (field.type) {
              case "text": {
                const value = field.defaultValue || "";
                storage.setValue(id, {
                  value
                });
                break;
              }
              case "checkbox":
              case "radiobutton": {
                const value = field.defaultValue === field.exportValues;
                storage.setValue(id, {
                  value
                });
                break;
              }
              case "combobox":
              case "listbox": {
                const value = field.defaultValue || "";
                storage.setValue(id, {
                  value
                });
                break;
              }
              default:
                continue;
            }
            const domElement = document.querySelector(`[data-element-id="${id}"]`);
            if (!domElement) {
              continue;
            } else if (!GetElementsByNameSet.has(domElement)) {
              warn(`_bindResetFormAction - element not allowed: ${id}`);
              continue;
            }
            domElement.dispatchEvent(new Event("resetform"));
          }
          if (this.enableScripting) {
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: "app",
                ids: allIds,
                name: "ResetForm"
              }
            });
          }
          return false;
        };
      }
    };
    TextAnnotationElement = class extends AnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: true
        });
      }
      render() {
        this.container.classList.add("textAnnotation");
        const image = document.createElement("img");
        image.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg";
        image.setAttribute("data-l10n-id", "pdfjs-text-annotation-type");
        image.setAttribute("data-l10n-args", JSON.stringify({
          type: this.data.name
        }));
        if (!this.data.popupRef && this.hasPopupData) {
          this._createPopup();
        }
        this.container.append(image);
        return this.container;
      }
    };
    WidgetAnnotationElement = class extends AnnotationElement {
      render() {
        return this.container;
      }
      showElementAndHideCanvas(element) {
        if (this.data.hasOwnCanvas) {
          if (element.previousSibling?.nodeName === "CANVAS") {
            element.previousSibling.hidden = true;
          }
          element.hidden = false;
        }
      }
      _getKeyModifier(event) {
        return util_FeatureTest.platform.isMac ? event.metaKey : event.ctrlKey;
      }
      _setEventListener(element, elementData, baseName, eventName, valueGetter) {
        if (baseName.includes("mouse")) {
          element.addEventListener(baseName, (event) => {
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: this.data.id,
                name: eventName,
                value: valueGetter(event),
                shift: event.shiftKey,
                modifier: this._getKeyModifier(event)
              }
            });
          });
        } else {
          element.addEventListener(baseName, (event) => {
            if (baseName === "blur") {
              if (!elementData.focused || !event.relatedTarget) {
                return;
              }
              elementData.focused = false;
            } else if (baseName === "focus") {
              if (elementData.focused) {
                return;
              }
              elementData.focused = true;
            }
            if (!valueGetter) {
              return;
            }
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id: this.data.id,
                name: eventName,
                value: valueGetter(event)
              }
            });
          });
        }
      }
      _setEventListeners(element, elementData, names, getter) {
        for (const [baseName, eventName] of names) {
          if (eventName === "Action" || this.data.actions?.[eventName]) {
            if (eventName === "Focus" || eventName === "Blur") {
              elementData ||= {
                focused: false
              };
            }
            this._setEventListener(element, elementData, baseName, eventName, getter);
            if (eventName === "Focus" && !this.data.actions?.Blur) {
              this._setEventListener(element, elementData, "blur", "Blur", null);
            } else if (eventName === "Blur" && !this.data.actions?.Focus) {
              this._setEventListener(element, elementData, "focus", "Focus", null);
            }
          }
        }
      }
      _setBackgroundColor(element) {
        const color = this.data.backgroundColor || null;
        element.style.backgroundColor = color === null ? "transparent" : Util.makeHexColor(color[0], color[1], color[2]);
      }
      _setTextStyle(element) {
        const TEXT_ALIGNMENT = ["left", "center", "right"];
        const {
          fontColor
        } = this.data.defaultAppearanceData;
        const fontSize = this.data.defaultAppearanceData.fontSize || annotation_layer_DEFAULT_FONT_SIZE;
        const style = element.style;
        let computedFontSize;
        const BORDER_SIZE = 2;
        const roundToOneDecimal = (x) => Math.round(10 * x) / 10;
        if (this.data.multiLine) {
          const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
          const numberOfLines = Math.round(height / (LINE_FACTOR * fontSize)) || 1;
          const lineHeight = height / numberOfLines;
          computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / LINE_FACTOR));
        } else {
          const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);
          computedFontSize = Math.min(fontSize, roundToOneDecimal(height / LINE_FACTOR));
        }
        style.fontSize = `calc(${computedFontSize}px * var(--total-scale-factor))`;
        style.color = Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);
        if (this.data.textAlignment !== null) {
          style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];
        }
      }
      _setRequired(element, isRequired) {
        if (isRequired) {
          element.setAttribute("required", true);
        } else {
          element.removeAttribute("required");
        }
        element.setAttribute("aria-required", isRequired);
      }
    };
    TextWidgetAnnotationElement = class extends WidgetAnnotationElement {
      constructor(parameters) {
        const isRenderable = parameters.renderForms || parameters.data.hasOwnCanvas || !parameters.data.hasAppearance && !!parameters.data.fieldValue;
        super(parameters, {
          isRenderable
        });
      }
      setPropertyOnSiblings(base, key, value, keyInStorage) {
        const storage = this.annotationStorage;
        for (const element of this._getElementsByName(base.name, base.id)) {
          if (element.domElement) {
            element.domElement[key] = value;
          }
          storage.setValue(element.id, {
            [keyInStorage]: value
          });
        }
      }
      render() {
        const storage = this.annotationStorage;
        const id = this.data.id;
        this.container.classList.add("textWidgetAnnotation");
        let element = null;
        if (this.renderForms) {
          const storedData = storage.getValue(id, {
            value: this.data.fieldValue
          });
          let textContent = storedData.value || "";
          const maxLen = storage.getValue(id, {
            charLimit: this.data.maxLen
          }).charLimit;
          if (maxLen && textContent.length > maxLen) {
            textContent = textContent.slice(0, maxLen);
          }
          let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join("\n") || null;
          if (fieldFormattedValues && this.data.comb) {
            fieldFormattedValues = fieldFormattedValues.replaceAll(/\s+/g, "");
          }
          const elementData = {
            userValue: textContent,
            formattedValue: fieldFormattedValues,
            lastCommittedValue: null,
            commitKey: 1,
            focused: false
          };
          if (this.data.multiLine) {
            element = document.createElement("textarea");
            element.textContent = fieldFormattedValues ?? textContent;
            if (this.data.doNotScroll) {
              element.style.overflowY = "hidden";
            }
          } else {
            element = document.createElement("input");
            element.type = this.data.password ? "password" : "text";
            element.setAttribute("value", fieldFormattedValues ?? textContent);
            if (this.data.doNotScroll) {
              element.style.overflowX = "hidden";
            }
          }
          if (this.data.hasOwnCanvas) {
            element.hidden = true;
          }
          GetElementsByNameSet.add(element);
          element.setAttribute("data-element-id", id);
          element.disabled = this.data.readOnly;
          element.name = this.data.fieldName;
          element.tabIndex = 0;
          const {
            datetimeFormat,
            datetimeType,
            timeStep
          } = this.data;
          const hasDateOrTime = !!datetimeType && this.enableScripting;
          if (datetimeFormat) {
            element.title = datetimeFormat;
          }
          this._setRequired(element, this.data.required);
          if (maxLen) {
            element.maxLength = maxLen;
          }
          element.addEventListener("input", (event) => {
            storage.setValue(id, {
              value: event.target.value
            });
            this.setPropertyOnSiblings(element, "value", event.target.value, "value");
            elementData.formattedValue = null;
          });
          element.addEventListener("resetform", (event) => {
            const defaultValue = this.data.defaultFieldValue ?? "";
            element.value = elementData.userValue = defaultValue;
            elementData.formattedValue = null;
          });
          let blurListener = (event) => {
            const {
              formattedValue
            } = elementData;
            if (formattedValue !== null && formattedValue !== void 0) {
              event.target.value = formattedValue;
            }
            event.target.scrollLeft = 0;
          };
          if (this.enableScripting && this.hasJSActions) {
            element.addEventListener("focus", (event) => {
              if (elementData.focused) {
                return;
              }
              const {
                target
              } = event;
              if (hasDateOrTime) {
                target.type = datetimeType;
                if (timeStep) {
                  target.step = timeStep;
                }
              }
              if (elementData.userValue) {
                const value = elementData.userValue;
                if (hasDateOrTime) {
                  if (datetimeType === "time") {
                    const date = new Date(value);
                    const parts = [date.getHours(), date.getMinutes(), date.getSeconds()];
                    target.value = parts.map((v) => v.toString().padStart(2, "0")).join(":");
                  } else {
                    target.value = new Date(value - TIMEZONE_OFFSET).toISOString().split(datetimeType === "date" ? "T" : ".", 1)[0];
                  }
                } else {
                  target.value = value;
                }
              }
              elementData.lastCommittedValue = target.value;
              elementData.commitKey = 1;
              if (!this.data.actions?.Focus) {
                elementData.focused = true;
              }
            });
            element.addEventListener("updatefromsandbox", (jsEvent) => {
              this.showElementAndHideCanvas(jsEvent.target);
              const actions = {
                value(event) {
                  elementData.userValue = event.detail.value ?? "";
                  if (!hasDateOrTime) {
                    storage.setValue(id, {
                      value: elementData.userValue.toString()
                    });
                  }
                  event.target.value = elementData.userValue;
                },
                formattedValue(event) {
                  const {
                    formattedValue
                  } = event.detail;
                  elementData.formattedValue = formattedValue;
                  if (formattedValue !== null && formattedValue !== void 0 && event.target !== document.activeElement) {
                    event.target.value = formattedValue;
                  }
                  const data = {
                    formattedValue
                  };
                  if (hasDateOrTime) {
                    data.value = formattedValue;
                  }
                  storage.setValue(id, data);
                },
                selRange(event) {
                  event.target.setSelectionRange(...event.detail.selRange);
                },
                charLimit: (event) => {
                  const {
                    charLimit
                  } = event.detail;
                  const {
                    target
                  } = event;
                  if (charLimit === 0) {
                    target.removeAttribute("maxLength");
                    return;
                  }
                  target.setAttribute("maxLength", charLimit);
                  let value = elementData.userValue;
                  if (!value || value.length <= charLimit) {
                    return;
                  }
                  value = value.slice(0, charLimit);
                  target.value = elementData.userValue = value;
                  storage.setValue(id, {
                    value
                  });
                  this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                    source: this,
                    detail: {
                      id,
                      name: "Keystroke",
                      value,
                      willCommit: true,
                      commitKey: 1,
                      selStart: target.selectionStart,
                      selEnd: target.selectionEnd
                    }
                  });
                }
              };
              this._dispatchEventFromSandbox(actions, jsEvent);
            });
            element.addEventListener("keydown", (event) => {
              elementData.commitKey = 1;
              let commitKey = -1;
              if (event.key === "Escape") {
                commitKey = 0;
              } else if (event.key === "Enter" && !this.data.multiLine) {
                commitKey = 2;
              } else if (event.key === "Tab") {
                elementData.commitKey = 3;
              }
              if (commitKey === -1) {
                return;
              }
              const {
                value
              } = event.target;
              if (elementData.lastCommittedValue === value) {
                return;
              }
              elementData.lastCommittedValue = value;
              elementData.userValue = value;
              this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                source: this,
                detail: {
                  id,
                  name: "Keystroke",
                  value,
                  willCommit: true,
                  commitKey,
                  selStart: event.target.selectionStart,
                  selEnd: event.target.selectionEnd
                }
              });
            });
            const _blurListener = blurListener;
            blurListener = null;
            element.addEventListener("blur", (event) => {
              if (!elementData.focused || !event.relatedTarget) {
                return;
              }
              if (!this.data.actions?.Blur) {
                elementData.focused = false;
              }
              const {
                target
              } = event;
              let {
                value
              } = target;
              if (hasDateOrTime) {
                if (value && datetimeType === "time") {
                  const parts = value.split(":").map((v) => parseInt(v, 10));
                  value = new Date(2e3, 0, 1, parts[0], parts[1], parts[2] || 0).valueOf();
                  target.step = "";
                } else {
                  if (!value.includes("T")) {
                    value = `${value}T00:00`;
                  }
                  value = new Date(value).valueOf();
                }
                target.type = "text";
              }
              elementData.userValue = value;
              if (elementData.lastCommittedValue !== value) {
                this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id,
                    name: "Keystroke",
                    value,
                    willCommit: true,
                    commitKey: elementData.commitKey,
                    selStart: event.target.selectionStart,
                    selEnd: event.target.selectionEnd
                  }
                });
              }
              _blurListener(event);
            });
            if (this.data.actions?.Keystroke) {
              element.addEventListener("beforeinput", (event) => {
                elementData.lastCommittedValue = null;
                const {
                  data,
                  target
                } = event;
                const {
                  value,
                  selectionStart,
                  selectionEnd
                } = target;
                let selStart = selectionStart, selEnd = selectionEnd;
                switch (event.inputType) {
                  case "deleteWordBackward": {
                    const match = value.substring(0, selectionStart).match(/\w*[^\w]*$/);
                    if (match) {
                      selStart -= match[0].length;
                    }
                    break;
                  }
                  case "deleteWordForward": {
                    const match = value.substring(selectionStart).match(/^[^\w]*\w*/);
                    if (match) {
                      selEnd += match[0].length;
                    }
                    break;
                  }
                  case "deleteContentBackward":
                    if (selectionStart === selectionEnd) {
                      selStart -= 1;
                    }
                    break;
                  case "deleteContentForward":
                    if (selectionStart === selectionEnd) {
                      selEnd += 1;
                    }
                    break;
                }
                event.preventDefault();
                this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
                  source: this,
                  detail: {
                    id,
                    name: "Keystroke",
                    value,
                    change: data || "",
                    willCommit: false,
                    selStart,
                    selEnd
                  }
                });
              });
            }
            this._setEventListeners(element, elementData, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.value);
          }
          if (blurListener) {
            element.addEventListener("blur", blurListener);
          }
          if (this.data.comb) {
            const fieldWidth = this.data.rect[2] - this.data.rect[0];
            const combWidth = fieldWidth / maxLen;
            element.classList.add("comb");
            element.style.letterSpacing = `calc(${combWidth}px * var(--total-scale-factor) - 1ch)`;
          }
        } else {
          element = document.createElement("div");
          element.textContent = this.data.fieldValue;
          element.style.verticalAlign = "middle";
          element.style.display = "table-cell";
          if (this.data.hasOwnCanvas) {
            element.hidden = true;
          }
        }
        this._setTextStyle(element);
        this._setBackgroundColor(element);
        this._setDefaultPropertiesFromJS(element);
        this.container.append(element);
        return this.container;
      }
    };
    SignatureWidgetAnnotationElement = class extends WidgetAnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: !!parameters.data.hasOwnCanvas
        });
      }
    };
    CheckboxWidgetAnnotationElement = class extends WidgetAnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: parameters.renderForms
        });
      }
      render() {
        const storage = this.annotationStorage;
        const data = this.data;
        const id = data.id;
        let value = storage.getValue(id, {
          value: data.exportValue === data.fieldValue
        }).value;
        if (typeof value === "string") {
          value = value !== "Off";
          storage.setValue(id, {
            value
          });
        }
        this.container.classList.add("buttonWidgetAnnotation", "checkBox");
        const element = document.createElement("input");
        GetElementsByNameSet.add(element);
        element.setAttribute("data-element-id", id);
        element.disabled = data.readOnly;
        this._setRequired(element, this.data.required);
        element.type = "checkbox";
        element.name = data.fieldName;
        if (value) {
          element.setAttribute("checked", true);
        }
        element.setAttribute("exportValue", data.exportValue);
        element.tabIndex = 0;
        element.addEventListener("change", (event) => {
          const {
            name,
            checked
          } = event.target;
          for (const checkbox of this._getElementsByName(name, id)) {
            const curChecked = checked && checkbox.exportValue === data.exportValue;
            if (checkbox.domElement) {
              checkbox.domElement.checked = curChecked;
            }
            storage.setValue(checkbox.id, {
              value: curChecked
            });
          }
          storage.setValue(id, {
            value: checked
          });
        });
        element.addEventListener("resetform", (event) => {
          const defaultValue = data.defaultFieldValue || "Off";
          event.target.checked = defaultValue === data.exportValue;
        });
        if (this.enableScripting && this.hasJSActions) {
          element.addEventListener("updatefromsandbox", (jsEvent) => {
            const actions = {
              value(event) {
                event.target.checked = event.detail.value !== "Off";
                storage.setValue(id, {
                  value: event.target.checked
                });
              }
            };
            this._dispatchEventFromSandbox(actions, jsEvent);
          });
          this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
        }
        this._setBackgroundColor(element);
        this._setDefaultPropertiesFromJS(element);
        this.container.append(element);
        return this.container;
      }
    };
    RadioButtonWidgetAnnotationElement = class extends WidgetAnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: parameters.renderForms
        });
      }
      render() {
        this.container.classList.add("buttonWidgetAnnotation", "radioButton");
        const storage = this.annotationStorage;
        const data = this.data;
        const id = data.id;
        let value = storage.getValue(id, {
          value: data.fieldValue === data.buttonValue
        }).value;
        if (typeof value === "string") {
          value = value !== data.buttonValue;
          storage.setValue(id, {
            value
          });
        }
        if (value) {
          for (const radio of this._getElementsByName(data.fieldName, id)) {
            storage.setValue(radio.id, {
              value: false
            });
          }
        }
        const element = document.createElement("input");
        GetElementsByNameSet.add(element);
        element.setAttribute("data-element-id", id);
        element.disabled = data.readOnly;
        this._setRequired(element, this.data.required);
        element.type = "radio";
        element.name = data.fieldName;
        if (value) {
          element.setAttribute("checked", true);
        }
        element.tabIndex = 0;
        element.addEventListener("change", (event) => {
          const {
            name,
            checked
          } = event.target;
          for (const radio of this._getElementsByName(name, id)) {
            storage.setValue(radio.id, {
              value: false
            });
          }
          storage.setValue(id, {
            value: checked
          });
        });
        element.addEventListener("resetform", (event) => {
          const defaultValue = data.defaultFieldValue;
          event.target.checked = defaultValue !== null && defaultValue !== void 0 && defaultValue === data.buttonValue;
        });
        if (this.enableScripting && this.hasJSActions) {
          const pdfButtonValue = data.buttonValue;
          element.addEventListener("updatefromsandbox", (jsEvent) => {
            const actions = {
              value: (event) => {
                const checked = pdfButtonValue === event.detail.value;
                for (const radio of this._getElementsByName(event.target.name)) {
                  const curChecked = checked && radio.id === id;
                  if (radio.domElement) {
                    radio.domElement.checked = curChecked;
                  }
                  storage.setValue(radio.id, {
                    value: curChecked
                  });
                }
              }
            };
            this._dispatchEventFromSandbox(actions, jsEvent);
          });
          this._setEventListeners(element, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], (event) => event.target.checked);
        }
        this._setBackgroundColor(element);
        this._setDefaultPropertiesFromJS(element);
        this.container.append(element);
        return this.container;
      }
    };
    PushButtonWidgetAnnotationElement = class extends LinkAnnotationElement {
      constructor(parameters) {
        super(parameters, {
          ignoreBorder: parameters.data.hasAppearance
        });
      }
      render() {
        const container = super.render();
        container.classList.add("buttonWidgetAnnotation", "pushButton");
        const linkElement = container.lastChild;
        if (this.enableScripting && this.hasJSActions && linkElement) {
          this._setDefaultPropertiesFromJS(linkElement);
          linkElement.addEventListener("updatefromsandbox", (jsEvent) => {
            this._dispatchEventFromSandbox({}, jsEvent);
          });
        }
        return container;
      }
    };
    ChoiceWidgetAnnotationElement = class extends WidgetAnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: parameters.renderForms
        });
      }
      render() {
        this.container.classList.add("choiceWidgetAnnotation");
        const storage = this.annotationStorage;
        const id = this.data.id;
        const storedData = storage.getValue(id, {
          value: this.data.fieldValue
        });
        const selectElement = document.createElement("select");
        GetElementsByNameSet.add(selectElement);
        selectElement.setAttribute("data-element-id", id);
        selectElement.disabled = this.data.readOnly;
        this._setRequired(selectElement, this.data.required);
        selectElement.name = this.data.fieldName;
        selectElement.tabIndex = 0;
        let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;
        if (!this.data.combo) {
          selectElement.size = this.data.options.length;
          if (this.data.multiSelect) {
            selectElement.multiple = true;
          }
        }
        selectElement.addEventListener("resetform", (event) => {
          const defaultValue = this.data.defaultFieldValue;
          for (const option of selectElement.options) {
            option.selected = option.value === defaultValue;
          }
        });
        for (const option of this.data.options) {
          const optionElement = document.createElement("option");
          optionElement.textContent = option.displayValue;
          optionElement.value = option.exportValue;
          if (storedData.value.includes(option.exportValue)) {
            optionElement.setAttribute("selected", true);
            addAnEmptyEntry = false;
          }
          selectElement.append(optionElement);
        }
        let removeEmptyEntry = null;
        if (addAnEmptyEntry) {
          const noneOptionElement = document.createElement("option");
          noneOptionElement.value = " ";
          noneOptionElement.setAttribute("hidden", true);
          noneOptionElement.setAttribute("selected", true);
          selectElement.prepend(noneOptionElement);
          removeEmptyEntry = () => {
            noneOptionElement.remove();
            selectElement.removeEventListener("input", removeEmptyEntry);
            removeEmptyEntry = null;
          };
          selectElement.addEventListener("input", removeEmptyEntry);
        }
        const getValue = (isExport) => {
          const name = isExport ? "value" : "textContent";
          const {
            options,
            multiple
          } = selectElement;
          if (!multiple) {
            return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];
          }
          return Array.prototype.filter.call(options, (option) => option.selected).map((option) => option[name]);
        };
        let selectedValues = getValue(false);
        const getItems = (event) => {
          const options = event.target.options;
          return Array.prototype.map.call(options, (option) => ({
            displayValue: option.textContent,
            exportValue: option.value
          }));
        };
        if (this.enableScripting && this.hasJSActions) {
          selectElement.addEventListener("updatefromsandbox", (jsEvent) => {
            const actions = {
              value(event) {
                removeEmptyEntry?.();
                const value = event.detail.value;
                const values2 = new Set(Array.isArray(value) ? value : [value]);
                for (const option of selectElement.options) {
                  option.selected = values2.has(option.value);
                }
                storage.setValue(id, {
                  value: getValue(true)
                });
                selectedValues = getValue(false);
              },
              multipleSelection(event) {
                selectElement.multiple = true;
              },
              remove(event) {
                const options = selectElement.options;
                const index = event.detail.remove;
                options[index].selected = false;
                selectElement.remove(index);
                if (options.length > 0) {
                  const i = Array.prototype.findIndex.call(options, (option) => option.selected);
                  if (i === -1) {
                    options[0].selected = true;
                  }
                }
                storage.setValue(id, {
                  value: getValue(true),
                  items: getItems(event)
                });
                selectedValues = getValue(false);
              },
              clear(event) {
                while (selectElement.length !== 0) {
                  selectElement.remove(0);
                }
                storage.setValue(id, {
                  value: null,
                  items: []
                });
                selectedValues = getValue(false);
              },
              insert(event) {
                const {
                  index,
                  displayValue,
                  exportValue
                } = event.detail.insert;
                const selectChild = selectElement.children[index];
                const optionElement = document.createElement("option");
                optionElement.textContent = displayValue;
                optionElement.value = exportValue;
                if (selectChild) {
                  selectChild.before(optionElement);
                } else {
                  selectElement.append(optionElement);
                }
                storage.setValue(id, {
                  value: getValue(true),
                  items: getItems(event)
                });
                selectedValues = getValue(false);
              },
              items(event) {
                const {
                  items
                } = event.detail;
                while (selectElement.length !== 0) {
                  selectElement.remove(0);
                }
                for (const item of items) {
                  const {
                    displayValue,
                    exportValue
                  } = item;
                  const optionElement = document.createElement("option");
                  optionElement.textContent = displayValue;
                  optionElement.value = exportValue;
                  selectElement.append(optionElement);
                }
                if (selectElement.options.length > 0) {
                  selectElement.options[0].selected = true;
                }
                storage.setValue(id, {
                  value: getValue(true),
                  items: getItems(event)
                });
                selectedValues = getValue(false);
              },
              indices(event) {
                const indices = new Set(event.detail.indices);
                for (const option of event.target.options) {
                  option.selected = indices.has(option.index);
                }
                storage.setValue(id, {
                  value: getValue(true)
                });
                selectedValues = getValue(false);
              },
              editable(event) {
                event.target.disabled = !event.detail.editable;
              }
            };
            this._dispatchEventFromSandbox(actions, jsEvent);
          });
          selectElement.addEventListener("input", (event) => {
            const exportValue = getValue(true);
            const change = getValue(false);
            storage.setValue(id, {
              value: exportValue
            });
            event.preventDefault();
            this.linkService.eventBus?.dispatch("dispatcheventinsandbox", {
              source: this,
              detail: {
                id,
                name: "Keystroke",
                value: selectedValues,
                change,
                changeEx: exportValue,
                willCommit: false,
                commitKey: 1,
                keyDown: false
              }
            });
          });
          this._setEventListeners(selectElement, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], (event) => event.target.value);
        } else {
          selectElement.addEventListener("input", function(event) {
            storage.setValue(id, {
              value: getValue(true)
            });
          });
        }
        if (this.data.combo) {
          this._setTextStyle(selectElement);
        } else {
        }
        this._setBackgroundColor(selectElement);
        this._setDefaultPropertiesFromJS(selectElement);
        this.container.append(selectElement);
        return this.container;
      }
    };
    PopupAnnotationElement = class extends AnnotationElement {
      constructor(parameters) {
        const {
          data,
          elements,
          parent
        } = parameters;
        const hasCommentManager = !!parent._commentManager;
        super(parameters, {
          isRenderable: !hasCommentManager && AnnotationElement._hasPopupData(data)
        });
        this.elements = elements;
        if (hasCommentManager && AnnotationElement._hasPopupData(data)) {
          const popup = this.popup = this.#createPopup();
          for (const element of elements) {
            element.popup = popup;
          }
        } else {
          this.popup = null;
        }
      }
      #createPopup() {
        return new PopupElement({
          container: this.container,
          color: this.data.color,
          titleObj: this.data.titleObj,
          modificationDate: this.data.modificationDate || this.data.creationDate,
          contentsObj: this.data.contentsObj,
          richText: this.data.richText,
          rect: this.data.rect,
          parentRect: this.data.parentRect || null,
          parent: this.parent,
          elements: this.elements,
          open: this.data.open,
          commentManager: this.parent._commentManager
        });
      }
      render() {
        const {
          container
        } = this;
        container.classList.add("popupAnnotation");
        container.role = "comment";
        const popup = this.popup = this.#createPopup();
        const elementIds = [];
        for (const element of this.elements) {
          element.popup = popup;
          element.container.ariaHasPopup = "dialog";
          elementIds.push(element.data.id);
          element.addHighlightArea();
        }
        this.container.setAttribute("aria-controls", elementIds.map((id) => `${AnnotationPrefix}${id}`).join(","));
        return this.container;
      }
    };
    PopupElement = class {
      #commentManager = null;
      #boundKeyDown = this.#keyDown.bind(this);
      #boundHide = this.#hide.bind(this);
      #boundShow = this.#show.bind(this);
      #boundToggle = this.#toggle.bind(this);
      #color = null;
      #container = null;
      #contentsObj = null;
      #dateObj = null;
      #elements = null;
      #parent = null;
      #parentRect = null;
      #pinned = false;
      #popup = null;
      #popupAbortController = null;
      #position = null;
      #commentButton = null;
      #commentButtonPosition = null;
      #popupPosition = null;
      #rect = null;
      #richText = null;
      #titleObj = null;
      #updates = null;
      #wasVisible = false;
      #firstElement = null;
      #commentText = null;
      constructor({
        container,
        color,
        elements,
        titleObj,
        modificationDate,
        contentsObj,
        richText,
        parent,
        rect,
        parentRect,
        open,
        commentManager = null
      }) {
        this.#container = container;
        this.#titleObj = titleObj;
        this.#contentsObj = contentsObj;
        this.#richText = richText;
        this.#parent = parent;
        this.#color = color;
        this.#rect = rect;
        this.#parentRect = parentRect;
        this.#elements = elements;
        this.#commentManager = commentManager;
        this.#firstElement = elements[0];
        this.#dateObj = PDFDateString.toDateObject(modificationDate);
        this.trigger = elements.flatMap((e) => e.getElementsToTriggerPopup());
        if (commentManager) {
          this.renderCommentButton();
        } else {
          this.#addEventListeners();
          this.#container.hidden = true;
          if (open) {
            this.#toggle();
          }
        }
      }
      #addEventListeners() {
        if (this.#popupAbortController) {
          return;
        }
        this.#popupAbortController = new AbortController();
        const {
          signal
        } = this.#popupAbortController;
        for (const element of this.trigger) {
          element.addEventListener("click", this.#boundToggle, {
            signal
          });
          element.addEventListener("pointerenter", this.#boundShow, {
            signal
          });
          element.addEventListener("pointerleave", this.#boundHide, {
            signal
          });
          element.classList.add("popupTriggerArea");
        }
        for (const element of this.#elements) {
          element.container?.addEventListener("keydown", this.#boundKeyDown, {
            signal
          });
        }
      }
      #setCommentButtonPosition() {
        const element = this.#elements.find((e) => e.hasCommentButton);
        if (!element) {
          return;
        }
        this.#commentButtonPosition = element._normalizePoint(element.commentButtonPosition);
      }
      renderCommentButton() {
        if (this.#commentButton) {
          return;
        }
        if (!this.#commentButtonPosition) {
          this.#setCommentButtonPosition();
        }
        if (!this.#commentButtonPosition) {
          return;
        }
        const {
          signal
        } = this.#popupAbortController = new AbortController();
        const hasOwnButton = !!this.#firstElement.extraPopupElement;
        const togglePopup = () => {
          this.#commentManager.toggleCommentPopup(this, true, void 0, !hasOwnButton);
        };
        const showPopup = () => {
          this.#commentManager.toggleCommentPopup(this, false, true, !hasOwnButton);
        };
        const hidePopup = () => {
          this.#commentManager.toggleCommentPopup(this, false, false);
        };
        if (!hasOwnButton) {
          const button = this.#commentButton = document.createElement("button");
          button.className = "annotationCommentButton";
          const parentContainer = this.#firstElement.container;
          button.style.zIndex = parentContainer.style.zIndex + 1;
          button.tabIndex = 0;
          button.ariaHasPopup = "dialog";
          button.ariaControls = "commentPopup";
          button.setAttribute("data-l10n-id", "pdfjs-show-comment-button");
          this.#updateColor();
          this.#updateCommentButtonPosition();
          button.addEventListener("keydown", this.#boundKeyDown, {
            signal
          });
          button.addEventListener("click", togglePopup, {
            signal
          });
          button.addEventListener("pointerenter", showPopup, {
            signal
          });
          button.addEventListener("pointerleave", hidePopup, {
            signal
          });
          parentContainer.after(button);
        } else {
          this.#commentButton = this.#firstElement.container;
          for (const element of this.trigger) {
            element.ariaHasPopup = "dialog";
            element.ariaControls = "commentPopup";
            element.addEventListener("keydown", this.#boundKeyDown, {
              signal
            });
            element.addEventListener("click", togglePopup, {
              signal
            });
            element.addEventListener("pointerenter", showPopup, {
              signal
            });
            element.addEventListener("pointerleave", hidePopup, {
              signal
            });
            element.classList.add("popupTriggerArea");
          }
        }
      }
      #updateCommentButtonPosition() {
        if (this.#firstElement.extraPopupElement && !this.#firstElement.editor) {
          return;
        }
        this.renderCommentButton();
        const [x, y] = this.#commentButtonPosition;
        const {
          style
        } = this.#commentButton;
        style.left = `calc(${x}%)`;
        style.top = `calc(${y}% - var(--comment-button-dim))`;
      }
      #updateColor() {
        if (this.#firstElement.extraPopupElement) {
          return;
        }
        this.renderCommentButton();
        this.#commentButton.style.backgroundColor = this.commentButtonColor || "";
      }
      get commentButtonColor() {
        const {
          color,
          opacity
        } = this.#firstElement.commentData;
        if (!color) {
          return null;
        }
        return this.#parent._commentManager.makeCommentColor(color, opacity);
      }
      focusCommentButton() {
        setTimeout(() => {
          this.#commentButton?.focus();
        }, 0);
      }
      getData() {
        const {
          richText,
          color,
          opacity,
          creationDate,
          modificationDate
        } = this.#firstElement.commentData;
        return {
          contentsObj: {
            str: this.comment
          },
          richText,
          color,
          opacity,
          creationDate,
          modificationDate
        };
      }
      get elementBeforePopup() {
        return this.#commentButton;
      }
      get comment() {
        this.#commentText ||= this.#firstElement.commentText;
        return this.#commentText;
      }
      set comment(text) {
        if (text === this.comment) {
          return;
        }
        this.#firstElement.commentText = this.#commentText = text;
      }
      get parentBoundingClientRect() {
        return this.#firstElement.layer.getBoundingClientRect();
      }
      setCommentButtonStates({
        selected,
        hasPopup
      }) {
        if (!this.#commentButton) {
          return;
        }
        this.#commentButton.classList.toggle("selected", selected);
        this.#commentButton.ariaExpanded = hasPopup;
      }
      setSelectedCommentButton(selected) {
        this.#commentButton.classList.toggle("selected", selected);
      }
      get commentPopupPosition() {
        if (this.#popupPosition) {
          return this.#popupPosition;
        }
        const {
          x,
          y,
          height
        } = this.#commentButton.getBoundingClientRect();
        const {
          x: parentX,
          y: parentY,
          width: parentWidth,
          height: parentHeight
        } = this.#firstElement.layer.getBoundingClientRect();
        return [(x - parentX) / parentWidth, (y + height - parentY) / parentHeight];
      }
      set commentPopupPosition(pos) {
        this.#popupPosition = pos;
      }
      hasDefaultPopupPosition() {
        return this.#popupPosition === null;
      }
      get commentButtonPosition() {
        return this.#commentButtonPosition;
      }
      get commentButtonWidth() {
        return this.#commentButton.getBoundingClientRect().width / this.parentBoundingClientRect.width;
      }
      editComment(options) {
        const [posX, posY] = this.#popupPosition || this.commentButtonPosition.map((x) => x / 100);
        const parentDimensions = this.parentBoundingClientRect;
        const {
          x: parentX,
          y: parentY,
          width: parentWidth,
          height: parentHeight
        } = parentDimensions;
        this.#commentManager.showDialog(null, this, parentX + posX * parentWidth, parentY + posY * parentHeight, {
          ...options,
          parentDimensions
        });
      }
      render() {
        if (this.#popup) {
          return;
        }
        const popup = this.#popup = document.createElement("div");
        popup.className = "popup";
        if (this.#color) {
          const baseColor = popup.style.outlineColor = Util.makeHexColor(...this.#color);
          popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;
        }
        const header = document.createElement("span");
        header.className = "header";
        if (this.#titleObj?.str) {
          const title = document.createElement("span");
          title.className = "title";
          header.append(title);
          ({
            dir: title.dir,
            str: title.textContent
          } = this.#titleObj);
        }
        popup.append(header);
        if (this.#dateObj) {
          const modificationDate = document.createElement("time");
          modificationDate.className = "popupDate";
          modificationDate.setAttribute("data-l10n-id", "pdfjs-annotation-date-time-string");
          modificationDate.setAttribute("data-l10n-args", JSON.stringify({
            dateObj: this.#dateObj.valueOf()
          }));
          modificationDate.dateTime = this.#dateObj.toISOString();
          header.append(modificationDate);
        }
        renderRichText({
          html: this.#html || this.#contentsObj.str,
          dir: this.#contentsObj?.dir,
          className: "popupContent"
        }, popup);
        this.#container.append(popup);
      }
      get #html() {
        const richText = this.#richText;
        const contentsObj = this.#contentsObj;
        if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {
          return this.#richText.html || null;
        }
        return null;
      }
      get #fontSize() {
        return this.#html?.attributes?.style?.fontSize || 0;
      }
      get #fontColor() {
        return this.#html?.attributes?.style?.color || null;
      }
      #makePopupContent(text) {
        const popupLines = [];
        const popupContent = {
          str: text,
          html: {
            name: "div",
            attributes: {
              dir: "auto"
            },
            children: [{
              name: "p",
              children: popupLines
            }]
          }
        };
        const lineAttributes = {
          style: {
            color: this.#fontColor,
            fontSize: this.#fontSize ? `calc(${this.#fontSize}px * var(--total-scale-factor))` : ""
          }
        };
        for (const line of text.split("\n")) {
          popupLines.push({
            name: "span",
            value: line,
            attributes: lineAttributes
          });
        }
        return popupContent;
      }
      #keyDown(event) {
        if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {
          return;
        }
        if (event.key === "Enter" || event.key === "Escape" && this.#pinned) {
          this.#toggle();
        }
      }
      updateEdited({
        rect,
        popup,
        deleted
      }) {
        if (this.#commentManager) {
          if (deleted) {
            this.remove();
            this.#commentText = null;
          } else if (popup) {
            if (popup.deleted) {
              this.remove();
            } else {
              this.#updateColor();
              this.#commentText = popup.text;
            }
          }
          if (rect) {
            this.#commentButtonPosition = null;
            this.#setCommentButtonPosition();
            this.#updateCommentButtonPosition();
          }
          return;
        }
        if (deleted || popup?.deleted) {
          this.remove();
          return;
        }
        this.#addEventListeners();
        this.#updates ||= {
          contentsObj: this.#contentsObj,
          richText: this.#richText
        };
        if (rect) {
          this.#position = null;
        }
        if (popup && popup.text) {
          this.#richText = this.#makePopupContent(popup.text);
          this.#dateObj = PDFDateString.toDateObject(popup.date);
          this.#contentsObj = null;
        }
        this.#popup?.remove();
        this.#popup = null;
      }
      resetEdited() {
        if (!this.#updates) {
          return;
        }
        ({
          contentsObj: this.#contentsObj,
          richText: this.#richText
        } = this.#updates);
        this.#updates = null;
        this.#popup?.remove();
        this.#popup = null;
        this.#position = null;
      }
      remove() {
        this.#popupAbortController?.abort();
        this.#popupAbortController = null;
        this.#popup?.remove();
        this.#popup = null;
        this.#wasVisible = false;
        this.#pinned = false;
        this.#commentButton?.remove();
        this.#commentButton = null;
        if (this.trigger) {
          for (const element of this.trigger) {
            element.classList.remove("popupTriggerArea");
          }
        }
      }
      #setPosition() {
        if (this.#position !== null) {
          return;
        }
        const {
          page: {
            view
          },
          viewport: {
            rawDims: {
              pageWidth,
              pageHeight,
              pageX,
              pageY
            }
          }
        } = this.#parent;
        let useParentRect = !!this.#parentRect;
        let rect = useParentRect ? this.#parentRect : this.#rect;
        for (const element of this.#elements) {
          if (!rect || Util.intersect(element.data.rect, rect) !== null) {
            rect = element.data.rect;
            useParentRect = true;
            break;
          }
        }
        const normalizedRect = Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);
        const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;
        const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;
        const popupLeft = normalizedRect[0] + parentWidth;
        const popupTop = normalizedRect[1];
        this.#position = [100 * (popupLeft - pageX) / pageWidth, 100 * (popupTop - pageY) / pageHeight];
        const {
          style
        } = this.#container;
        style.left = `${this.#position[0]}%`;
        style.top = `${this.#position[1]}%`;
      }
      #toggle() {
        if (this.#commentManager) {
          this.#commentManager.toggleCommentPopup(this, false);
          return;
        }
        this.#pinned = !this.#pinned;
        if (this.#pinned) {
          this.#show();
          this.#container.addEventListener("click", this.#boundToggle);
          this.#container.addEventListener("keydown", this.#boundKeyDown);
        } else {
          this.#hide();
          this.#container.removeEventListener("click", this.#boundToggle);
          this.#container.removeEventListener("keydown", this.#boundKeyDown);
        }
      }
      #show() {
        if (!this.#popup) {
          this.render();
        }
        if (!this.isVisible) {
          this.#setPosition();
          this.#container.hidden = false;
          this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1e3;
        } else if (this.#pinned) {
          this.#container.classList.add("focused");
        }
      }
      #hide() {
        this.#container.classList.remove("focused");
        if (this.#pinned || !this.isVisible) {
          return;
        }
        this.#container.hidden = true;
        this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1e3;
      }
      forceHide() {
        this.#wasVisible = this.isVisible;
        if (!this.#wasVisible) {
          return;
        }
        this.#container.hidden = true;
      }
      maybeShow() {
        if (this.#commentManager) {
          return;
        }
        this.#addEventListeners();
        if (!this.#wasVisible) {
          return;
        }
        if (!this.#popup) {
          this.#show();
        }
        this.#wasVisible = false;
        this.#container.hidden = false;
      }
      get isVisible() {
        if (this.#commentManager) {
          return false;
        }
        return this.#container.hidden === false;
      }
    };
    FreeTextAnnotationElement = class extends AnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true
        });
        this.textContent = parameters.data.textContent;
        this.textPosition = parameters.data.textPosition;
        this.annotationEditorType = AnnotationEditorType.FREETEXT;
      }
      render() {
        this.container.classList.add("freeTextAnnotation");
        if (this.textContent) {
          const content = document.createElement("div");
          content.classList.add("annotationTextContent");
          content.setAttribute("role", "comment");
          for (const line of this.textContent) {
            const lineSpan = document.createElement("span");
            lineSpan.textContent = line;
            content.append(lineSpan);
          }
          this.container.append(content);
        }
        if (!this.data.popupRef && this.hasPopupData) {
          this._createPopup();
        }
        this._editOnDoubleClick();
        return this.container;
      }
    };
    LineAnnotationElement = class extends AnnotationElement {
      #line = null;
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true
        });
      }
      render() {
        this.container.classList.add("lineAnnotation");
        const {
          data,
          width,
          height
        } = this;
        const svg = this.svgFactory.create(width, height, true);
        const line = this.#line = this.svgFactory.createElement("svg:line");
        line.setAttribute("x1", data.rect[2] - data.lineCoordinates[0]);
        line.setAttribute("y1", data.rect[3] - data.lineCoordinates[1]);
        line.setAttribute("x2", data.rect[2] - data.lineCoordinates[2]);
        line.setAttribute("y2", data.rect[3] - data.lineCoordinates[3]);
        line.setAttribute("stroke-width", data.borderStyle.width || 1);
        line.setAttribute("stroke", "transparent");
        line.setAttribute("fill", "transparent");
        svg.append(line);
        this.container.append(svg);
        if (!data.popupRef && this.hasPopupData) {
          this._createPopup();
        }
        return this.container;
      }
      getElementsToTriggerPopup() {
        return this.#line;
      }
      addHighlightArea() {
        this.container.classList.add("highlightArea");
      }
    };
    SquareAnnotationElement = class extends AnnotationElement {
      #square = null;
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true
        });
      }
      render() {
        this.container.classList.add("squareAnnotation");
        const {
          data,
          width,
          height
        } = this;
        const svg = this.svgFactory.create(width, height, true);
        const borderWidth = data.borderStyle.width;
        const square = this.#square = this.svgFactory.createElement("svg:rect");
        square.setAttribute("x", borderWidth / 2);
        square.setAttribute("y", borderWidth / 2);
        square.setAttribute("width", width - borderWidth);
        square.setAttribute("height", height - borderWidth);
        square.setAttribute("stroke-width", borderWidth || 1);
        square.setAttribute("stroke", "transparent");
        square.setAttribute("fill", "transparent");
        svg.append(square);
        this.container.append(svg);
        if (!data.popupRef && this.hasPopupData) {
          this._createPopup();
        }
        return this.container;
      }
      getElementsToTriggerPopup() {
        return this.#square;
      }
      addHighlightArea() {
        this.container.classList.add("highlightArea");
      }
    };
    CircleAnnotationElement = class extends AnnotationElement {
      #circle = null;
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true
        });
      }
      render() {
        this.container.classList.add("circleAnnotation");
        const {
          data,
          width,
          height
        } = this;
        const svg = this.svgFactory.create(width, height, true);
        const borderWidth = data.borderStyle.width;
        const circle = this.#circle = this.svgFactory.createElement("svg:ellipse");
        circle.setAttribute("cx", width / 2);
        circle.setAttribute("cy", height / 2);
        circle.setAttribute("rx", width / 2 - borderWidth / 2);
        circle.setAttribute("ry", height / 2 - borderWidth / 2);
        circle.setAttribute("stroke-width", borderWidth || 1);
        circle.setAttribute("stroke", "transparent");
        circle.setAttribute("fill", "transparent");
        svg.append(circle);
        this.container.append(svg);
        if (!data.popupRef && this.hasPopupData) {
          this._createPopup();
        }
        return this.container;
      }
      getElementsToTriggerPopup() {
        return this.#circle;
      }
      addHighlightArea() {
        this.container.classList.add("highlightArea");
      }
    };
    PolylineAnnotationElement = class extends AnnotationElement {
      #polyline = null;
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true
        });
        this.containerClassName = "polylineAnnotation";
        this.svgElementName = "svg:polyline";
      }
      render() {
        this.container.classList.add(this.containerClassName);
        const {
          data: {
            rect,
            vertices,
            borderStyle,
            popupRef
          },
          width,
          height
        } = this;
        if (!vertices) {
          return this.container;
        }
        const svg = this.svgFactory.create(width, height, true);
        let points = [];
        for (let i = 0, ii = vertices.length; i < ii; i += 2) {
          const x = vertices[i] - rect[0];
          const y = rect[3] - vertices[i + 1];
          points.push(`${x},${y}`);
        }
        points = points.join(" ");
        const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);
        polyline.setAttribute("points", points);
        polyline.setAttribute("stroke-width", borderStyle.width || 1);
        polyline.setAttribute("stroke", "transparent");
        polyline.setAttribute("fill", "transparent");
        svg.append(polyline);
        this.container.append(svg);
        if (!popupRef && this.hasPopupData) {
          this._createPopup();
        }
        return this.container;
      }
      getElementsToTriggerPopup() {
        return this.#polyline;
      }
      addHighlightArea() {
        this.container.classList.add("highlightArea");
      }
    };
    PolygonAnnotationElement = class extends PolylineAnnotationElement {
      constructor(parameters) {
        super(parameters);
        this.containerClassName = "polygonAnnotation";
        this.svgElementName = "svg:polygon";
      }
    };
    CaretAnnotationElement = class extends AnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true
        });
      }
      render() {
        this.container.classList.add("caretAnnotation");
        if (!this.data.popupRef && this.hasPopupData) {
          this._createPopup();
        }
        return this.container;
      }
    };
    InkAnnotationElement = class extends AnnotationElement {
      #polylinesGroupElement = null;
      #polylines = [];
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true
        });
        this.containerClassName = "inkAnnotation";
        this.svgElementName = "svg:polyline";
        this.annotationEditorType = this.data.it === "InkHighlight" ? AnnotationEditorType.HIGHLIGHT : AnnotationEditorType.INK;
      }
      #getTransform(rotation, rect) {
        switch (rotation) {
          case 90:
            return {
              transform: `rotate(90) translate(${-rect[0]},${rect[1]}) scale(1,-1)`,
              width: rect[3] - rect[1],
              height: rect[2] - rect[0]
            };
          case 180:
            return {
              transform: `rotate(180) translate(${-rect[2]},${rect[1]}) scale(1,-1)`,
              width: rect[2] - rect[0],
              height: rect[3] - rect[1]
            };
          case 270:
            return {
              transform: `rotate(270) translate(${-rect[2]},${rect[3]}) scale(1,-1)`,
              width: rect[3] - rect[1],
              height: rect[2] - rect[0]
            };
          default:
            return {
              transform: `translate(${-rect[0]},${rect[3]}) scale(1,-1)`,
              width: rect[2] - rect[0],
              height: rect[3] - rect[1]
            };
        }
      }
      render() {
        this.container.classList.add(this.containerClassName);
        const {
          data: {
            rect,
            rotation,
            inkLists,
            borderStyle,
            popupRef
          }
        } = this;
        const {
          transform,
          width,
          height
        } = this.#getTransform(rotation, rect);
        const svg = this.svgFactory.create(width, height, true);
        const g = this.#polylinesGroupElement = this.svgFactory.createElement("svg:g");
        svg.append(g);
        g.setAttribute("stroke-width", borderStyle.width || 1);
        g.setAttribute("stroke-linecap", "round");
        g.setAttribute("stroke-linejoin", "round");
        g.setAttribute("stroke-miterlimit", 10);
        g.setAttribute("stroke", "transparent");
        g.setAttribute("fill", "transparent");
        g.setAttribute("transform", transform);
        for (let i = 0, ii = inkLists.length; i < ii; i++) {
          const polyline = this.svgFactory.createElement(this.svgElementName);
          this.#polylines.push(polyline);
          polyline.setAttribute("points", inkLists[i].join(","));
          g.append(polyline);
        }
        if (!popupRef && this.hasPopupData) {
          this._createPopup();
        }
        this.container.append(svg);
        this._editOnDoubleClick();
        return this.container;
      }
      updateEdited(params) {
        super.updateEdited(params);
        const {
          thickness,
          points,
          rect
        } = params;
        const g = this.#polylinesGroupElement;
        if (thickness >= 0) {
          g.setAttribute("stroke-width", thickness || 1);
        }
        if (points) {
          for (let i = 0, ii = this.#polylines.length; i < ii; i++) {
            this.#polylines[i].setAttribute("points", points[i].join(","));
          }
        }
        if (rect) {
          const {
            transform,
            width,
            height
          } = this.#getTransform(this.data.rotation, rect);
          const root2 = g.parentElement;
          root2.setAttribute("viewBox", `0 0 ${width} ${height}`);
          g.setAttribute("transform", transform);
        }
      }
      getElementsToTriggerPopup() {
        return this.#polylines;
      }
      addHighlightArea() {
        this.container.classList.add("highlightArea");
      }
    };
    HighlightAnnotationElement = class extends AnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true,
          createQuadrilaterals: true
        });
        this.annotationEditorType = AnnotationEditorType.HIGHLIGHT;
      }
      render() {
        const {
          data: {
            overlaidText,
            popupRef
          }
        } = this;
        if (!popupRef && this.hasPopupData) {
          this._createPopup();
        }
        this.container.classList.add("highlightAnnotation");
        this._editOnDoubleClick();
        if (overlaidText) {
          const mark = document.createElement("mark");
          mark.classList.add("overlaidText");
          mark.textContent = overlaidText;
          this.container.append(mark);
        }
        return this.container;
      }
    };
    UnderlineAnnotationElement = class extends AnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true,
          createQuadrilaterals: true
        });
      }
      render() {
        const {
          data: {
            overlaidText,
            popupRef
          }
        } = this;
        if (!popupRef && this.hasPopupData) {
          this._createPopup();
        }
        this.container.classList.add("underlineAnnotation");
        if (overlaidText) {
          const underline = document.createElement("u");
          underline.classList.add("overlaidText");
          underline.textContent = overlaidText;
          this.container.append(underline);
        }
        return this.container;
      }
    };
    SquigglyAnnotationElement = class extends AnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true,
          createQuadrilaterals: true
        });
      }
      render() {
        const {
          data: {
            overlaidText,
            popupRef
          }
        } = this;
        if (!popupRef && this.hasPopupData) {
          this._createPopup();
        }
        this.container.classList.add("squigglyAnnotation");
        if (overlaidText) {
          const underline = document.createElement("u");
          underline.classList.add("overlaidText");
          underline.textContent = overlaidText;
          this.container.append(underline);
        }
        return this.container;
      }
    };
    StrikeOutAnnotationElement = class extends AnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true,
          createQuadrilaterals: true
        });
      }
      render() {
        const {
          data: {
            overlaidText,
            popupRef
          }
        } = this;
        if (!popupRef && this.hasPopupData) {
          this._createPopup();
        }
        this.container.classList.add("strikeoutAnnotation");
        if (overlaidText) {
          const strikeout = document.createElement("s");
          strikeout.classList.add("overlaidText");
          strikeout.textContent = overlaidText;
          this.container.append(strikeout);
        }
        return this.container;
      }
    };
    StampAnnotationElement = class extends AnnotationElement {
      constructor(parameters) {
        super(parameters, {
          isRenderable: true,
          ignoreBorder: true
        });
        this.annotationEditorType = AnnotationEditorType.STAMP;
      }
      render() {
        this.container.classList.add("stampAnnotation");
        this.container.setAttribute("role", "img");
        if (!this.data.popupRef && this.hasPopupData) {
          this._createPopup();
        }
        this._editOnDoubleClick();
        return this.container;
      }
    };
    FileAttachmentAnnotationElement = class extends AnnotationElement {
      #trigger = null;
      constructor(parameters) {
        super(parameters, {
          isRenderable: true
        });
        const {
          file
        } = this.data;
        this.filename = file.filename;
        this.content = file.content;
        this.linkService.eventBus?.dispatch("fileattachmentannotation", {
          source: this,
          ...file
        });
      }
      render() {
        this.container.classList.add("fileAttachmentAnnotation");
        const {
          container,
          data
        } = this;
        let trigger;
        if (data.hasAppearance || data.fillAlpha === 0) {
          trigger = document.createElement("div");
        } else {
          trigger = document.createElement("img");
          trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? "paperclip" : "pushpin"}.svg`;
          if (data.fillAlpha && data.fillAlpha < 1) {
            trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;
          }
        }
        trigger.addEventListener("dblclick", this.#download.bind(this));
        this.#trigger = trigger;
        const {
          isMac
        } = util_FeatureTest.platform;
        container.addEventListener("keydown", (evt) => {
          if (evt.key === "Enter" && (isMac ? evt.metaKey : evt.ctrlKey)) {
            this.#download();
          }
        });
        if (!data.popupRef && this.hasPopupData) {
          this._createPopup();
        } else {
          trigger.classList.add("popupTriggerArea");
        }
        container.append(trigger);
        return container;
      }
      getElementsToTriggerPopup() {
        return this.#trigger;
      }
      addHighlightArea() {
        this.container.classList.add("highlightArea");
      }
      #download() {
        this.downloadManager?.openOrDownloadData(this.content, this.filename);
      }
    };
    AnnotationLayer = class _AnnotationLayer {
      #accessibilityManager = null;
      #annotationCanvasMap = null;
      #annotationStorage = null;
      #editableAnnotations = /* @__PURE__ */ new Map();
      #structTreeLayer = null;
      #linkService = null;
      constructor({
        div,
        accessibilityManager,
        annotationCanvasMap,
        annotationEditorUIManager,
        page,
        viewport,
        structTreeLayer,
        commentManager,
        linkService,
        annotationStorage
      }) {
        this.div = div;
        this.#accessibilityManager = accessibilityManager;
        this.#annotationCanvasMap = annotationCanvasMap;
        this.#structTreeLayer = structTreeLayer || null;
        this.#linkService = linkService || null;
        this.#annotationStorage = annotationStorage || new AnnotationStorage();
        this.page = page;
        this.viewport = viewport;
        this.zIndex = 0;
        this._annotationEditorUIManager = annotationEditorUIManager;
        this._commentManager = commentManager || null;
      }
      hasEditableAnnotations() {
        return this.#editableAnnotations.size > 0;
      }
      async #appendElement(element, id, popupElements) {
        const contentElement = element.firstChild || element;
        const annotationId = contentElement.id = `${AnnotationPrefix}${id}`;
        const ariaAttributes = await this.#structTreeLayer?.getAriaAttributes(annotationId);
        if (ariaAttributes) {
          for (const [key, value] of ariaAttributes) {
            contentElement.setAttribute(key, value);
          }
        }
        if (popupElements) {
          popupElements.at(-1).container.after(element);
        } else {
          this.div.append(element);
          this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);
        }
      }
      async render(params) {
        const {
          annotations
        } = params;
        const layer = this.div;
        setLayerDimensions(layer, this.viewport);
        const popupToElements = /* @__PURE__ */ new Map();
        const elementParams = {
          data: null,
          layer,
          linkService: this.#linkService,
          downloadManager: params.downloadManager,
          imageResourcesPath: params.imageResourcesPath || "",
          renderForms: params.renderForms !== false,
          svgFactory: new DOMSVGFactory(),
          annotationStorage: this.#annotationStorage,
          enableComment: params.enableComment === true,
          enableScripting: params.enableScripting === true,
          hasJSActions: params.hasJSActions,
          fieldObjects: params.fieldObjects,
          parent: this,
          elements: null
        };
        for (const data of annotations) {
          if (data.noHTML) {
            continue;
          }
          const isPopupAnnotation = data.annotationType === AnnotationType.POPUP;
          if (!isPopupAnnotation) {
            if (data.rect[2] === data.rect[0] || data.rect[3] === data.rect[1]) {
              continue;
            }
          } else {
            const elements = popupToElements.get(data.id);
            if (!elements) {
              continue;
            }
            elementParams.elements = elements;
          }
          elementParams.data = data;
          const element = AnnotationElementFactory.create(elementParams);
          if (!element.isRenderable) {
            continue;
          }
          if (!isPopupAnnotation && data.popupRef) {
            const elements = popupToElements.get(data.popupRef);
            if (!elements) {
              popupToElements.set(data.popupRef, [element]);
            } else {
              elements.push(element);
            }
          }
          const rendered = element.render();
          if (data.hidden) {
            rendered.style.visibility = "hidden";
          }
          await this.#appendElement(rendered, data.id, elementParams.elements);
          element.extraPopupElement?.popup?.renderCommentButton();
          if (element._isEditable) {
            this.#editableAnnotations.set(element.data.id, element);
            this._annotationEditorUIManager?.renderAnnotationElement(element);
          }
        }
        this.#setAnnotationCanvasMap();
      }
      async addLinkAnnotations(annotations) {
        const elementParams = {
          data: null,
          layer: this.div,
          linkService: this.#linkService,
          svgFactory: new DOMSVGFactory(),
          parent: this
        };
        for (const data of annotations) {
          data.borderStyle ||= _AnnotationLayer._defaultBorderStyle;
          elementParams.data = data;
          const element = AnnotationElementFactory.create(elementParams);
          if (!element.isRenderable) {
            continue;
          }
          const rendered = element.render();
          await this.#appendElement(rendered, data.id, null);
        }
      }
      update({
        viewport
      }) {
        const layer = this.div;
        this.viewport = viewport;
        setLayerDimensions(layer, {
          rotation: viewport.rotation
        });
        this.#setAnnotationCanvasMap();
        layer.hidden = false;
      }
      #setAnnotationCanvasMap() {
        if (!this.#annotationCanvasMap) {
          return;
        }
        const layer = this.div;
        for (const [id, canvas] of this.#annotationCanvasMap) {
          const element = layer.querySelector(`[data-annotation-id="${id}"]`);
          if (!element) {
            continue;
          }
          canvas.className = "annotationContent";
          const {
            firstChild
          } = element;
          if (!firstChild) {
            element.append(canvas);
          } else if (firstChild.nodeName === "CANVAS") {
            firstChild.replaceWith(canvas);
          } else if (!firstChild.classList.contains("annotationContent")) {
            firstChild.before(canvas);
          } else {
            firstChild.after(canvas);
          }
          const editableAnnotation = this.#editableAnnotations.get(id);
          if (!editableAnnotation) {
            continue;
          }
          if (editableAnnotation._hasNoCanvas) {
            this._annotationEditorUIManager?.setMissingCanvas(id, element.id, canvas);
            editableAnnotation._hasNoCanvas = false;
          } else {
            editableAnnotation.canvas = canvas;
          }
        }
        this.#annotationCanvasMap.clear();
      }
      getEditableAnnotations() {
        return Array.from(this.#editableAnnotations.values());
      }
      getEditableAnnotation(id) {
        return this.#editableAnnotations.get(id);
      }
      addFakeAnnotation(editor) {
        const {
          div
        } = this;
        const {
          id,
          rotation
        } = editor;
        const element = new EditorAnnotationElement({
          data: {
            id,
            rect: editor.getPDFRect(),
            rotation
          },
          editor,
          layer: div,
          parent: this,
          enableComment: !!this._commentManager,
          linkService: this.#linkService,
          annotationStorage: this.#annotationStorage
        });
        const htmlElement = element.render();
        div.append(htmlElement);
        this.#accessibilityManager?.moveElementInDOM(div, htmlElement, htmlElement, false);
        element.createOrUpdatePopup();
        return element;
      }
      static get _defaultBorderStyle() {
        return shadow(this, "_defaultBorderStyle", Object.freeze({
          width: 1,
          rawWidth: 1,
          style: AnnotationBorderStyleType.SOLID,
          dashArray: [3],
          horizontalCornerRadius: 0,
          verticalCornerRadius: 0
        }));
      }
    };
    EOL_PATTERN = /\r\n?|\n/g;
    FreeTextEditor = class _FreeTextEditor extends AnnotationEditor {
      #content = "";
      #editorDivId = `${this.id}-editor`;
      #editModeAC = null;
      #fontSize;
      _colorPicker = null;
      static _freeTextDefaultContent = "";
      static _internalPadding = 0;
      static _defaultColor = null;
      static _defaultFontSize = 10;
      static get _keyboardManager() {
        const proto = _FreeTextEditor.prototype;
        const arrowChecker = (self2) => self2.isEmpty();
        const small = AnnotationEditorUIManager.TRANSLATE_SMALL;
        const big = AnnotationEditorUIManager.TRANSLATE_BIG;
        return shadow(this, "_keyboardManager", new KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], proto.commitOrRemove, {
          bubbles: true
        }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], proto.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], proto._translateEmpty, {
          args: [-small, 0],
          checker: arrowChecker
        }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], proto._translateEmpty, {
          args: [-big, 0],
          checker: arrowChecker
        }], [["ArrowRight", "mac+ArrowRight"], proto._translateEmpty, {
          args: [small, 0],
          checker: arrowChecker
        }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], proto._translateEmpty, {
          args: [big, 0],
          checker: arrowChecker
        }], [["ArrowUp", "mac+ArrowUp"], proto._translateEmpty, {
          args: [0, -small],
          checker: arrowChecker
        }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], proto._translateEmpty, {
          args: [0, -big],
          checker: arrowChecker
        }], [["ArrowDown", "mac+ArrowDown"], proto._translateEmpty, {
          args: [0, small],
          checker: arrowChecker
        }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], proto._translateEmpty, {
          args: [0, big],
          checker: arrowChecker
        }]]));
      }
      static _type = "freetext";
      static _editorType = AnnotationEditorType.FREETEXT;
      constructor(params) {
        super({
          ...params,
          name: "freeTextEditor"
        });
        this.color = params.color || _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor;
        this.#fontSize = params.fontSize || _FreeTextEditor._defaultFontSize;
        if (!this.annotationElementId) {
          this._uiManager.a11yAlert("pdfjs-editor-freetext-added-alert");
        }
      }
      static initialize(l10n, uiManager) {
        AnnotationEditor.initialize(l10n, uiManager);
        const style = getComputedStyle(document.documentElement);
        this._internalPadding = parseFloat(style.getPropertyValue("--freetext-padding"));
      }
      static updateDefaultParams(type, value) {
        switch (type) {
          case AnnotationEditorParamsType.FREETEXT_SIZE:
            _FreeTextEditor._defaultFontSize = value;
            break;
          case AnnotationEditorParamsType.FREETEXT_COLOR:
            _FreeTextEditor._defaultColor = value;
            break;
        }
      }
      updateParams(type, value) {
        switch (type) {
          case AnnotationEditorParamsType.FREETEXT_SIZE:
            this.#updateFontSize(value);
            break;
          case AnnotationEditorParamsType.FREETEXT_COLOR:
            this.#updateColor(value);
            break;
        }
      }
      static get defaultPropertiesToUpdate() {
        return [[AnnotationEditorParamsType.FREETEXT_SIZE, _FreeTextEditor._defaultFontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, _FreeTextEditor._defaultColor || AnnotationEditor._defaultLineColor]];
      }
      get propertiesToUpdate() {
        return [[AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [AnnotationEditorParamsType.FREETEXT_COLOR, this.color]];
      }
      get toolbarButtons() {
        this._colorPicker ||= new BasicColorPicker(this);
        return [["colorPicker", this._colorPicker]];
      }
      get colorType() {
        return AnnotationEditorParamsType.FREETEXT_COLOR;
      }
      #updateFontSize(fontSize) {
        const setFontsize = (size2) => {
          this.editorDiv.style.fontSize = `calc(${size2}px * var(--total-scale-factor))`;
          this.translate(0, -(size2 - this.#fontSize) * this.parentScale);
          this.#fontSize = size2;
          this.#setEditorDimensions();
        };
        const savedFontsize = this.#fontSize;
        this.addCommands({
          cmd: setFontsize.bind(this, fontSize),
          undo: setFontsize.bind(this, savedFontsize),
          post: this._uiManager.updateUI.bind(this._uiManager, this),
          mustExec: true,
          type: AnnotationEditorParamsType.FREETEXT_SIZE,
          overwriteIfSameType: true,
          keepUndo: true
        });
      }
      onUpdatedColor() {
        this.editorDiv.style.color = this.color;
        this._colorPicker?.update(this.color);
        super.onUpdatedColor();
      }
      #updateColor(color) {
        const setColor = (col) => {
          this.color = col;
          this.onUpdatedColor();
        };
        const savedColor = this.color;
        this.addCommands({
          cmd: setColor.bind(this, color),
          undo: setColor.bind(this, savedColor),
          post: this._uiManager.updateUI.bind(this._uiManager, this),
          mustExec: true,
          type: AnnotationEditorParamsType.FREETEXT_COLOR,
          overwriteIfSameType: true,
          keepUndo: true
        });
      }
      _translateEmpty(x, y) {
        this._uiManager.translateSelectedEditors(x, y, true);
      }
      getInitialTranslation() {
        const scale = this.parentScale;
        return [-_FreeTextEditor._internalPadding * scale, -(_FreeTextEditor._internalPadding + this.#fontSize) * scale];
      }
      rebuild() {
        if (!this.parent) {
          return;
        }
        super.rebuild();
        if (this.div === null) {
          return;
        }
        if (!this.isAttachedToDOM) {
          this.parent.add(this);
        }
      }
      enableEditMode() {
        if (!super.enableEditMode()) {
          return false;
        }
        this.overlayDiv.classList.remove("enabled");
        this.editorDiv.contentEditable = true;
        this._isDraggable = false;
        this.div.removeAttribute("aria-activedescendant");
        this.#editModeAC = new AbortController();
        const signal = this._uiManager.combinedSignal(this.#editModeAC);
        this.editorDiv.addEventListener("keydown", this.editorDivKeydown.bind(this), {
          signal
        });
        this.editorDiv.addEventListener("focus", this.editorDivFocus.bind(this), {
          signal
        });
        this.editorDiv.addEventListener("blur", this.editorDivBlur.bind(this), {
          signal
        });
        this.editorDiv.addEventListener("input", this.editorDivInput.bind(this), {
          signal
        });
        this.editorDiv.addEventListener("paste", this.editorDivPaste.bind(this), {
          signal
        });
        return true;
      }
      disableEditMode() {
        if (!super.disableEditMode()) {
          return false;
        }
        this.overlayDiv.classList.add("enabled");
        this.editorDiv.contentEditable = false;
        this.div.setAttribute("aria-activedescendant", this.#editorDivId);
        this._isDraggable = true;
        this.#editModeAC?.abort();
        this.#editModeAC = null;
        this.div.focus({
          preventScroll: true
        });
        this.isEditing = false;
        this.parent.div.classList.add("freetextEditing");
        return true;
      }
      focusin(event) {
        if (!this._focusEventsAllowed) {
          return;
        }
        super.focusin(event);
        if (event.target !== this.editorDiv) {
          this.editorDiv.focus();
        }
      }
      onceAdded(focus) {
        if (this.width) {
          return;
        }
        this.enableEditMode();
        if (focus) {
          this.editorDiv.focus();
        }
        if (this._initialOptions?.isCentered) {
          this.center();
        }
        this._initialOptions = null;
      }
      isEmpty() {
        return !this.editorDiv || this.editorDiv.innerText.trim() === "";
      }
      remove() {
        this.isEditing = false;
        if (this.parent) {
          this.parent.setEditingState(true);
          this.parent.div.classList.add("freetextEditing");
        }
        super.remove();
      }
      #extractText() {
        const buffer = [];
        this.editorDiv.normalize();
        let prevChild = null;
        for (const child of this.editorDiv.childNodes) {
          if (prevChild?.nodeType === Node.TEXT_NODE && child.nodeName === "BR") {
            continue;
          }
          buffer.push(_FreeTextEditor.#getNodeContent(child));
          prevChild = child;
        }
        return buffer.join("\n");
      }
      #setEditorDimensions() {
        const [parentWidth, parentHeight] = this.parentDimensions;
        let rect;
        if (this.isAttachedToDOM) {
          rect = this.div.getBoundingClientRect();
        } else {
          const {
            currentLayer,
            div
          } = this;
          const savedDisplay = div.style.display;
          const savedVisibility = div.classList.contains("hidden");
          div.classList.remove("hidden");
          div.style.display = "hidden";
          currentLayer.div.append(this.div);
          rect = div.getBoundingClientRect();
          div.remove();
          div.style.display = savedDisplay;
          div.classList.toggle("hidden", savedVisibility);
        }
        if (this.rotation % 180 === this.parentRotation % 180) {
          this.width = rect.width / parentWidth;
          this.height = rect.height / parentHeight;
        } else {
          this.width = rect.height / parentWidth;
          this.height = rect.width / parentHeight;
        }
        this.fixAndSetPosition();
      }
      commit() {
        if (!this.isInEditMode()) {
          return;
        }
        super.commit();
        this.disableEditMode();
        const savedText = this.#content;
        const newText = this.#content = this.#extractText().trimEnd();
        if (savedText === newText) {
          return;
        }
        const setText = (text) => {
          this.#content = text;
          if (!text) {
            this.remove();
            return;
          }
          this.#setContent();
          this._uiManager.rebuild(this);
          this.#setEditorDimensions();
        };
        this.addCommands({
          cmd: () => {
            setText(newText);
          },
          undo: () => {
            setText(savedText);
          },
          mustExec: false
        });
        this.#setEditorDimensions();
      }
      shouldGetKeyboardEvents() {
        return this.isInEditMode();
      }
      enterInEditMode() {
        this.enableEditMode();
        this.editorDiv.focus();
      }
      keydown(event) {
        if (event.target === this.div && event.key === "Enter") {
          this.enterInEditMode();
          event.preventDefault();
        }
      }
      editorDivKeydown(event) {
        _FreeTextEditor._keyboardManager.exec(this, event);
      }
      editorDivFocus(event) {
        this.isEditing = true;
      }
      editorDivBlur(event) {
        this.isEditing = false;
      }
      editorDivInput(event) {
        this.parent.div.classList.toggle("freetextEditing", this.isEmpty());
      }
      disableEditing() {
        this.editorDiv.setAttribute("role", "comment");
        this.editorDiv.removeAttribute("aria-multiline");
      }
      enableEditing() {
        this.editorDiv.setAttribute("role", "textbox");
        this.editorDiv.setAttribute("aria-multiline", true);
      }
      get canChangeContent() {
        return true;
      }
      render() {
        if (this.div) {
          return this.div;
        }
        let baseX, baseY;
        if (this._isCopy || this.annotationElementId) {
          baseX = this.x;
          baseY = this.y;
        }
        super.render();
        this.editorDiv = document.createElement("div");
        this.editorDiv.className = "internal";
        this.editorDiv.setAttribute("id", this.#editorDivId);
        this.editorDiv.setAttribute("data-l10n-id", "pdfjs-free-text2");
        this.editorDiv.setAttribute("data-l10n-attrs", "default-content");
        this.enableEditing();
        this.editorDiv.contentEditable = true;
        const {
          style
        } = this.editorDiv;
        style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;
        style.color = this.color;
        this.div.append(this.editorDiv);
        this.overlayDiv = document.createElement("div");
        this.overlayDiv.classList.add("overlay", "enabled");
        this.div.append(this.overlayDiv);
        if (this._isCopy || this.annotationElementId) {
          const [parentWidth, parentHeight] = this.parentDimensions;
          if (this.annotationElementId) {
            const {
              position
            } = this._initialData;
            let [tx, ty] = this.getInitialTranslation();
            [tx, ty] = this.pageTranslationToScreen(tx, ty);
            const [pageWidth, pageHeight] = this.pageDimensions;
            const [pageX, pageY] = this.pageTranslation;
            let posX, posY;
            switch (this.rotation) {
              case 0:
                posX = baseX + (position[0] - pageX) / pageWidth;
                posY = baseY + this.height - (position[1] - pageY) / pageHeight;
                break;
              case 90:
                posX = baseX + (position[0] - pageX) / pageWidth;
                posY = baseY - (position[1] - pageY) / pageHeight;
                [tx, ty] = [ty, -tx];
                break;
              case 180:
                posX = baseX - this.width + (position[0] - pageX) / pageWidth;
                posY = baseY - (position[1] - pageY) / pageHeight;
                [tx, ty] = [-tx, -ty];
                break;
              case 270:
                posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;
                posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;
                [tx, ty] = [-ty, tx];
                break;
            }
            this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);
          } else {
            this._moveAfterPaste(baseX, baseY);
          }
          this.#setContent();
          this._isDraggable = true;
          this.editorDiv.contentEditable = false;
        } else {
          this._isDraggable = false;
          this.editorDiv.contentEditable = true;
        }
        return this.div;
      }
      static #getNodeContent(node) {
        return (node.nodeType === Node.TEXT_NODE ? node.nodeValue : node.innerText).replaceAll(EOL_PATTERN, "");
      }
      editorDivPaste(event) {
        const clipboardData = event.clipboardData || window.clipboardData;
        const {
          types
        } = clipboardData;
        if (types.length === 1 && types[0] === "text/plain") {
          return;
        }
        event.preventDefault();
        const paste = _FreeTextEditor.#deserializeContent(clipboardData.getData("text") || "").replaceAll(EOL_PATTERN, "\n");
        if (!paste) {
          return;
        }
        const selection = window.getSelection();
        if (!selection.rangeCount) {
          return;
        }
        this.editorDiv.normalize();
        selection.deleteFromDocument();
        const range2 = selection.getRangeAt(0);
        if (!paste.includes("\n")) {
          range2.insertNode(document.createTextNode(paste));
          this.editorDiv.normalize();
          selection.collapseToStart();
          return;
        }
        const {
          startContainer,
          startOffset
        } = range2;
        const bufferBefore = [];
        const bufferAfter = [];
        if (startContainer.nodeType === Node.TEXT_NODE) {
          const parent = startContainer.parentElement;
          bufferAfter.push(startContainer.nodeValue.slice(startOffset).replaceAll(EOL_PATTERN, ""));
          if (parent !== this.editorDiv) {
            let buffer = bufferBefore;
            for (const child of this.editorDiv.childNodes) {
              if (child === parent) {
                buffer = bufferAfter;
                continue;
              }
              buffer.push(_FreeTextEditor.#getNodeContent(child));
            }
          }
          bufferBefore.push(startContainer.nodeValue.slice(0, startOffset).replaceAll(EOL_PATTERN, ""));
        } else if (startContainer === this.editorDiv) {
          let buffer = bufferBefore;
          let i = 0;
          for (const child of this.editorDiv.childNodes) {
            if (i++ === startOffset) {
              buffer = bufferAfter;
            }
            buffer.push(_FreeTextEditor.#getNodeContent(child));
          }
        }
        this.#content = `${bufferBefore.join("\n")}${paste}${bufferAfter.join("\n")}`;
        this.#setContent();
        const newRange = new Range();
        let beforeLength = Math.sumPrecise(bufferBefore.map((line) => line.length));
        for (const {
          firstChild
        } of this.editorDiv.childNodes) {
          if (firstChild.nodeType === Node.TEXT_NODE) {
            const length = firstChild.nodeValue.length;
            if (beforeLength <= length) {
              newRange.setStart(firstChild, beforeLength);
              newRange.setEnd(firstChild, beforeLength);
              break;
            }
            beforeLength -= length;
          }
        }
        selection.removeAllRanges();
        selection.addRange(newRange);
      }
      #setContent() {
        this.editorDiv.replaceChildren();
        if (!this.#content) {
          return;
        }
        for (const line of this.#content.split("\n")) {
          const div = document.createElement("div");
          div.append(line ? document.createTextNode(line) : document.createElement("br"));
          this.editorDiv.append(div);
        }
      }
      #serializeContent() {
        return this.#content.replaceAll("\xA0", " ");
      }
      static #deserializeContent(content) {
        return content.replaceAll(" ", "\xA0");
      }
      get contentDiv() {
        return this.editorDiv;
      }
      getPDFRect() {
        const padding = _FreeTextEditor._internalPadding * this.parentScale;
        return this.getRect(padding, padding);
      }
      static async deserialize(data, parent, uiManager) {
        let initialData = null;
        if (data instanceof FreeTextAnnotationElement) {
          const {
            data: {
              defaultAppearanceData: {
                fontSize,
                fontColor
              },
              rect,
              rotation,
              id,
              popupRef,
              richText,
              contentsObj,
              creationDate,
              modificationDate
            },
            textContent,
            textPosition,
            parent: {
              page: {
                pageNumber
              }
            }
          } = data;
          if (!textContent || textContent.length === 0) {
            return null;
          }
          initialData = data = {
            annotationType: AnnotationEditorType.FREETEXT,
            color: Array.from(fontColor),
            fontSize,
            value: textContent.join("\n"),
            position: textPosition,
            pageIndex: pageNumber - 1,
            rect: rect.slice(0),
            rotation,
            annotationElementId: id,
            id,
            deleted: false,
            popupRef,
            comment: contentsObj?.str || null,
            richText,
            creationDate,
            modificationDate
          };
        }
        const editor = await super.deserialize(data, parent, uiManager);
        editor.#fontSize = data.fontSize;
        editor.color = Util.makeHexColor(...data.color);
        editor.#content = _FreeTextEditor.#deserializeContent(data.value);
        editor._initialData = initialData;
        if (data.comment) {
          editor.setCommentData(data);
        }
        return editor;
      }
      serialize(isForCopying = false) {
        if (this.isEmpty()) {
          return null;
        }
        if (this.deleted) {
          return this.serializeDeleted();
        }
        const color = AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.color);
        const serialized = Object.assign(super.serialize(isForCopying), {
          color,
          fontSize: this.#fontSize,
          value: this.#serializeContent()
        });
        this.addComment(serialized);
        if (isForCopying) {
          serialized.isCopy = true;
          return serialized;
        }
        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
          return null;
        }
        serialized.id = this.annotationElementId;
        return serialized;
      }
      #hasElementChanged(serialized) {
        const {
          value,
          fontSize,
          color,
          pageIndex
        } = this._initialData;
        return this.hasEditedComment || this._hasBeenMoved || serialized.value !== value || serialized.fontSize !== fontSize || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;
      }
      renderAnnotationElement(annotation) {
        const content = super.renderAnnotationElement(annotation);
        if (!content) {
          return null;
        }
        const {
          style
        } = content;
        style.fontSize = `calc(${this.#fontSize}px * var(--total-scale-factor))`;
        style.color = this.color;
        content.replaceChildren();
        for (const line of this.#content.split("\n")) {
          const div = document.createElement("div");
          div.append(line ? document.createTextNode(line) : document.createElement("br"));
          content.append(div);
        }
        annotation.updateEdited({
          rect: this.getPDFRect(),
          popup: this._uiManager.hasCommentManager() || this.hasEditedComment ? this.comment : {
            text: this.#content
          }
        });
        return content;
      }
      resetAnnotationElement(annotation) {
        super.resetAnnotationElement(annotation);
        annotation.resetEdited();
      }
    };
    Outline = class {
      static PRECISION = 1e-4;
      toSVGPath() {
        unreachable("Abstract method `toSVGPath` must be implemented.");
      }
      get box() {
        unreachable("Abstract getter `box` must be implemented.");
      }
      serialize(_bbox, _rotation) {
        unreachable("Abstract method `serialize` must be implemented.");
      }
      static _rescale(src, tx, ty, sx, sy, dest) {
        dest ||= new Float32Array(src.length);
        for (let i = 0, ii = src.length; i < ii; i += 2) {
          dest[i] = tx + src[i] * sx;
          dest[i + 1] = ty + src[i + 1] * sy;
        }
        return dest;
      }
      static _rescaleAndSwap(src, tx, ty, sx, sy, dest) {
        dest ||= new Float32Array(src.length);
        for (let i = 0, ii = src.length; i < ii; i += 2) {
          dest[i] = tx + src[i + 1] * sx;
          dest[i + 1] = ty + src[i] * sy;
        }
        return dest;
      }
      static _translate(src, tx, ty, dest) {
        dest ||= new Float32Array(src.length);
        for (let i = 0, ii = src.length; i < ii; i += 2) {
          dest[i] = tx + src[i];
          dest[i + 1] = ty + src[i + 1];
        }
        return dest;
      }
      static svgRound(x) {
        return Math.round(x * 1e4);
      }
      static _normalizePoint(x, y, parentWidth, parentHeight, rotation) {
        switch (rotation) {
          case 90:
            return [1 - y / parentWidth, x / parentHeight];
          case 180:
            return [1 - x / parentWidth, 1 - y / parentHeight];
          case 270:
            return [y / parentWidth, 1 - x / parentHeight];
          default:
            return [x / parentWidth, y / parentHeight];
        }
      }
      static _normalizePagePoint(x, y, rotation) {
        switch (rotation) {
          case 90:
            return [1 - y, x];
          case 180:
            return [1 - x, 1 - y];
          case 270:
            return [y, 1 - x];
          default:
            return [x, y];
        }
      }
      static createBezierPoints(x1, y1, x2, y2, x3, y3) {
        return [(x1 + 5 * x2) / 6, (y1 + 5 * y2) / 6, (5 * x2 + x3) / 6, (5 * y2 + y3) / 6, (x2 + x3) / 2, (y2 + y3) / 2];
      }
    };
    FreeDrawOutliner = class _FreeDrawOutliner {
      #box;
      #bottom = [];
      #innerMargin;
      #isLTR;
      #top = [];
      #last = new Float32Array(18);
      #lastX;
      #lastY;
      #min;
      #min_dist;
      #scaleFactor;
      #thickness;
      #points = [];
      static #MIN_DIST = 8;
      static #MIN_DIFF = 2;
      static #MIN = _FreeDrawOutliner.#MIN_DIST + _FreeDrawOutliner.#MIN_DIFF;
      constructor({
        x,
        y
      }, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
        this.#box = box;
        this.#thickness = thickness * scaleFactor;
        this.#isLTR = isLTR;
        this.#last.set([NaN, NaN, NaN, NaN, x, y], 6);
        this.#innerMargin = innerMargin;
        this.#min_dist = _FreeDrawOutliner.#MIN_DIST * scaleFactor;
        this.#min = _FreeDrawOutliner.#MIN * scaleFactor;
        this.#scaleFactor = scaleFactor;
        this.#points.push(x, y);
      }
      isEmpty() {
        return isNaN(this.#last[8]);
      }
      #getLastCoords() {
        const lastTop = this.#last.subarray(4, 6);
        const lastBottom = this.#last.subarray(16, 18);
        const [x, y, width, height] = this.#box;
        return [(this.#lastX + (lastTop[0] - lastBottom[0]) / 2 - x) / width, (this.#lastY + (lastTop[1] - lastBottom[1]) / 2 - y) / height, (this.#lastX + (lastBottom[0] - lastTop[0]) / 2 - x) / width, (this.#lastY + (lastBottom[1] - lastTop[1]) / 2 - y) / height];
      }
      add({
        x,
        y
      }) {
        this.#lastX = x;
        this.#lastY = y;
        const [layerX, layerY, layerWidth, layerHeight] = this.#box;
        let [x1, y1, x2, y2] = this.#last.subarray(8, 12);
        const diffX = x - x2;
        const diffY = y - y2;
        const d = Math.hypot(diffX, diffY);
        if (d < this.#min) {
          return false;
        }
        const diffD = d - this.#min_dist;
        const K = diffD / d;
        const shiftX = K * diffX;
        const shiftY = K * diffY;
        let x0 = x1;
        let y0 = y1;
        x1 = x2;
        y1 = y2;
        x2 += shiftX;
        y2 += shiftY;
        this.#points?.push(x, y);
        const nX = -shiftY / diffD;
        const nY = shiftX / diffD;
        const thX = nX * this.#thickness;
        const thY = nY * this.#thickness;
        this.#last.set(this.#last.subarray(2, 8), 0);
        this.#last.set([x2 + thX, y2 + thY], 4);
        this.#last.set(this.#last.subarray(14, 18), 12);
        this.#last.set([x2 - thX, y2 - thY], 16);
        if (isNaN(this.#last[6])) {
          if (this.#top.length === 0) {
            this.#last.set([x1 + thX, y1 + thY], 2);
            this.#top.push(NaN, NaN, NaN, NaN, (x1 + thX - layerX) / layerWidth, (y1 + thY - layerY) / layerHeight);
            this.#last.set([x1 - thX, y1 - thY], 14);
            this.#bottom.push(NaN, NaN, NaN, NaN, (x1 - thX - layerX) / layerWidth, (y1 - thY - layerY) / layerHeight);
          }
          this.#last.set([x0, y0, x1, y1, x2, y2], 6);
          return !this.isEmpty();
        }
        this.#last.set([x0, y0, x1, y1, x2, y2], 6);
        const angle = Math.abs(Math.atan2(y0 - y1, x0 - x1) - Math.atan2(shiftY, shiftX));
        if (angle < Math.PI / 2) {
          [x1, y1, x2, y2] = this.#last.subarray(2, 6);
          this.#top.push(NaN, NaN, NaN, NaN, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
          [x1, y1, x0, y0] = this.#last.subarray(14, 18);
          this.#bottom.push(NaN, NaN, NaN, NaN, ((x0 + x1) / 2 - layerX) / layerWidth, ((y0 + y1) / 2 - layerY) / layerHeight);
          return true;
        }
        [x0, y0, x1, y1, x2, y2] = this.#last.subarray(0, 6);
        this.#top.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
        [x2, y2, x1, y1, x0, y0] = this.#last.subarray(12, 18);
        this.#bottom.push(((x0 + 5 * x1) / 6 - layerX) / layerWidth, ((y0 + 5 * y1) / 6 - layerY) / layerHeight, ((5 * x1 + x2) / 6 - layerX) / layerWidth, ((5 * y1 + y2) / 6 - layerY) / layerHeight, ((x1 + x2) / 2 - layerX) / layerWidth, ((y1 + y2) / 2 - layerY) / layerHeight);
        return true;
      }
      toSVGPath() {
        if (this.isEmpty()) {
          return "";
        }
        const top = this.#top;
        const bottom = this.#bottom;
        if (isNaN(this.#last[6]) && !this.isEmpty()) {
          return this.#toSVGPathTwoPoints();
        }
        const buffer = [];
        buffer.push(`M${top[4]} ${top[5]}`);
        for (let i = 6; i < top.length; i += 6) {
          if (isNaN(top[i])) {
            buffer.push(`L${top[i + 4]} ${top[i + 5]}`);
          } else {
            buffer.push(`C${top[i]} ${top[i + 1]} ${top[i + 2]} ${top[i + 3]} ${top[i + 4]} ${top[i + 5]}`);
          }
        }
        this.#toSVGPathEnd(buffer);
        for (let i = bottom.length - 6; i >= 6; i -= 6) {
          if (isNaN(bottom[i])) {
            buffer.push(`L${bottom[i + 4]} ${bottom[i + 5]}`);
          } else {
            buffer.push(`C${bottom[i]} ${bottom[i + 1]} ${bottom[i + 2]} ${bottom[i + 3]} ${bottom[i + 4]} ${bottom[i + 5]}`);
          }
        }
        this.#toSVGPathStart(buffer);
        return buffer.join(" ");
      }
      #toSVGPathTwoPoints() {
        const [x, y, width, height] = this.#box;
        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
        return `M${(this.#last[2] - x) / width} ${(this.#last[3] - y) / height} L${(this.#last[4] - x) / width} ${(this.#last[5] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(this.#last[16] - x) / width} ${(this.#last[17] - y) / height} L${(this.#last[14] - x) / width} ${(this.#last[15] - y) / height} Z`;
      }
      #toSVGPathStart(buffer) {
        const bottom = this.#bottom;
        buffer.push(`L${bottom[4]} ${bottom[5]} Z`);
      }
      #toSVGPathEnd(buffer) {
        const [x, y, width, height] = this.#box;
        const lastTop = this.#last.subarray(4, 6);
        const lastBottom = this.#last.subarray(16, 18);
        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
        buffer.push(`L${(lastTop[0] - x) / width} ${(lastTop[1] - y) / height} L${lastTopX} ${lastTopY} L${lastBottomX} ${lastBottomY} L${(lastBottom[0] - x) / width} ${(lastBottom[1] - y) / height}`);
      }
      newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
        return new FreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
      }
      getOutlines() {
        const top = this.#top;
        const bottom = this.#bottom;
        const last2 = this.#last;
        const [layerX, layerY, layerWidth, layerHeight] = this.#box;
        const points = new Float32Array((this.#points?.length ?? 0) + 2);
        for (let i = 0, ii = points.length - 2; i < ii; i += 2) {
          points[i] = (this.#points[i] - layerX) / layerWidth;
          points[i + 1] = (this.#points[i + 1] - layerY) / layerHeight;
        }
        points[points.length - 2] = (this.#lastX - layerX) / layerWidth;
        points[points.length - 1] = (this.#lastY - layerY) / layerHeight;
        if (isNaN(last2[6]) && !this.isEmpty()) {
          return this.#getOutlineTwoPoints(points);
        }
        const outline = new Float32Array(this.#top.length + 24 + this.#bottom.length);
        let N = top.length;
        for (let i = 0; i < N; i += 2) {
          if (isNaN(top[i])) {
            outline[i] = outline[i + 1] = NaN;
            continue;
          }
          outline[i] = top[i];
          outline[i + 1] = top[i + 1];
        }
        N = this.#getOutlineEnd(outline, N);
        for (let i = bottom.length - 6; i >= 6; i -= 6) {
          for (let j = 0; j < 6; j += 2) {
            if (isNaN(bottom[i + j])) {
              outline[N] = outline[N + 1] = NaN;
              N += 2;
              continue;
            }
            outline[N] = bottom[i + j];
            outline[N + 1] = bottom[i + j + 1];
            N += 2;
          }
        }
        this.#getOutlineStart(outline, N);
        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
      }
      #getOutlineTwoPoints(points) {
        const last2 = this.#last;
        const [layerX, layerY, layerWidth, layerHeight] = this.#box;
        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
        const outline = new Float32Array(36);
        outline.set([NaN, NaN, NaN, NaN, (last2[2] - layerX) / layerWidth, (last2[3] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last2[4] - layerX) / layerWidth, (last2[5] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (last2[16] - layerX) / layerWidth, (last2[17] - layerY) / layerHeight, NaN, NaN, NaN, NaN, (last2[14] - layerX) / layerWidth, (last2[15] - layerY) / layerHeight], 0);
        return this.newFreeDrawOutline(outline, points, this.#box, this.#scaleFactor, this.#innerMargin, this.#isLTR);
      }
      #getOutlineStart(outline, pos) {
        const bottom = this.#bottom;
        outline.set([NaN, NaN, NaN, NaN, bottom[4], bottom[5]], pos);
        return pos += 6;
      }
      #getOutlineEnd(outline, pos) {
        const lastTop = this.#last.subarray(4, 6);
        const lastBottom = this.#last.subarray(16, 18);
        const [layerX, layerY, layerWidth, layerHeight] = this.#box;
        const [lastTopX, lastTopY, lastBottomX, lastBottomY] = this.#getLastCoords();
        outline.set([NaN, NaN, NaN, NaN, (lastTop[0] - layerX) / layerWidth, (lastTop[1] - layerY) / layerHeight, NaN, NaN, NaN, NaN, lastTopX, lastTopY, NaN, NaN, NaN, NaN, lastBottomX, lastBottomY, NaN, NaN, NaN, NaN, (lastBottom[0] - layerX) / layerWidth, (lastBottom[1] - layerY) / layerHeight], pos);
        return pos += 24;
      }
    };
    FreeDrawOutline = class extends Outline {
      #box;
      #bbox = new Float32Array(4);
      #innerMargin;
      #isLTR;
      #points;
      #scaleFactor;
      #outline;
      constructor(outline, points, box, scaleFactor, innerMargin, isLTR) {
        super();
        this.#outline = outline;
        this.#points = points;
        this.#box = box;
        this.#scaleFactor = scaleFactor;
        this.#innerMargin = innerMargin;
        this.#isLTR = isLTR;
        this.firstPoint = [NaN, NaN];
        this.lastPoint = [NaN, NaN];
        this.#computeMinMax(isLTR);
        const [x, y, width, height] = this.#bbox;
        for (let i = 0, ii = outline.length; i < ii; i += 2) {
          outline[i] = (outline[i] - x) / width;
          outline[i + 1] = (outline[i + 1] - y) / height;
        }
        for (let i = 0, ii = points.length; i < ii; i += 2) {
          points[i] = (points[i] - x) / width;
          points[i + 1] = (points[i + 1] - y) / height;
        }
      }
      toSVGPath() {
        const buffer = [`M${this.#outline[4]} ${this.#outline[5]}`];
        for (let i = 6, ii = this.#outline.length; i < ii; i += 6) {
          if (isNaN(this.#outline[i])) {
            buffer.push(`L${this.#outline[i + 4]} ${this.#outline[i + 5]}`);
            continue;
          }
          buffer.push(`C${this.#outline[i]} ${this.#outline[i + 1]} ${this.#outline[i + 2]} ${this.#outline[i + 3]} ${this.#outline[i + 4]} ${this.#outline[i + 5]}`);
        }
        buffer.push("Z");
        return buffer.join(" ");
      }
      serialize([blX, blY, trX, trY], rotation) {
        const width = trX - blX;
        const height = trY - blY;
        let outline;
        let points;
        switch (rotation) {
          case 0:
            outline = Outline._rescale(this.#outline, blX, trY, width, -height);
            points = Outline._rescale(this.#points, blX, trY, width, -height);
            break;
          case 90:
            outline = Outline._rescaleAndSwap(this.#outline, blX, blY, width, height);
            points = Outline._rescaleAndSwap(this.#points, blX, blY, width, height);
            break;
          case 180:
            outline = Outline._rescale(this.#outline, trX, blY, -width, height);
            points = Outline._rescale(this.#points, trX, blY, -width, height);
            break;
          case 270:
            outline = Outline._rescaleAndSwap(this.#outline, trX, trY, -width, -height);
            points = Outline._rescaleAndSwap(this.#points, trX, trY, -width, -height);
            break;
        }
        return {
          outline: Array.from(outline),
          points: [Array.from(points)]
        };
      }
      #computeMinMax(isLTR) {
        const outline = this.#outline;
        let lastX = outline[4];
        let lastY = outline[5];
        const minMax = [lastX, lastY, lastX, lastY];
        let firstPointX = lastX;
        let firstPointY = lastY;
        let lastPointX = lastX;
        let lastPointY = lastY;
        const ltrCallback = isLTR ? Math.max : Math.min;
        const bezierBbox = new Float32Array(4);
        for (let i = 6, ii = outline.length; i < ii; i += 6) {
          const x = outline[i + 4], y = outline[i + 5];
          if (isNaN(outline[i])) {
            Util.pointBoundingBox(x, y, minMax);
            if (firstPointY > y) {
              firstPointX = x;
              firstPointY = y;
            } else if (firstPointY === y) {
              firstPointX = ltrCallback(firstPointX, x);
            }
            if (lastPointY < y) {
              lastPointX = x;
              lastPointY = y;
            } else if (lastPointY === y) {
              lastPointX = ltrCallback(lastPointX, x);
            }
          } else {
            bezierBbox[0] = bezierBbox[1] = Infinity;
            bezierBbox[2] = bezierBbox[3] = -Infinity;
            Util.bezierBoundingBox(lastX, lastY, ...outline.slice(i, i + 6), bezierBbox);
            Util.rectBoundingBox(bezierBbox[0], bezierBbox[1], bezierBbox[2], bezierBbox[3], minMax);
            if (firstPointY > bezierBbox[1]) {
              firstPointX = bezierBbox[0];
              firstPointY = bezierBbox[1];
            } else if (firstPointY === bezierBbox[1]) {
              firstPointX = ltrCallback(firstPointX, bezierBbox[0]);
            }
            if (lastPointY < bezierBbox[3]) {
              lastPointX = bezierBbox[2];
              lastPointY = bezierBbox[3];
            } else if (lastPointY === bezierBbox[3]) {
              lastPointX = ltrCallback(lastPointX, bezierBbox[2]);
            }
          }
          lastX = x;
          lastY = y;
        }
        const bbox = this.#bbox;
        bbox[0] = minMax[0] - this.#innerMargin;
        bbox[1] = minMax[1] - this.#innerMargin;
        bbox[2] = minMax[2] - minMax[0] + 2 * this.#innerMargin;
        bbox[3] = minMax[3] - minMax[1] + 2 * this.#innerMargin;
        this.firstPoint = [firstPointX, firstPointY];
        this.lastPoint = [lastPointX, lastPointY];
      }
      get box() {
        return this.#bbox;
      }
      newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
        return new FreeDrawOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
      }
      getNewOutline(thickness, innerMargin) {
        const [x, y, width, height] = this.#bbox;
        const [layerX, layerY, layerWidth, layerHeight] = this.#box;
        const sx = width * layerWidth;
        const sy = height * layerHeight;
        const tx = x * layerWidth + layerX;
        const ty = y * layerHeight + layerY;
        const outliner = this.newOutliner({
          x: this.#points[0] * sx + tx,
          y: this.#points[1] * sy + ty
        }, this.#box, this.#scaleFactor, thickness, this.#isLTR, innerMargin ?? this.#innerMargin);
        for (let i = 2; i < this.#points.length; i += 2) {
          outliner.add({
            x: this.#points[i] * sx + tx,
            y: this.#points[i + 1] * sy + ty
          });
        }
        return outliner.getOutlines();
      }
    };
    HighlightOutliner = class {
      #box;
      #firstPoint;
      #lastPoint;
      #verticalEdges = [];
      #intervals = [];
      constructor(boxes, borderWidth = 0, innerMargin = 0, isLTR = true) {
        const minMax = [Infinity, Infinity, -Infinity, -Infinity];
        const NUMBER_OF_DIGITS = 4;
        const EPSILON = 10 ** -NUMBER_OF_DIGITS;
        for (const {
          x,
          y,
          width,
          height
        } of boxes) {
          const x1 = Math.floor((x - borderWidth) / EPSILON) * EPSILON;
          const x2 = Math.ceil((x + width + borderWidth) / EPSILON) * EPSILON;
          const y1 = Math.floor((y - borderWidth) / EPSILON) * EPSILON;
          const y2 = Math.ceil((y + height + borderWidth) / EPSILON) * EPSILON;
          const left = [x1, y1, y2, true];
          const right = [x2, y1, y2, false];
          this.#verticalEdges.push(left, right);
          Util.rectBoundingBox(x1, y1, x2, y2, minMax);
        }
        const bboxWidth = minMax[2] - minMax[0] + 2 * innerMargin;
        const bboxHeight = minMax[3] - minMax[1] + 2 * innerMargin;
        const shiftedMinX = minMax[0] - innerMargin;
        const shiftedMinY = minMax[1] - innerMargin;
        let firstPointX = isLTR ? -Infinity : Infinity;
        let firstPointY = Infinity;
        const lastEdge = this.#verticalEdges.at(isLTR ? -1 : -2);
        const lastPoint = [lastEdge[0], lastEdge[2]];
        for (const edge of this.#verticalEdges) {
          const [x, y1, y2, left] = edge;
          if (!left && isLTR) {
            if (y1 < firstPointY) {
              firstPointY = y1;
              firstPointX = x;
            } else if (y1 === firstPointY) {
              firstPointX = Math.max(firstPointX, x);
            }
          } else if (left && !isLTR) {
            if (y1 < firstPointY) {
              firstPointY = y1;
              firstPointX = x;
            } else if (y1 === firstPointY) {
              firstPointX = Math.min(firstPointX, x);
            }
          }
          edge[0] = (x - shiftedMinX) / bboxWidth;
          edge[1] = (y1 - shiftedMinY) / bboxHeight;
          edge[2] = (y2 - shiftedMinY) / bboxHeight;
        }
        this.#box = new Float32Array([shiftedMinX, shiftedMinY, bboxWidth, bboxHeight]);
        this.#firstPoint = [firstPointX, firstPointY];
        this.#lastPoint = lastPoint;
      }
      getOutlines() {
        this.#verticalEdges.sort((a, b) => a[0] - b[0] || a[1] - b[1] || a[2] - b[2]);
        const outlineVerticalEdges = [];
        for (const edge of this.#verticalEdges) {
          if (edge[3]) {
            outlineVerticalEdges.push(...this.#breakEdge(edge));
            this.#insert(edge);
          } else {
            this.#remove(edge);
            outlineVerticalEdges.push(...this.#breakEdge(edge));
          }
        }
        return this.#getOutlines(outlineVerticalEdges);
      }
      #getOutlines(outlineVerticalEdges) {
        const edges = [];
        const allEdges = /* @__PURE__ */ new Set();
        for (const edge of outlineVerticalEdges) {
          const [x, y1, y2] = edge;
          edges.push([x, y1, edge], [x, y2, edge]);
        }
        edges.sort((a, b) => a[1] - b[1] || a[0] - b[0]);
        for (let i = 0, ii = edges.length; i < ii; i += 2) {
          const edge1 = edges[i][2];
          const edge2 = edges[i + 1][2];
          edge1.push(edge2);
          edge2.push(edge1);
          allEdges.add(edge1);
          allEdges.add(edge2);
        }
        const outlines = [];
        let outline;
        while (allEdges.size > 0) {
          const edge = allEdges.values().next().value;
          let [x, y1, y2, edge1, edge2] = edge;
          allEdges.delete(edge);
          let lastPointX = x;
          let lastPointY = y1;
          outline = [x, y2];
          outlines.push(outline);
          while (true) {
            let e;
            if (allEdges.has(edge1)) {
              e = edge1;
            } else if (allEdges.has(edge2)) {
              e = edge2;
            } else {
              break;
            }
            allEdges.delete(e);
            [x, y1, y2, edge1, edge2] = e;
            if (lastPointX !== x) {
              outline.push(lastPointX, lastPointY, x, lastPointY === y1 ? y1 : y2);
              lastPointX = x;
            }
            lastPointY = lastPointY === y1 ? y2 : y1;
          }
          outline.push(lastPointX, lastPointY);
        }
        return new HighlightOutline(outlines, this.#box, this.#firstPoint, this.#lastPoint);
      }
      #binarySearch(y) {
        const array = this.#intervals;
        let start = 0;
        let end = array.length - 1;
        while (start <= end) {
          const middle = start + end >> 1;
          const y1 = array[middle][0];
          if (y1 === y) {
            return middle;
          }
          if (y1 < y) {
            start = middle + 1;
          } else {
            end = middle - 1;
          }
        }
        return end + 1;
      }
      #insert([, y1, y2]) {
        const index = this.#binarySearch(y1);
        this.#intervals.splice(index, 0, [y1, y2]);
      }
      #remove([, y1, y2]) {
        const index = this.#binarySearch(y1);
        for (let i = index; i < this.#intervals.length; i++) {
          const [start, end] = this.#intervals[i];
          if (start !== y1) {
            break;
          }
          if (start === y1 && end === y2) {
            this.#intervals.splice(i, 1);
            return;
          }
        }
        for (let i = index - 1; i >= 0; i--) {
          const [start, end] = this.#intervals[i];
          if (start !== y1) {
            break;
          }
          if (start === y1 && end === y2) {
            this.#intervals.splice(i, 1);
            return;
          }
        }
      }
      #breakEdge(edge) {
        const [x, y1, y2] = edge;
        const results = [[x, y1, y2]];
        const index = this.#binarySearch(y2);
        for (let i = 0; i < index; i++) {
          const [start, end] = this.#intervals[i];
          for (let j = 0, jj = results.length; j < jj; j++) {
            const [, y3, y4] = results[j];
            if (end <= y3 || y4 <= start) {
              continue;
            }
            if (y3 >= start) {
              if (y4 > end) {
                results[j][1] = end;
              } else {
                if (jj === 1) {
                  return [];
                }
                results.splice(j, 1);
                j--;
                jj--;
              }
              continue;
            }
            results[j][2] = start;
            if (y4 > end) {
              results.push([x, end, y4]);
            }
          }
        }
        return results;
      }
    };
    HighlightOutline = class extends Outline {
      #box;
      #outlines;
      constructor(outlines, box, firstPoint, lastPoint) {
        super();
        this.#outlines = outlines;
        this.#box = box;
        this.firstPoint = firstPoint;
        this.lastPoint = lastPoint;
      }
      toSVGPath() {
        const buffer = [];
        for (const polygon of this.#outlines) {
          let [prevX, prevY] = polygon;
          buffer.push(`M${prevX} ${prevY}`);
          for (let i = 2; i < polygon.length; i += 2) {
            const x = polygon[i];
            const y = polygon[i + 1];
            if (x === prevX) {
              buffer.push(`V${y}`);
              prevY = y;
            } else if (y === prevY) {
              buffer.push(`H${x}`);
              prevX = x;
            }
          }
          buffer.push("Z");
        }
        return buffer.join(" ");
      }
      serialize([blX, blY, trX, trY], _rotation) {
        const outlines = [];
        const width = trX - blX;
        const height = trY - blY;
        for (const outline of this.#outlines) {
          const points = new Array(outline.length);
          for (let i = 0; i < outline.length; i += 2) {
            points[i] = blX + outline[i] * width;
            points[i + 1] = trY - outline[i + 1] * height;
          }
          outlines.push(points);
        }
        return outlines;
      }
      get box() {
        return this.#box;
      }
      get classNamesForOutlining() {
        return ["highlightOutline"];
      }
    };
    FreeHighlightOutliner = class extends FreeDrawOutliner {
      newFreeDrawOutline(outline, points, box, scaleFactor, innerMargin, isLTR) {
        return new FreeHighlightOutline(outline, points, box, scaleFactor, innerMargin, isLTR);
      }
    };
    FreeHighlightOutline = class extends FreeDrawOutline {
      newOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin = 0) {
        return new FreeHighlightOutliner(point, box, scaleFactor, thickness, isLTR, innerMargin);
      }
    };
    HighlightEditor = class _HighlightEditor extends AnnotationEditor {
      #anchorNode = null;
      #anchorOffset = 0;
      #boxes;
      #clipPathId = null;
      #colorPicker = null;
      #focusOutlines = null;
      #focusNode = null;
      #focusOffset = 0;
      #highlightDiv = null;
      #highlightOutlines = null;
      #id = null;
      #isFreeHighlight = false;
      #firstPoint = null;
      #lastPoint = null;
      #outlineId = null;
      #text = "";
      #thickness;
      #methodOfCreation = "";
      static _defaultColor = null;
      static _defaultOpacity = 1;
      static _defaultThickness = 12;
      static _type = "highlight";
      static _editorType = AnnotationEditorType.HIGHLIGHT;
      static _freeHighlightId = -1;
      static _freeHighlight = null;
      static _freeHighlightClipId = "";
      static get _keyboardManager() {
        const proto = _HighlightEditor.prototype;
        return shadow(this, "_keyboardManager", new KeyboardManager([[["ArrowLeft", "mac+ArrowLeft"], proto._moveCaret, {
          args: [0]
        }], [["ArrowRight", "mac+ArrowRight"], proto._moveCaret, {
          args: [1]
        }], [["ArrowUp", "mac+ArrowUp"], proto._moveCaret, {
          args: [2]
        }], [["ArrowDown", "mac+ArrowDown"], proto._moveCaret, {
          args: [3]
        }]]));
      }
      constructor(params) {
        super({
          ...params,
          name: "highlightEditor"
        });
        this.color = params.color || _HighlightEditor._defaultColor;
        this.#thickness = params.thickness || _HighlightEditor._defaultThickness;
        this.opacity = params.opacity || _HighlightEditor._defaultOpacity;
        this.#boxes = params.boxes || null;
        this.#methodOfCreation = params.methodOfCreation || "";
        this.#text = params.text || "";
        this._isDraggable = false;
        this.defaultL10nId = "pdfjs-editor-highlight-editor";
        if (params.highlightId > -1) {
          this.#isFreeHighlight = true;
          this.#createFreeOutlines(params);
          this.#addToDrawLayer();
        } else if (this.#boxes) {
          this.#anchorNode = params.anchorNode;
          this.#anchorOffset = params.anchorOffset;
          this.#focusNode = params.focusNode;
          this.#focusOffset = params.focusOffset;
          this.#createOutlines();
          this.#addToDrawLayer();
          this.rotate(this.rotation);
        }
        if (!this.annotationElementId) {
          this._uiManager.a11yAlert("pdfjs-editor-highlight-added-alert");
        }
      }
      get telemetryInitialData() {
        return {
          action: "added",
          type: this.#isFreeHighlight ? "free_highlight" : "highlight",
          color: this._uiManager.getNonHCMColorName(this.color),
          thickness: this.#thickness,
          methodOfCreation: this.#methodOfCreation
        };
      }
      get telemetryFinalData() {
        return {
          type: "highlight",
          color: this._uiManager.getNonHCMColorName(this.color)
        };
      }
      static computeTelemetryFinalData(data) {
        return {
          numberOfColors: data.get("color").size
        };
      }
      #createOutlines() {
        const outliner = new HighlightOutliner(this.#boxes, 1e-3);
        this.#highlightOutlines = outliner.getOutlines();
        [this.x, this.y, this.width, this.height] = this.#highlightOutlines.box;
        const outlinerForOutline = new HighlightOutliner(this.#boxes, 25e-4, 1e-3, this._uiManager.direction === "ltr");
        this.#focusOutlines = outlinerForOutline.getOutlines();
        const {
          firstPoint
        } = this.#highlightOutlines;
        this.#firstPoint = [(firstPoint[0] - this.x) / this.width, (firstPoint[1] - this.y) / this.height];
        const {
          lastPoint
        } = this.#focusOutlines;
        this.#lastPoint = [(lastPoint[0] - this.x) / this.width, (lastPoint[1] - this.y) / this.height];
      }
      #createFreeOutlines({
        highlightOutlines,
        highlightId,
        clipPathId
      }) {
        this.#highlightOutlines = highlightOutlines;
        const extraThickness = 1.5;
        this.#focusOutlines = highlightOutlines.getNewOutline(this.#thickness / 2 + extraThickness, 25e-4);
        if (highlightId >= 0) {
          this.#id = highlightId;
          this.#clipPathId = clipPathId;
          this.parent.drawLayer.finalizeDraw(highlightId, {
            bbox: highlightOutlines.box,
            path: {
              d: highlightOutlines.toSVGPath()
            }
          });
          this.#outlineId = this.parent.drawLayer.drawOutline({
            rootClass: {
              highlightOutline: true,
              free: true
            },
            bbox: this.#focusOutlines.box,
            path: {
              d: this.#focusOutlines.toSVGPath()
            }
          }, true);
        } else if (this.parent) {
          const angle = this.parent.viewport.rotation;
          this.parent.drawLayer.updateProperties(this.#id, {
            bbox: _HighlightEditor.#rotateBbox(this.#highlightOutlines.box, (angle - this.rotation + 360) % 360),
            path: {
              d: highlightOutlines.toSVGPath()
            }
          });
          this.parent.drawLayer.updateProperties(this.#outlineId, {
            bbox: _HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),
            path: {
              d: this.#focusOutlines.toSVGPath()
            }
          });
        }
        const [x, y, width, height] = highlightOutlines.box;
        switch (this.rotation) {
          case 0:
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            break;
          case 90: {
            const [pageWidth, pageHeight] = this.parentDimensions;
            this.x = y;
            this.y = 1 - x;
            this.width = width * pageHeight / pageWidth;
            this.height = height * pageWidth / pageHeight;
            break;
          }
          case 180:
            this.x = 1 - x;
            this.y = 1 - y;
            this.width = width;
            this.height = height;
            break;
          case 270: {
            const [pageWidth, pageHeight] = this.parentDimensions;
            this.x = 1 - y;
            this.y = x;
            this.width = width * pageHeight / pageWidth;
            this.height = height * pageWidth / pageHeight;
            break;
          }
        }
        const {
          firstPoint
        } = highlightOutlines;
        this.#firstPoint = [(firstPoint[0] - x) / width, (firstPoint[1] - y) / height];
        const {
          lastPoint
        } = this.#focusOutlines;
        this.#lastPoint = [(lastPoint[0] - x) / width, (lastPoint[1] - y) / height];
      }
      static initialize(l10n, uiManager) {
        AnnotationEditor.initialize(l10n, uiManager);
        _HighlightEditor._defaultColor ||= uiManager.highlightColors?.values().next().value || "#fff066";
      }
      static updateDefaultParams(type, value) {
        switch (type) {
          case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
            _HighlightEditor._defaultColor = value;
            break;
          case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
            _HighlightEditor._defaultThickness = value;
            break;
        }
      }
      translateInPage(x, y) {
      }
      get toolbarPosition() {
        return this.#lastPoint;
      }
      get commentButtonPosition() {
        return this.#firstPoint;
      }
      updateParams(type, value) {
        switch (type) {
          case AnnotationEditorParamsType.HIGHLIGHT_COLOR:
            this.#updateColor(value);
            break;
          case AnnotationEditorParamsType.HIGHLIGHT_THICKNESS:
            this.#updateThickness(value);
            break;
        }
      }
      static get defaultPropertiesToUpdate() {
        return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, _HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, _HighlightEditor._defaultThickness]];
      }
      get propertiesToUpdate() {
        return [[AnnotationEditorParamsType.HIGHLIGHT_COLOR, this.color || _HighlightEditor._defaultColor], [AnnotationEditorParamsType.HIGHLIGHT_THICKNESS, this.#thickness || _HighlightEditor._defaultThickness], [AnnotationEditorParamsType.HIGHLIGHT_FREE, this.#isFreeHighlight]];
      }
      onUpdatedColor() {
        this.parent?.drawLayer.updateProperties(this.#id, {
          root: {
            fill: this.color,
            "fill-opacity": this.opacity
          }
        });
        this.#colorPicker?.updateColor(this.color);
        super.onUpdatedColor();
      }
      #updateColor(color) {
        const setColorAndOpacity = (col, opa) => {
          this.color = col;
          this.opacity = opa;
          this.onUpdatedColor();
        };
        const savedColor = this.color;
        const savedOpacity = this.opacity;
        this.addCommands({
          cmd: setColorAndOpacity.bind(this, color, _HighlightEditor._defaultOpacity),
          undo: setColorAndOpacity.bind(this, savedColor, savedOpacity),
          post: this._uiManager.updateUI.bind(this._uiManager, this),
          mustExec: true,
          type: AnnotationEditorParamsType.HIGHLIGHT_COLOR,
          overwriteIfSameType: true,
          keepUndo: true
        });
        this._reportTelemetry({
          action: "color_changed",
          color: this._uiManager.getNonHCMColorName(color)
        }, true);
      }
      #updateThickness(thickness) {
        const savedThickness = this.#thickness;
        const setThickness = (th) => {
          this.#thickness = th;
          this.#changeThickness(th);
        };
        this.addCommands({
          cmd: setThickness.bind(this, thickness),
          undo: setThickness.bind(this, savedThickness),
          post: this._uiManager.updateUI.bind(this._uiManager, this),
          mustExec: true,
          type: AnnotationEditorParamsType.INK_THICKNESS,
          overwriteIfSameType: true,
          keepUndo: true
        });
        this._reportTelemetry({
          action: "thickness_changed",
          thickness
        }, true);
      }
      get toolbarButtons() {
        if (this._uiManager.highlightColors) {
          const colorPicker = this.#colorPicker = new ColorPicker({
            editor: this
          });
          return [["colorPicker", colorPicker]];
        }
        return super.toolbarButtons;
      }
      disableEditing() {
        super.disableEditing();
        this.div.classList.toggle("disabled", true);
      }
      enableEditing() {
        super.enableEditing();
        this.div.classList.toggle("disabled", false);
      }
      fixAndSetPosition() {
        return super.fixAndSetPosition(this.#getRotation());
      }
      getBaseTranslation() {
        return [0, 0];
      }
      getRect(tx, ty) {
        return super.getRect(tx, ty, this.#getRotation());
      }
      onceAdded(focus) {
        if (!this.annotationElementId) {
          this.parent.addUndoableEditor(this);
        }
        if (focus) {
          this.div.focus();
        }
      }
      remove() {
        this.#cleanDrawLayer();
        this._reportTelemetry({
          action: "deleted"
        });
        super.remove();
      }
      rebuild() {
        if (!this.parent) {
          return;
        }
        super.rebuild();
        if (this.div === null) {
          return;
        }
        this.#addToDrawLayer();
        if (!this.isAttachedToDOM) {
          this.parent.add(this);
        }
      }
      setParent(parent) {
        let mustBeSelected = false;
        if (this.parent && !parent) {
          this.#cleanDrawLayer();
        } else if (parent) {
          this.#addToDrawLayer(parent);
          mustBeSelected = !this.parent && this.div?.classList.contains("selectedEditor");
        }
        super.setParent(parent);
        this.show(this._isVisible);
        if (mustBeSelected) {
          this.select();
        }
      }
      #changeThickness(thickness) {
        if (!this.#isFreeHighlight) {
          return;
        }
        this.#createFreeOutlines({
          highlightOutlines: this.#highlightOutlines.getNewOutline(thickness / 2)
        });
        this.fixAndSetPosition();
        this.setDims(this.width, this.height);
      }
      #cleanDrawLayer() {
        if (this.#id === null || !this.parent) {
          return;
        }
        this.parent.drawLayer.remove(this.#id);
        this.#id = null;
        this.parent.drawLayer.remove(this.#outlineId);
        this.#outlineId = null;
      }
      #addToDrawLayer(parent = this.parent) {
        if (this.#id !== null) {
          return;
        }
        ({
          id: this.#id,
          clipPathId: this.#clipPathId
        } = parent.drawLayer.draw({
          bbox: this.#highlightOutlines.box,
          root: {
            viewBox: "0 0 1 1",
            fill: this.color,
            "fill-opacity": this.opacity
          },
          rootClass: {
            highlight: true,
            free: this.#isFreeHighlight
          },
          path: {
            d: this.#highlightOutlines.toSVGPath()
          }
        }, false, true));
        this.#outlineId = parent.drawLayer.drawOutline({
          rootClass: {
            highlightOutline: true,
            free: this.#isFreeHighlight
          },
          bbox: this.#focusOutlines.box,
          path: {
            d: this.#focusOutlines.toSVGPath()
          }
        }, this.#isFreeHighlight);
        if (this.#highlightDiv) {
          this.#highlightDiv.style.clipPath = this.#clipPathId;
        }
      }
      static #rotateBbox([x, y, width, height], angle) {
        switch (angle) {
          case 90:
            return [1 - y - height, x, height, width];
          case 180:
            return [1 - x - width, 1 - y - height, width, height];
          case 270:
            return [y, 1 - x - width, height, width];
        }
        return [x, y, width, height];
      }
      rotate(angle) {
        const {
          drawLayer
        } = this.parent;
        let box;
        if (this.#isFreeHighlight) {
          angle = (angle - this.rotation + 360) % 360;
          box = _HighlightEditor.#rotateBbox(this.#highlightOutlines.box, angle);
        } else {
          box = _HighlightEditor.#rotateBbox([this.x, this.y, this.width, this.height], angle);
        }
        drawLayer.updateProperties(this.#id, {
          bbox: box,
          root: {
            "data-main-rotation": angle
          }
        });
        drawLayer.updateProperties(this.#outlineId, {
          bbox: _HighlightEditor.#rotateBbox(this.#focusOutlines.box, angle),
          root: {
            "data-main-rotation": angle
          }
        });
      }
      render() {
        if (this.div) {
          return this.div;
        }
        const div = super.render();
        if (this.#text) {
          div.setAttribute("aria-label", this.#text);
          div.setAttribute("role", "mark");
        }
        if (this.#isFreeHighlight) {
          div.classList.add("free");
        } else {
          this.div.addEventListener("keydown", this.#keydown.bind(this), {
            signal: this._uiManager._signal
          });
        }
        const highlightDiv = this.#highlightDiv = document.createElement("div");
        div.append(highlightDiv);
        highlightDiv.setAttribute("aria-hidden", "true");
        highlightDiv.className = "internal";
        highlightDiv.style.clipPath = this.#clipPathId;
        this.setDims(this.width, this.height);
        bindEvents(this, this.#highlightDiv, ["pointerover", "pointerleave"]);
        this.enableEditing();
        return div;
      }
      pointerover() {
        if (!this.isSelected) {
          this.parent?.drawLayer.updateProperties(this.#outlineId, {
            rootClass: {
              hovered: true
            }
          });
        }
      }
      pointerleave() {
        if (!this.isSelected) {
          this.parent?.drawLayer.updateProperties(this.#outlineId, {
            rootClass: {
              hovered: false
            }
          });
        }
      }
      #keydown(event) {
        _HighlightEditor._keyboardManager.exec(this, event);
      }
      _moveCaret(direction) {
        this.parent.unselect(this);
        switch (direction) {
          case 0:
          case 2:
            this.#setCaret(true);
            break;
          case 1:
          case 3:
            this.#setCaret(false);
            break;
        }
      }
      #setCaret(start) {
        if (!this.#anchorNode) {
          return;
        }
        const selection = window.getSelection();
        if (start) {
          selection.setPosition(this.#anchorNode, this.#anchorOffset);
        } else {
          selection.setPosition(this.#focusNode, this.#focusOffset);
        }
      }
      select() {
        super.select();
        if (!this.#outlineId) {
          return;
        }
        this.parent?.drawLayer.updateProperties(this.#outlineId, {
          rootClass: {
            hovered: false,
            selected: true
          }
        });
      }
      unselect() {
        super.unselect();
        if (!this.#outlineId) {
          return;
        }
        this.parent?.drawLayer.updateProperties(this.#outlineId, {
          rootClass: {
            selected: false
          }
        });
        if (!this.#isFreeHighlight) {
          this.#setCaret(false);
        }
      }
      get _mustFixPosition() {
        return !this.#isFreeHighlight;
      }
      show(visible = this._isVisible) {
        super.show(visible);
        if (this.parent) {
          this.parent.drawLayer.updateProperties(this.#id, {
            rootClass: {
              hidden: !visible
            }
          });
          this.parent.drawLayer.updateProperties(this.#outlineId, {
            rootClass: {
              hidden: !visible
            }
          });
        }
      }
      #getRotation() {
        return this.#isFreeHighlight ? this.rotation : 0;
      }
      #serializeBoxes() {
        if (this.#isFreeHighlight) {
          return null;
        }
        const [pageWidth, pageHeight] = this.pageDimensions;
        const [pageX, pageY] = this.pageTranslation;
        const boxes = this.#boxes;
        const quadPoints = new Float32Array(boxes.length * 8);
        let i = 0;
        for (const {
          x,
          y,
          width,
          height
        } of boxes) {
          const sx = x * pageWidth + pageX;
          const sy = (1 - y) * pageHeight + pageY;
          quadPoints[i] = quadPoints[i + 4] = sx;
          quadPoints[i + 1] = quadPoints[i + 3] = sy;
          quadPoints[i + 2] = quadPoints[i + 6] = sx + width * pageWidth;
          quadPoints[i + 5] = quadPoints[i + 7] = sy - height * pageHeight;
          i += 8;
        }
        return quadPoints;
      }
      #serializeOutlines(rect) {
        return this.#highlightOutlines.serialize(rect, this.#getRotation());
      }
      static startHighlighting(parent, isLTR, {
        target: textLayer,
        x,
        y
      }) {
        const {
          x: layerX,
          y: layerY,
          width: parentWidth,
          height: parentHeight
        } = textLayer.getBoundingClientRect();
        const ac = new AbortController();
        const signal = parent.combinedSignal(ac);
        const pointerUpCallback = (e) => {
          ac.abort();
          this.#endHighlight(parent, e);
        };
        window.addEventListener("blur", pointerUpCallback, {
          signal
        });
        window.addEventListener("pointerup", pointerUpCallback, {
          signal
        });
        window.addEventListener("pointerdown", stopEvent, {
          capture: true,
          passive: false,
          signal
        });
        window.addEventListener("contextmenu", noContextMenu, {
          signal
        });
        textLayer.addEventListener("pointermove", this.#highlightMove.bind(this, parent), {
          signal
        });
        this._freeHighlight = new FreeHighlightOutliner({
          x,
          y
        }, [layerX, layerY, parentWidth, parentHeight], parent.scale, this._defaultThickness / 2, isLTR, 1e-3);
        ({
          id: this._freeHighlightId,
          clipPathId: this._freeHighlightClipId
        } = parent.drawLayer.draw({
          bbox: [0, 0, 1, 1],
          root: {
            viewBox: "0 0 1 1",
            fill: this._defaultColor,
            "fill-opacity": this._defaultOpacity
          },
          rootClass: {
            highlight: true,
            free: true
          },
          path: {
            d: this._freeHighlight.toSVGPath()
          }
        }, true, true));
      }
      static #highlightMove(parent, event) {
        if (this._freeHighlight.add(event)) {
          parent.drawLayer.updateProperties(this._freeHighlightId, {
            path: {
              d: this._freeHighlight.toSVGPath()
            }
          });
        }
      }
      static #endHighlight(parent, event) {
        if (!this._freeHighlight.isEmpty()) {
          parent.createAndAddNewEditor(event, false, {
            highlightId: this._freeHighlightId,
            highlightOutlines: this._freeHighlight.getOutlines(),
            clipPathId: this._freeHighlightClipId,
            methodOfCreation: "main_toolbar"
          });
        } else {
          parent.drawLayer.remove(this._freeHighlightId);
        }
        this._freeHighlightId = -1;
        this._freeHighlight = null;
        this._freeHighlightClipId = "";
      }
      static async deserialize(data, parent, uiManager) {
        let initialData = null;
        if (data instanceof HighlightAnnotationElement) {
          const {
            data: {
              quadPoints: quadPoints2,
              rect,
              rotation,
              id,
              color: color2,
              opacity: opacity2,
              popupRef,
              richText,
              contentsObj,
              creationDate,
              modificationDate
            },
            parent: {
              page: {
                pageNumber
              }
            }
          } = data;
          initialData = data = {
            annotationType: AnnotationEditorType.HIGHLIGHT,
            color: Array.from(color2),
            opacity: opacity2,
            quadPoints: quadPoints2,
            boxes: null,
            pageIndex: pageNumber - 1,
            rect: rect.slice(0),
            rotation,
            annotationElementId: id,
            id,
            deleted: false,
            popupRef,
            richText,
            comment: contentsObj?.str || null,
            creationDate,
            modificationDate
          };
        } else if (data instanceof InkAnnotationElement) {
          const {
            data: {
              inkLists: inkLists2,
              rect,
              rotation,
              id,
              color: color2,
              borderStyle: {
                rawWidth: thickness
              },
              popupRef,
              richText,
              contentsObj,
              creationDate,
              modificationDate
            },
            parent: {
              page: {
                pageNumber
              }
            }
          } = data;
          initialData = data = {
            annotationType: AnnotationEditorType.HIGHLIGHT,
            color: Array.from(color2),
            thickness,
            inkLists: inkLists2,
            boxes: null,
            pageIndex: pageNumber - 1,
            rect: rect.slice(0),
            rotation,
            annotationElementId: id,
            id,
            deleted: false,
            popupRef,
            richText,
            comment: contentsObj?.str || null,
            creationDate,
            modificationDate
          };
        }
        const {
          color,
          quadPoints,
          inkLists,
          opacity
        } = data;
        const editor = await super.deserialize(data, parent, uiManager);
        editor.color = Util.makeHexColor(...color);
        editor.opacity = opacity || 1;
        if (inkLists) {
          editor.#thickness = data.thickness;
        }
        editor._initialData = initialData;
        if (data.comment) {
          editor.setCommentData(data);
        }
        const [pageWidth, pageHeight] = editor.pageDimensions;
        const [pageX, pageY] = editor.pageTranslation;
        if (quadPoints) {
          const boxes = editor.#boxes = [];
          for (let i = 0; i < quadPoints.length; i += 8) {
            boxes.push({
              x: (quadPoints[i] - pageX) / pageWidth,
              y: 1 - (quadPoints[i + 1] - pageY) / pageHeight,
              width: (quadPoints[i + 2] - quadPoints[i]) / pageWidth,
              height: (quadPoints[i + 1] - quadPoints[i + 5]) / pageHeight
            });
          }
          editor.#createOutlines();
          editor.#addToDrawLayer();
          editor.rotate(editor.rotation);
        } else if (inkLists) {
          editor.#isFreeHighlight = true;
          const points = inkLists[0];
          const point = {
            x: points[0] - pageX,
            y: pageHeight - (points[1] - pageY)
          };
          const outliner = new FreeHighlightOutliner(point, [0, 0, pageWidth, pageHeight], 1, editor.#thickness / 2, true, 1e-3);
          for (let i = 0, ii = points.length; i < ii; i += 2) {
            point.x = points[i] - pageX;
            point.y = pageHeight - (points[i + 1] - pageY);
            outliner.add(point);
          }
          const {
            id,
            clipPathId
          } = parent.drawLayer.draw({
            bbox: [0, 0, 1, 1],
            root: {
              viewBox: "0 0 1 1",
              fill: editor.color,
              "fill-opacity": editor._defaultOpacity
            },
            rootClass: {
              highlight: true,
              free: true
            },
            path: {
              d: outliner.toSVGPath()
            }
          }, true, true);
          editor.#createFreeOutlines({
            highlightOutlines: outliner.getOutlines(),
            highlightId: id,
            clipPathId
          });
          editor.#addToDrawLayer();
          editor.rotate(editor.parentRotation);
        }
        return editor;
      }
      serialize(isForCopying = false) {
        if (this.isEmpty() || isForCopying) {
          return null;
        }
        if (this.deleted) {
          return this.serializeDeleted();
        }
        const color = AnnotationEditor._colorManager.convert(this._uiManager.getNonHCMColor(this.color));
        const serialized = super.serialize(isForCopying);
        Object.assign(serialized, {
          color,
          opacity: this.opacity,
          thickness: this.#thickness,
          quadPoints: this.#serializeBoxes(),
          outlines: this.#serializeOutlines(serialized.rect)
        });
        this.addComment(serialized);
        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
          return null;
        }
        serialized.id = this.annotationElementId;
        return serialized;
      }
      #hasElementChanged(serialized) {
        const {
          color
        } = this._initialData;
        return this.hasEditedComment || serialized.color.some((c, i) => c !== color[i]);
      }
      renderAnnotationElement(annotation) {
        if (this.deleted) {
          annotation.hide();
          return null;
        }
        annotation.updateEdited({
          rect: this.getPDFRect(),
          popup: this.comment
        });
        return null;
      }
      static canCreateNewEmptyEditor() {
        return false;
      }
    };
    DrawingOptions = class {
      #svgProperties = /* @__PURE__ */ Object.create(null);
      updateProperty(name, value) {
        this[name] = value;
        this.updateSVGProperty(name, value);
      }
      updateProperties(properties) {
        if (!properties) {
          return;
        }
        for (const [name, value] of Object.entries(properties)) {
          if (!name.startsWith("_")) {
            this.updateProperty(name, value);
          }
        }
      }
      updateSVGProperty(name, value) {
        this.#svgProperties[name] = value;
      }
      toSVGProperties() {
        const root2 = this.#svgProperties;
        this.#svgProperties = /* @__PURE__ */ Object.create(null);
        return {
          root: root2
        };
      }
      reset() {
        this.#svgProperties = /* @__PURE__ */ Object.create(null);
      }
      updateAll(options = this) {
        this.updateProperties(options);
      }
      clone() {
        unreachable("Not implemented");
      }
    };
    DrawingEditor = class _DrawingEditor extends AnnotationEditor {
      #drawOutlines = null;
      #mustBeCommitted;
      _colorPicker = null;
      _drawId = null;
      static _currentDrawId = -1;
      static _currentParent = null;
      static #currentDraw = null;
      static #currentDrawingAC = null;
      static #currentDrawingOptions = null;
      static #currentPointerId = NaN;
      static #currentPointerType = null;
      static #currentPointerIds = null;
      static #currentMoveTimestamp = NaN;
      static _INNER_MARGIN = 3;
      constructor(params) {
        super(params);
        this.#mustBeCommitted = params.mustBeCommitted || false;
        this._addOutlines(params);
      }
      onUpdatedColor() {
        this._colorPicker?.update(this.color);
        super.onUpdatedColor();
      }
      _addOutlines(params) {
        if (params.drawOutlines) {
          this.#createDrawOutlines(params);
          this.#addToDrawLayer();
        }
      }
      #createDrawOutlines({
        drawOutlines,
        drawId,
        drawingOptions
      }) {
        this.#drawOutlines = drawOutlines;
        this._drawingOptions ||= drawingOptions;
        if (!this.annotationElementId) {
          this._uiManager.a11yAlert(`pdfjs-editor-${this.editorType}-added-alert`);
        }
        if (drawId >= 0) {
          this._drawId = drawId;
          this.parent.drawLayer.finalizeDraw(drawId, drawOutlines.defaultProperties);
        } else {
          this._drawId = this.#createDrawing(drawOutlines, this.parent);
        }
        this.#updateBbox(drawOutlines.box);
      }
      #createDrawing(drawOutlines, parent) {
        const {
          id
        } = parent.drawLayer.draw(_DrawingEditor._mergeSVGProperties(this._drawingOptions.toSVGProperties(), drawOutlines.defaultSVGProperties), false, false);
        return id;
      }
      static _mergeSVGProperties(p1, p2) {
        const p1Keys = new Set(Object.keys(p1));
        for (const [key, value] of Object.entries(p2)) {
          if (p1Keys.has(key)) {
            Object.assign(p1[key], value);
          } else {
            p1[key] = value;
          }
        }
        return p1;
      }
      static getDefaultDrawingOptions(_options) {
        unreachable("Not implemented");
      }
      static get typesMap() {
        unreachable("Not implemented");
      }
      static get isDrawer() {
        return true;
      }
      static get supportMultipleDrawings() {
        return false;
      }
      static updateDefaultParams(type, value) {
        const propertyName = this.typesMap.get(type);
        if (propertyName) {
          this._defaultDrawingOptions.updateProperty(propertyName, value);
        }
        if (this._currentParent) {
          _DrawingEditor.#currentDraw.updateProperty(propertyName, value);
          this._currentParent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
        }
      }
      updateParams(type, value) {
        const propertyName = this.constructor.typesMap.get(type);
        if (propertyName) {
          this._updateProperty(type, propertyName, value);
        }
      }
      static get defaultPropertiesToUpdate() {
        const properties = [];
        const options = this._defaultDrawingOptions;
        for (const [type, name] of this.typesMap) {
          properties.push([type, options[name]]);
        }
        return properties;
      }
      get propertiesToUpdate() {
        const properties = [];
        const {
          _drawingOptions
        } = this;
        for (const [type, name] of this.constructor.typesMap) {
          properties.push([type, _drawingOptions[name]]);
        }
        return properties;
      }
      _updateProperty(type, name, value) {
        const options = this._drawingOptions;
        const savedValue = options[name];
        const setter = (val) => {
          options.updateProperty(name, val);
          const bbox = this.#drawOutlines.updateProperty(name, val);
          if (bbox) {
            this.#updateBbox(bbox);
          }
          this.parent?.drawLayer.updateProperties(this._drawId, options.toSVGProperties());
          if (type === this.colorType) {
            this.onUpdatedColor();
          }
        };
        this.addCommands({
          cmd: setter.bind(this, value),
          undo: setter.bind(this, savedValue),
          post: this._uiManager.updateUI.bind(this._uiManager, this),
          mustExec: true,
          type,
          overwriteIfSameType: true,
          keepUndo: true
        });
      }
      _onResizing() {
        this.parent?.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizingSVGProperties(this.#convertToDrawSpace()), {
          bbox: this.#rotateBox()
        }));
      }
      _onResized() {
        this.parent?.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathResizedSVGProperties(this.#convertToDrawSpace()), {
          bbox: this.#rotateBox()
        }));
      }
      _onTranslating(_x, _y) {
        this.parent?.drawLayer.updateProperties(this._drawId, {
          bbox: this.#rotateBox()
        });
      }
      _onTranslated() {
        this.parent?.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties(this.#drawOutlines.getPathTranslatedSVGProperties(this.#convertToDrawSpace(), this.parentDimensions), {
          bbox: this.#rotateBox()
        }));
      }
      _onStartDragging() {
        this.parent?.drawLayer.updateProperties(this._drawId, {
          rootClass: {
            moving: true
          }
        });
      }
      _onStopDragging() {
        this.parent?.drawLayer.updateProperties(this._drawId, {
          rootClass: {
            moving: false
          }
        });
      }
      commit() {
        super.commit();
        this.disableEditMode();
        this.disableEditing();
      }
      disableEditing() {
        super.disableEditing();
        this.div.classList.toggle("disabled", true);
      }
      enableEditing() {
        super.enableEditing();
        this.div.classList.toggle("disabled", false);
      }
      getBaseTranslation() {
        return [0, 0];
      }
      get isResizable() {
        return true;
      }
      onceAdded(focus) {
        if (!this.annotationElementId) {
          this.parent.addUndoableEditor(this);
        }
        this._isDraggable = true;
        if (this.#mustBeCommitted) {
          this.#mustBeCommitted = false;
          this.commit();
          this.parent.setSelected(this);
          if (focus && this.isOnScreen) {
            this.div.focus();
          }
        }
      }
      remove() {
        this.#cleanDrawLayer();
        super.remove();
      }
      rebuild() {
        if (!this.parent) {
          return;
        }
        super.rebuild();
        if (this.div === null) {
          return;
        }
        this.#addToDrawLayer();
        this.#updateBbox(this.#drawOutlines.box);
        if (!this.isAttachedToDOM) {
          this.parent.add(this);
        }
      }
      setParent(parent) {
        let mustBeSelected = false;
        if (this.parent && !parent) {
          this._uiManager.removeShouldRescale(this);
          this.#cleanDrawLayer();
        } else if (parent) {
          this._uiManager.addShouldRescale(this);
          this.#addToDrawLayer(parent);
          mustBeSelected = !this.parent && this.div?.classList.contains("selectedEditor");
        }
        super.setParent(parent);
        if (mustBeSelected) {
          this.select();
        }
      }
      #cleanDrawLayer() {
        if (this._drawId === null || !this.parent) {
          return;
        }
        this.parent.drawLayer.remove(this._drawId);
        this._drawId = null;
        this._drawingOptions.reset();
      }
      #addToDrawLayer(parent = this.parent) {
        if (this._drawId !== null && this.parent === parent) {
          return;
        }
        if (this._drawId !== null) {
          this.parent.drawLayer.updateParent(this._drawId, parent.drawLayer);
          return;
        }
        this._drawingOptions.updateAll();
        this._drawId = this.#createDrawing(this.#drawOutlines, parent);
      }
      #convertToParentSpace([x, y, width, height]) {
        const {
          parentDimensions: [pW, pH],
          rotation
        } = this;
        switch (rotation) {
          case 90:
            return [y, 1 - x, width * (pH / pW), height * (pW / pH)];
          case 180:
            return [1 - x, 1 - y, width, height];
          case 270:
            return [1 - y, x, width * (pH / pW), height * (pW / pH)];
          default:
            return [x, y, width, height];
        }
      }
      #convertToDrawSpace() {
        const {
          x,
          y,
          width,
          height,
          parentDimensions: [pW, pH],
          rotation
        } = this;
        switch (rotation) {
          case 90:
            return [1 - y, x, width * (pW / pH), height * (pH / pW)];
          case 180:
            return [1 - x, 1 - y, width, height];
          case 270:
            return [y, 1 - x, width * (pW / pH), height * (pH / pW)];
          default:
            return [x, y, width, height];
        }
      }
      #updateBbox(bbox) {
        [this.x, this.y, this.width, this.height] = this.#convertToParentSpace(bbox);
        if (this.div) {
          this.fixAndSetPosition();
          this.setDims();
        }
        this._onResized();
      }
      #rotateBox() {
        const {
          x,
          y,
          width,
          height,
          rotation,
          parentRotation,
          parentDimensions: [pW, pH]
        } = this;
        switch ((rotation * 4 + parentRotation) / 90) {
          case 1:
            return [1 - y - height, x, height, width];
          case 2:
            return [1 - x - width, 1 - y - height, width, height];
          case 3:
            return [y, 1 - x - width, height, width];
          case 4:
            return [x, y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];
          case 5:
            return [1 - y, x, width * (pW / pH), height * (pH / pW)];
          case 6:
            return [1 - x - height * (pH / pW), 1 - y, height * (pH / pW), width * (pW / pH)];
          case 7:
            return [y - width * (pW / pH), 1 - x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];
          case 8:
            return [x - width, y - height, width, height];
          case 9:
            return [1 - y, x - width, height, width];
          case 10:
            return [1 - x, 1 - y, width, height];
          case 11:
            return [y - height, 1 - x, height, width];
          case 12:
            return [x - height * (pH / pW), y, height * (pH / pW), width * (pW / pH)];
          case 13:
            return [1 - y - width * (pW / pH), x - height * (pH / pW), width * (pW / pH), height * (pH / pW)];
          case 14:
            return [1 - x, 1 - y - width * (pW / pH), height * (pH / pW), width * (pW / pH)];
          case 15:
            return [y, 1 - x, width * (pW / pH), height * (pH / pW)];
          default:
            return [x, y, width, height];
        }
      }
      rotate() {
        if (!this.parent) {
          return;
        }
        this.parent.drawLayer.updateProperties(this._drawId, _DrawingEditor._mergeSVGProperties({
          bbox: this.#rotateBox()
        }, this.#drawOutlines.updateRotation((this.parentRotation - this.rotation + 360) % 360)));
      }
      onScaleChanging() {
        if (!this.parent) {
          return;
        }
        this.#updateBbox(this.#drawOutlines.updateParentDimensions(this.parentDimensions, this.parent.scale));
      }
      static onScaleChangingWhenDrawing() {
      }
      render() {
        if (this.div) {
          return this.div;
        }
        let baseX, baseY;
        if (this._isCopy) {
          baseX = this.x;
          baseY = this.y;
        }
        const div = super.render();
        div.classList.add("draw");
        const drawDiv = document.createElement("div");
        div.append(drawDiv);
        drawDiv.setAttribute("aria-hidden", "true");
        drawDiv.className = "internal";
        this.setDims();
        this._uiManager.addShouldRescale(this);
        this.disableEditing();
        if (this._isCopy) {
          this._moveAfterPaste(baseX, baseY);
        }
        return div;
      }
      static createDrawerInstance(_x, _y, _parentWidth, _parentHeight, _rotation) {
        unreachable("Not implemented");
      }
      static startDrawing(parent, uiManager, _isLTR, event) {
        const {
          target,
          offsetX: x,
          offsetY: y,
          pointerId,
          pointerType
        } = event;
        if (_DrawingEditor.#currentPointerType && _DrawingEditor.#currentPointerType !== pointerType) {
          return;
        }
        const {
          viewport: {
            rotation
          }
        } = parent;
        const {
          width: parentWidth,
          height: parentHeight
        } = target.getBoundingClientRect();
        const ac = _DrawingEditor.#currentDrawingAC = new AbortController();
        const signal = parent.combinedSignal(ac);
        _DrawingEditor.#currentPointerId ||= pointerId;
        _DrawingEditor.#currentPointerType ??= pointerType;
        window.addEventListener("pointerup", (e) => {
          if (_DrawingEditor.#currentPointerId === e.pointerId) {
            this._endDraw(e);
          } else {
            _DrawingEditor.#currentPointerIds?.delete(e.pointerId);
          }
        }, {
          signal
        });
        window.addEventListener("pointercancel", (e) => {
          if (_DrawingEditor.#currentPointerId === e.pointerId) {
            this._currentParent.endDrawingSession();
          } else {
            _DrawingEditor.#currentPointerIds?.delete(e.pointerId);
          }
        }, {
          signal
        });
        window.addEventListener("pointerdown", (e) => {
          if (_DrawingEditor.#currentPointerType !== e.pointerType) {
            return;
          }
          (_DrawingEditor.#currentPointerIds ||= /* @__PURE__ */ new Set()).add(e.pointerId);
          if (_DrawingEditor.#currentDraw.isCancellable()) {
            _DrawingEditor.#currentDraw.removeLastElement();
            if (_DrawingEditor.#currentDraw.isEmpty()) {
              this._currentParent.endDrawingSession(true);
            } else {
              this._endDraw(null);
            }
          }
        }, {
          capture: true,
          passive: false,
          signal
        });
        window.addEventListener("contextmenu", noContextMenu, {
          signal
        });
        target.addEventListener("pointermove", this._drawMove.bind(this), {
          signal
        });
        target.addEventListener("touchmove", (e) => {
          if (e.timeStamp === _DrawingEditor.#currentMoveTimestamp) {
            stopEvent(e);
          }
        }, {
          signal
        });
        parent.toggleDrawing();
        uiManager._editorUndoBar?.hide();
        if (_DrawingEditor.#currentDraw) {
          parent.drawLayer.updateProperties(this._currentDrawId, _DrawingEditor.#currentDraw.startNew(x, y, parentWidth, parentHeight, rotation));
          return;
        }
        uiManager.updateUIForDefaultProperties(this);
        _DrawingEditor.#currentDraw = this.createDrawerInstance(x, y, parentWidth, parentHeight, rotation);
        _DrawingEditor.#currentDrawingOptions = this.getDefaultDrawingOptions();
        this._currentParent = parent;
        ({
          id: this._currentDrawId
        } = parent.drawLayer.draw(this._mergeSVGProperties(_DrawingEditor.#currentDrawingOptions.toSVGProperties(), _DrawingEditor.#currentDraw.defaultSVGProperties), true, false));
      }
      static _drawMove(event) {
        _DrawingEditor.#currentMoveTimestamp = -1;
        if (!_DrawingEditor.#currentDraw) {
          return;
        }
        const {
          offsetX,
          offsetY,
          pointerId
        } = event;
        if (_DrawingEditor.#currentPointerId !== pointerId) {
          return;
        }
        if (_DrawingEditor.#currentPointerIds?.size >= 1) {
          this._endDraw(event);
          return;
        }
        this._currentParent.drawLayer.updateProperties(this._currentDrawId, _DrawingEditor.#currentDraw.add(offsetX, offsetY));
        _DrawingEditor.#currentMoveTimestamp = event.timeStamp;
        stopEvent(event);
      }
      static _cleanup(all) {
        if (all) {
          this._currentDrawId = -1;
          this._currentParent = null;
          _DrawingEditor.#currentDraw = null;
          _DrawingEditor.#currentDrawingOptions = null;
          _DrawingEditor.#currentPointerType = null;
          _DrawingEditor.#currentMoveTimestamp = NaN;
        }
        if (_DrawingEditor.#currentDrawingAC) {
          _DrawingEditor.#currentDrawingAC.abort();
          _DrawingEditor.#currentDrawingAC = null;
          _DrawingEditor.#currentPointerId = NaN;
          _DrawingEditor.#currentPointerIds = null;
        }
      }
      static _endDraw(event) {
        const parent = this._currentParent;
        if (!parent) {
          return;
        }
        parent.toggleDrawing(true);
        this._cleanup(false);
        if (event?.target === parent.div) {
          parent.drawLayer.updateProperties(this._currentDrawId, _DrawingEditor.#currentDraw.end(event.offsetX, event.offsetY));
        }
        if (this.supportMultipleDrawings) {
          const draw = _DrawingEditor.#currentDraw;
          const drawId = this._currentDrawId;
          const lastElement = draw.getLastElement();
          parent.addCommands({
            cmd: () => {
              parent.drawLayer.updateProperties(drawId, draw.setLastElement(lastElement));
            },
            undo: () => {
              parent.drawLayer.updateProperties(drawId, draw.removeLastElement());
            },
            mustExec: false,
            type: AnnotationEditorParamsType.DRAW_STEP
          });
          return;
        }
        this.endDrawing(false);
      }
      static endDrawing(isAborted) {
        const parent = this._currentParent;
        if (!parent) {
          return null;
        }
        parent.toggleDrawing(true);
        parent.cleanUndoStack(AnnotationEditorParamsType.DRAW_STEP);
        if (!_DrawingEditor.#currentDraw.isEmpty()) {
          const {
            pageDimensions: [pageWidth, pageHeight],
            scale
          } = parent;
          const editor = parent.createAndAddNewEditor({
            offsetX: 0,
            offsetY: 0
          }, false, {
            drawId: this._currentDrawId,
            drawOutlines: _DrawingEditor.#currentDraw.getOutlines(pageWidth * scale, pageHeight * scale, scale, this._INNER_MARGIN),
            drawingOptions: _DrawingEditor.#currentDrawingOptions,
            mustBeCommitted: !isAborted
          });
          this._cleanup(true);
          return editor;
        }
        parent.drawLayer.remove(this._currentDrawId);
        this._cleanup(true);
        return null;
      }
      createDrawingOptions(_data) {
      }
      static deserializeDraw(_pageX, _pageY, _pageWidth, _pageHeight, _innerWidth, _data) {
        unreachable("Not implemented");
      }
      static async deserialize(data, parent, uiManager) {
        const {
          rawDims: {
            pageWidth,
            pageHeight,
            pageX,
            pageY
          }
        } = parent.viewport;
        const drawOutlines = this.deserializeDraw(pageX, pageY, pageWidth, pageHeight, this._INNER_MARGIN, data);
        const editor = await super.deserialize(data, parent, uiManager);
        editor.createDrawingOptions(data);
        editor.#createDrawOutlines({
          drawOutlines
        });
        editor.#addToDrawLayer();
        editor.onScaleChanging();
        editor.rotate();
        return editor;
      }
      serializeDraw(isForCopying) {
        const [pageX, pageY] = this.pageTranslation;
        const [pageWidth, pageHeight] = this.pageDimensions;
        return this.#drawOutlines.serialize([pageX, pageY, pageWidth, pageHeight], isForCopying);
      }
      renderAnnotationElement(annotation) {
        annotation.updateEdited({
          rect: this.getPDFRect()
        });
        return null;
      }
      static canCreateNewEmptyEditor() {
        return false;
      }
    };
    InkDrawOutliner = class {
      #last = new Float64Array(6);
      #line;
      #lines;
      #rotation;
      #thickness;
      #points;
      #lastSVGPath = "";
      #lastIndex = 0;
      #outlines = new InkDrawOutline();
      #parentWidth;
      #parentHeight;
      constructor(x, y, parentWidth, parentHeight, rotation, thickness) {
        this.#parentWidth = parentWidth;
        this.#parentHeight = parentHeight;
        this.#rotation = rotation;
        this.#thickness = thickness;
        [x, y] = this.#normalizePoint(x, y);
        const line = this.#line = [NaN, NaN, NaN, NaN, x, y];
        this.#points = [x, y];
        this.#lines = [{
          line,
          points: this.#points
        }];
        this.#last.set(line, 0);
      }
      updateProperty(name, value) {
        if (name === "stroke-width") {
          this.#thickness = value;
        }
      }
      #normalizePoint(x, y) {
        return Outline._normalizePoint(x, y, this.#parentWidth, this.#parentHeight, this.#rotation);
      }
      isEmpty() {
        return !this.#lines || this.#lines.length === 0;
      }
      isCancellable() {
        return this.#points.length <= 10;
      }
      add(x, y) {
        [x, y] = this.#normalizePoint(x, y);
        const [x1, y1, x2, y2] = this.#last.subarray(2, 6);
        const diffX = x - x2;
        const diffY = y - y2;
        const d = Math.hypot(this.#parentWidth * diffX, this.#parentHeight * diffY);
        if (d <= 2) {
          return null;
        }
        this.#points.push(x, y);
        if (isNaN(x1)) {
          this.#last.set([x2, y2, x, y], 2);
          this.#line.push(NaN, NaN, NaN, NaN, x, y);
          return {
            path: {
              d: this.toSVGPath()
            }
          };
        }
        if (isNaN(this.#last[0])) {
          this.#line.splice(6, 6);
        }
        this.#last.set([x1, y1, x2, y2, x, y], 0);
        this.#line.push(...Outline.createBezierPoints(x1, y1, x2, y2, x, y));
        return {
          path: {
            d: this.toSVGPath()
          }
        };
      }
      end(x, y) {
        const change = this.add(x, y);
        if (change) {
          return change;
        }
        if (this.#points.length === 2) {
          return {
            path: {
              d: this.toSVGPath()
            }
          };
        }
        return null;
      }
      startNew(x, y, parentWidth, parentHeight, rotation) {
        this.#parentWidth = parentWidth;
        this.#parentHeight = parentHeight;
        this.#rotation = rotation;
        [x, y] = this.#normalizePoint(x, y);
        const line = this.#line = [NaN, NaN, NaN, NaN, x, y];
        this.#points = [x, y];
        const last2 = this.#lines.at(-1);
        if (last2) {
          last2.line = new Float32Array(last2.line);
          last2.points = new Float32Array(last2.points);
        }
        this.#lines.push({
          line,
          points: this.#points
        });
        this.#last.set(line, 0);
        this.#lastIndex = 0;
        this.toSVGPath();
        return null;
      }
      getLastElement() {
        return this.#lines.at(-1);
      }
      setLastElement(element) {
        if (!this.#lines) {
          return this.#outlines.setLastElement(element);
        }
        this.#lines.push(element);
        this.#line = element.line;
        this.#points = element.points;
        this.#lastIndex = 0;
        return {
          path: {
            d: this.toSVGPath()
          }
        };
      }
      removeLastElement() {
        if (!this.#lines) {
          return this.#outlines.removeLastElement();
        }
        this.#lines.pop();
        this.#lastSVGPath = "";
        for (let i = 0, ii = this.#lines.length; i < ii; i++) {
          const {
            line,
            points
          } = this.#lines[i];
          this.#line = line;
          this.#points = points;
          this.#lastIndex = 0;
          this.toSVGPath();
        }
        return {
          path: {
            d: this.#lastSVGPath
          }
        };
      }
      toSVGPath() {
        const firstX = Outline.svgRound(this.#line[4]);
        const firstY = Outline.svgRound(this.#line[5]);
        if (this.#points.length === 2) {
          this.#lastSVGPath = `${this.#lastSVGPath} M ${firstX} ${firstY} Z`;
          return this.#lastSVGPath;
        }
        if (this.#points.length <= 6) {
          const i = this.#lastSVGPath.lastIndexOf("M");
          this.#lastSVGPath = `${this.#lastSVGPath.slice(0, i)} M ${firstX} ${firstY}`;
          this.#lastIndex = 6;
        }
        if (this.#points.length === 4) {
          const secondX = Outline.svgRound(this.#line[10]);
          const secondY = Outline.svgRound(this.#line[11]);
          this.#lastSVGPath = `${this.#lastSVGPath} L ${secondX} ${secondY}`;
          this.#lastIndex = 12;
          return this.#lastSVGPath;
        }
        const buffer = [];
        if (this.#lastIndex === 0) {
          buffer.push(`M ${firstX} ${firstY}`);
          this.#lastIndex = 6;
        }
        for (let i = this.#lastIndex, ii = this.#line.length; i < ii; i += 6) {
          const [c1x, c1y, c2x, c2y, x, y] = this.#line.slice(i, i + 6).map(Outline.svgRound);
          buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);
        }
        this.#lastSVGPath += buffer.join(" ");
        this.#lastIndex = this.#line.length;
        return this.#lastSVGPath;
      }
      getOutlines(parentWidth, parentHeight, scale, innerMargin) {
        const last2 = this.#lines.at(-1);
        last2.line = new Float32Array(last2.line);
        last2.points = new Float32Array(last2.points);
        this.#outlines.build(this.#lines, parentWidth, parentHeight, scale, this.#rotation, this.#thickness, innerMargin);
        this.#last = null;
        this.#line = null;
        this.#lines = null;
        this.#lastSVGPath = null;
        return this.#outlines;
      }
      get defaultSVGProperties() {
        return {
          root: {
            viewBox: "0 0 10000 10000"
          },
          rootClass: {
            draw: true
          },
          bbox: [0, 0, 1, 1]
        };
      }
    };
    InkDrawOutline = class extends Outline {
      #bbox;
      #currentRotation = 0;
      #innerMargin;
      #lines;
      #parentWidth;
      #parentHeight;
      #parentScale;
      #rotation;
      #thickness;
      build(lines, parentWidth, parentHeight, parentScale, rotation, thickness, innerMargin) {
        this.#parentWidth = parentWidth;
        this.#parentHeight = parentHeight;
        this.#parentScale = parentScale;
        this.#rotation = rotation;
        this.#thickness = thickness;
        this.#innerMargin = innerMargin ?? 0;
        this.#lines = lines;
        this.#computeBbox();
      }
      get thickness() {
        return this.#thickness;
      }
      setLastElement(element) {
        this.#lines.push(element);
        return {
          path: {
            d: this.toSVGPath()
          }
        };
      }
      removeLastElement() {
        this.#lines.pop();
        return {
          path: {
            d: this.toSVGPath()
          }
        };
      }
      toSVGPath() {
        const buffer = [];
        for (const {
          line
        } of this.#lines) {
          buffer.push(`M${Outline.svgRound(line[4])} ${Outline.svgRound(line[5])}`);
          if (line.length === 6) {
            buffer.push("Z");
            continue;
          }
          if (line.length === 12 && isNaN(line[6])) {
            buffer.push(`L${Outline.svgRound(line[10])} ${Outline.svgRound(line[11])}`);
            continue;
          }
          for (let i = 6, ii = line.length; i < ii; i += 6) {
            const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6).map(Outline.svgRound);
            buffer.push(`C${c1x} ${c1y} ${c2x} ${c2y} ${x} ${y}`);
          }
        }
        return buffer.join("");
      }
      serialize([pageX, pageY, pageWidth, pageHeight], isForCopying) {
        const serializedLines = [];
        const serializedPoints = [];
        const [x, y, width, height] = this.#getBBoxWithNoMargin();
        let tx, ty, sx, sy, x1, y1, x2, y2, rescaleFn;
        switch (this.#rotation) {
          case 0:
            rescaleFn = Outline._rescale;
            tx = pageX;
            ty = pageY + pageHeight;
            sx = pageWidth;
            sy = -pageHeight;
            x1 = pageX + x * pageWidth;
            y1 = pageY + (1 - y - height) * pageHeight;
            x2 = pageX + (x + width) * pageWidth;
            y2 = pageY + (1 - y) * pageHeight;
            break;
          case 90:
            rescaleFn = Outline._rescaleAndSwap;
            tx = pageX;
            ty = pageY;
            sx = pageWidth;
            sy = pageHeight;
            x1 = pageX + y * pageWidth;
            y1 = pageY + x * pageHeight;
            x2 = pageX + (y + height) * pageWidth;
            y2 = pageY + (x + width) * pageHeight;
            break;
          case 180:
            rescaleFn = Outline._rescale;
            tx = pageX + pageWidth;
            ty = pageY;
            sx = -pageWidth;
            sy = pageHeight;
            x1 = pageX + (1 - x - width) * pageWidth;
            y1 = pageY + y * pageHeight;
            x2 = pageX + (1 - x) * pageWidth;
            y2 = pageY + (y + height) * pageHeight;
            break;
          case 270:
            rescaleFn = Outline._rescaleAndSwap;
            tx = pageX + pageWidth;
            ty = pageY + pageHeight;
            sx = -pageWidth;
            sy = -pageHeight;
            x1 = pageX + (1 - y - height) * pageWidth;
            y1 = pageY + (1 - x - width) * pageHeight;
            x2 = pageX + (1 - y) * pageWidth;
            y2 = pageY + (1 - x) * pageHeight;
            break;
        }
        for (const {
          line,
          points
        } of this.#lines) {
          serializedLines.push(rescaleFn(line, tx, ty, sx, sy, isForCopying ? new Array(line.length) : null));
          serializedPoints.push(rescaleFn(points, tx, ty, sx, sy, isForCopying ? new Array(points.length) : null));
        }
        return {
          lines: serializedLines,
          points: serializedPoints,
          rect: [x1, y1, x2, y2]
        };
      }
      static deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, {
        paths: {
          lines,
          points
        },
        rotation,
        thickness
      }) {
        const newLines = [];
        let tx, ty, sx, sy, rescaleFn;
        switch (rotation) {
          case 0:
            rescaleFn = Outline._rescale;
            tx = -pageX / pageWidth;
            ty = pageY / pageHeight + 1;
            sx = 1 / pageWidth;
            sy = -1 / pageHeight;
            break;
          case 90:
            rescaleFn = Outline._rescaleAndSwap;
            tx = -pageY / pageHeight;
            ty = -pageX / pageWidth;
            sx = 1 / pageHeight;
            sy = 1 / pageWidth;
            break;
          case 180:
            rescaleFn = Outline._rescale;
            tx = pageX / pageWidth + 1;
            ty = -pageY / pageHeight;
            sx = -1 / pageWidth;
            sy = 1 / pageHeight;
            break;
          case 270:
            rescaleFn = Outline._rescaleAndSwap;
            tx = pageY / pageHeight + 1;
            ty = pageX / pageWidth + 1;
            sx = -1 / pageHeight;
            sy = -1 / pageWidth;
            break;
        }
        if (!lines) {
          lines = [];
          for (const point of points) {
            const len = point.length;
            if (len === 2) {
              lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1]]));
              continue;
            }
            if (len === 4) {
              lines.push(new Float32Array([NaN, NaN, NaN, NaN, point[0], point[1], NaN, NaN, NaN, NaN, point[2], point[3]]));
              continue;
            }
            const line = new Float32Array(3 * (len - 2));
            lines.push(line);
            let [x1, y1, x2, y2] = point.subarray(0, 4);
            line.set([NaN, NaN, NaN, NaN, x1, y1], 0);
            for (let i = 4; i < len; i += 2) {
              const x = point[i];
              const y = point[i + 1];
              line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);
              [x1, y1, x2, y2] = [x2, y2, x, y];
            }
          }
        }
        for (let i = 0, ii = lines.length; i < ii; i++) {
          newLines.push({
            line: rescaleFn(lines[i].map((x) => x ?? NaN), tx, ty, sx, sy),
            points: rescaleFn(points[i].map((x) => x ?? NaN), tx, ty, sx, sy)
          });
        }
        const outlines = new this.prototype.constructor();
        outlines.build(newLines, pageWidth, pageHeight, 1, rotation, thickness, innerMargin);
        return outlines;
      }
      #getMarginComponents(thickness = this.#thickness) {
        const margin = this.#innerMargin + thickness / 2 * this.#parentScale;
        return this.#rotation % 180 === 0 ? [margin / this.#parentWidth, margin / this.#parentHeight] : [margin / this.#parentHeight, margin / this.#parentWidth];
      }
      #getBBoxWithNoMargin() {
        const [x, y, width, height] = this.#bbox;
        const [marginX, marginY] = this.#getMarginComponents(0);
        return [x + marginX, y + marginY, width - 2 * marginX, height - 2 * marginY];
      }
      #computeBbox() {
        const bbox = this.#bbox = new Float32Array([Infinity, Infinity, -Infinity, -Infinity]);
        for (const {
          line
        } of this.#lines) {
          if (line.length <= 12) {
            for (let i = 4, ii = line.length; i < ii; i += 6) {
              Util.pointBoundingBox(line[i], line[i + 1], bbox);
            }
            continue;
          }
          let lastX = line[4], lastY = line[5];
          for (let i = 6, ii = line.length; i < ii; i += 6) {
            const [c1x, c1y, c2x, c2y, x, y] = line.subarray(i, i + 6);
            Util.bezierBoundingBox(lastX, lastY, c1x, c1y, c2x, c2y, x, y, bbox);
            lastX = x;
            lastY = y;
          }
        }
        const [marginX, marginY] = this.#getMarginComponents();
        bbox[0] = MathClamp(bbox[0] - marginX, 0, 1);
        bbox[1] = MathClamp(bbox[1] - marginY, 0, 1);
        bbox[2] = MathClamp(bbox[2] + marginX, 0, 1);
        bbox[3] = MathClamp(bbox[3] + marginY, 0, 1);
        bbox[2] -= bbox[0];
        bbox[3] -= bbox[1];
      }
      get box() {
        return this.#bbox;
      }
      updateProperty(name, value) {
        if (name === "stroke-width") {
          return this.#updateThickness(value);
        }
        return null;
      }
      #updateThickness(thickness) {
        const [oldMarginX, oldMarginY] = this.#getMarginComponents();
        this.#thickness = thickness;
        const [newMarginX, newMarginY] = this.#getMarginComponents();
        const [diffMarginX, diffMarginY] = [newMarginX - oldMarginX, newMarginY - oldMarginY];
        const bbox = this.#bbox;
        bbox[0] -= diffMarginX;
        bbox[1] -= diffMarginY;
        bbox[2] += 2 * diffMarginX;
        bbox[3] += 2 * diffMarginY;
        return bbox;
      }
      updateParentDimensions([width, height], scale) {
        const [oldMarginX, oldMarginY] = this.#getMarginComponents();
        this.#parentWidth = width;
        this.#parentHeight = height;
        this.#parentScale = scale;
        const [newMarginX, newMarginY] = this.#getMarginComponents();
        const diffMarginX = newMarginX - oldMarginX;
        const diffMarginY = newMarginY - oldMarginY;
        const bbox = this.#bbox;
        bbox[0] -= diffMarginX;
        bbox[1] -= diffMarginY;
        bbox[2] += 2 * diffMarginX;
        bbox[3] += 2 * diffMarginY;
        return bbox;
      }
      updateRotation(rotation) {
        this.#currentRotation = rotation;
        return {
          path: {
            transform: this.rotationTransform
          }
        };
      }
      get viewBox() {
        return this.#bbox.map(Outline.svgRound).join(" ");
      }
      get defaultProperties() {
        const [x, y] = this.#bbox;
        return {
          root: {
            viewBox: this.viewBox
          },
          path: {
            "transform-origin": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`
          }
        };
      }
      get rotationTransform() {
        const [, , width, height] = this.#bbox;
        let a = 0, b = 0, c = 0, d = 0, e = 0, f = 0;
        switch (this.#currentRotation) {
          case 90:
            b = height / width;
            c = -width / height;
            e = width;
            break;
          case 180:
            a = -1;
            d = -1;
            e = width;
            f = height;
            break;
          case 270:
            b = -height / width;
            c = width / height;
            f = height;
            break;
          default:
            return "";
        }
        return `matrix(${a} ${b} ${c} ${d} ${Outline.svgRound(e)} ${Outline.svgRound(f)})`;
      }
      getPathResizingSVGProperties([newX, newY, newWidth, newHeight]) {
        const [marginX, marginY] = this.#getMarginComponents();
        const [x, y, width, height] = this.#bbox;
        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
          const tx = newX + newWidth / 2 - (x + width / 2);
          const ty = newY + newHeight / 2 - (y + height / 2);
          return {
            path: {
              "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
              transform: `${this.rotationTransform} translate(${tx} ${ty})`
            }
          };
        }
        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
        const s2x = width / newWidth;
        const s2y = height / newHeight;
        return {
          path: {
            "transform-origin": `${Outline.svgRound(x)} ${Outline.svgRound(y)}`,
            transform: `${this.rotationTransform} scale(${s2x} ${s2y}) translate(${Outline.svgRound(marginX)} ${Outline.svgRound(marginY)}) scale(${s1x} ${s1y}) translate(${Outline.svgRound(-marginX)} ${Outline.svgRound(-marginY)})`
          }
        };
      }
      getPathResizedSVGProperties([newX, newY, newWidth, newHeight]) {
        const [marginX, marginY] = this.#getMarginComponents();
        const bbox = this.#bbox;
        const [x, y, width, height] = bbox;
        bbox[0] = newX;
        bbox[1] = newY;
        bbox[2] = newWidth;
        bbox[3] = newHeight;
        if (Math.abs(width - marginX) <= Outline.PRECISION || Math.abs(height - marginY) <= Outline.PRECISION) {
          const tx2 = newX + newWidth / 2 - (x + width / 2);
          const ty2 = newY + newHeight / 2 - (y + height / 2);
          for (const {
            line,
            points
          } of this.#lines) {
            Outline._translate(line, tx2, ty2, line);
            Outline._translate(points, tx2, ty2, points);
          }
          return {
            root: {
              viewBox: this.viewBox
            },
            path: {
              "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
              transform: this.rotationTransform || null,
              d: this.toSVGPath()
            }
          };
        }
        const s1x = (newWidth - 2 * marginX) / (width - 2 * marginX);
        const s1y = (newHeight - 2 * marginY) / (height - 2 * marginY);
        const tx = -s1x * (x + marginX) + newX + marginX;
        const ty = -s1y * (y + marginY) + newY + marginY;
        if (s1x !== 1 || s1y !== 1 || tx !== 0 || ty !== 0) {
          for (const {
            line,
            points
          } of this.#lines) {
            Outline._rescale(line, tx, ty, s1x, s1y, line);
            Outline._rescale(points, tx, ty, s1x, s1y, points);
          }
        }
        return {
          root: {
            viewBox: this.viewBox
          },
          path: {
            "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`,
            transform: this.rotationTransform || null,
            d: this.toSVGPath()
          }
        };
      }
      getPathTranslatedSVGProperties([newX, newY], parentDimensions) {
        const [newParentWidth, newParentHeight] = parentDimensions;
        const bbox = this.#bbox;
        const tx = newX - bbox[0];
        const ty = newY - bbox[1];
        if (this.#parentWidth === newParentWidth && this.#parentHeight === newParentHeight) {
          for (const {
            line,
            points
          } of this.#lines) {
            Outline._translate(line, tx, ty, line);
            Outline._translate(points, tx, ty, points);
          }
        } else {
          const sx = this.#parentWidth / newParentWidth;
          const sy = this.#parentHeight / newParentHeight;
          this.#parentWidth = newParentWidth;
          this.#parentHeight = newParentHeight;
          for (const {
            line,
            points
          } of this.#lines) {
            Outline._rescale(line, tx, ty, sx, sy, line);
            Outline._rescale(points, tx, ty, sx, sy, points);
          }
          bbox[2] *= sx;
          bbox[3] *= sy;
        }
        bbox[0] = newX;
        bbox[1] = newY;
        return {
          root: {
            viewBox: this.viewBox
          },
          path: {
            d: this.toSVGPath(),
            "transform-origin": `${Outline.svgRound(newX)} ${Outline.svgRound(newY)}`
          }
        };
      }
      get defaultSVGProperties() {
        const bbox = this.#bbox;
        return {
          root: {
            viewBox: this.viewBox
          },
          rootClass: {
            draw: true
          },
          path: {
            d: this.toSVGPath(),
            "transform-origin": `${Outline.svgRound(bbox[0])} ${Outline.svgRound(bbox[1])}`,
            transform: this.rotationTransform || null
          },
          bbox
        };
      }
    };
    InkDrawingOptions = class _InkDrawingOptions extends DrawingOptions {
      constructor(viewerParameters) {
        super();
        this._viewParameters = viewerParameters;
        super.updateProperties({
          fill: "none",
          stroke: AnnotationEditor._defaultLineColor,
          "stroke-opacity": 1,
          "stroke-width": 1,
          "stroke-linecap": "round",
          "stroke-linejoin": "round",
          "stroke-miterlimit": 10
        });
      }
      updateSVGProperty(name, value) {
        if (name === "stroke-width") {
          value ??= this["stroke-width"];
          value *= this._viewParameters.realScale;
        }
        super.updateSVGProperty(name, value);
      }
      clone() {
        const clone2 = new _InkDrawingOptions(this._viewParameters);
        clone2.updateAll(this);
        return clone2;
      }
    };
    InkEditor = class _InkEditor extends DrawingEditor {
      static _type = "ink";
      static _editorType = AnnotationEditorType.INK;
      static _defaultDrawingOptions = null;
      constructor(params) {
        super({
          ...params,
          name: "inkEditor"
        });
        this._willKeepAspectRatio = true;
        this.defaultL10nId = "pdfjs-editor-ink-editor";
      }
      static initialize(l10n, uiManager) {
        AnnotationEditor.initialize(l10n, uiManager);
        this._defaultDrawingOptions = new InkDrawingOptions(uiManager.viewParameters);
      }
      static getDefaultDrawingOptions(options) {
        const clone2 = this._defaultDrawingOptions.clone();
        clone2.updateProperties(options);
        return clone2;
      }
      static get supportMultipleDrawings() {
        return true;
      }
      static get typesMap() {
        return shadow(this, "typesMap", /* @__PURE__ */ new Map([[AnnotationEditorParamsType.INK_THICKNESS, "stroke-width"], [AnnotationEditorParamsType.INK_COLOR, "stroke"], [AnnotationEditorParamsType.INK_OPACITY, "stroke-opacity"]]));
      }
      static createDrawerInstance(x, y, parentWidth, parentHeight, rotation) {
        return new InkDrawOutliner(x, y, parentWidth, parentHeight, rotation, this._defaultDrawingOptions["stroke-width"]);
      }
      static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
      }
      static async deserialize(data, parent, uiManager) {
        let initialData = null;
        if (data instanceof InkAnnotationElement) {
          const {
            data: {
              inkLists,
              rect,
              rotation,
              id,
              color,
              opacity,
              borderStyle: {
                rawWidth: thickness
              },
              popupRef,
              richText,
              contentsObj,
              creationDate,
              modificationDate
            },
            parent: {
              page: {
                pageNumber
              }
            }
          } = data;
          initialData = data = {
            annotationType: AnnotationEditorType.INK,
            color: Array.from(color),
            thickness,
            opacity,
            paths: {
              points: inkLists
            },
            boxes: null,
            pageIndex: pageNumber - 1,
            rect: rect.slice(0),
            rotation,
            annotationElementId: id,
            id,
            deleted: false,
            popupRef,
            richText,
            comment: contentsObj?.str || null,
            creationDate,
            modificationDate
          };
        }
        const editor = await super.deserialize(data, parent, uiManager);
        editor._initialData = initialData;
        if (data.comment) {
          editor.setCommentData(data);
        }
        return editor;
      }
      get toolbarButtons() {
        this._colorPicker ||= new BasicColorPicker(this);
        return [["colorPicker", this._colorPicker]];
      }
      get colorType() {
        return AnnotationEditorParamsType.INK_COLOR;
      }
      get color() {
        return this._drawingOptions.stroke;
      }
      get opacity() {
        return this._drawingOptions["stroke-opacity"];
      }
      onScaleChanging() {
        if (!this.parent) {
          return;
        }
        super.onScaleChanging();
        const {
          _drawId,
          _drawingOptions,
          parent
        } = this;
        _drawingOptions.updateSVGProperty("stroke-width");
        parent.drawLayer.updateProperties(_drawId, _drawingOptions.toSVGProperties());
      }
      static onScaleChangingWhenDrawing() {
        const parent = this._currentParent;
        if (!parent) {
          return;
        }
        super.onScaleChangingWhenDrawing();
        this._defaultDrawingOptions.updateSVGProperty("stroke-width");
        parent.drawLayer.updateProperties(this._currentDrawId, this._defaultDrawingOptions.toSVGProperties());
      }
      createDrawingOptions({
        color,
        thickness,
        opacity
      }) {
        this._drawingOptions = _InkEditor.getDefaultDrawingOptions({
          stroke: Util.makeHexColor(...color),
          "stroke-width": thickness,
          "stroke-opacity": opacity
        });
      }
      serialize(isForCopying = false) {
        if (this.isEmpty()) {
          return null;
        }
        if (this.deleted) {
          return this.serializeDeleted();
        }
        const {
          lines,
          points
        } = this.serializeDraw(isForCopying);
        const {
          _drawingOptions: {
            stroke,
            "stroke-opacity": opacity,
            "stroke-width": thickness
          }
        } = this;
        const serialized = Object.assign(super.serialize(isForCopying), {
          color: AnnotationEditor._colorManager.convert(stroke),
          opacity,
          thickness,
          paths: {
            lines,
            points
          }
        });
        this.addComment(serialized);
        if (isForCopying) {
          serialized.isCopy = true;
          return serialized;
        }
        if (this.annotationElementId && !this.#hasElementChanged(serialized)) {
          return null;
        }
        serialized.id = this.annotationElementId;
        return serialized;
      }
      #hasElementChanged(serialized) {
        const {
          color,
          thickness,
          opacity,
          pageIndex
        } = this._initialData;
        return this.hasEditedComment || this._hasBeenMoved || this._hasBeenResized || serialized.color.some((c, i) => c !== color[i]) || serialized.thickness !== thickness || serialized.opacity !== opacity || serialized.pageIndex !== pageIndex;
      }
      renderAnnotationElement(annotation) {
        if (this.deleted) {
          annotation.hide();
          return null;
        }
        const {
          points,
          rect
        } = this.serializeDraw(false);
        annotation.updateEdited({
          rect,
          thickness: this._drawingOptions["stroke-width"],
          points,
          popup: this.comment
        });
        return null;
      }
    };
    ContourDrawOutline = class extends InkDrawOutline {
      toSVGPath() {
        let path = super.toSVGPath();
        if (!path.endsWith("Z")) {
          path += "Z";
        }
        return path;
      }
    };
    BASE_HEADER_LENGTH = 8;
    POINTS_PROPERTIES_NUMBER = 3;
    SignatureExtractor = class {
      static #PARAMETERS = {
        maxDim: 512,
        sigmaSFactor: 0.02,
        sigmaR: 25,
        kernelSize: 16
      };
      static #neighborIndexToId(i0, j0, i, j) {
        i -= i0;
        j -= j0;
        if (i === 0) {
          return j > 0 ? 0 : 4;
        }
        if (i === 1) {
          return j + 6;
        }
        return 2 - j;
      }
      static #neighborIdToIndex = new Int32Array([0, 1, -1, 1, -1, 0, -1, -1, 0, -1, 1, -1, 1, 0, 1, 1]);
      static #clockwiseNonZero(buf, width, i0, j0, i, j, offset) {
        const id = this.#neighborIndexToId(i0, j0, i, j);
        for (let k = 0; k < 8; k++) {
          const kk = (-k + id - offset + 16) % 8;
          const shiftI = this.#neighborIdToIndex[2 * kk];
          const shiftJ = this.#neighborIdToIndex[2 * kk + 1];
          if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {
            return kk;
          }
        }
        return -1;
      }
      static #counterClockwiseNonZero(buf, width, i0, j0, i, j, offset) {
        const id = this.#neighborIndexToId(i0, j0, i, j);
        for (let k = 0; k < 8; k++) {
          const kk = (k + id + offset + 16) % 8;
          const shiftI = this.#neighborIdToIndex[2 * kk];
          const shiftJ = this.#neighborIdToIndex[2 * kk + 1];
          if (buf[(i0 + shiftI) * width + (j0 + shiftJ)] !== 0) {
            return kk;
          }
        }
        return -1;
      }
      static #findContours(buf, width, height, threshold) {
        const N = buf.length;
        const types = new Int32Array(N);
        for (let i = 0; i < N; i++) {
          types[i] = buf[i] <= threshold ? 1 : 0;
        }
        for (let i = 1; i < height - 1; i++) {
          types[i * width] = types[i * width + width - 1] = 0;
        }
        for (let i = 0; i < width; i++) {
          types[i] = types[width * height - 1 - i] = 0;
        }
        let nbd = 1;
        let lnbd;
        const contours = [];
        for (let i = 1; i < height - 1; i++) {
          lnbd = 1;
          for (let j = 1; j < width - 1; j++) {
            const ij = i * width + j;
            const pix = types[ij];
            if (pix === 0) {
              continue;
            }
            let i2 = i;
            let j2 = j;
            if (pix === 1 && types[ij - 1] === 0) {
              nbd += 1;
              j2 -= 1;
            } else if (pix >= 1 && types[ij + 1] === 0) {
              nbd += 1;
              j2 += 1;
              if (pix > 1) {
                lnbd = pix;
              }
            } else {
              if (pix !== 1) {
                lnbd = Math.abs(pix);
              }
              continue;
            }
            const points = [j, i];
            const isHole = j2 === j + 1;
            const contour = {
              isHole,
              points,
              id: nbd,
              parent: 0
            };
            contours.push(contour);
            let contour0;
            for (const c of contours) {
              if (c.id === lnbd) {
                contour0 = c;
                break;
              }
            }
            if (!contour0) {
              contour.parent = isHole ? lnbd : 0;
            } else if (contour0.isHole) {
              contour.parent = isHole ? contour0.parent : lnbd;
            } else {
              contour.parent = isHole ? lnbd : contour0.parent;
            }
            const k = this.#clockwiseNonZero(types, width, i, j, i2, j2, 0);
            if (k === -1) {
              types[ij] = -nbd;
              if (types[ij] !== 1) {
                lnbd = Math.abs(types[ij]);
              }
              continue;
            }
            let shiftI = this.#neighborIdToIndex[2 * k];
            let shiftJ = this.#neighborIdToIndex[2 * k + 1];
            const i1 = i + shiftI;
            const j1 = j + shiftJ;
            i2 = i1;
            j2 = j1;
            let i3 = i;
            let j3 = j;
            while (true) {
              const kk = this.#counterClockwiseNonZero(types, width, i3, j3, i2, j2, 1);
              shiftI = this.#neighborIdToIndex[2 * kk];
              shiftJ = this.#neighborIdToIndex[2 * kk + 1];
              const i4 = i3 + shiftI;
              const j4 = j3 + shiftJ;
              points.push(j4, i4);
              const ij3 = i3 * width + j3;
              if (types[ij3 + 1] === 0) {
                types[ij3] = -nbd;
              } else if (types[ij3] === 1) {
                types[ij3] = nbd;
              }
              if (i4 === i && j4 === j && i3 === i1 && j3 === j1) {
                if (types[ij] !== 1) {
                  lnbd = Math.abs(types[ij]);
                }
                break;
              } else {
                i2 = i3;
                j2 = j3;
                i3 = i4;
                j3 = j4;
              }
            }
          }
        }
        return contours;
      }
      static #douglasPeuckerHelper(points, start, end, output) {
        if (end - start <= 4) {
          for (let i = start; i < end - 2; i += 2) {
            output.push(points[i], points[i + 1]);
          }
          return;
        }
        const ax = points[start];
        const ay = points[start + 1];
        const abx = points[end - 4] - ax;
        const aby = points[end - 3] - ay;
        const dist = Math.hypot(abx, aby);
        const nabx = abx / dist;
        const naby = aby / dist;
        const aa = nabx * ay - naby * ax;
        const m = aby / abx;
        const invS = 1 / dist;
        const phi = Math.atan(m);
        const cosPhi = Math.cos(phi);
        const sinPhi = Math.sin(phi);
        const tmax = invS * (Math.abs(cosPhi) + Math.abs(sinPhi));
        const poly = invS * (1 - tmax + tmax ** 2);
        const partialPhi = Math.max(Math.atan(Math.abs(sinPhi + cosPhi) * poly), Math.atan(Math.abs(sinPhi - cosPhi) * poly));
        let dmax = 0;
        let index = start;
        for (let i = start + 2; i < end - 2; i += 2) {
          const d = Math.abs(aa - nabx * points[i + 1] + naby * points[i]);
          if (d > dmax) {
            index = i;
            dmax = d;
          }
        }
        if (dmax > (dist * partialPhi) ** 2) {
          this.#douglasPeuckerHelper(points, start, index + 2, output);
          this.#douglasPeuckerHelper(points, index, end, output);
        } else {
          output.push(ax, ay);
        }
      }
      static #douglasPeucker(points) {
        const output = [];
        const len = points.length;
        this.#douglasPeuckerHelper(points, 0, len, output);
        output.push(points[len - 2], points[len - 1]);
        return output.length <= 4 ? null : output;
      }
      static #bilateralFilter(buf, width, height, sigmaS, sigmaR, kernelSize) {
        const kernel = new Float32Array(kernelSize ** 2);
        const sigmaS2 = -2 * sigmaS ** 2;
        const halfSize = kernelSize >> 1;
        for (let i = 0; i < kernelSize; i++) {
          const x = (i - halfSize) ** 2;
          for (let j = 0; j < kernelSize; j++) {
            kernel[i * kernelSize + j] = Math.exp((x + (j - halfSize) ** 2) / sigmaS2);
          }
        }
        const rangeValues = new Float32Array(256);
        const sigmaR2 = -2 * sigmaR ** 2;
        for (let i = 0; i < 256; i++) {
          rangeValues[i] = Math.exp(i ** 2 / sigmaR2);
        }
        const N = buf.length;
        const out = new Uint8Array(N);
        const histogram = new Uint32Array(256);
        for (let i = 0; i < height; i++) {
          for (let j = 0; j < width; j++) {
            const ij = i * width + j;
            const center = buf[ij];
            let sum = 0;
            let norm = 0;
            for (let k = 0; k < kernelSize; k++) {
              const y = i + k - halfSize;
              if (y < 0 || y >= height) {
                continue;
              }
              for (let l2 = 0; l2 < kernelSize; l2++) {
                const x = j + l2 - halfSize;
                if (x < 0 || x >= width) {
                  continue;
                }
                const neighbour = buf[y * width + x];
                const w = kernel[k * kernelSize + l2] * rangeValues[Math.abs(neighbour - center)];
                sum += neighbour * w;
                norm += w;
              }
            }
            const pix = out[ij] = Math.round(sum / norm);
            histogram[pix]++;
          }
        }
        return [out, histogram];
      }
      static #getHistogram(buf) {
        const histogram = new Uint32Array(256);
        for (const g of buf) {
          histogram[g]++;
        }
        return histogram;
      }
      static #toUint8(buf) {
        const N = buf.length;
        const out = new Uint8ClampedArray(N >> 2);
        let max2 = -Infinity;
        let min2 = Infinity;
        for (let i = 0, ii = out.length; i < ii; i++) {
          const pix = out[i] = buf[i << 2];
          max2 = Math.max(max2, pix);
          min2 = Math.min(min2, pix);
        }
        const ratio = 255 / (max2 - min2);
        for (let i = 0, ii = out.length; i < ii; i++) {
          out[i] = (out[i] - min2) * ratio;
        }
        return out;
      }
      static #guessThreshold(histogram) {
        let i;
        let M = -Infinity;
        let L = -Infinity;
        const min2 = histogram.findIndex((v) => v !== 0);
        let pos = min2;
        let spos = min2;
        for (i = min2; i < 256; i++) {
          const v = histogram[i];
          if (v > M) {
            if (i - pos > L) {
              L = i - pos;
              spos = i - 1;
            }
            M = v;
            pos = i;
          }
        }
        for (i = spos - 1; i >= 0; i--) {
          if (histogram[i] > histogram[i + 1]) {
            break;
          }
        }
        return i;
      }
      static #getGrayPixels(bitmap) {
        const originalBitmap = bitmap;
        const {
          width,
          height
        } = bitmap;
        const {
          maxDim
        } = this.#PARAMETERS;
        let newWidth = width;
        let newHeight = height;
        if (width > maxDim || height > maxDim) {
          let prevWidth = width;
          let prevHeight = height;
          let steps = Math.log2(Math.max(width, height) / maxDim);
          const isteps = Math.floor(steps);
          steps = steps === isteps ? isteps - 1 : isteps;
          for (let i = 0; i < steps; i++) {
            newWidth = Math.ceil(prevWidth / 2);
            newHeight = Math.ceil(prevHeight / 2);
            const offscreen2 = new OffscreenCanvas(newWidth, newHeight);
            const ctx2 = offscreen2.getContext("2d");
            ctx2.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
            prevWidth = newWidth;
            prevHeight = newHeight;
            if (bitmap !== originalBitmap) {
              bitmap.close();
            }
            bitmap = offscreen2.transferToImageBitmap();
          }
          const ratio = Math.min(maxDim / newWidth, maxDim / newHeight);
          newWidth = Math.round(newWidth * ratio);
          newHeight = Math.round(newHeight * ratio);
        }
        const offscreen = new OffscreenCanvas(newWidth, newHeight);
        const ctx = offscreen.getContext("2d", {
          willReadFrequently: true
        });
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, newWidth, newHeight);
        ctx.filter = "grayscale(1)";
        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, newWidth, newHeight);
        const grayImage = ctx.getImageData(0, 0, newWidth, newHeight).data;
        const uint8Buf = this.#toUint8(grayImage);
        return [uint8Buf, newWidth, newHeight];
      }
      static extractContoursFromText(text, {
        fontFamily,
        fontStyle,
        fontWeight
      }, pageWidth, pageHeight, rotation, innerMargin) {
        let canvas = new OffscreenCanvas(1, 1);
        let ctx = canvas.getContext("2d", {
          alpha: false
        });
        const fontSize = 200;
        const font = ctx.font = `${fontStyle} ${fontWeight} ${fontSize}px ${fontFamily}`;
        const {
          actualBoundingBoxLeft,
          actualBoundingBoxRight,
          actualBoundingBoxAscent,
          actualBoundingBoxDescent,
          fontBoundingBoxAscent,
          fontBoundingBoxDescent,
          width
        } = ctx.measureText(text);
        const SCALE = 1.5;
        const canvasWidth = Math.ceil(Math.max(Math.abs(actualBoundingBoxLeft) + Math.abs(actualBoundingBoxRight) || 0, width) * SCALE);
        const canvasHeight = Math.ceil(Math.max(Math.abs(actualBoundingBoxAscent) + Math.abs(actualBoundingBoxDescent) || fontSize, Math.abs(fontBoundingBoxAscent) + Math.abs(fontBoundingBoxDescent) || fontSize) * SCALE);
        canvas = new OffscreenCanvas(canvasWidth, canvasHeight);
        ctx = canvas.getContext("2d", {
          alpha: true,
          willReadFrequently: true
        });
        ctx.font = font;
        ctx.filter = "grayscale(1)";
        ctx.fillStyle = "white";
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);
        ctx.fillStyle = "black";
        ctx.fillText(text, canvasWidth * (SCALE - 1) / 2, canvasHeight * (3 - SCALE) / 2);
        const uint8Buf = this.#toUint8(ctx.getImageData(0, 0, canvasWidth, canvasHeight).data);
        const histogram = this.#getHistogram(uint8Buf);
        const threshold = this.#guessThreshold(histogram);
        const contourList = this.#findContours(uint8Buf, canvasWidth, canvasHeight, threshold);
        return this.processDrawnLines({
          lines: {
            curves: contourList,
            width: canvasWidth,
            height: canvasHeight
          },
          pageWidth,
          pageHeight,
          rotation,
          innerMargin,
          mustSmooth: true,
          areContours: true
        });
      }
      static process(bitmap, pageWidth, pageHeight, rotation, innerMargin) {
        const [uint8Buf, width, height] = this.#getGrayPixels(bitmap);
        const [buffer, histogram] = this.#bilateralFilter(uint8Buf, width, height, Math.hypot(width, height) * this.#PARAMETERS.sigmaSFactor, this.#PARAMETERS.sigmaR, this.#PARAMETERS.kernelSize);
        const threshold = this.#guessThreshold(histogram);
        const contourList = this.#findContours(buffer, width, height, threshold);
        return this.processDrawnLines({
          lines: {
            curves: contourList,
            width,
            height
          },
          pageWidth,
          pageHeight,
          rotation,
          innerMargin,
          mustSmooth: true,
          areContours: true
        });
      }
      static processDrawnLines({
        lines,
        pageWidth,
        pageHeight,
        rotation,
        innerMargin,
        mustSmooth,
        areContours
      }) {
        if (rotation % 180 !== 0) {
          [pageWidth, pageHeight] = [pageHeight, pageWidth];
        }
        const {
          curves,
          width,
          height
        } = lines;
        const thickness = lines.thickness ?? 0;
        const linesAndPoints = [];
        const ratio = Math.min(pageWidth / width, pageHeight / height);
        const xScale = ratio / pageWidth;
        const yScale = ratio / pageHeight;
        const newCurves = [];
        for (const {
          points
        } of curves) {
          const reducedPoints = mustSmooth ? this.#douglasPeucker(points) : points;
          if (!reducedPoints) {
            continue;
          }
          newCurves.push(reducedPoints);
          const len = reducedPoints.length;
          const newPoints = new Float32Array(len);
          const line = new Float32Array(3 * (len === 2 ? 2 : len - 2));
          linesAndPoints.push({
            line,
            points: newPoints
          });
          if (len === 2) {
            newPoints[0] = reducedPoints[0] * xScale;
            newPoints[1] = reducedPoints[1] * yScale;
            line.set([NaN, NaN, NaN, NaN, newPoints[0], newPoints[1]], 0);
            continue;
          }
          let [x1, y1, x2, y2] = reducedPoints;
          x1 *= xScale;
          y1 *= yScale;
          x2 *= xScale;
          y2 *= yScale;
          newPoints.set([x1, y1, x2, y2], 0);
          line.set([NaN, NaN, NaN, NaN, x1, y1], 0);
          for (let i = 4; i < len; i += 2) {
            const x = newPoints[i] = reducedPoints[i] * xScale;
            const y = newPoints[i + 1] = reducedPoints[i + 1] * yScale;
            line.set(Outline.createBezierPoints(x1, y1, x2, y2, x, y), (i - 2) * 3);
            [x1, y1, x2, y2] = [x2, y2, x, y];
          }
        }
        if (linesAndPoints.length === 0) {
          return null;
        }
        const outline = areContours ? new ContourDrawOutline() : new InkDrawOutline();
        outline.build(linesAndPoints, pageWidth, pageHeight, 1, rotation, areContours ? 0 : thickness, innerMargin);
        return {
          outline,
          newCurves,
          areContours,
          thickness,
          width,
          height
        };
      }
      static async compressSignature({
        outlines,
        areContours,
        thickness,
        width,
        height
      }) {
        let minDiff = Infinity;
        let maxDiff = -Infinity;
        let outlinesLength = 0;
        for (const points of outlines) {
          outlinesLength += points.length;
          for (let i = 2, ii = points.length; i < ii; i++) {
            const dx = points[i] - points[i - 2];
            minDiff = Math.min(minDiff, dx);
            maxDiff = Math.max(maxDiff, dx);
          }
        }
        let bufferType;
        if (minDiff >= -128 && maxDiff <= 127) {
          bufferType = Int8Array;
        } else if (minDiff >= -32768 && maxDiff <= 32767) {
          bufferType = Int16Array;
        } else {
          bufferType = Int32Array;
        }
        const len = outlines.length;
        const headerLength = BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * len;
        const header = new Uint32Array(headerLength);
        let offset = 0;
        header[offset++] = headerLength * Uint32Array.BYTES_PER_ELEMENT + (outlinesLength - 2 * len) * bufferType.BYTES_PER_ELEMENT;
        header[offset++] = 0;
        header[offset++] = width;
        header[offset++] = height;
        header[offset++] = areContours ? 0 : 1;
        header[offset++] = Math.max(0, Math.floor(thickness ?? 0));
        header[offset++] = len;
        header[offset++] = bufferType.BYTES_PER_ELEMENT;
        for (const points of outlines) {
          header[offset++] = points.length - 2;
          header[offset++] = points[0];
          header[offset++] = points[1];
        }
        const cs = new CompressionStream("deflate-raw");
        const writer = cs.writable.getWriter();
        await writer.ready;
        writer.write(header);
        const BufferCtor = bufferType.prototype.constructor;
        for (const points of outlines) {
          const diffs = new BufferCtor(points.length - 2);
          for (let i = 2, ii = points.length; i < ii; i++) {
            diffs[i - 2] = points[i] - points[i - 2];
          }
          writer.write(diffs);
        }
        writer.close();
        const buf = await new Response(cs.readable).arrayBuffer();
        const bytes = new Uint8Array(buf);
        return toBase64Util(bytes);
      }
      static async decompressSignature(signatureData) {
        try {
          const bytes = fromBase64Util(signatureData);
          const {
            readable,
            writable
          } = new DecompressionStream("deflate-raw");
          const writer = writable.getWriter();
          await writer.ready;
          writer.write(bytes).then(async () => {
            await writer.ready;
            await writer.close();
          }).catch(() => {
          });
          let data = null;
          let offset = 0;
          for await (const chunk2 of readable) {
            data ||= new Uint8Array(new Uint32Array(chunk2.buffer, 0, 4)[0]);
            data.set(chunk2, offset);
            offset += chunk2.length;
          }
          const header = new Uint32Array(data.buffer, 0, data.length >> 2);
          const version2 = header[1];
          if (version2 !== 0) {
            throw new Error(`Invalid version: ${version2}`);
          }
          const width = header[2];
          const height = header[3];
          const areContours = header[4] === 0;
          const thickness = header[5];
          const numberOfDrawings = header[6];
          const bufferType = header[7];
          const outlines = [];
          const diffsOffset = (BASE_HEADER_LENGTH + POINTS_PROPERTIES_NUMBER * numberOfDrawings) * Uint32Array.BYTES_PER_ELEMENT;
          let diffs;
          switch (bufferType) {
            case Int8Array.BYTES_PER_ELEMENT:
              diffs = new Int8Array(data.buffer, diffsOffset);
              break;
            case Int16Array.BYTES_PER_ELEMENT:
              diffs = new Int16Array(data.buffer, diffsOffset);
              break;
            case Int32Array.BYTES_PER_ELEMENT:
              diffs = new Int32Array(data.buffer, diffsOffset);
              break;
          }
          offset = 0;
          for (let i = 0; i < numberOfDrawings; i++) {
            const len = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH];
            const points = new Float32Array(len + 2);
            outlines.push(points);
            for (let j = 0; j < POINTS_PROPERTIES_NUMBER - 1; j++) {
              points[j] = header[POINTS_PROPERTIES_NUMBER * i + BASE_HEADER_LENGTH + j + 1];
            }
            for (let j = 0; j < len; j++) {
              points[j + 2] = points[j] + diffs[offset++];
            }
          }
          return {
            areContours,
            thickness,
            outlines,
            width,
            height
          };
        } catch (e) {
          warn(`decompressSignature: ${e}`);
          return null;
        }
      }
    };
    SignatureOptions = class _SignatureOptions extends DrawingOptions {
      constructor() {
        super();
        super.updateProperties({
          fill: AnnotationEditor._defaultLineColor,
          "stroke-width": 0
        });
      }
      clone() {
        const clone2 = new _SignatureOptions();
        clone2.updateAll(this);
        return clone2;
      }
    };
    DrawnSignatureOptions = class _DrawnSignatureOptions extends InkDrawingOptions {
      constructor(viewerParameters) {
        super(viewerParameters);
        super.updateProperties({
          stroke: AnnotationEditor._defaultLineColor,
          "stroke-width": 1
        });
      }
      clone() {
        const clone2 = new _DrawnSignatureOptions(this._viewParameters);
        clone2.updateAll(this);
        return clone2;
      }
    };
    SignatureEditor = class _SignatureEditor extends DrawingEditor {
      #isExtracted = false;
      #description = null;
      #signatureData = null;
      #signatureUUID = null;
      static _type = "signature";
      static _editorType = AnnotationEditorType.SIGNATURE;
      static _defaultDrawingOptions = null;
      constructor(params) {
        super({
          ...params,
          mustBeCommitted: true,
          name: "signatureEditor"
        });
        this._willKeepAspectRatio = true;
        this.#signatureData = params.signatureData || null;
        this.#description = null;
        this.defaultL10nId = "pdfjs-editor-signature-editor1";
      }
      static initialize(l10n, uiManager) {
        AnnotationEditor.initialize(l10n, uiManager);
        this._defaultDrawingOptions = new SignatureOptions();
        this._defaultDrawnSignatureOptions = new DrawnSignatureOptions(uiManager.viewParameters);
      }
      static getDefaultDrawingOptions(options) {
        const clone2 = this._defaultDrawingOptions.clone();
        clone2.updateProperties(options);
        return clone2;
      }
      static get supportMultipleDrawings() {
        return false;
      }
      static get typesMap() {
        return shadow(this, "typesMap", /* @__PURE__ */ new Map());
      }
      static get isDrawer() {
        return false;
      }
      get telemetryFinalData() {
        return {
          type: "signature",
          hasDescription: !!this.#description
        };
      }
      static computeTelemetryFinalData(data) {
        const hasDescriptionStats = data.get("hasDescription");
        return {
          hasAltText: hasDescriptionStats.get(true) ?? 0,
          hasNoAltText: hasDescriptionStats.get(false) ?? 0
        };
      }
      get isResizable() {
        return true;
      }
      onScaleChanging() {
        if (this._drawId === null) {
          return;
        }
        super.onScaleChanging();
      }
      render() {
        if (this.div) {
          return this.div;
        }
        let baseX, baseY;
        const {
          _isCopy
        } = this;
        if (_isCopy) {
          this._isCopy = false;
          baseX = this.x;
          baseY = this.y;
        }
        super.render();
        if (this._drawId === null) {
          if (this.#signatureData) {
            const {
              lines,
              mustSmooth,
              areContours,
              description,
              uuid,
              heightInPage
            } = this.#signatureData;
            const {
              rawDims: {
                pageWidth,
                pageHeight
              },
              rotation
            } = this.parent.viewport;
            const outline = SignatureExtractor.processDrawnLines({
              lines,
              pageWidth,
              pageHeight,
              rotation,
              innerMargin: _SignatureEditor._INNER_MARGIN,
              mustSmooth,
              areContours
            });
            this.addSignature(outline, heightInPage, description, uuid);
          } else {
            this.div.setAttribute("data-l10n-args", JSON.stringify({
              description: ""
            }));
            this.div.hidden = true;
            this._uiManager.getSignature(this);
          }
        } else {
          this.div.setAttribute("data-l10n-args", JSON.stringify({
            description: this.#description || ""
          }));
        }
        if (_isCopy) {
          this._isCopy = true;
          this._moveAfterPaste(baseX, baseY);
        }
        return this.div;
      }
      setUuid(uuid) {
        this.#signatureUUID = uuid;
        this.addEditToolbar();
      }
      getUuid() {
        return this.#signatureUUID;
      }
      get description() {
        return this.#description;
      }
      set description(description) {
        this.#description = description;
        if (!this.div) {
          return;
        }
        this.div.setAttribute("data-l10n-args", JSON.stringify({
          description
        }));
        super.addEditToolbar().then((toolbar) => {
          toolbar?.updateEditSignatureButton(description);
        });
      }
      getSignaturePreview() {
        const {
          newCurves,
          areContours,
          thickness,
          width,
          height
        } = this.#signatureData;
        const maxDim = Math.max(width, height);
        const outlineData = SignatureExtractor.processDrawnLines({
          lines: {
            curves: newCurves.map((points) => ({
              points
            })),
            thickness,
            width,
            height
          },
          pageWidth: maxDim,
          pageHeight: maxDim,
          rotation: 0,
          innerMargin: 0,
          mustSmooth: false,
          areContours
        });
        return {
          areContours,
          outline: outlineData.outline
        };
      }
      get toolbarButtons() {
        if (this._uiManager.signatureManager) {
          return [["editSignature", this._uiManager.signatureManager]];
        }
        return super.toolbarButtons;
      }
      addSignature(data, heightInPage, description, uuid) {
        const {
          x: savedX,
          y: savedY
        } = this;
        const {
          outline
        } = this.#signatureData = data;
        this.#isExtracted = outline instanceof ContourDrawOutline;
        this.description = description;
        let drawingOptions;
        if (this.#isExtracted) {
          drawingOptions = _SignatureEditor.getDefaultDrawingOptions();
        } else {
          drawingOptions = _SignatureEditor._defaultDrawnSignatureOptions.clone();
          drawingOptions.updateProperties({
            "stroke-width": outline.thickness
          });
        }
        this._addOutlines({
          drawOutlines: outline,
          drawingOptions
        });
        const [, pageHeight] = this.pageDimensions;
        let newHeight = heightInPage / pageHeight;
        newHeight = newHeight >= 1 ? 0.5 : newHeight;
        this.width *= newHeight / this.height;
        if (this.width >= 1) {
          newHeight *= 0.9 / this.width;
          this.width = 0.9;
        }
        this.height = newHeight;
        this.setDims();
        this.x = savedX;
        this.y = savedY;
        this.center();
        this._onResized();
        this.onScaleChanging();
        this.rotate();
        this._uiManager.addToAnnotationStorage(this);
        this.setUuid(uuid);
        this._reportTelemetry({
          action: "pdfjs.signature.inserted",
          data: {
            hasBeenSaved: !!uuid,
            hasDescription: !!description
          }
        });
        this.div.hidden = false;
      }
      getFromImage(bitmap) {
        const {
          rawDims: {
            pageWidth,
            pageHeight
          },
          rotation
        } = this.parent.viewport;
        return SignatureExtractor.process(bitmap, pageWidth, pageHeight, rotation, _SignatureEditor._INNER_MARGIN);
      }
      getFromText(text, fontInfo) {
        const {
          rawDims: {
            pageWidth,
            pageHeight
          },
          rotation
        } = this.parent.viewport;
        return SignatureExtractor.extractContoursFromText(text, fontInfo, pageWidth, pageHeight, rotation, _SignatureEditor._INNER_MARGIN);
      }
      getDrawnSignature(curves) {
        const {
          rawDims: {
            pageWidth,
            pageHeight
          },
          rotation
        } = this.parent.viewport;
        return SignatureExtractor.processDrawnLines({
          lines: curves,
          pageWidth,
          pageHeight,
          rotation,
          innerMargin: _SignatureEditor._INNER_MARGIN,
          mustSmooth: false,
          areContours: false
        });
      }
      createDrawingOptions({
        areContours,
        thickness
      }) {
        if (areContours) {
          this._drawingOptions = _SignatureEditor.getDefaultDrawingOptions();
        } else {
          this._drawingOptions = _SignatureEditor._defaultDrawnSignatureOptions.clone();
          this._drawingOptions.updateProperties({
            "stroke-width": thickness
          });
        }
      }
      serialize(isForCopying = false) {
        if (this.isEmpty()) {
          return null;
        }
        const {
          lines,
          points
        } = this.serializeDraw(isForCopying);
        const {
          _drawingOptions: {
            "stroke-width": thickness
          }
        } = this;
        const serialized = Object.assign(super.serialize(isForCopying), {
          isSignature: true,
          areContours: this.#isExtracted,
          color: [0, 0, 0],
          thickness: this.#isExtracted ? 0 : thickness
        });
        this.addComment(serialized);
        if (isForCopying) {
          serialized.paths = {
            lines,
            points
          };
          serialized.uuid = this.#signatureUUID;
          serialized.isCopy = true;
        } else {
          serialized.lines = lines;
        }
        if (this.#description) {
          serialized.accessibilityData = {
            type: "Figure",
            alt: this.#description
          };
        }
        return serialized;
      }
      static deserializeDraw(pageX, pageY, pageWidth, pageHeight, innerMargin, data) {
        if (data.areContours) {
          return ContourDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
        }
        return InkDrawOutline.deserialize(pageX, pageY, pageWidth, pageHeight, innerMargin, data);
      }
      static async deserialize(data, parent, uiManager) {
        const editor = await super.deserialize(data, parent, uiManager);
        editor.#isExtracted = data.areContours;
        editor.description = data.accessibilityData?.alt || "";
        editor.#signatureUUID = data.uuid;
        return editor;
      }
    };
    StampEditor = class extends AnnotationEditor {
      #bitmap = null;
      #bitmapId = null;
      #bitmapPromise = null;
      #bitmapUrl = null;
      #bitmapFile = null;
      #bitmapFileName = "";
      #canvas = null;
      #missingCanvas = false;
      #resizeTimeoutId = null;
      #isSvg = false;
      #hasBeenAddedInUndoStack = false;
      static _type = "stamp";
      static _editorType = AnnotationEditorType.STAMP;
      constructor(params) {
        super({
          ...params,
          name: "stampEditor"
        });
        this.#bitmapUrl = params.bitmapUrl;
        this.#bitmapFile = params.bitmapFile;
        this.defaultL10nId = "pdfjs-editor-stamp-editor";
      }
      static initialize(l10n, uiManager) {
        AnnotationEditor.initialize(l10n, uiManager);
      }
      static isHandlingMimeForPasting(mime) {
        return SupportedImageMimeTypes.includes(mime);
      }
      static paste(item, parent) {
        parent.pasteEditor({
          mode: AnnotationEditorType.STAMP
        }, {
          bitmapFile: item.getAsFile()
        });
      }
      altTextFinish() {
        if (this._uiManager.useNewAltTextFlow) {
          this.div.hidden = false;
        }
        super.altTextFinish();
      }
      get telemetryFinalData() {
        return {
          type: "stamp",
          hasAltText: !!this.altTextData?.altText
        };
      }
      static computeTelemetryFinalData(data) {
        const hasAltTextStats = data.get("hasAltText");
        return {
          hasAltText: hasAltTextStats.get(true) ?? 0,
          hasNoAltText: hasAltTextStats.get(false) ?? 0
        };
      }
      #getBitmapFetched(data, fromId = false) {
        if (!data) {
          this.remove();
          return;
        }
        this.#bitmap = data.bitmap;
        if (!fromId) {
          this.#bitmapId = data.id;
          this.#isSvg = data.isSvg;
        }
        if (data.file) {
          this.#bitmapFileName = data.file.name;
        }
        this.#createCanvas();
      }
      #getBitmapDone() {
        this.#bitmapPromise = null;
        this._uiManager.enableWaiting(false);
        if (!this.#canvas) {
          return;
        }
        if (this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {
          this.addEditToolbar().then(() => {
            this._editToolbar.hide();
            this._uiManager.editAltText(this, true);
          });
          return;
        }
        if (!this._uiManager.useNewAltTextWhenAddingImage && this._uiManager.useNewAltTextFlow && this.#bitmap) {
          this._reportTelemetry({
            action: "pdfjs.image.image_added",
            data: {
              alt_text_modal: false,
              alt_text_type: "empty"
            }
          });
          try {
            this.mlGuessAltText();
          } catch {
          }
        }
        this.div.focus();
      }
      async mlGuessAltText(imageData = null, updateAltTextData = true) {
        if (this.hasAltTextData()) {
          return null;
        }
        const {
          mlManager
        } = this._uiManager;
        if (!mlManager) {
          throw new Error("No ML.");
        }
        if (!await mlManager.isEnabledFor("altText")) {
          throw new Error("ML isn't enabled for alt text.");
        }
        const {
          data,
          width,
          height
        } = imageData || this.copyCanvas(null, null, true).imageData;
        const response = await mlManager.guess({
          name: "altText",
          request: {
            data,
            width,
            height,
            channels: data.length / (width * height)
          }
        });
        if (!response) {
          throw new Error("No response from the AI service.");
        }
        if (response.error) {
          throw new Error("Error from the AI service.");
        }
        if (response.cancel) {
          return null;
        }
        if (!response.output) {
          throw new Error("No valid response from the AI service.");
        }
        const altText = response.output;
        await this.setGuessedAltText(altText);
        if (updateAltTextData && !this.hasAltTextData()) {
          this.altTextData = {
            alt: altText,
            decorative: false
          };
        }
        return altText;
      }
      #getBitmap() {
        if (this.#bitmapId) {
          this._uiManager.enableWaiting(true);
          this._uiManager.imageManager.getFromId(this.#bitmapId).then((data) => this.#getBitmapFetched(data, true)).finally(() => this.#getBitmapDone());
          return;
        }
        if (this.#bitmapUrl) {
          const url = this.#bitmapUrl;
          this.#bitmapUrl = null;
          this._uiManager.enableWaiting(true);
          this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then((data) => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());
          return;
        }
        if (this.#bitmapFile) {
          const file = this.#bitmapFile;
          this.#bitmapFile = null;
          this._uiManager.enableWaiting(true);
          this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then((data) => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());
          return;
        }
        const input = document.createElement("input");
        input.type = "file";
        input.accept = SupportedImageMimeTypes.join(",");
        const signal = this._uiManager._signal;
        this.#bitmapPromise = new Promise((resolve) => {
          input.addEventListener("change", async () => {
            if (!input.files || input.files.length === 0) {
              this.remove();
            } else {
              this._uiManager.enableWaiting(true);
              const data = await this._uiManager.imageManager.getFromFile(input.files[0]);
              this._reportTelemetry({
                action: "pdfjs.image.image_selected",
                data: {
                  alt_text_modal: this._uiManager.useNewAltTextFlow
                }
              });
              this.#getBitmapFetched(data);
            }
            resolve();
          }, {
            signal
          });
          input.addEventListener("cancel", () => {
            this.remove();
            resolve();
          }, {
            signal
          });
        }).finally(() => this.#getBitmapDone());
        input.click();
      }
      remove() {
        if (this.#bitmapId) {
          this.#bitmap = null;
          this._uiManager.imageManager.deleteId(this.#bitmapId);
          this.#canvas?.remove();
          this.#canvas = null;
          if (this.#resizeTimeoutId) {
            clearTimeout(this.#resizeTimeoutId);
            this.#resizeTimeoutId = null;
          }
        }
        super.remove();
      }
      rebuild() {
        if (!this.parent) {
          if (this.#bitmapId) {
            this.#getBitmap();
          }
          return;
        }
        super.rebuild();
        if (this.div === null) {
          return;
        }
        if (this.#bitmapId && this.#canvas === null) {
          this.#getBitmap();
        }
        if (!this.isAttachedToDOM) {
          this.parent.add(this);
        }
      }
      onceAdded(focus) {
        this._isDraggable = true;
        if (focus) {
          this.div.focus();
        }
      }
      isEmpty() {
        return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile || this.#bitmapId || this.#missingCanvas);
      }
      get toolbarButtons() {
        return [["altText", this.createAltText()]];
      }
      get isResizable() {
        return true;
      }
      render() {
        if (this.div) {
          return this.div;
        }
        let baseX, baseY;
        if (this._isCopy) {
          baseX = this.x;
          baseY = this.y;
        }
        super.render();
        this.div.hidden = true;
        this.createAltText();
        if (!this.#missingCanvas) {
          if (this.#bitmap) {
            this.#createCanvas();
          } else {
            this.#getBitmap();
          }
        }
        if (this._isCopy) {
          this._moveAfterPaste(baseX, baseY);
        }
        this._uiManager.addShouldRescale(this);
        return this.div;
      }
      setCanvas(annotationElementId, canvas) {
        const {
          id: bitmapId,
          bitmap
        } = this._uiManager.imageManager.getFromCanvas(annotationElementId, canvas);
        canvas.remove();
        if (bitmapId && this._uiManager.imageManager.isValidId(bitmapId)) {
          this.#bitmapId = bitmapId;
          if (bitmap) {
            this.#bitmap = bitmap;
          }
          this.#missingCanvas = false;
          this.#createCanvas();
        }
      }
      _onResized() {
        this.onScaleChanging();
      }
      onScaleChanging() {
        if (!this.parent) {
          return;
        }
        if (this.#resizeTimeoutId !== null) {
          clearTimeout(this.#resizeTimeoutId);
        }
        const TIME_TO_WAIT = 200;
        this.#resizeTimeoutId = setTimeout(() => {
          this.#resizeTimeoutId = null;
          this.#drawBitmap();
        }, TIME_TO_WAIT);
      }
      #createCanvas() {
        const {
          div
        } = this;
        let {
          width,
          height
        } = this.#bitmap;
        const [pageWidth, pageHeight] = this.pageDimensions;
        const MAX_RATIO = 0.75;
        if (this.width) {
          width = this.width * pageWidth;
          height = this.height * pageHeight;
        } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {
          const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);
          width *= factor;
          height *= factor;
        }
        this._uiManager.enableWaiting(false);
        const canvas = this.#canvas = document.createElement("canvas");
        canvas.setAttribute("role", "img");
        this.addContainer(canvas);
        this.width = width / pageWidth;
        this.height = height / pageHeight;
        this.setDims();
        if (this._initialOptions?.isCentered) {
          this.center();
        } else {
          this.fixAndSetPosition();
        }
        this._initialOptions = null;
        if (!this._uiManager.useNewAltTextWhenAddingImage || !this._uiManager.useNewAltTextFlow || this.annotationElementId) {
          div.hidden = false;
        }
        this.#drawBitmap();
        if (!this.#hasBeenAddedInUndoStack) {
          this.parent.addUndoableEditor(this);
          this.#hasBeenAddedInUndoStack = true;
        }
        this._reportTelemetry({
          action: "inserted_image"
        });
        if (this.#bitmapFileName) {
          this.div.setAttribute("aria-description", this.#bitmapFileName);
        }
        if (!this.annotationElementId) {
          this._uiManager.a11yAlert("pdfjs-editor-stamp-added-alert");
        }
      }
      copyCanvas(maxDataDimension, maxPreviewDimension, createImageData = false) {
        if (!maxDataDimension) {
          maxDataDimension = 224;
        }
        const {
          width: bitmapWidth,
          height: bitmapHeight
        } = this.#bitmap;
        const outputScale = new OutputScale();
        let bitmap = this.#bitmap;
        let width = bitmapWidth, height = bitmapHeight;
        let canvas = null;
        if (maxPreviewDimension) {
          if (bitmapWidth > maxPreviewDimension || bitmapHeight > maxPreviewDimension) {
            const ratio = Math.min(maxPreviewDimension / bitmapWidth, maxPreviewDimension / bitmapHeight);
            width = Math.floor(bitmapWidth * ratio);
            height = Math.floor(bitmapHeight * ratio);
          }
          canvas = document.createElement("canvas");
          const scaledWidth = canvas.width = Math.ceil(width * outputScale.sx);
          const scaledHeight = canvas.height = Math.ceil(height * outputScale.sy);
          if (!this.#isSvg) {
            bitmap = this.#scaleBitmap(scaledWidth, scaledHeight);
          }
          const ctx = canvas.getContext("2d");
          ctx.filter = this._uiManager.hcmFilter;
          let white = "white", black = "#cfcfd8";
          if (this._uiManager.hcmFilter !== "none") {
            black = "black";
          } else if (ColorScheme.isDarkMode) {
            white = "#8f8f9d";
            black = "#42414d";
          }
          const boxDim = 15;
          const boxDimWidth = boxDim * outputScale.sx;
          const boxDimHeight = boxDim * outputScale.sy;
          const pattern = new OffscreenCanvas(boxDimWidth * 2, boxDimHeight * 2);
          const patternCtx = pattern.getContext("2d");
          patternCtx.fillStyle = white;
          patternCtx.fillRect(0, 0, boxDimWidth * 2, boxDimHeight * 2);
          patternCtx.fillStyle = black;
          patternCtx.fillRect(0, 0, boxDimWidth, boxDimHeight);
          patternCtx.fillRect(boxDimWidth, boxDimHeight, boxDimWidth, boxDimHeight);
          ctx.fillStyle = ctx.createPattern(pattern, "repeat");
          ctx.fillRect(0, 0, scaledWidth, scaledHeight);
          ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
        }
        let imageData = null;
        if (createImageData) {
          let dataWidth, dataHeight;
          if (outputScale.symmetric && bitmap.width < maxDataDimension && bitmap.height < maxDataDimension) {
            dataWidth = bitmap.width;
            dataHeight = bitmap.height;
          } else {
            bitmap = this.#bitmap;
            if (bitmapWidth > maxDataDimension || bitmapHeight > maxDataDimension) {
              const ratio = Math.min(maxDataDimension / bitmapWidth, maxDataDimension / bitmapHeight);
              dataWidth = Math.floor(bitmapWidth * ratio);
              dataHeight = Math.floor(bitmapHeight * ratio);
              if (!this.#isSvg) {
                bitmap = this.#scaleBitmap(dataWidth, dataHeight);
              }
            }
          }
          const offscreen = new OffscreenCanvas(dataWidth, dataHeight);
          const offscreenCtx = offscreen.getContext("2d", {
            willReadFrequently: true
          });
          offscreenCtx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, dataWidth, dataHeight);
          imageData = {
            width: dataWidth,
            height: dataHeight,
            data: offscreenCtx.getImageData(0, 0, dataWidth, dataHeight).data
          };
        }
        return {
          canvas,
          width,
          height,
          imageData
        };
      }
      #scaleBitmap(width, height) {
        const {
          width: bitmapWidth,
          height: bitmapHeight
        } = this.#bitmap;
        let newWidth = bitmapWidth;
        let newHeight = bitmapHeight;
        let bitmap = this.#bitmap;
        while (newWidth > 2 * width || newHeight > 2 * height) {
          const prevWidth = newWidth;
          const prevHeight = newHeight;
          if (newWidth > 2 * width) {
            newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);
          }
          if (newHeight > 2 * height) {
            newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);
          }
          const offscreen = new OffscreenCanvas(newWidth, newHeight);
          const ctx = offscreen.getContext("2d");
          ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);
          bitmap = offscreen.transferToImageBitmap();
        }
        return bitmap;
      }
      #drawBitmap() {
        const [parentWidth, parentHeight] = this.parentDimensions;
        const {
          width,
          height
        } = this;
        const outputScale = new OutputScale();
        const scaledWidth = Math.ceil(width * parentWidth * outputScale.sx);
        const scaledHeight = Math.ceil(height * parentHeight * outputScale.sy);
        const canvas = this.#canvas;
        if (!canvas || canvas.width === scaledWidth && canvas.height === scaledHeight) {
          return;
        }
        canvas.width = scaledWidth;
        canvas.height = scaledHeight;
        const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(scaledWidth, scaledHeight);
        const ctx = canvas.getContext("2d");
        ctx.filter = this._uiManager.hcmFilter;
        ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, scaledWidth, scaledHeight);
      }
      #serializeBitmap(toUrl) {
        if (toUrl) {
          if (this.#isSvg) {
            const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);
            if (url) {
              return url;
            }
          }
          const canvas = document.createElement("canvas");
          ({
            width: canvas.width,
            height: canvas.height
          } = this.#bitmap);
          const ctx = canvas.getContext("2d");
          ctx.drawImage(this.#bitmap, 0, 0);
          return canvas.toDataURL();
        }
        if (this.#isSvg) {
          const [pageWidth, pageHeight] = this.pageDimensions;
          const width = Math.round(this.width * pageWidth * PixelsPerInch.PDF_TO_CSS_UNITS);
          const height = Math.round(this.height * pageHeight * PixelsPerInch.PDF_TO_CSS_UNITS);
          const offscreen = new OffscreenCanvas(width, height);
          const ctx = offscreen.getContext("2d");
          ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);
          return offscreen.transferToImageBitmap();
        }
        return structuredClone(this.#bitmap);
      }
      static async deserialize(data, parent, uiManager) {
        let initialData = null;
        let missingCanvas = false;
        if (data instanceof StampAnnotationElement) {
          const {
            data: {
              rect: rect2,
              rotation,
              id,
              structParent,
              popupRef,
              richText,
              contentsObj,
              creationDate,
              modificationDate
            },
            container,
            parent: {
              page: {
                pageNumber
              }
            },
            canvas
          } = data;
          let bitmapId2, bitmap2;
          if (canvas) {
            delete data.canvas;
            ({
              id: bitmapId2,
              bitmap: bitmap2
            } = uiManager.imageManager.getFromCanvas(container.id, canvas));
            canvas.remove();
          } else {
            missingCanvas = true;
            data._hasNoCanvas = true;
          }
          const altText = (await parent._structTree.getAriaAttributes(`${AnnotationPrefix}${id}`))?.get("aria-label") || "";
          initialData = data = {
            annotationType: AnnotationEditorType.STAMP,
            bitmapId: bitmapId2,
            bitmap: bitmap2,
            pageIndex: pageNumber - 1,
            rect: rect2.slice(0),
            rotation,
            annotationElementId: id,
            id,
            deleted: false,
            accessibilityData: {
              decorative: false,
              altText
            },
            isSvg: false,
            structParent,
            popupRef,
            richText,
            comment: contentsObj?.str || null,
            creationDate,
            modificationDate
          };
        }
        const editor = await super.deserialize(data, parent, uiManager);
        const {
          rect,
          bitmap,
          bitmapUrl,
          bitmapId,
          isSvg,
          accessibilityData
        } = data;
        if (missingCanvas) {
          uiManager.addMissingCanvas(data.id, editor);
          editor.#missingCanvas = true;
        } else if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {
          editor.#bitmapId = bitmapId;
          if (bitmap) {
            editor.#bitmap = bitmap;
          }
        } else {
          editor.#bitmapUrl = bitmapUrl;
        }
        editor.#isSvg = isSvg;
        const [parentWidth, parentHeight] = editor.pageDimensions;
        editor.width = (rect[2] - rect[0]) / parentWidth;
        editor.height = (rect[3] - rect[1]) / parentHeight;
        if (accessibilityData) {
          editor.altTextData = accessibilityData;
        }
        editor._initialData = initialData;
        if (data.comment) {
          editor.setCommentData(data);
        }
        editor.#hasBeenAddedInUndoStack = !!initialData;
        return editor;
      }
      serialize(isForCopying = false, context = null) {
        if (this.isEmpty()) {
          return null;
        }
        if (this.deleted) {
          return this.serializeDeleted();
        }
        const serialized = Object.assign(super.serialize(isForCopying), {
          bitmapId: this.#bitmapId,
          isSvg: this.#isSvg
        });
        this.addComment(serialized);
        if (isForCopying) {
          serialized.bitmapUrl = this.#serializeBitmap(true);
          serialized.accessibilityData = this.serializeAltText(true);
          serialized.isCopy = true;
          return serialized;
        }
        const {
          decorative,
          altText
        } = this.serializeAltText(false);
        if (!decorative && altText) {
          serialized.accessibilityData = {
            type: "Figure",
            alt: altText
          };
        }
        if (this.annotationElementId) {
          const changes = this.#hasElementChanged(serialized);
          if (changes.isSame) {
            return null;
          }
          if (changes.isSameAltText) {
            delete serialized.accessibilityData;
          } else {
            serialized.accessibilityData.structParent = this._initialData.structParent ?? -1;
          }
          serialized.id = this.annotationElementId;
          delete serialized.bitmapId;
          return serialized;
        }
        if (context === null) {
          return serialized;
        }
        context.stamps ||= /* @__PURE__ */ new Map();
        const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;
        if (!context.stamps.has(this.#bitmapId)) {
          context.stamps.set(this.#bitmapId, {
            area,
            serialized
          });
          serialized.bitmap = this.#serializeBitmap(false);
        } else if (this.#isSvg) {
          const prevData = context.stamps.get(this.#bitmapId);
          if (area > prevData.area) {
            prevData.area = area;
            prevData.serialized.bitmap.close();
            prevData.serialized.bitmap = this.#serializeBitmap(false);
          }
        }
        return serialized;
      }
      #hasElementChanged(serialized) {
        const {
          pageIndex,
          accessibilityData: {
            altText
          }
        } = this._initialData;
        const isSamePageIndex = serialized.pageIndex === pageIndex;
        const isSameAltText = (serialized.accessibilityData?.alt || "") === altText;
        return {
          isSame: !this.hasEditedComment && !this._hasBeenMoved && !this._hasBeenResized && isSamePageIndex && isSameAltText,
          isSameAltText
        };
      }
      renderAnnotationElement(annotation) {
        if (this.deleted) {
          annotation.hide();
          return null;
        }
        annotation.updateEdited({
          rect: this.getPDFRect(),
          popup: this.comment
        });
        return null;
      }
    };
    AnnotationEditorLayer = class _AnnotationEditorLayer {
      #accessibilityManager;
      #allowClick = false;
      #annotationLayer = null;
      #clickAC = null;
      #editorFocusTimeoutId = null;
      #editors = /* @__PURE__ */ new Map();
      #hadPointerDown = false;
      #isDisabling = false;
      #isEnabling = false;
      #drawingAC = null;
      #focusedElement = null;
      #textLayer = null;
      #textSelectionAC = null;
      #textLayerDblClickAC = null;
      #lastPointerDownTimestamp = -1;
      #uiManager;
      static _initialized = false;
      static #editorTypes = new Map([FreeTextEditor, InkEditor, StampEditor, HighlightEditor, SignatureEditor].map((type) => [type._editorType, type]));
      constructor({
        uiManager,
        pageIndex,
        div,
        structTreeLayer,
        accessibilityManager,
        annotationLayer,
        drawLayer,
        textLayer,
        viewport,
        l10n
      }) {
        const editorTypes = [..._AnnotationEditorLayer.#editorTypes.values()];
        if (!_AnnotationEditorLayer._initialized) {
          _AnnotationEditorLayer._initialized = true;
          for (const editorType of editorTypes) {
            editorType.initialize(l10n, uiManager);
          }
        }
        uiManager.registerEditorTypes(editorTypes);
        this.#uiManager = uiManager;
        this.pageIndex = pageIndex;
        this.div = div;
        this.#accessibilityManager = accessibilityManager;
        this.#annotationLayer = annotationLayer;
        this.viewport = viewport;
        this.#textLayer = textLayer;
        this.drawLayer = drawLayer;
        this._structTree = structTreeLayer;
        this.#uiManager.addLayer(this);
      }
      get isEmpty() {
        return this.#editors.size === 0;
      }
      get isInvisible() {
        return this.isEmpty && this.#uiManager.getMode() === AnnotationEditorType.NONE;
      }
      updateToolbar(options) {
        this.#uiManager.updateToolbar(options);
      }
      updateMode(mode = this.#uiManager.getMode()) {
        this.#cleanup();
        switch (mode) {
          case AnnotationEditorType.NONE:
            this.div.classList.toggle("nonEditing", true);
            this.disableTextSelection();
            this.togglePointerEvents(false);
            this.toggleAnnotationLayerPointerEvents(true);
            this.disableClick();
            return;
          case AnnotationEditorType.INK:
            this.disableTextSelection();
            this.togglePointerEvents(true);
            this.enableClick();
            break;
          case AnnotationEditorType.HIGHLIGHT:
            this.enableTextSelection();
            this.togglePointerEvents(false);
            this.disableClick();
            break;
          default:
            this.disableTextSelection();
            this.togglePointerEvents(true);
            this.enableClick();
        }
        this.toggleAnnotationLayerPointerEvents(false);
        const {
          classList
        } = this.div;
        classList.toggle("nonEditing", false);
        if (mode === AnnotationEditorType.POPUP) {
          classList.toggle("commentEditing", true);
        } else {
          classList.toggle("commentEditing", false);
          for (const editorType of _AnnotationEditorLayer.#editorTypes.values()) {
            classList.toggle(`${editorType._type}Editing`, mode === editorType._editorType);
          }
        }
        this.div.hidden = false;
      }
      hasTextLayer(textLayer) {
        return textLayer === this.#textLayer?.div;
      }
      setEditingState(isEditing) {
        this.#uiManager.setEditingState(isEditing);
      }
      addCommands(params) {
        this.#uiManager.addCommands(params);
      }
      cleanUndoStack(type) {
        this.#uiManager.cleanUndoStack(type);
      }
      toggleDrawing(enabled = false) {
        this.div.classList.toggle("drawing", !enabled);
      }
      togglePointerEvents(enabled = false) {
        this.div.classList.toggle("disabled", !enabled);
      }
      toggleAnnotationLayerPointerEvents(enabled = false) {
        this.#annotationLayer?.div.classList.toggle("disabled", !enabled);
      }
      get #allEditorsIterator() {
        return this.#editors.size !== 0 ? this.#editors.values() : this.#uiManager.getEditors(this.pageIndex);
      }
      async enable() {
        this.#isEnabling = true;
        this.div.tabIndex = 0;
        this.togglePointerEvents(true);
        this.div.classList.toggle("nonEditing", false);
        this.#textLayerDblClickAC?.abort();
        this.#textLayerDblClickAC = null;
        const annotationElementIds = /* @__PURE__ */ new Set();
        for (const editor of this.#allEditorsIterator) {
          editor.enableEditing();
          editor.show(true);
          if (editor.annotationElementId) {
            this.#uiManager.removeChangedExistingAnnotation(editor);
            annotationElementIds.add(editor.annotationElementId);
          }
        }
        const annotationLayer = this.#annotationLayer;
        if (annotationLayer) {
          for (const editable of annotationLayer.getEditableAnnotations()) {
            editable.hide();
            if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {
              continue;
            }
            if (annotationElementIds.has(editable.data.id)) {
              continue;
            }
            const editor = await this.deserialize(editable);
            if (!editor) {
              continue;
            }
            this.addOrRebuild(editor);
            editor.enableEditing();
          }
        }
        this.#isEnabling = false;
        this.#uiManager._eventBus.dispatch("editorsrendered", {
          source: this,
          pageNumber: this.pageIndex + 1
        });
      }
      disable() {
        this.#isDisabling = true;
        this.div.tabIndex = -1;
        this.togglePointerEvents(false);
        this.div.classList.toggle("nonEditing", true);
        if (this.#textLayer && !this.#textLayerDblClickAC) {
          this.#textLayerDblClickAC = new AbortController();
          const signal = this.#uiManager.combinedSignal(this.#textLayerDblClickAC);
          this.#textLayer.div.addEventListener("pointerdown", (e) => {
            const DBL_CLICK_THRESHOLD = 500;
            const {
              clientX,
              clientY,
              timeStamp
            } = e;
            const lastPointerDownTimestamp = this.#lastPointerDownTimestamp;
            if (timeStamp - lastPointerDownTimestamp > DBL_CLICK_THRESHOLD) {
              this.#lastPointerDownTimestamp = timeStamp;
              return;
            }
            this.#lastPointerDownTimestamp = -1;
            const {
              classList: classList2
            } = this.div;
            classList2.toggle("getElements", true);
            const elements = document.elementsFromPoint(clientX, clientY);
            classList2.toggle("getElements", false);
            if (!this.div.contains(elements[0])) {
              return;
            }
            let id;
            const regex = new RegExp(`^${AnnotationEditorPrefix}[0-9]+$`);
            for (const element of elements) {
              if (regex.test(element.id)) {
                id = element.id;
                break;
              }
            }
            if (!id) {
              return;
            }
            const editor = this.#editors.get(id);
            if (editor?.annotationElementId === null) {
              e.stopPropagation();
              e.preventDefault();
              editor.dblclick(e);
            }
          }, {
            signal,
            capture: true
          });
        }
        const annotationLayer = this.#annotationLayer;
        if (annotationLayer) {
          const changedAnnotations = /* @__PURE__ */ new Map();
          const resetAnnotations = /* @__PURE__ */ new Map();
          for (const editor of this.#allEditorsIterator) {
            editor.disableEditing();
            if (!editor.annotationElementId) {
              editor.updateFakeAnnotationElement(annotationLayer);
              continue;
            }
            if (editor.serialize() !== null) {
              changedAnnotations.set(editor.annotationElementId, editor);
              continue;
            } else {
              resetAnnotations.set(editor.annotationElementId, editor);
            }
            this.getEditableAnnotation(editor.annotationElementId)?.show();
            editor.remove();
          }
          const editables = annotationLayer.getEditableAnnotations();
          for (const editable of editables) {
            const {
              id
            } = editable.data;
            if (this.#uiManager.isDeletedAnnotationElement(id)) {
              editable.updateEdited({
                deleted: true
              });
              continue;
            }
            let editor = resetAnnotations.get(id);
            if (editor) {
              editor.resetAnnotationElement(editable);
              editor.show(false);
              editable.show();
              continue;
            }
            editor = changedAnnotations.get(id);
            if (editor) {
              this.#uiManager.addChangedExistingAnnotation(editor);
              if (editor.renderAnnotationElement(editable)) {
                editor.show(false);
              }
            }
            editable.show();
          }
        }
        this.#cleanup();
        if (this.isEmpty) {
          this.div.hidden = true;
        }
        const {
          classList
        } = this.div;
        for (const editorType of _AnnotationEditorLayer.#editorTypes.values()) {
          classList.remove(`${editorType._type}Editing`);
        }
        this.disableTextSelection();
        this.toggleAnnotationLayerPointerEvents(true);
        this.#isDisabling = false;
      }
      getEditableAnnotation(id) {
        return this.#annotationLayer?.getEditableAnnotation(id) || null;
      }
      setActiveEditor(editor) {
        const currentActive = this.#uiManager.getActive();
        if (currentActive === editor) {
          return;
        }
        this.#uiManager.setActiveEditor(editor);
      }
      enableTextSelection() {
        this.div.tabIndex = -1;
        if (this.#textLayer?.div && !this.#textSelectionAC) {
          this.#textSelectionAC = new AbortController();
          const signal = this.#uiManager.combinedSignal(this.#textSelectionAC);
          this.#textLayer.div.addEventListener("pointerdown", this.#textLayerPointerDown.bind(this), {
            signal
          });
          this.#textLayer.div.classList.add("highlighting");
        }
      }
      disableTextSelection() {
        this.div.tabIndex = 0;
        if (this.#textLayer?.div && this.#textSelectionAC) {
          this.#textSelectionAC.abort();
          this.#textSelectionAC = null;
          this.#textLayer.div.classList.remove("highlighting");
        }
      }
      #textLayerPointerDown(event) {
        this.#uiManager.unselectAll();
        const {
          target
        } = event;
        if (target === this.#textLayer.div || (target.getAttribute("role") === "img" || target.classList.contains("endOfContent")) && this.#textLayer.div.contains(target)) {
          const {
            isMac
          } = util_FeatureTest.platform;
          if (event.button !== 0 || event.ctrlKey && isMac) {
            return;
          }
          this.#uiManager.showAllEditors("highlight", true, true);
          this.#textLayer.div.classList.add("free");
          this.toggleDrawing();
          HighlightEditor.startHighlighting(this, this.#uiManager.direction === "ltr", {
            target: this.#textLayer.div,
            x: event.x,
            y: event.y
          });
          this.#textLayer.div.addEventListener("pointerup", () => {
            this.#textLayer.div.classList.remove("free");
            this.toggleDrawing(true);
          }, {
            once: true,
            signal: this.#uiManager._signal
          });
          event.preventDefault();
        }
      }
      enableClick() {
        if (this.#clickAC) {
          return;
        }
        this.#clickAC = new AbortController();
        const signal = this.#uiManager.combinedSignal(this.#clickAC);
        this.div.addEventListener("pointerdown", this.pointerdown.bind(this), {
          signal
        });
        const pointerup = this.pointerup.bind(this);
        this.div.addEventListener("pointerup", pointerup, {
          signal
        });
        this.div.addEventListener("pointercancel", pointerup, {
          signal
        });
      }
      disableClick() {
        this.#clickAC?.abort();
        this.#clickAC = null;
      }
      attach(editor) {
        this.#editors.set(editor.id, editor);
        const {
          annotationElementId
        } = editor;
        if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {
          this.#uiManager.removeDeletedAnnotationElement(editor);
        }
      }
      detach(editor) {
        this.#editors.delete(editor.id);
        this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
        if (!this.#isDisabling && editor.annotationElementId) {
          this.#uiManager.addDeletedAnnotationElement(editor);
        }
      }
      remove(editor) {
        this.detach(editor);
        this.#uiManager.removeEditor(editor);
        editor.div.remove();
        editor.isAttachedToDOM = false;
      }
      changeParent(editor) {
        if (editor.parent === this) {
          return;
        }
        if (editor.parent && editor.annotationElementId) {
          this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);
          AnnotationEditor.deleteAnnotationElement(editor);
          editor.annotationElementId = null;
        }
        this.attach(editor);
        editor.parent?.detach(editor);
        editor.setParent(this);
        if (editor.div && editor.isAttachedToDOM) {
          editor.div.remove();
          this.div.append(editor.div);
        }
      }
      add(editor) {
        if (editor.parent === this && editor.isAttachedToDOM) {
          return;
        }
        this.changeParent(editor);
        this.#uiManager.addEditor(editor);
        this.attach(editor);
        if (!editor.isAttachedToDOM) {
          const div = editor.render();
          this.div.append(div);
          editor.isAttachedToDOM = true;
        }
        editor.fixAndSetPosition();
        editor.onceAdded(!this.#isEnabling);
        this.#uiManager.addToAnnotationStorage(editor);
        editor._reportTelemetry(editor.telemetryInitialData);
      }
      moveEditorInDOM(editor) {
        if (!editor.isAttachedToDOM) {
          return;
        }
        const {
          activeElement
        } = document;
        if (editor.div.contains(activeElement) && !this.#editorFocusTimeoutId) {
          editor._focusEventsAllowed = false;
          this.#editorFocusTimeoutId = setTimeout(() => {
            this.#editorFocusTimeoutId = null;
            if (!editor.div.contains(document.activeElement)) {
              editor.div.addEventListener("focusin", () => {
                editor._focusEventsAllowed = true;
              }, {
                once: true,
                signal: this.#uiManager._signal
              });
              activeElement.focus();
            } else {
              editor._focusEventsAllowed = true;
            }
          }, 0);
        }
        editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);
      }
      addOrRebuild(editor) {
        if (editor.needsToBeRebuilt()) {
          editor.parent ||= this;
          editor.rebuild();
          editor.show();
        } else {
          this.add(editor);
        }
      }
      addUndoableEditor(editor) {
        const cmd = () => editor._uiManager.rebuild(editor);
        const undo = () => {
          editor.remove();
        };
        this.addCommands({
          cmd,
          undo,
          mustExec: false
        });
      }
      getEditorByUID(uid) {
        for (const editor of this.#editors.values()) {
          if (editor.uid === uid) {
            return editor;
          }
        }
        return null;
      }
      getNextId() {
        return this.#uiManager.getId();
      }
      get #currentEditorType() {
        return _AnnotationEditorLayer.#editorTypes.get(this.#uiManager.getMode());
      }
      combinedSignal(ac) {
        return this.#uiManager.combinedSignal(ac);
      }
      #createNewEditor(params) {
        const editorType = this.#currentEditorType;
        return editorType ? new editorType.prototype.constructor(params) : null;
      }
      canCreateNewEmptyEditor() {
        return this.#currentEditorType?.canCreateNewEmptyEditor();
      }
      async pasteEditor(options, params) {
        this.updateToolbar(options);
        await this.#uiManager.updateMode(options.mode);
        const {
          offsetX,
          offsetY
        } = this.#getCenterPoint();
        const id = this.getNextId();
        const editor = this.#createNewEditor({
          parent: this,
          id,
          x: offsetX,
          y: offsetY,
          uiManager: this.#uiManager,
          isCentered: true,
          ...params
        });
        if (editor) {
          this.add(editor);
        }
      }
      async deserialize(data) {
        return await _AnnotationEditorLayer.#editorTypes.get(data.annotationType ?? data.annotationEditorType)?.deserialize(data, this, this.#uiManager) || null;
      }
      createAndAddNewEditor(event, isCentered, data = {}) {
        const id = this.getNextId();
        const editor = this.#createNewEditor({
          parent: this,
          id,
          x: event.offsetX,
          y: event.offsetY,
          uiManager: this.#uiManager,
          isCentered,
          ...data
        });
        if (editor) {
          this.add(editor);
        }
        return editor;
      }
      get boundingClientRect() {
        return this.div.getBoundingClientRect();
      }
      #getCenterPoint() {
        const {
          x,
          y,
          width,
          height
        } = this.boundingClientRect;
        const tlX = Math.max(0, x);
        const tlY = Math.max(0, y);
        const brX = Math.min(window.innerWidth, x + width);
        const brY = Math.min(window.innerHeight, y + height);
        const centerX = (tlX + brX) / 2 - x;
        const centerY = (tlY + brY) / 2 - y;
        const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];
        return {
          offsetX,
          offsetY
        };
      }
      addNewEditor(data = {}) {
        this.createAndAddNewEditor(this.#getCenterPoint(), true, data);
      }
      setSelected(editor) {
        this.#uiManager.setSelected(editor);
      }
      toggleSelected(editor) {
        this.#uiManager.toggleSelected(editor);
      }
      unselect(editor) {
        this.#uiManager.unselect(editor);
      }
      pointerup(event) {
        const {
          isMac
        } = util_FeatureTest.platform;
        if (event.button !== 0 || event.ctrlKey && isMac) {
          return;
        }
        if (event.target !== this.div) {
          return;
        }
        if (!this.#hadPointerDown) {
          return;
        }
        this.#hadPointerDown = false;
        if (this.#currentEditorType?.isDrawer && this.#currentEditorType.supportMultipleDrawings) {
          return;
        }
        if (!this.#allowClick) {
          this.#allowClick = true;
          return;
        }
        const currentMode = this.#uiManager.getMode();
        if (currentMode === AnnotationEditorType.STAMP || currentMode === AnnotationEditorType.SIGNATURE) {
          this.#uiManager.unselectAll();
          return;
        }
        this.createAndAddNewEditor(event, false);
      }
      pointerdown(event) {
        if (this.#uiManager.getMode() === AnnotationEditorType.HIGHLIGHT) {
          this.enableTextSelection();
        }
        if (this.#hadPointerDown) {
          this.#hadPointerDown = false;
          return;
        }
        const {
          isMac
        } = util_FeatureTest.platform;
        if (event.button !== 0 || event.ctrlKey && isMac) {
          return;
        }
        if (event.target !== this.div) {
          return;
        }
        this.#hadPointerDown = true;
        if (this.#currentEditorType?.isDrawer) {
          this.startDrawingSession(event);
          return;
        }
        const editor = this.#uiManager.getActive();
        this.#allowClick = !editor || editor.isEmpty();
      }
      startDrawingSession(event) {
        this.div.focus({
          preventScroll: true
        });
        if (this.#drawingAC) {
          this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);
          return;
        }
        this.#uiManager.setCurrentDrawingSession(this);
        this.#drawingAC = new AbortController();
        const signal = this.#uiManager.combinedSignal(this.#drawingAC);
        this.div.addEventListener("blur", ({
          relatedTarget
        }) => {
          if (relatedTarget && !this.div.contains(relatedTarget)) {
            this.#focusedElement = null;
            this.commitOrRemove();
          }
        }, {
          signal
        });
        this.#currentEditorType.startDrawing(this, this.#uiManager, false, event);
      }
      pause(on) {
        if (on) {
          const {
            activeElement
          } = document;
          if (this.div.contains(activeElement)) {
            this.#focusedElement = activeElement;
          }
          return;
        }
        if (this.#focusedElement) {
          setTimeout(() => {
            this.#focusedElement?.focus();
            this.#focusedElement = null;
          }, 0);
        }
      }
      endDrawingSession(isAborted = false) {
        if (!this.#drawingAC) {
          return null;
        }
        this.#uiManager.setCurrentDrawingSession(null);
        this.#drawingAC.abort();
        this.#drawingAC = null;
        this.#focusedElement = null;
        return this.#currentEditorType.endDrawing(isAborted);
      }
      findNewParent(editor, x, y) {
        const layer = this.#uiManager.findParent(x, y);
        if (layer === null || layer === this) {
          return false;
        }
        layer.changeParent(editor);
        return true;
      }
      commitOrRemove() {
        if (this.#drawingAC) {
          this.endDrawingSession();
          return true;
        }
        return false;
      }
      onScaleChanging() {
        if (!this.#drawingAC) {
          return;
        }
        this.#currentEditorType.onScaleChangingWhenDrawing(this);
      }
      destroy() {
        this.commitOrRemove();
        if (this.#uiManager.getActive()?.parent === this) {
          this.#uiManager.commitOrRemove();
          this.#uiManager.setActiveEditor(null);
        }
        if (this.#editorFocusTimeoutId) {
          clearTimeout(this.#editorFocusTimeoutId);
          this.#editorFocusTimeoutId = null;
        }
        for (const editor of this.#editors.values()) {
          this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);
          editor.setParent(null);
          editor.isAttachedToDOM = false;
          editor.div.remove();
        }
        this.div = null;
        this.#editors.clear();
        this.#uiManager.removeLayer(this);
      }
      #cleanup() {
        for (const editor of this.#editors.values()) {
          if (editor.isEmpty()) {
            editor.remove();
          }
        }
      }
      render({
        viewport
      }) {
        this.viewport = viewport;
        setLayerDimensions(this.div, viewport);
        for (const editor of this.#uiManager.getEditors(this.pageIndex)) {
          this.add(editor);
          editor.rebuild();
        }
        this.updateMode();
      }
      update({
        viewport
      }) {
        this.#uiManager.commitOrRemove();
        this.#cleanup();
        const oldRotation = this.viewport.rotation;
        const rotation = viewport.rotation;
        this.viewport = viewport;
        setLayerDimensions(this.div, {
          rotation
        });
        if (oldRotation !== rotation) {
          for (const editor of this.#editors.values()) {
            editor.rotate(rotation);
          }
        }
      }
      get pageDimensions() {
        const {
          pageWidth,
          pageHeight
        } = this.viewport.rawDims;
        return [pageWidth, pageHeight];
      }
      get scale() {
        return this.#uiManager.viewParameters.realScale;
      }
    };
    DrawLayer = class _DrawLayer {
      #parent = null;
      #mapping = /* @__PURE__ */ new Map();
      #toUpdate = /* @__PURE__ */ new Map();
      static #id = 0;
      constructor({
        pageIndex
      }) {
        this.pageIndex = pageIndex;
      }
      setParent(parent) {
        if (!this.#parent) {
          this.#parent = parent;
          return;
        }
        if (this.#parent !== parent) {
          if (this.#mapping.size > 0) {
            for (const root2 of this.#mapping.values()) {
              root2.remove();
              parent.append(root2);
            }
          }
          this.#parent = parent;
        }
      }
      static get _svgFactory() {
        return shadow(this, "_svgFactory", new DOMSVGFactory());
      }
      static #setBox(element, [x, y, width, height]) {
        const {
          style
        } = element;
        style.top = `${100 * y}%`;
        style.left = `${100 * x}%`;
        style.width = `${100 * width}%`;
        style.height = `${100 * height}%`;
      }
      #createSVG() {
        const svg = _DrawLayer._svgFactory.create(1, 1, true);
        this.#parent.append(svg);
        svg.setAttribute("aria-hidden", true);
        return svg;
      }
      #createClipPath(defs, pathId) {
        const clipPath = _DrawLayer._svgFactory.createElement("clipPath");
        defs.append(clipPath);
        const clipPathId = `clip_${pathId}`;
        clipPath.setAttribute("id", clipPathId);
        clipPath.setAttribute("clipPathUnits", "objectBoundingBox");
        const clipPathUse = _DrawLayer._svgFactory.createElement("use");
        clipPath.append(clipPathUse);
        clipPathUse.setAttribute("href", `#${pathId}`);
        clipPathUse.classList.add("clip");
        return clipPathId;
      }
      #updateProperties(element, properties) {
        for (const [key, value] of Object.entries(properties)) {
          if (value === null) {
            element.removeAttribute(key);
          } else {
            element.setAttribute(key, value);
          }
        }
      }
      draw(properties, isPathUpdatable = false, hasClip = false) {
        const id = _DrawLayer.#id++;
        const root2 = this.#createSVG();
        const defs = _DrawLayer._svgFactory.createElement("defs");
        root2.append(defs);
        const path = _DrawLayer._svgFactory.createElement("path");
        defs.append(path);
        const pathId = `path_p${this.pageIndex}_${id}`;
        path.setAttribute("id", pathId);
        path.setAttribute("vector-effect", "non-scaling-stroke");
        if (isPathUpdatable) {
          this.#toUpdate.set(id, path);
        }
        const clipPathId = hasClip ? this.#createClipPath(defs, pathId) : null;
        const use = _DrawLayer._svgFactory.createElement("use");
        root2.append(use);
        use.setAttribute("href", `#${pathId}`);
        this.updateProperties(root2, properties);
        this.#mapping.set(id, root2);
        return {
          id,
          clipPathId: `url(#${clipPathId})`
        };
      }
      drawOutline(properties, mustRemoveSelfIntersections) {
        const id = _DrawLayer.#id++;
        const root2 = this.#createSVG();
        const defs = _DrawLayer._svgFactory.createElement("defs");
        root2.append(defs);
        const path = _DrawLayer._svgFactory.createElement("path");
        defs.append(path);
        const pathId = `path_p${this.pageIndex}_${id}`;
        path.setAttribute("id", pathId);
        path.setAttribute("vector-effect", "non-scaling-stroke");
        let maskId;
        if (mustRemoveSelfIntersections) {
          const mask = _DrawLayer._svgFactory.createElement("mask");
          defs.append(mask);
          maskId = `mask_p${this.pageIndex}_${id}`;
          mask.setAttribute("id", maskId);
          mask.setAttribute("maskUnits", "objectBoundingBox");
          const rect = _DrawLayer._svgFactory.createElement("rect");
          mask.append(rect);
          rect.setAttribute("width", "1");
          rect.setAttribute("height", "1");
          rect.setAttribute("fill", "white");
          const use = _DrawLayer._svgFactory.createElement("use");
          mask.append(use);
          use.setAttribute("href", `#${pathId}`);
          use.setAttribute("stroke", "none");
          use.setAttribute("fill", "black");
          use.setAttribute("fill-rule", "nonzero");
          use.classList.add("mask");
        }
        const use1 = _DrawLayer._svgFactory.createElement("use");
        root2.append(use1);
        use1.setAttribute("href", `#${pathId}`);
        if (maskId) {
          use1.setAttribute("mask", `url(#${maskId})`);
        }
        const use2 = use1.cloneNode();
        root2.append(use2);
        use1.classList.add("mainOutline");
        use2.classList.add("secondaryOutline");
        this.updateProperties(root2, properties);
        this.#mapping.set(id, root2);
        return id;
      }
      finalizeDraw(id, properties) {
        this.#toUpdate.delete(id);
        this.updateProperties(id, properties);
      }
      updateProperties(elementOrId, properties) {
        if (!properties) {
          return;
        }
        const {
          root: root2,
          bbox,
          rootClass,
          path
        } = properties;
        const element = typeof elementOrId === "number" ? this.#mapping.get(elementOrId) : elementOrId;
        if (!element) {
          return;
        }
        if (root2) {
          this.#updateProperties(element, root2);
        }
        if (bbox) {
          _DrawLayer.#setBox(element, bbox);
        }
        if (rootClass) {
          const {
            classList
          } = element;
          for (const [className, value] of Object.entries(rootClass)) {
            classList.toggle(className, value);
          }
        }
        if (path) {
          const defs = element.firstChild;
          const pathElement = defs.firstChild;
          this.#updateProperties(pathElement, path);
        }
      }
      updateParent(id, layer) {
        if (layer === this) {
          return;
        }
        const root2 = this.#mapping.get(id);
        if (!root2) {
          return;
        }
        layer.#parent.append(root2);
        this.#mapping.delete(id);
        layer.#mapping.set(id, root2);
      }
      remove(id) {
        this.#toUpdate.delete(id);
        if (this.#parent === null) {
          return;
        }
        this.#mapping.get(id).remove();
        this.#mapping.delete(id);
      }
      destroy() {
        this.#parent = null;
        for (const root2 of this.#mapping.values()) {
          root2.remove();
        }
        this.#mapping.clear();
        this.#toUpdate.clear();
      }
    };
    {
      globalThis._pdfjsTestingUtils = {
        HighlightOutliner
      };
    }
    globalThis.pdfjsLib = {
      AbortException,
      AnnotationEditorLayer,
      AnnotationEditorParamsType,
      AnnotationEditorType,
      AnnotationEditorUIManager,
      AnnotationLayer,
      AnnotationMode,
      AnnotationType,
      applyOpacity,
      build,
      ColorPicker,
      createValidAbsoluteUrl,
      CSSConstants,
      DOMSVGFactory,
      DrawLayer,
      FeatureTest: util_FeatureTest,
      fetchData,
      findContrastColor,
      getDocument,
      getFilenameFromUrl,
      getPdfFilenameFromUrl,
      getRGB,
      getUuid,
      getXfaPageViewport,
      GlobalWorkerOptions,
      ImageKind: util_ImageKind,
      InvalidPDFException,
      isDataScheme,
      isPdfFile,
      isValidExplicitDest,
      MathClamp,
      noContextMenu,
      normalizeUnicode,
      OPS,
      OutputScale,
      PasswordResponses,
      PDFDataRangeTransport,
      PDFDateString,
      PDFWorker,
      PermissionFlag,
      PixelsPerInch,
      RenderingCancelledException,
      renderRichText,
      ResponseException,
      setLayerDimensions,
      shadow,
      SignatureExtractor,
      stopEvent,
      SupportedImageMimeTypes,
      TextLayer,
      TouchManager,
      updateUrlHash,
      Util,
      VerbosityLevel,
      version,
      XfaLayer
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/Exception.js
function getException(error) {
  if (error instanceof Error) {
    switch (error.name) {
      case "InvalidPDFException":
        return new InvalidPDFException2(error.message, error);
      case "PasswordException":
        return new PasswordException2(error.message, error);
      case "FormatError":
        return new FormatError2(error.message, error);
      case "UnknownErrorException":
        return new UnknownErrorException2(error.message, error.details, error);
      case "ResponseException":
        return new ResponseException2(error.message, error.status, error.missing, error);
      case "AbortException":
        return new AbortException2(error.message, error);
      // add other mappings as needed
      default:
        return error;
    }
  }
  return new Error(String(error));
}
var InvalidPDFException2, PasswordException2, FormatError2, UnknownErrorException2, ResponseException2, AbortException2;
var init_Exception = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/Exception.js"() {
    InvalidPDFException2 = class _InvalidPDFException extends Error {
      /**
       * Create a new InvalidPDFException.
       * @param message - Optional error message.
       * @param cause - Optional underlying cause (preserved on modern runtimes).
       */
      constructor(message, cause) {
        if (cause !== void 0) {
          super(message ?? "Invalid PDF", { cause });
        } else {
          super(message ?? "Invalid PDF");
        }
        this.name = "InvalidPDFException";
        Object.setPrototypeOf(this, _InvalidPDFException.prototype);
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _InvalidPDFException);
        }
      }
    };
    PasswordException2 = class _PasswordException extends Error {
      /**
       * Create a new PasswordException.
       * @param message - Optional error message.
       * @param cause - Optional underlying cause.
       */
      constructor(message, cause) {
        if (cause !== void 0) {
          super(message ?? "Password required or incorrect", { cause });
        } else {
          super(message ?? "Password required or incorrect");
        }
        this.name = "PasswordException";
        Object.setPrototypeOf(this, _PasswordException.prototype);
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _PasswordException);
        }
      }
    };
    FormatError2 = class _FormatError extends Error {
      /**
       * Create a new FormatError.
       * @param message - Optional message describing the format problem.
       * @param cause - Optional underlying cause.
       */
      constructor(message, cause) {
        if (cause !== void 0) {
          super(message ?? "PDF format error", { cause });
        } else {
          super(message ?? "PDF format error");
        }
        this.name = "FormatError";
        Object.setPrototypeOf(this, _FormatError.prototype);
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _FormatError);
        }
      }
    };
    UnknownErrorException2 = class _UnknownErrorException extends Error {
      /**
       * Create a new UnknownErrorException.
       * @param message - Optional error message.
       * @param details - Optional additional details from the PDF library.
       * @param cause - Optional underlying cause.
       */
      constructor(message, details, cause) {
        if (cause !== void 0) {
          super(message ?? "Unknown error", { cause });
        } else {
          super(message ?? "Unknown error");
        }
        this.name = "UnknownErrorException";
        Object.setPrototypeOf(this, _UnknownErrorException.prototype);
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _UnknownErrorException);
        }
        this.details = details;
      }
    };
    ResponseException2 = class _ResponseException extends Error {
      /**
       * Create a new ResponseException.
       * @param message - Optional error message.
       * @param status - Optional numeric HTTP/status code.
       * @param missing - Optional field describing missing resources.
       * @param cause - Optional underlying cause.
       */
      constructor(message, status, missing, cause) {
        if (cause !== void 0) {
          super(message ?? "Response error", { cause });
        } else {
          super(message ?? "Response error");
        }
        this.name = "ResponseException";
        Object.setPrototypeOf(this, _ResponseException.prototype);
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _ResponseException);
        }
        this.status = status;
        this.missing = missing;
      }
    };
    AbortException2 = class _AbortException extends Error {
      /**
       * Create a new AbortException.
       * @param message - Optional error message.
       * @param cause - Optional underlying cause.
       */
      constructor(message, cause) {
        if (cause !== void 0) {
          super(message ?? "Operation aborted", { cause });
        } else {
          super(message ?? "Operation aborted");
        }
        this.name = "AbortException";
        Object.setPrototypeOf(this, _AbortException.prototype);
        if (typeof Error.captureStackTrace === "function") {
          Error.captureStackTrace(this, _AbortException);
        }
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Shape.js
var Shape;
var init_Shape = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Shape.js"() {
    Shape = class {
      static tolerance = 2;
      static applyTransform(p, m) {
        const xt = p[0] * m[0] + p[1] * m[2] + m[4];
        const yt = p[0] * m[1] + p[1] * m[3] + m[5];
        return [xt, yt];
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Point.js
var Point;
var init_Point = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Point.js"() {
    init_Shape();
    Point = class extends Shape {
      x;
      y;
      constructor(x, y) {
        super();
        this.x = x;
        this.y = y;
      }
      equal(point) {
        return point.x === this.x && point.y === this.y;
      }
      transform(matrix) {
        const p = Shape.applyTransform([this.x, this.y], matrix);
        this.x = p[0];
        this.y = p[1];
        return this;
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Line.js
var LineDirection, Line;
var init_Line = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Line.js"() {
    init_Point();
    init_Shape();
    (function(LineDirection2) {
      LineDirection2[LineDirection2["None"] = 0] = "None";
      LineDirection2[LineDirection2["Horizontal"] = 1] = "Horizontal";
      LineDirection2[LineDirection2["Vertical"] = 2] = "Vertical";
    })(LineDirection || (LineDirection = {}));
    Line = class _Line extends Shape {
      from;
      to;
      direction = LineDirection.None;
      length = 0;
      intersections = [];
      gaps = [];
      constructor(from, to) {
        super();
        this.from = from;
        this.to = to;
        this.init();
      }
      init() {
        let from = this.from;
        let to = this.to;
        if (Math.abs(from.y - to.y) < Shape.tolerance) {
          this.direction = LineDirection.Horizontal;
          to.y = from.y;
          if (from.x > to.x) {
            const temp = from;
            from = to;
            to = temp;
          }
          this.length = to.x - from.x;
        } else if (Math.abs(from.x - to.x) < Shape.tolerance) {
          this.direction = LineDirection.Vertical;
          to.x = from.x;
          if (from.y > to.y) {
            const temp = from;
            from = to;
            to = temp;
          }
          this.length = to.y - from.y;
        }
        this.from = from;
        this.to = to;
      }
      _valid = void 0;
      get valid() {
        if (this._valid === void 0) {
          this._valid = this.direction !== LineDirection.None && this.length > Shape.tolerance;
        }
        return this._valid;
      }
      get normalized() {
        if (this.direction === LineDirection.Horizontal) {
          return new _Line(new Point(this.from.x - Shape.tolerance, this.from.y), new Point(this.to.x + Shape.tolerance, this.from.y));
        } else if (this.direction === LineDirection.Vertical) {
          return new _Line(new Point(this.from.x, this.from.y - Shape.tolerance), new Point(this.from.x, this.to.y + Shape.tolerance));
        }
        return this;
      }
      addGap(line) {
        this.gaps.push(line);
      }
      containsPoint(p) {
        if (this.direction === LineDirection.Vertical) {
          return this.from.x === p.x && p.y >= this.from.y && p.y <= this.to.y;
        } else if (this.direction === LineDirection.Horizontal) {
          return this.from.y === p.y && p.x >= this.from.x && p.x <= this.to.x;
        }
        return false;
      }
      // // todo implement
      // public containsLine(l:Line):boolean{
      //     if(this.direction === LineDirection.Vertical && l.direction === LineDirection.Vertical){
      //         return this.from.x === l.from.x
      //     }
      //     else if(this.direction === LineDirection.Horizontal && l.direction === LineDirection.Horizontal){
      //         return this.from.y === l.from.y
      //     }
      //     return false
      // }
      addIntersectionPoint(point) {
        for (const intPoint of this.intersections) {
          if (intPoint.equal(point))
            return;
        }
        this.intersections.push(point);
      }
      intersection(line) {
        let result2;
        if (!this.valid || !line.valid) {
          return result2;
        }
        const thisNormalized = this.normalized;
        const lineNormalized = line.normalized;
        if (this.direction === LineDirection.Horizontal && line.direction === LineDirection.Vertical) {
          const x = lineNormalized.from.x;
          const y = thisNormalized.from.y;
          const isOk = x > thisNormalized.from.x && x < thisNormalized.to.x && y > lineNormalized.from.y && y < lineNormalized.to.y;
          if (isOk) {
            const intPoint = new Point(x, y);
            this.addIntersectionPoint(intPoint);
            line.addIntersectionPoint(intPoint);
            result2 = intPoint;
          }
        } else if (this.direction === LineDirection.Vertical && line.direction === LineDirection.Horizontal) {
          const x = thisNormalized.from.x;
          const y = lineNormalized.from.y;
          const isOk = x > lineNormalized.from.x && x < lineNormalized.to.x && y > thisNormalized.from.y && y < thisNormalized.to.y;
          if (isOk) {
            const intPoint = new Point(x, y);
            this.addIntersectionPoint(intPoint);
            line.addIntersectionPoint(intPoint);
            result2 = intPoint;
          }
        }
        return result2;
      }
      transform(matrix) {
        const p1 = this.from.transform(matrix);
        const p2 = this.to.transform(matrix);
        const x = Math.min(p1.x, p2.x);
        const y = Math.min(p1.y, p2.y);
        const width = Math.abs(p1.x - p2.x);
        const height = Math.abs(p1.y - p2.y);
        this.from = new Point(x, y);
        this.to = new Point(x + width, y + height);
        this.init();
        return this;
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/geometry/TableData.js
var TableData;
var init_TableData = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/geometry/TableData.js"() {
    TableData = class {
      minXY;
      maxXY;
      rows;
      rowPivots;
      colPivots;
      constructor(minXY, maxXY, rowPivots, colPivots) {
        this.minXY = minXY;
        this.maxXY = maxXY;
        this.rows = [];
        this.rowPivots = rowPivots;
        this.colPivots = colPivots;
      }
      findCell(x, y) {
        if (x >= this.minXY.x && y >= this.minXY.y && x <= this.maxXY.x && y <= this.maxXY.y) {
          for (const row of this.rows) {
            for (const cell of row) {
              if (cell.minXY.x <= x && cell.minXY.y <= y && cell.maxXY.x >= x && cell.maxXY.y >= y) {
                return cell;
              }
            }
          }
        }
        return void 0;
      }
      get cellCount() {
        return this.rows.reduce((acc, row) => acc + row.length, 0);
      }
      get rowCount() {
        return this.rows.length;
      }
      check() {
        const virtualCellCount = (this.colPivots.length - 1) * (this.rowPivots.length - 1);
        let allCellCount = 0;
        for (const row of this.rows) {
          for (const cell of row) {
            const count = (cell.colspan || 1) * (cell.rowspan || 1);
            allCellCount += count;
          }
        }
        if (virtualCellCount !== allCellCount) {
          return false;
        }
        return true;
      }
      toArray() {
        const tableArr = [];
        for (const row of this.rows) {
          const rowArr = [];
          for (const cell of row) {
            let text = cell.text.join("");
            text = text.replace(/^[\s]+|[\s]+$/g, "");
            text = text.trim();
            rowArr.push(text);
          }
          tableArr.push(rowArr);
        }
        return tableArr;
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Table.js
var Table;
var init_Table = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Table.js"() {
    init_Line();
    init_Point();
    init_Shape();
    init_TableData();
    Table = class {
      hLines = [];
      vLines = [];
      constructor(line) {
        if (line.direction === LineDirection.Horizontal) {
          this.hLines.push(line);
        } else if (line.direction === LineDirection.Vertical) {
          this.vLines.push(line);
        }
      }
      get isValid() {
        return this.hLines.length + this.vLines.length > 4;
      }
      get rowPivots() {
        const rowSet = /* @__PURE__ */ new Set();
        for (const line of this.hLines) {
          rowSet.add(line.from.y);
        }
        return [...rowSet].sort((a, b) => a - b);
      }
      get colPivots() {
        const colSet = /* @__PURE__ */ new Set();
        for (const line of this.vLines) {
          colSet.add(line.from.x);
        }
        return [...colSet].sort((a, b) => a - b);
      }
      add(line) {
        const hasIntersection = this.intersection(line);
        if (hasIntersection) {
          if (line.direction === LineDirection.Horizontal) {
            this.hLines.push(line);
            return true;
          } else if (line.direction === LineDirection.Vertical) {
            this.vLines.push(line);
            return true;
          }
        }
        return false;
      }
      intersection(line) {
        let flag = false;
        if (!line.valid)
          return flag;
        if (line.direction === LineDirection.Horizontal) {
          for (const vLine of this.vLines) {
            const p = line.intersection(vLine);
            if (p) {
              flag = true;
            }
          }
        } else if (line.direction === LineDirection.Vertical) {
          for (const hLine of this.hLines) {
            const p = line.intersection(hLine);
            if (p) {
              flag = true;
            }
          }
        }
        return flag;
      }
      getSameHorizontal(line) {
        const same = [line];
        const other = [];
        while (this.hLines.length > 0) {
          const hLine = this.hLines.shift();
          if (!hLine)
            continue;
          if (hLine.from.y === line.from.y) {
            same.push(hLine);
          } else {
            other.push(hLine);
          }
        }
        this.hLines = other;
        return same;
      }
      getSameVertical(line) {
        const same = [line];
        const other = [];
        while (this.vLines.length > 0) {
          const vLine = this.vLines.shift();
          if (!vLine)
            continue;
          if (vLine.from.x === line.from.x) {
            same.push(vLine);
          } else {
            other.push(vLine);
          }
        }
        this.vLines = other;
        return same;
      }
      mergeHorizontalLines(lines) {
        lines.sort((l1, l2) => l1.from.x - l2.from.x);
        const minX = lines[0].from.x;
        const maxX = lines[lines.length - 1].to.x;
        const resultLine = new Line(new Point(minX, lines[0].from.y), new Point(maxX, lines[0].from.y));
        for (let i = 1; i < lines.length; i++) {
          const prevLine = lines[i - 1];
          const currLine = lines[i];
          if (Math.abs(prevLine.to.x - currLine.from.x) > Shape.tolerance) {
            const gapLine = new Line(new Point(prevLine.to.x, prevLine.from.y), new Point(currLine.from.x, currLine.from.y));
            resultLine.addGap(gapLine);
          }
        }
        return resultLine;
      }
      mergeVerticalLines(lines) {
        lines.sort((l1, l2) => l1.from.y - l2.from.y);
        const minY = lines[0].from.y;
        const maxY = lines[lines.length - 1].to.y;
        const resultLine = new Line(new Point(lines[0].from.x, minY), new Point(lines[0].from.x, maxY));
        for (let i = 1; i < lines.length; i++) {
          const prevLine = lines[i - 1];
          const currLine = lines[i];
          if (Math.abs(prevLine.to.y - currLine.from.y) > Shape.tolerance) {
            const gapLine = new Line(new Point(prevLine.to.x, prevLine.to.y), new Point(prevLine.to.x, currLine.from.y));
            resultLine.addGap(gapLine);
          }
        }
        return resultLine;
      }
      normalize() {
        this.hLines = this.hLines.filter((l2) => l2.intersections.length > 1);
        this.vLines = this.vLines.filter((l2) => l2.intersections.length > 1);
        this.hLines.sort((l1, l2) => l1.from.y - l2.from.y);
        this.vLines.sort((l1, l2) => l1.from.x - l2.from.x);
        const newHLines = [];
        while (this.hLines.length > 0) {
          const line = this.hLines.shift();
          if (!line)
            continue;
          const lines = this.getSameHorizontal(line);
          const merged = this.mergeHorizontalLines(lines);
          newHLines.push(merged);
        }
        this.hLines = newHLines;
        const newVLines = [];
        while (this.vLines.length > 0) {
          const line = this.vLines.shift();
          if (!line)
            continue;
          const lines = this.getSameVertical(line);
          const merged = this.mergeVerticalLines(lines);
          newVLines.push(merged);
        }
        this.vLines = newVLines;
      }
      verticalExists(line, y1, y2) {
        if (line.direction !== LineDirection.Vertical) {
          throw new Error("Line is not vertical");
        }
        if (y1 >= y2) {
          throw new Error("y1 must be less than y2");
        }
        if (line.from.y <= y1 && line.to.y >= y2) {
          for (const gap of line.gaps) {
            if (gap.from.y <= y1 && gap.to.y >= y2) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      horizontalExists(line, x1, x2) {
        if (line.direction !== LineDirection.Horizontal) {
          throw new Error("Line is not horizontal");
        }
        if (x1 >= x2) {
          throw new Error("x1 must be less than x2");
        }
        if (line.from.x <= x1 && line.to.x >= x2) {
          for (const gap of line.gaps) {
            if (gap.from.x <= x1 && gap.to.x >= x2) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      findBottomLineIndex(h2Index, xMiddle) {
        for (let i = h2Index; i < this.hLines.length; i++) {
          const hLine = this.hLines[i];
          if (hLine.from.x <= xMiddle && hLine.to.x >= xMiddle) {
            return i;
          }
        }
        return -1;
      }
      findVerticalLineIndexs(topHLine, yMiddle) {
        const result2 = [];
        for (let i = 0; i < this.vLines.length; i++) {
          const vLine = this.vLines[i];
          if (vLine.from.y <= yMiddle && vLine.to.y >= yMiddle && topHLine.intersection(vLine)) {
            result2.push(i);
          }
        }
        return result2;
      }
      getRow(h1Index, h2Index, yMiddle) {
        const tableRow = [];
        const topHLine = this.hLines[h1Index];
        const vLineIndexes = this.findVerticalLineIndexs(topHLine, yMiddle);
        for (let i = 1; i < vLineIndexes.length; i++) {
          const leftVLine = this.vLines[vLineIndexes[i - 1]];
          const rightVLine = this.vLines[vLineIndexes[i]];
          const xMiddle = (leftVLine.from.x + rightVLine.from.x) / 2;
          const bottomHLineIndex = this.findBottomLineIndex(h2Index, xMiddle);
          const bottomHLine = this.hLines[bottomHLineIndex];
          const tableCell = {
            minXY: new Point(leftVLine.from.x, topHLine.from.y),
            maxXY: new Point(rightVLine.from.x, bottomHLine.from.y),
            width: rightVLine.from.x - leftVLine.from.x,
            height: bottomHLine.from.y - topHLine.from.y,
            text: []
          };
          const colSpan = vLineIndexes[i] - vLineIndexes[i - 1];
          const rowSpan = bottomHLineIndex - h1Index;
          if (colSpan > 1) {
            tableCell.colspan = colSpan;
          }
          if (rowSpan > 1) {
            tableCell.rowspan = rowSpan;
          }
          tableRow.push(tableCell);
        }
        return tableRow;
      }
      toData() {
        const rowPivots = this.rowPivots;
        const colPivots = this.colPivots;
        const minXY = new Point(colPivots[0], rowPivots[0]);
        const maxXY = new Point(colPivots[colPivots.length - 1], rowPivots[rowPivots.length - 1]);
        const result2 = new TableData(minXY, maxXY, rowPivots, colPivots);
        for (let h1 = 1; h1 < this.hLines.length; h1++) {
          const prevHLine = this.hLines[h1 - 1];
          const currHLine = this.hLines[h1];
          const YMiddle = (prevHLine.from.y + currHLine.from.y) / 2;
          const rowData = this.getRow(h1 - 1, h1, YMiddle);
          result2.rows.push(rowData);
        }
        return result2;
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/geometry/LineStore.js
var LineStore;
var init_LineStore = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/geometry/LineStore.js"() {
    init_Line();
    init_Point();
    init_Shape();
    init_Table();
    LineStore = class {
      hLines = [];
      vLines = [];
      add(line) {
        if (line.valid) {
          if (line.direction === LineDirection.Horizontal) {
            this.hLines.push(line);
          } else if (line.direction === LineDirection.Vertical) {
            this.vLines.push(line);
          }
        }
      }
      addRectangle(rect) {
        for (const line of rect.getLines()) {
          this.add(line);
        }
      }
      getTableData() {
        const result2 = [];
        const tables = this.getTables();
        for (const table of tables) {
          const data = table.toData();
          if (data) {
            result2.push(data);
          }
        }
        return result2;
      }
      getTables() {
        const result2 = [];
        while (this.hLines.length !== 0) {
          const hLine = this.hLines.shift();
          if (!hLine)
            continue;
          const filled = this.tryFill(result2, hLine);
          if (filled)
            continue;
          const table = new Table(hLine);
          this.fillTable(table);
          result2.push(table);
        }
        while (this.vLines.length !== 0) {
          const vLine = this.vLines.shift();
          if (!vLine)
            continue;
          const filled = this.tryFill(result2, vLine);
          if (filled)
            continue;
          const table = new Table(vLine);
          this.fillTable(table);
          result2.push(table);
        }
        const validTables = result2.filter((t) => t.isValid);
        for (const table of validTables) {
          table.normalize();
        }
        return validTables;
      }
      normalize() {
        this.normalizeHorizontal();
        this.normalizeVertical();
      }
      normalizeHorizontal() {
        this.hLines.sort((l1, l2) => l1.from.y - l2.from.y);
        const newLines = [];
        let sameY = [];
        for (const line of this.hLines) {
          if (sameY.length === 0) {
            sameY.push(line);
          } else if (Math.abs(sameY[0]?.from.y - line.from.y) < Shape.tolerance) {
            sameY.push(line);
          } else {
            const merged = this.margeHorizontalLines(sameY);
            newLines.push(...merged);
            sameY = [line];
          }
        }
        if (sameY.length > 0) {
          const merged = this.margeHorizontalLines(sameY);
          newLines.push(...merged);
        }
        this.hLines = newLines;
      }
      normalizeVertical() {
        this.vLines.sort((l1, l2) => l1.from.x - l2.from.x);
        const newLines = [];
        let sameX = [];
        for (const line of this.vLines) {
          if (sameX.length === 0) {
            sameX.push(line);
          } else if (Math.abs(sameX[0]?.from.x - line.from.x) < Shape.tolerance) {
            sameX.push(line);
          } else {
            const merged = this.margeVerticalLines(sameX);
            newLines.push(...merged);
            sameX = [line];
          }
        }
        if (sameX.length > 0) {
          const merged = this.margeVerticalLines(sameX);
          newLines.push(...merged);
        }
        this.vLines = newLines;
      }
      fillTable(table) {
        const newVLines = [];
        const newHLines = [];
        for (const vLine of this.vLines) {
          if (!table.add(vLine)) {
            newVLines.push(vLine);
          }
        }
        for (const hLine of this.hLines) {
          if (!table.add(hLine)) {
            newHLines.push(hLine);
          }
        }
        this.hLines = newHLines;
        this.vLines = newVLines;
      }
      tryFill(tables, line) {
        for (const table of tables) {
          if (table.add(line)) {
            this.fillTable(table);
            return true;
          }
        }
        return false;
      }
      margeHorizontalLines(sameYLines) {
        const result2 = [];
        sameYLines.sort((l1, l2) => l1.from.x - l2.from.x);
        const sameY = sameYLines[0]?.from.y;
        if (sameY === void 0)
          return result2;
        let minX = Number.MAX_SAFE_INTEGER;
        let maxX = Number.MIN_SAFE_INTEGER;
        for (const line of sameYLines) {
          if (line.from.x - maxX < Shape.tolerance) {
            if (line.from.x < minX) {
              minX = line.from.x;
            }
            if (line.to.x > maxX) {
              maxX = line.to.x;
            }
          } else {
            if (maxX > minX) {
              result2.push(new Line(new Point(minX, sameY), new Point(maxX, sameY)));
            }
            minX = line.from.x;
            maxX = line.to.x;
          }
        }
        const last2 = result2[result2.length - 1];
        if (last2) {
          if (last2.from.x !== minX && last2.to.x !== maxX) {
            result2.push(new Line(new Point(minX, sameY), new Point(maxX, sameY)));
          }
        } else {
          result2.push(new Line(new Point(minX, sameY), new Point(maxX, sameY)));
        }
        return result2;
      }
      margeVerticalLines(sameXLines) {
        const result2 = [];
        sameXLines.sort((l1, l2) => l1.from.y - l2.from.y);
        const sameX = sameXLines[0]?.from.x;
        if (sameX === void 0)
          return result2;
        let minY = Number.MAX_SAFE_INTEGER;
        let maxY = Number.MIN_SAFE_INTEGER;
        for (const line of sameXLines) {
          if (line.from.y - maxY < Shape.tolerance) {
            if (line.from.y < minY) {
              minY = line.from.y;
            }
            if (line.to.y > maxY) {
              maxY = line.to.y;
            }
          } else {
            if (maxY > minY) {
              result2.push(new Line(new Point(sameX, minY), new Point(sameX, maxY)));
            }
            minY = line.from.y;
            maxY = line.to.y;
          }
        }
        const last2 = result2[result2.length - 1];
        if (last2) {
          if (last2.from.y !== minY && last2.to.y !== maxY) {
            result2.push(new Line(new Point(sameX, minY), new Point(sameX, maxY)));
          }
        } else {
          result2.push(new Line(new Point(sameX, minY), new Point(sameX, maxY)));
        }
        return result2;
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Rectangle.js
var Rectangle;
var init_Rectangle = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/geometry/Rectangle.js"() {
    init_Line();
    init_Point();
    init_Shape();
    Rectangle = class extends Shape {
      from;
      width;
      height;
      constructor(from, width, height) {
        super();
        this.from = from;
        this.width = width;
        this.height = height;
      }
      get to() {
        return new Point(this.from.x + this.width, this.from.y + this.height);
      }
      getLines() {
        const to = this.to;
        const lines = [
          new Line(this.from, new Point(to.x, this.from.y)),
          new Line(this.from, new Point(this.from.x, to.y)),
          new Line(new Point(to.x, this.from.y), to),
          new Line(new Point(this.from.x, to.y), to)
        ];
        return lines.filter((l2) => l2.valid);
      }
      transform(matrix) {
        const p1 = Shape.applyTransform([this.from.x, this.from.y], matrix);
        const p2 = Shape.applyTransform([this.from.x + this.width, this.from.y + this.height], matrix);
        const x = Math.min(p1[0], p2[0]);
        const y = Math.min(p1[1], p2[1]);
        const width = Math.abs(p1[0] - p2[0]);
        const height = Math.abs(p1[1] - p2[1]);
        this.from = new Point(x, y);
        this.width = width;
        this.height = height;
        return this;
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/geometry/index.js
var init_geometry = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/geometry/index.js"() {
    init_Line();
    init_LineStore();
    init_Point();
    init_Rectangle();
    init_Shape();
    init_Table();
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/ImageResult.js
var ImageResult;
var init_ImageResult = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/ImageResult.js"() {
    ImageResult = class {
      pages = [];
      total = 0;
      getPageImage(num, name) {
        for (const pageData of this.pages) {
          if (pageData.pageNumber === num) {
            for (const img of pageData.images) {
              if (img.name === name) {
                return img;
              }
            }
          }
        }
        return null;
      }
      constructor(total) {
        this.total = total;
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/InfoResult.js
var XMP_DATE_PROPERTIES, InfoResult;
var init_InfoResult = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/InfoResult.js"() {
    init_pdf();
    XMP_DATE_PROPERTIES = [
      "xmp:createdate",
      "xmp:modifydate",
      "xmp:metadatadate",
      "xap:createdate",
      "xap:modifydate",
      "xap:metadatadate"
    ];
    InfoResult = class {
      // Total number of pages in the PDF document (count of physical pages).
      total;
      /**
       * The PDF 'Info' dictionary. Typical fields include title, author, subject,
       * Creator, Producer and Creation/Modification dates. The exact structure is
       * determined by the PDF and as returned by PDF.js.
       */
      // biome-ignore lint/suspicious/noExplicitAny: <unsupported underline type>
      info;
      // Low-level document metadata object (XMP). Use this to access extended
      // properties that are not present in the Info dictionary.
      metadata;
      /**
       * An array of document fingerprint strings provided by PDF.js. Useful
       * for caching, de-duplication or identifying a document across runs.
       */
      fingerprints;
      /**
       * Permission flags for the document as returned by PDF.js (or null).
       * These flags indicate capabilities such as printing, copying and
       * other restrictions imposed by the PDF security settings.
       */
      permission;
      /**
       * Optional document outline (bookmarks). When present this is the
       * hierarchical navigation structure which viewers use for quick access.
       */
      outline;
      // Results with per-page hyperlink extraction. Empty array by default.
      pages = [];
      /**
       * Collects dates from different sources (Info dictionary and XMP/XAP metadata)
       * and returns them as a DateNode where available. This helps callers compare
       * and choose the most relevant timestamp (for example a creation date vs XMP date).
       */
      getDateNode() {
        const result2 = {};
        const CreationDate = this.info?.CreationDate;
        if (CreationDate) {
          result2.CreationDate = PDFDateString.toDateObject(CreationDate);
        }
        const ModDate = this.info?.ModDate;
        if (ModDate) {
          result2.ModDate = PDFDateString.toDateObject(ModDate);
        }
        if (!this.metadata) {
          return result2;
        }
        for (const prop of XMP_DATE_PROPERTIES) {
          const value = this.metadata?.get(prop);
          const date = this.parseISODateString(value);
          switch (prop) {
            case XMP_DATE_PROPERTIES[0]:
              result2.XmpCreateDate = date;
              break;
            case XMP_DATE_PROPERTIES[1]:
              result2.XmpModifyDate = date;
              break;
            case XMP_DATE_PROPERTIES[2]:
              result2.XmpMetadataDate = date;
              break;
            case XMP_DATE_PROPERTIES[3]:
              result2.XapCreateDate = date;
              break;
            case XMP_DATE_PROPERTIES[4]:
              result2.XapModifyDate = date;
              break;
            case XMP_DATE_PROPERTIES[5]:
              result2.XapMetadataDate = date;
              break;
          }
        }
        return result2;
      }
      /**
       * Try to parse an ISO-8601 date string from XMP/XAP metadata. If the
       * value is falsy or cannot be parsed, undefined is returned to indicate
       * absence or unparsable input.
       */
      parseISODateString(isoDateString) {
        if (!isoDateString)
          return void 0;
        const parsedDate = Date.parse(isoDateString);
        if (!Number.isNaN(parsedDate)) {
          return new Date(parsedDate);
        }
        return void 0;
      }
      constructor(total) {
        this.total = total;
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/ParseParameters.js
function setDefaultParseParameters(params) {
  params.lineThreshold = params?.lineThreshold ?? 4.6;
  params.cellThreshold = params?.cellThreshold ?? 7;
  params.cellSeparator = params?.cellSeparator ?? "	";
  params.lineEnforce = params?.lineEnforce ?? true;
  params.pageJoiner = params?.pageJoiner ?? "\n-- page_number of total_number --";
  params.imageThreshold = params?.imageThreshold ?? 80;
  params.imageDataUrl = params?.imageDataUrl ?? true;
  params.imageBuffer = params?.imageBuffer ?? true;
  params.scale = params?.scale ?? 1;
  return params;
}
var init_ParseParameters = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/ParseParameters.js"() {
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/PathGeometry.js
var PathGeometry, DrawOPS2;
var init_PathGeometry = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/PathGeometry.js"() {
    (function(PathGeometry2) {
      PathGeometry2[PathGeometry2["undefined"] = 0] = "undefined";
      PathGeometry2[PathGeometry2["hline"] = 1] = "hline";
      PathGeometry2[PathGeometry2["vline"] = 2] = "vline";
      PathGeometry2[PathGeometry2["rectangle"] = 3] = "rectangle";
    })(PathGeometry || (PathGeometry = {}));
    (function(DrawOPS3) {
      DrawOPS3[DrawOPS3["moveTo"] = 0] = "moveTo";
      DrawOPS3[DrawOPS3["lineTo"] = 1] = "lineTo";
      DrawOPS3[DrawOPS3["curveTo"] = 2] = "curveTo";
      DrawOPS3[DrawOPS3["closePath"] = 3] = "closePath";
      DrawOPS3[DrawOPS3["rectangle"] = 4] = "rectangle";
    })(DrawOPS2 || (DrawOPS2 = {}));
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/ScreenshotResult.js
var ScreenshotResult;
var init_ScreenshotResult = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/ScreenshotResult.js"() {
    ScreenshotResult = class {
      pages = [];
      total = 0;
      constructor(total) {
        this.total = total;
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/TableResult.js
var TableResult;
var init_TableResult = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/TableResult.js"() {
    TableResult = class {
      pages = [];
      mergedTables = [];
      total = 0;
      constructor(total) {
        this.total = total;
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/TextResult.js
var TextResult;
var init_TextResult = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/TextResult.js"() {
    TextResult = class {
      pages = [];
      text = "";
      total = 0;
      getPageText(num) {
        for (const pageData of this.pages) {
          if (pageData.num === num)
            return pageData.text;
        }
        return "";
      }
      constructor(total) {
        this.total = total;
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/PDFParse.js
var PDFParse;
var init_PDFParse = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/PDFParse.js"() {
    init_pdf();
    init_Exception();
    init_geometry();
    init_ImageResult();
    init_InfoResult();
    init_ParseParameters();
    init_PathGeometry();
    init_ScreenshotResult();
    init_TableResult();
    init_TextResult();
    PDFParse = class {
      options;
      doc;
      progress = { loaded: -1, total: 0 };
      /**
       * Create a new parser with `LoadParameters`.
       * Converts Node.js `Buffer` data to `Uint8Array` automatically and ensures a default verbosity level.
       * @param options - Initialization parameters.
       */
      constructor(options) {
        if (options.verbosity === void 0) {
          options.verbosity = VerbosityLevel.ERRORS;
        }
        if (typeof Buffer !== "undefined" && options.data instanceof Buffer) {
          options.data = new Uint8Array(options.data);
        }
        this.options = options;
      }
      async destroy() {
        if (this.doc) {
          await this.doc.destroy();
          this.doc = void 0;
        }
      }
      // biome-ignore-start lint/suspicious/noExplicitAny: unsupported underline type
      static get isNodeJS() {
        const isNodeJS2 = typeof process === "object" && `${process}` === "[object process]" && !process.versions.nw && !(process.versions.electron && typeof process.type !== "undefined" && process.type !== "browser");
        return isNodeJS2;
      }
      static setWorker(workerSrc) {
        if (typeof globalThis.pdfjs === "undefined") {
          globalThis.pdfjs = pdf_exports;
        }
        if (pdf_exports?.GlobalWorkerOptions === null)
          return "";
        if (workerSrc !== void 0) {
          GlobalWorkerOptions.workerSrc = workerSrc;
          return GlobalWorkerOptions.workerSrc;
        }
        return GlobalWorkerOptions.workerSrc;
      }
      // biome-ignore-end lint/suspicious/noExplicitAny: unsupported underline type
      /**
       * Load document-level metadata (info, outline, permissions, page labels) and optionally gather per-page link details.
       * @param params - Parse options; set `parsePageInfo` to collect per-page metadata described in `ParseParameters`.
       * @returns Aggregated document metadata in an `InfoResult`.
       */
      async getInfo(params = {}) {
        const doc = await this.load();
        const result2 = new InfoResult(doc.numPages);
        const { info: info2, metadata } = await doc.getMetadata();
        result2.info = info2;
        result2.metadata = metadata;
        result2.fingerprints = doc.fingerprints;
        result2.outline = await doc.getOutline();
        result2.permission = await doc.getPermissions();
        const pageLabels = await doc.getPageLabels();
        if (params.parsePageInfo) {
          for (let i = 1; i <= result2.total; i++) {
            if (this.shouldParse(i, result2.total, params)) {
              const page = await doc.getPage(i);
              const pageLinkResult = await this.getPageLinks(page);
              pageLinkResult.pageLabel = pageLabels?.[page.pageNumber];
              result2.pages.push(pageLinkResult);
              page.cleanup();
            }
          }
        }
        return result2;
      }
      async getPageLinks(page) {
        const viewport = page.getViewport({ scale: 1 });
        const result2 = {
          pageNumber: page.pageNumber,
          links: [],
          width: viewport.width,
          height: viewport.height
        };
        const annotations = await page.getAnnotations({ intent: "display" }) || [];
        for (const i of annotations) {
          if (i.subtype !== "Link")
            continue;
          const url = i.url ?? i.unsafeUrl;
          if (!url)
            continue;
          const text = i.overlaidText || "";
          result2.links.push({ url, text });
        }
        return result2;
      }
      /**
       * Extract plain text for each requested page, optionally enriching hyperlinks and enforcing line or cell separators.
       * @param params - Parse options controlling pagination, link handling, and line/cell thresholds.
       * @returns A `TextResult` containing page-wise text and a concatenated document string.
       */
      async getText(params = {}) {
        const doc = await this.load();
        const result2 = new TextResult(doc.numPages);
        for (let i = 1; i <= result2.total; i++) {
          if (this.shouldParse(i, result2.total, params)) {
            const page = await doc.getPage(i);
            const text = await this.getPageText(page, params, result2.total);
            result2.pages.push({
              text,
              num: i
            });
            page.cleanup();
          }
        }
        for (const page of result2.pages) {
          if (params.pageJoiner) {
            let pageNumber = params.pageJoiner.replace("page_number", `${page.num}`);
            pageNumber = pageNumber.replace("total_number", `${result2.total}`);
            result2.text += `${page.text}
${pageNumber}

`;
          } else {
            result2.text += `${page.text}

`;
          }
        }
        return result2;
      }
      async load() {
        try {
          if (this.doc === void 0) {
            const loadingTask = getDocument(this.options);
            loadingTask.onProgress = (progress) => {
              this.progress = progress;
            };
            this.doc = await loadingTask.promise;
          }
          return this.doc;
        } catch (error) {
          throw getException(error);
        }
      }
      shouldParse(currentPage, totalPage, params) {
        params.partial = params?.partial ?? [];
        params.first = params?.first ?? 0;
        params.last = params?.last ?? 0;
        if (params.partial.length > 0) {
          if (params.partial.includes(currentPage)) {
            return true;
          }
          return false;
        }
        if (params.first > 0 && params.last > 0) {
          if (currentPage >= params.first && currentPage <= params.last) {
            return true;
          }
          return false;
        }
        if (params.first > 0) {
          if (currentPage <= params.first) {
            return true;
          }
          return false;
        }
        if (params.last > 0) {
          if (currentPage > totalPage - params.last) {
            return true;
          }
          return false;
        }
        return true;
      }
      async getPageText(page, parseParams, total) {
        const viewport = page.getViewport({ scale: 1 });
        const params = setDefaultParseParameters(parseParams);
        const textContent = await page.getTextContent({
          includeMarkedContent: !!params.includeMarkedContent,
          disableNormalization: !!params.disableNormalization
        });
        let links = /* @__PURE__ */ new Map();
        if (params.parseHyperlinks) {
          links = await this.getHyperlinks(page, viewport);
        }
        const strBuf = [];
        let lastX;
        let lastY;
        let lineHeight = 0;
        for (const item of textContent.items) {
          if (!("str" in item))
            continue;
          const tm = item.transform ?? item.transform;
          const [x, y] = viewport.convertToViewportPoint(tm[4], tm[5]);
          if (params.parseHyperlinks) {
            const posArr = links.get(item.str) || [];
            const hit = posArr.find((l2) => x >= l2.rect.left && x <= l2.rect.right && y >= l2.rect.top && y <= l2.rect.bottom);
            if (hit) {
              item.str = `[${item.str}](${hit.url})`;
            }
          }
          if (params.lineEnforce) {
            if (lastY !== void 0 && Math.abs(lastY - y) > params.lineThreshold) {
              const lastItem = strBuf.length ? strBuf[strBuf.length - 1] : void 0;
              const isCurrentItemHasNewLine = item.str.startsWith("\n") || item.str.trim() === "" && item.hasEOL;
              if (lastItem?.endsWith("\n") === false && !isCurrentItemHasNewLine) {
                const ydiff = Math.abs(lastY - y);
                if (ydiff - 1 > lineHeight) {
                  strBuf.push("\n");
                  lineHeight = 0;
                }
              }
            }
          }
          if (params.cellSeparator) {
            if (lastY !== void 0 && Math.abs(lastY - y) < params.lineThreshold) {
              if (lastX !== void 0 && Math.abs(lastX - x) > params.cellThreshold) {
                item.str = `${params.cellSeparator}${item.str}`;
              }
            }
          }
          strBuf.push(item.str);
          lastX = x + item.width;
          lastY = y;
          lineHeight = Math.max(lineHeight, item.height);
          if (item.hasEOL) {
            strBuf.push("\n");
          }
          if (item.hasEOL || item.str.endsWith("\n")) {
            lineHeight = 0;
          }
        }
        if (params.itemJoiner) {
          return strBuf.join(params.itemJoiner);
        }
        return strBuf.join("");
      }
      async getHyperlinks(page, viewport) {
        const result2 = /* @__PURE__ */ new Map();
        const annotations = await page.getAnnotations({ intent: "display" }) || [];
        for (const i of annotations) {
          if (i.subtype !== "Link")
            continue;
          const url = i.url ?? i.unsafeUrl;
          if (!url)
            continue;
          const text = i.overlaidText;
          if (!text)
            continue;
          const rectVp = viewport.convertToViewportRectangle(i.rect);
          const left = Math.min(rectVp[0], rectVp[2]) - 0.5;
          const top = Math.min(rectVp[1], rectVp[3]) - 0.5;
          const right = Math.max(rectVp[0], rectVp[2]) + 0.5;
          const bottom = Math.max(rectVp[1], rectVp[3]) + 0.5;
          const pos = { rect: { left, top, right, bottom }, url, text, used: false };
          const el = result2.get(text);
          if (el) {
            el.push(pos);
          } else {
            result2.set(text, [pos]);
          }
        }
        return result2;
      }
      /**
       * Extract embedded images from requested pages.
       *
       * Behavior notes:
       * - Pages are selected according to ParseParameters (partial, first, last).
       * - Images smaller than `params.imageThreshold` (width OR height) are skipped.
       * - Returned ImageResult contains per-page PageImages; each image entry includes:
       *     - data: Uint8Array (present when params.imageBuffer === true)
       *     - dataUrl: string (present when params.imageDataUrl === true)
       *     - width, height, kind, name
       * - Works in both Node.js (canvas.toBuffer) and browser (canvas.toDataURL) environments.
       *
       * @param params - ParseParameters controlling page selection, thresholds and output format.
       * @returns Promise<ImageResult> with extracted images grouped by page.
       */
      async getImage(params = {}) {
        const doc = await this.load();
        const result2 = new ImageResult(doc.numPages);
        setDefaultParseParameters(params);
        for (let i = 1; i <= result2.total; i++) {
          if (this.shouldParse(i, result2.total, params)) {
            const page = await doc.getPage(i);
            const ops = await page.getOperatorList();
            const pageImages = { pageNumber: i, images: [] };
            result2.pages.push(pageImages);
            for (let j = 0; j < ops.fnArray.length; j++) {
              if (ops.fnArray[j] === OPS.paintInlineImageXObject || ops.fnArray[j] === OPS.paintImageXObject) {
                const name = ops.argsArray[j][0];
                const isCommon = page.commonObjs.has(name);
                const imgPromise = isCommon ? this.resolveEmbeddedImage(page.commonObjs, name) : this.resolveEmbeddedImage(page.objs, name);
                const { width, height, kind, data } = await imgPromise;
                if (params.imageThreshold) {
                  if (params.imageThreshold >= width || params.imageThreshold >= height) {
                    continue;
                  }
                }
                const canvasFactory = doc.canvasFactory;
                const canvasAndContext = canvasFactory.create(width, height);
                const context = canvasAndContext.context;
                let imgData = null;
                if (kind === util_ImageKind.RGBA_32BPP) {
                  imgData = context.createImageData(width, height);
                  imgData.data.set(data);
                } else {
                  imgData = context.createImageData(width, height);
                  this.convertToRGBA({
                    src: data,
                    dest: new Uint32Array(imgData.data.buffer),
                    width,
                    height,
                    kind
                  });
                }
                context.putImageData(imgData, 0, 0);
                let buffer = new Uint8Array();
                let dataUrl = "";
                if (typeof canvasAndContext.canvas.toBuffer === "function") {
                  let nodeBuffer;
                  if (params.imageBuffer) {
                    nodeBuffer = canvasAndContext.canvas.toBuffer("image/png");
                    buffer = new Uint8Array(nodeBuffer);
                  }
                  if (params.imageDataUrl) {
                    if (nodeBuffer) {
                      dataUrl = `data:image/png;base64,${nodeBuffer.toString("base64")}`;
                    } else {
                      nodeBuffer = canvasAndContext.canvas.toBuffer("image/png");
                      buffer = new Uint8Array(nodeBuffer);
                      dataUrl = `data:image/png;base64,${nodeBuffer.toString("base64")}`;
                    }
                  }
                } else {
                  if (params.imageBuffer) {
                    const imageData = canvasAndContext.context.getImageData(0, 0, canvasAndContext.canvas.width, canvasAndContext.canvas.height);
                    buffer = new Uint8Array(imageData.data);
                  }
                  if (params.imageDataUrl) {
                    dataUrl = canvasAndContext.canvas.toDataURL("image/png");
                  }
                }
                pageImages.images.push({
                  data: buffer,
                  dataUrl,
                  name,
                  height,
                  width,
                  kind
                });
              }
            }
          }
        }
        return result2;
      }
      convertToRGBA({ src, dest, width, height, kind }) {
        if (kind === util_ImageKind.RGB_24BPP) {
          for (let i = 0, j = 0; i < src.length; i += 3, j++) {
            const r = src[i];
            const g = src[i + 1];
            const b = src[i + 2];
            dest[j] = 255 << 24 | b << 16 | g << 8 | r;
          }
        } else if (kind === util_ImageKind.GRAYSCALE_1BPP) {
          let pixelIndex = 0;
          for (let i = 0; i < src.length; i++) {
            const byte = src[i];
            for (let bit = 7; bit >= 0; bit--) {
              if (pixelIndex >= width * height)
                break;
              const isWhite = (byte >> bit & 1) === 1;
              const gray = isWhite ? 255 : 0;
              dest[pixelIndex++] = 255 << 24 | gray << 16 | gray << 8 | gray;
            }
          }
        } else if (kind === void 0 || kind === null) {
          const bytesPerPixel = src.length / (width * height);
          if (Math.abs(bytesPerPixel - 3) < 0.1) {
            for (let i = 0, j = 0; i < src.length; i += 3, j++) {
              const r = src[i];
              const g = src[i + 1];
              const b = src[i + 2];
              dest[j] = 255 << 24 | b << 16 | g << 8 | r;
            }
          } else if (Math.abs(bytesPerPixel - 4) < 0.1) {
            for (let i = 0, j = 0; i < src.length; i += 4, j++) {
              const r = src[i];
              const g = src[i + 1];
              const b = src[i + 2];
              const a = src[i + 3];
              dest[j] = a << 24 | b << 16 | g << 8 | r;
            }
          } else if (Math.abs(bytesPerPixel - 1) < 0.1) {
            for (let i = 0; i < src.length; i++) {
              const gray = src[i];
              dest[i] = 255 << 24 | gray << 16 | gray << 8 | gray;
            }
          } else {
            throw new Error(`convertToRGBA: Cannot infer image format. kind: ${kind}, bytesPerPixel: ${bytesPerPixel}, width: ${width}, height: ${height}, dataLength: ${src.length}`);
          }
        } else {
          throw new Error(`convertToRGBA: Unsupported image kind: ${kind}. Available kinds: GRAYSCALE_1BPP=${util_ImageKind.GRAYSCALE_1BPP}, RGB_24BPP=${util_ImageKind.RGB_24BPP}, RGBA_32BPP=${util_ImageKind.RGBA_32BPP}`);
        }
      }
      resolveEmbeddedImage(pdfObjects, name) {
        return new Promise((resolve, reject2) => {
          pdfObjects.get(name, (imgData) => {
            if (imgData) {
              let dataBuff;
              if (imgData.data instanceof Uint8Array) {
                dataBuff = imgData.data;
              } else if (imgData.data instanceof Uint8ClampedArray) {
                dataBuff = new Uint8Array(imgData.data);
              } else if (imgData.data?.buffer) {
                dataBuff = new Uint8Array(imgData.data.buffer);
              } else if (imgData.bitmap) {
                const canvasFactory = this.doc.canvasFactory;
                const canvasAndContext = canvasFactory.create(imgData.bitmap.width, imgData.bitmap.height);
                canvasAndContext.context.drawImage(imgData.bitmap, 0, 0);
                const imageData = canvasAndContext.context.getImageData(0, 0, imgData.bitmap.width, imgData.bitmap.height);
                dataBuff = new Uint8Array(imageData.data.buffer);
              } else if (ArrayBuffer.isView(imgData.data)) {
                dataBuff = new Uint8Array(imgData.data.buffer, imgData.data.byteOffset, imgData.data.byteLength);
              }
              if (!dataBuff) {
                reject2(new Error(`Image object ${name}: data field is empty or invalid. Available fields: ${Object.keys(imgData).join(", ")}`));
                return;
              }
              if (dataBuff.length === 0) {
                reject2(new Error(`Image object ${name}: data buffer is empty (length: 0)`));
                return;
              }
              resolve({ width: imgData.width, height: imgData.height, kind: imgData.kind, data: dataBuff });
            } else {
              reject2(new Error(`Image object ${name} not found`));
            }
          });
        });
      }
      /**
       * Render pages to raster screenshots.
       *
       * Behavior notes:
       * - Pages are selected according to ParseParameters (partial, first, last).
       * - Use params.scale for zoom; if params.desiredWidth is specified it takes precedence.
       * - Each ScreenshotResult page contains:
       *     - data: Uint8Array (when params.imageBuffer === true)
       *     - dataUrl: string (when params.imageDataUrl === true)
       *     - pageNumber, width, height, scale
       * - Works in both Node.js (canvas.toBuffer) and browser (canvas.toDataURL) environments.
       *
       * @param parseParams - ParseParameters controlling page selection and render options.
       * @returns Promise<ScreenshotResult> with rendered page images.
       */
      async getScreenshot(parseParams = {}) {
        const params = setDefaultParseParameters(parseParams);
        const doc = await this.load();
        const result2 = new ScreenshotResult(doc.numPages);
        if (this.doc === void 0) {
          throw new Error("PDF document not loaded");
        }
        for (let i = 1; i <= result2.total; i++) {
          if (this.shouldParse(i, result2.total, params)) {
            const page = await this.doc.getPage(i);
            let viewport = page.getViewport({ scale: params.scale });
            if (params.desiredWidth) {
              viewport = page.getViewport({ scale: 1 });
              const scale = params.desiredWidth / viewport.width;
              viewport = page.getViewport({ scale });
            }
            const canvasFactory = this.doc.canvasFactory;
            const canvasAndContext = canvasFactory.create(viewport.width, viewport.height);
            const renderContext = {
              canvasContext: canvasAndContext.context,
              viewport,
              canvas: canvasAndContext.canvas
            };
            const renderTask = page.render(renderContext);
            await renderTask.promise;
            let data = new Uint8Array();
            let dataUrl = "";
            if (typeof canvasAndContext.canvas.toBuffer === "function") {
              let nodeBuffer;
              if (params.imageBuffer) {
                nodeBuffer = canvasAndContext.canvas.toBuffer("image/png");
                data = new Uint8Array(nodeBuffer);
              }
              if (params.imageDataUrl) {
                if (nodeBuffer) {
                  dataUrl = `data:image/png;base64,${nodeBuffer.toString("base64")}`;
                } else {
                  nodeBuffer = canvasAndContext.canvas.toBuffer("image/png");
                  data = new Uint8Array(nodeBuffer);
                  dataUrl = `data:image/png;base64,${nodeBuffer.toString("base64")}`;
                }
              }
            } else {
              if (params.imageBuffer) {
                const imageData = canvasAndContext.context.getImageData(0, 0, canvasAndContext.canvas.width, canvasAndContext.canvas.height);
                data = new Uint8Array(imageData.data);
              }
              if (params.imageDataUrl) {
                dataUrl = canvasAndContext.canvas.toDataURL("image/png");
              }
            }
            result2.pages.push({
              data,
              dataUrl,
              pageNumber: i,
              width: viewport.width,
              height: viewport.height,
              scale: viewport.scale
            });
            page.cleanup();
          }
        }
        return result2;
      }
      /**
       * Detect and extract tables from pages by analysing vector drawing operators, then populate cells with text.
       *
       * Behavior notes:
       * - Scans operator lists for rectangles/lines that form table grids (uses PathGeometry and LineStore).
       * - Normalizes detected geometry and matches positioned text to table cells.
       * - Honors ParseParameters for page selection.
       *
       * @param params - ParseParameters controlling which pages to analyse (partial/first/last).
       * @returns Promise<TableResult> containing discovered tables per page.
       */
      async getTable(params = {}) {
        const doc = await this.load();
        const result2 = new TableResult(doc.numPages);
        if (this.doc === void 0) {
          throw new Error("PDF document not loaded");
        }
        for (let i = 1; i <= result2.total; i++) {
          if (this.shouldParse(i, result2.total, params)) {
            const page = await this.doc.getPage(i);
            const store = await this.getPageTables(page);
            store.normalize();
            const tableDataArr = store.getTableData();
            await this.fillPageTables(page, tableDataArr);
            const pageTableResult = { num: i, tables: [] };
            for (const table of tableDataArr) {
              pageTableResult.tables.push(table.toArray());
            }
            result2.pages.push(pageTableResult);
            page.cleanup();
          }
        }
        return result2;
      }
      getPathGeometry(mm) {
        const width = mm[2] - mm[0];
        const height = mm[3] - mm[1];
        if (mm[0] === Infinity) {
          return PathGeometry.undefined;
        }
        if (width > 5 && height > 5) {
          return PathGeometry.rectangle;
        } else if (width > 5 && height === 0) {
          return PathGeometry.hline;
        } else if (width === 0 && height > 5) {
          return PathGeometry.vline;
        }
        return PathGeometry.undefined;
      }
      async getPageTables(page) {
        const lineStore = new LineStore();
        const viewport = page.getViewport({ scale: 1 });
        let transformMatrix = [1, 0, 0, 1, 0, 0];
        const transformStack = [];
        const opList = await page.getOperatorList();
        for (let i = 0; i < opList.fnArray.length; i++) {
          const fn = opList.fnArray[i];
          const args = opList.argsArray[i];
          const op = args?.[0] ?? 0;
          const mm = args?.[2] ?? [Infinity, Infinity, -Infinity, -Infinity];
          if (fn === OPS.constructPath) {
            if (op === OPS.fill) {
            }
            if (op !== OPS.stroke) {
              continue;
            }
            const pg = this.getPathGeometry(mm);
            if (pg === PathGeometry.rectangle) {
              const rect = new Rectangle(new Point(mm[0], mm[1]), mm[2] - mm[0], mm[3] - mm[1]);
              rect.transform(transformMatrix);
              rect.transform(viewport.transform);
              lineStore.addRectangle(rect);
            } else if (pg === PathGeometry.hline || pg === PathGeometry.vline) {
              const from = new Point(mm[0], mm[1]);
              const to = new Point(mm[2], mm[3]);
              const line = new Line(from, to);
              line.transform(transformMatrix);
              line.transform(viewport.transform);
              lineStore.add(line);
            } else {
            }
          } else if (fn === OPS.setLineWidth) {
          } else if (fn === OPS.save) {
            transformStack.push(transformMatrix);
          } else if (fn === OPS.restore) {
            const restoredMatrix = transformStack.pop();
            if (restoredMatrix) {
              transformMatrix = restoredMatrix;
            }
          } else if (fn === OPS.transform) {
            transformMatrix = Util.transform(transformMatrix, args);
          }
        }
        return lineStore;
      }
      // private async getPageGeometry(page: PDFPageProxy): Promise<LineStore> {
      // 	const lineStore: LineStore = new LineStore();
      // 	const opList = await page.getOperatorList();
      // 	const viewport = page.getViewport({ scale: 1 });
      // 	let transformMatrix = [1, 0, 0, 1, 0, 0];
      // 	const transformStack: Array<Array<number>> = [];
      // 	let current_x: number = 0;
      // 	let current_y: number = 0;
      // 	for (let j = 0; j < opList.fnArray.length; j++) {
      // 		const fn = opList.fnArray[j];
      // 		const args = opList.argsArray[j];
      // 		if (fn === pdfjs.OPS.constructPath) {
      // 			while (args[0].length) {
      // 				const op = args[0].shift();
      // 				const combinedMatrix = pdfjs.Util.transform(viewport.transform, transformMatrix);
      // 				if (op === pdfjs.OPS.rectangle) {
      // 					const x = args[1].shift();
      // 					const y = args[1].shift();
      // 					const width = args[1].shift();
      // 					const height = args[1].shift();
      // 					if (Math.min(width, height) <= 2) {
      // 						// TODO remove
      // 						debugger;
      // 					}
      // 					const rect = new Rectangle(new Point(x, y), width, height);
      // 					rect.transform(combinedMatrix);
      // 					//rect.transform(viewport.transform);
      // 					lineStore.addRectangle(rect);
      // 				} else if (op === pdfjs.OPS.moveTo) {
      // 					current_x = args[1].shift();
      // 					current_y = args[1].shift();
      // 				} else if (op === pdfjs.OPS.lineTo) {
      // 					const x = args[1].shift();
      // 					const y = args[1].shift();
      // 					//default trasform
      // 					const from = new Point(current_x, current_y);
      // 					const to = new Point(x, y);
      // 					const line = new Line(from, to);
      // 					line.transform(combinedMatrix);
      // 					//line.transform(viewport.transform);
      // 					// // viewport transform
      // 					// const _from = viewport.convertToViewportPoint(line.from.x, line.from.y)
      // 					// const _to = viewport.convertToViewportPoint(line.to.x, line.to.y)
      // 					//
      // 					// const transformedLine = new Line(new Point(_from[0], _from[1]), new Point(_to[0], _to[1]))
      // 					lineStore.add(line);
      // 					current_x = x;
      // 					current_y = y;
      // 				}
      // 			}
      // 		} else if (fn === pdfjs.OPS.save) {
      // 			transformStack.push(transformMatrix);
      // 		} else if (fn === pdfjs.OPS.restore) {
      // 			const restoredMatrix = transformStack.pop();
      // 			if (restoredMatrix) {
      // 				transformMatrix = restoredMatrix;
      // 			}
      // 		} else if (fn === pdfjs.OPS.transform) {
      // 			//transformMatrix = this.transform_fn(transformMatrix, args);
      // 			transformMatrix = pdfjs.Util.transform(transformMatrix, args);
      // 		}
      // 	}
      // 	return lineStore;
      // }
      async fillPageTables(page, pageTables) {
        const viewport = page.getViewport({ scale: 1 });
        const textContent = await page.getTextContent({
          includeMarkedContent: false,
          disableNormalization: false
        });
        for (const textItem of textContent.items) {
          if (!("str" in textItem))
            continue;
          const tx = Util.transform(Util.transform(viewport.transform, textItem.transform), [1, 0, 0, -1, 0, 0]);
          for (const pageTable of pageTables) {
            const cell = pageTable.findCell(tx[4], tx[5]);
            if (cell) {
              cell.text.push(textItem.str);
              if (textItem.hasEOL) {
                cell.text.push("\n");
              }
              break;
            }
          }
        }
      }
    };
  }
});

// node_modules/pdf-parse/dist/pdf-parse/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  AbortException: () => AbortException2,
  FormatError: () => FormatError2,
  InvalidPDFException: () => InvalidPDFException2,
  Line: () => Line,
  LineDirection: () => LineDirection,
  LineStore: () => LineStore,
  PDFParse: () => PDFParse,
  PasswordException: () => PasswordException2,
  Point: () => Point,
  Rectangle: () => Rectangle,
  ResponseException: () => ResponseException2,
  Shape: () => Shape,
  Table: () => Table,
  UnknownErrorException: () => UnknownErrorException2,
  VerbosityLevel: () => VerbosityLevel,
  getException: () => getException
});
var init_esm = __esm({
  "node_modules/pdf-parse/dist/pdf-parse/esm/index.js"() {
    init_PDFParse();
    init_pdf();
    init_Exception();
    init_geometry();
  }
});

// api/index.ts
var import_cookie = __toESM(require_dist(), 1);
import OpenAI2 from "openai";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import Stripe from "stripe";
import { getSignedUrl } from "@aws-sdk/s3-request-presigner";

// api/lib/s3.ts
import { S3Client, GetObjectCommand, PutObjectCommand } from "@aws-sdk/client-s3";
function getS3Client() {
  const region = process.env.AWS_REGION || "us-east-1";
  return new S3Client({ region });
}

// api/lib/db.ts
import { neon } from "@neondatabase/serverless";
if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL is required in environment for DB connections");
}
var sql = neon(process.env.DATABASE_URL);

// api/lib/processResume.ts
import OpenAI from "openai";
var openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
async function processResume(resumeId, originalText, userId, userPlan) {
  try {
    const [optimizationResult, scoreResult] = await Promise.all([
      openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          { role: "system", content: "Optimize resumes. Output JSON only." },
          {
            role: "user",
            content: `Rewrite this resume with strong action verbs and quantified achievements.

${originalText}

{"improvedText": "optimized resume"}`
          }
        ],
        response_format: { type: "json_object" },
        max_tokens: 2500
      }),
      openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages: [
          { role: "system", content: "Score resumes. Output JSON only." },
          {
            role: "user",
            content: `Score this resume.

${originalText.substring(0, 1500)}

{"atsScore": 0-100, "keywordsScore": 0-10, "formattingScore": 0-10, "issues": [{"type": "issue", "message": "fix", "severity": "high"}]}`
          }
        ],
        response_format: { type: "json_object" },
        max_tokens: 500
      })
    ]);
    const optimization = JSON.parse(optimizationResult.choices[0].message.content || "{}");
    const scores = JSON.parse(scoreResult.choices[0].message.content || "{}");
    await sql`
      UPDATE resumes SET
        improved_text = ${optimization.improvedText || originalText},
        ats_score = ${scores.atsScore || 70},
        keywords_score = ${scores.keywordsScore || 7},
        formatting_score = ${scores.formattingScore || 7},
        issues = ${JSON.stringify(scores.issues || [])},
        status = 'completed',
        updated_at = NOW()
      WHERE id = ${resumeId}
    `;
  } catch (error) {
    console.error("[Process] Error optimizing resume:", error);
    await sql`UPDATE resumes SET status = 'failed' WHERE id = ${resumeId}`;
    if (userPlan !== "admin") {
      await sql`UPDATE users SET credits_remaining = credits_remaining + 1 WHERE id = ${userId}`;
      console.log(`[Credit] Refunded 1 credit to user ${userId} due to optimization failure`);
    }
  }
}

// api/lib/queue.ts
import { EventEmitter } from "events";
var QUEUE_KEY = "upload_jobs_v1";
var queue = [];
var events = new EventEmitter();
events.setMaxListeners(0);
async function enqueueJob(job) {
  queue.push(job);
  events.emit(QUEUE_KEY);
}

// api/lib/fileParser.ts
var import_mammoth = __toESM(require_lib6(), 1);
var IS_SERVERLESS_VERCEL = process.env.VERCEL === "1" && process.env.NODE_ENV === "production";
var PDF_PARSER_DISABLED = process.env.DISABLE_PDF_PARSE === "1";
var PDF_PARSE_SUPPORTED = !IS_SERVERLESS_VERCEL && !PDF_PARSER_DISABLED;
var cachedPdfParse = null;
async function resolvePdfParse() {
  if (cachedPdfParse) {
    return cachedPdfParse;
  }
  try {
    const module2 = await Promise.resolve().then(() => (init_esm(), esm_exports));
    const resolved = module2.default || module2;
    cachedPdfParse = resolved;
    return cachedPdfParse;
  } catch (err) {
    const message = err instanceof Error ? err.message : String(err);
    throw new Error(`pdf-parse could not be loaded: ${message}`);
  }
}
function cleanExtractedText(text) {
  return text.replace(/\r\n/g, "\n").replace(/\n{3,}/g, "\n\n").replace(/[ \t]+/g, " ").trim();
}
function validateExtractedText(text, filename) {
  const MIN_TEXT_LENGTH = 50;
  if (!text || text.trim().length === 0) {
    throw new Error(`File appears to be empty or corrupted: ${filename}`);
  }
  if (text.trim().length < MIN_TEXT_LENGTH) {
    throw new Error(
      `File contains insufficient text content (minimum ${MIN_TEXT_LENGTH} characters required): ${filename}`
    );
  }
}
async function parseFile(buffer, mimetype, filename = "unknown") {
  try {
    let rawText = "";
    if (mimetype === "application/pdf") {
      if (!PDF_PARSE_SUPPORTED) {
        throw new Error(
          "PDF parsing is disabled in the current runtime (Vercel serverless or overridden). Please upload a DOCX or TXT file instead."
        );
      }
      const pdfParse = await resolvePdfParse();
      const data = await pdfParse(buffer);
      rawText = data.text;
    } else if (mimetype === "application/vnd.openxmlformats-officedocument.wordprocessingml.document" || mimetype === "application/zip" || mimetype === "application/x-zip" || mimetype === "application/x-zip-compressed" || mimetype === "application/octet-stream") {
      try {
        const result2 = await import_mammoth.default.extractRawText({ buffer });
        if (result2.messages.length > 0) {
          console.log(`[FileParser] Mammoth warnings for ${filename}:`, result2.messages);
        }
        rawText = result2.value;
      } catch (mammothError) {
        throw new Error(
          `Failed to parse DOCX file. The file may be corrupted or in an unsupported format.`
        );
      }
    } else if (mimetype === "application/msword" || mimetype === "application/vnd.ms-word") {
      throw new Error(
        "Legacy .doc files are not supported. Please convert to .docx or PDF before uploading."
      );
    } else if (mimetype === "text/plain") {
      rawText = buffer.toString("utf-8");
    } else {
      throw new Error(`Unsupported file type: ${mimetype}. Please upload PDF, DOCX, or TXT files.`);
    }
    const cleanedText = cleanExtractedText(rawText);
    validateExtractedText(cleanedText, filename);
    return cleanedText;
  } catch (error) {
    if (error instanceof Error) {
      throw error;
    }
    throw new Error(`Failed to parse file: ${String(error)}`);
  }
}

// api/index.ts
import formidable from "formidable";
import fs from "fs/promises";
import crypto2 from "crypto";
function validateEnv() {
  const required = ["DATABASE_URL", "JWT_SECRET", "OPENAI_API_KEY", "STRIPE_SECRET_KEY"];
  const missing = required.filter((key) => !process.env[key]);
  if (missing.length > 0) {
    console.error("[ENV] Missing required environment variables:", missing.join(", "));
    throw new Error(`Missing required environment variables: ${missing.join(", ")}`);
  }
  console.log("[ENV] All required environment variables validated");
}
validateEnv();
var openai2 = new OpenAI2({ apiKey: process.env.OPENAI_API_KEY });
var stripe = new Stripe(process.env.STRIPE_SECRET_KEY);
var config = {
  api: {
    bodyParser: false
  }
};
var isProductionEnv = (req) => {
  if (process.env.NODE_ENV === "production") return true;
  if (process.env.VERCEL === "1") return true;
  const host = req.headers.host || "";
  return !host.includes("localhost") && !host.includes("127.0.0.1");
};
var PRICES = {
  basic: { amount: 700, credits: 1, name: "Basic Plan" },
  pro: { amount: 1900, credits: 3, name: "Pro Plan" },
  premium: { amount: 2900, credits: 999, name: "Premium Plan" }
};
async function parseMultipartForm(req) {
  return new Promise((resolve, reject2) => {
    const form = new formidable.IncomingForm({ multiples: false, keepExtensions: true });
    form.parse(req, async (err, fieldsRaw, filesRaw) => {
      if (err) return reject2(err);
      try {
        const fields = {};
        const files = [];
        for (const key of Object.keys(fieldsRaw || {})) {
          const val = fieldsRaw[key];
          fields[key] = Array.isArray(val) ? String(val[0]) : String(val);
        }
        for (const key of Object.keys(filesRaw || {})) {
          const fileEntry = filesRaw[key];
          if (!fileEntry) continue;
          const fileList = Array.isArray(fileEntry) ? fileEntry : [fileEntry];
          for (const f of fileList) {
            const filepath = f.filepath || f.path || f.file;
            const filename = f.originalFilename || f.name || f.filename || f.newFilename || f.path?.split("/").pop();
            const mimetype = f.mimetype || f.type || "application/octet-stream";
            if (filepath) {
              const data = await fs.readFile(String(filepath));
              files.push({ name: key, filename: String(filename), mimetype: String(mimetype), data });
              try {
                await fs.unlink(String(filepath));
              } catch {
              }
            }
          }
        }
        resolve({ fields, files });
      } catch (e) {
        reject2(e);
      }
    });
  });
}
async function getRawBody(req) {
  return new Promise((resolve) => {
    const chunks = [];
    try {
      if (req.body && typeof req.body === "string") {
        return resolve(Buffer.from(req.body, "utf8"));
      }
    } catch (e) {
    }
    req.on("data", (chunk2) => chunks.push(Buffer.isBuffer(chunk2) ? chunk2 : Buffer.from(String(chunk2))));
    req.on("end", () => resolve(Buffer.concat(chunks)));
    req.on("error", () => resolve(Buffer.alloc(0)));
  });
}
async function parseJSONBody(req) {
  return new Promise((resolve) => {
    const chunks = [];
    try {
      if (req.body && typeof req.body === "object") return resolve(req.body);
      if (req.body && typeof req.body === "string") return resolve(JSON.parse(req.body));
    } catch (e) {
      console.warn("[parseJSONBody] Pre-parsed body parse failed, falling back to stream");
    }
    req.on("data", (chunk2) => chunks.push(Buffer.isBuffer(chunk2) ? chunk2 : Buffer.from(String(chunk2))));
    req.on("end", () => {
      try {
        const bodyStr = Buffer.concat(chunks).toString("utf-8").trim();
        if (!bodyStr) return resolve(null);
        try {
          return resolve(JSON.parse(bodyStr));
        } catch (err) {
          console.error("[parseJSONBody] JSON.parse failed:", err instanceof Error ? err.message : String(err));
          return resolve(null);
        }
      } catch (error) {
        console.error("[parseJSONBody] Unknown error reading body:", error);
        return resolve(null);
      }
    });
    req.on("error", (error) => {
      console.error("[parseJSONBody] Stream error:", error);
      return resolve(null);
    });
  });
}
function generateToken(payload) {
  return jwt.sign(payload, process.env.JWT_SECRET, { expiresIn: "7d" });
}
function verifyToken(token) {
  try {
    return jwt.verify(token, process.env.JWT_SECRET);
  } catch {
    return null;
  }
}
async function getUserFromRequest(req) {
  const cookies = (0, import_cookie.parse)(req.headers.cookie || "");
  const token = cookies.token;
  if (!token) return null;
  const decoded = verifyToken(token);
  if (!decoded) return null;
  const users = await sql`SELECT * FROM users WHERE id = ${decoded.userId}`;
  return users[0] || null;
}
function isAdmin(email) {
  const adminEmails = (process.env.ADMIN_EMAILS || "").split(",").map((e) => e.trim().toLowerCase());
  return adminEmails.includes(email.toLowerCase());
}
function getRequestPath(req) {
  try {
    const origin = req.headers.origin || (req.headers.host ? `https://${req.headers.host}` : "https://localhost");
    const url = new URL(req.url || "/", origin);
    return url.pathname;
  } catch {
    return req.url?.split("?")[0] || "";
  }
}
async function handler(req, res) {
  const method = req.method || "GET";
  const path = getRequestPath(req);
  try {
    console.log(`[${method}] ${path}`);
    const allowedOrigins = [
      "https://rewriteme.app",
      "http://localhost:5174",
      "http://localhost:3003",
      "http://localhost:5000"
    ];
    const origin = req.headers.origin || "";
    const isAllowed = allowedOrigins.includes(origin) || origin.includes("vercel.app");
    res.setHeader("Access-Control-Allow-Credentials", "true");
    res.setHeader("Access-Control-Allow-Origin", isAllowed ? origin : allowedOrigins[0]);
    res.setHeader("Access-Control-Allow-Methods", "GET,POST,PUT,DELETE,OPTIONS");
    res.setHeader("Access-Control-Allow-Headers", "Content-Type,Authorization");
    if (method === "OPTIONS") {
      return res.status(200).end();
    }
    if (path === "/api" || path === "/api/health") {
      return res.json({ status: "ok", timestamp: (/* @__PURE__ */ new Date()).toISOString() });
    }
    if (path === "/api/auth/me" && method === "GET") {
      const user = await getUserFromRequest(req);
      if (!user) {
        return res.json({
          authenticated: false,
          user: null
        });
      }
      return res.json({
        authenticated: true,
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          plan: user.plan,
          creditsRemaining: user.credits_remaining,
          emailVerified: user.email_verified
        }
      });
    }
    if (path === "/api/auth/login" && method === "POST") {
      const body = await parseJSONBody(req);
      if (!body) {
        return res.status(400).json({ error: "Empty request body" });
      }
      const { email, password } = body;
      if (!email || !password) {
        return res.status(400).json({ error: "Email and password required" });
      }
      const users = await sql`SELECT * FROM users WHERE email = ${email}`;
      const user = users[0];
      if (!user || !await bcrypt.compare(password, user.password_hash)) {
        return res.status(401).json({ error: "Invalid credentials" });
      }
      const token = generateToken({ userId: user.id, email: user.email });
      res.setHeader(
        "Set-Cookie",
        (0, import_cookie.serialize)("token", token, {
          httpOnly: true,
          secure: isProductionEnv(req),
          sameSite: "lax",
          maxAge: 7 * 24 * 60 * 60,
          path: "/"
        })
      );
      return res.json({
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          plan: user.plan,
          creditsRemaining: user.credits_remaining
        }
      });
    }
    if (path === "/api/auth/register" && method === "POST") {
      const body = await parseJSONBody(req);
      if (!body) {
        return res.status(400).json({ error: "Empty request body" });
      }
      const { email, password, name } = body;
      if (!email || !password) {
        return res.status(400).json({ error: "Email and password required" });
      }
      const existing = await sql`SELECT id FROM users WHERE email = ${email}`;
      if (existing.length > 0) {
        return res.status(400).json({ error: "Email already registered" });
      }
      const passwordHash = await bcrypt.hash(password, 10);
      const admin = isAdmin(email);
      const result2 = await sql`
        INSERT INTO users (email, password_hash, name, plan, credits_remaining, email_verified)
        VALUES (${email}, ${passwordHash}, ${name || null}, ${admin ? "admin" : "free"}, ${admin ? 9999 : 1}, NULL)
        RETURNING *
      `;
      const user = result2[0];
      const token = generateToken({ userId: user.id, email: user.email });
      res.setHeader(
        "Set-Cookie",
        (0, import_cookie.serialize)("token", token, {
          httpOnly: true,
          secure: isProductionEnv(req),
          sameSite: "lax",
          maxAge: 7 * 24 * 60 * 60,
          path: "/"
        })
      );
      return res.json({
        user: {
          id: user.id,
          email: user.email,
          name: user.name,
          plan: user.plan,
          creditsRemaining: user.credits_remaining
        }
      });
    }
    if (path === "/api/auth/logout" && method === "POST") {
      res.setHeader(
        "Set-Cookie",
        (0, import_cookie.serialize)("token", "", {
          httpOnly: true,
          secure: isProductionEnv(req),
          sameSite: "lax",
          maxAge: 0,
          path: "/"
        })
      );
      return res.json({ success: true });
    }
    if (path === "/api/auth/google" && method === "GET") {
      const redirectUri = `${process.env.APP_URL}/api/auth/google/callback`;
      const scope = encodeURIComponent("email profile");
      const authUrl = `https://accounts.google.com/o/oauth2/v2/auth?client_id=${process.env.GOOGLE_CLIENT_ID}&redirect_uri=${encodeURIComponent(redirectUri)}&response_type=code&scope=${scope}&access_type=offline&prompt=consent`;
      return res.redirect(302, authUrl);
    }
    if (path === "/api/auth/google/callback" && method === "GET") {
      const code = req.query.code;
      if (!code) {
        return res.redirect(302, "/auth?error=no_code");
      }
      const redirectUri = `${process.env.APP_URL}/api/auth/google/callback`;
      const tokenRes = await fetch("https://oauth2.googleapis.com/token", {
        method: "POST",
        headers: { "Content-Type": "application/x-www-form-urlencoded" },
        body: new URLSearchParams({
          code,
          client_id: process.env.GOOGLE_CLIENT_ID,
          client_secret: process.env.GOOGLE_CLIENT_SECRET,
          redirect_uri: redirectUri,
          grant_type: "authorization_code"
        })
      });
      if (!tokenRes.ok) {
        return res.redirect(302, "/auth?error=token_failed");
      }
      const tokens = await tokenRes.json();
      const userRes = await fetch("https://www.googleapis.com/oauth2/v2/userinfo", {
        headers: { Authorization: `Bearer ${tokens.access_token}` }
      });
      if (!userRes.ok) {
        return res.redirect(302, "/auth?error=user_info_failed");
      }
      const googleUser = await userRes.json();
      let users = await sql`SELECT * FROM users WHERE email = ${googleUser.email}`;
      let user = users[0];
      const admin = isAdmin(googleUser.email);
      if (!user) {
        const secureOAuthHash = crypto2.randomBytes(32).toString("hex");
        const result2 = await sql`
          INSERT INTO users (email, password_hash, name, plan, credits_remaining, email_verified)
          VALUES (${googleUser.email}, ${secureOAuthHash}, ${googleUser.name || null}, ${admin ? "admin" : "free"}, ${admin ? 9999 : 1}, true)
          RETURNING *
        `;
        user = result2[0];
      } else if (admin && user.plan !== "admin") {
        await sql`UPDATE users SET plan = 'admin', credits_remaining = 9999 WHERE id = ${user.id}`;
        user.plan = "admin";
        user.credits_remaining = 9999;
      }
      const token = generateToken({ userId: user.id, email: user.email });
      res.setHeader(
        "Set-Cookie",
        (0, import_cookie.serialize)("token", token, {
          httpOnly: true,
          secure: isProductionEnv(req),
          sameSite: "lax",
          maxAge: 7 * 24 * 60 * 60,
          path: "/"
        })
      );
      return res.redirect(302, "/");
    }
    if (path === "/api/resumes" && method === "GET") {
      const user = await getUserFromRequest(req);
      if (!user) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const resumes = await sql`SELECT * FROM resumes WHERE user_id = ${user.id} ORDER BY created_at DESC`;
      return res.json(resumes);
    }
    if (path.match(/^\/api\/resumes\/[^/]+$/) && method === "GET") {
      const resumeId = path.split("/").pop();
      const resumes = await sql`SELECT * FROM resumes WHERE id = ${resumeId}`;
      const resume = resumes[0];
      if (!resume) {
        return res.status(404).json({ error: "Resume not found" });
      }
      const user = await getUserFromRequest(req);
      const canAccessImprovedText = user && user.plan !== "free";
      return res.json({
        id: resume.id,
        userId: resume.user_id,
        fileName: resume.file_name,
        originalText: resume.original_text,
        improvedText: canAccessImprovedText ? resume.improved_text : null,
        atsScore: resume.ats_score,
        keywordsScore: resume.keywords_score,
        formattingScore: resume.formatting_score,
        issues: resume.issues,
        status: resume.status,
        createdAt: resume.created_at,
        updatedAt: resume.updated_at,
        requiresUpgrade: !canAccessImprovedText && resume.status === "completed"
      });
    }
    if (path === "/api/resumes/upload" && method === "POST") {
      try {
        console.log("[Upload] Starting upload handler...");
        const user = await getUserFromRequest(req);
        if (!user) {
          console.log("[Upload] User not authenticated");
          return res.status(401).json({ error: "Not authenticated" });
        }
        console.log(`[Upload] User authenticated: ${user.id}, plan: ${user.plan}, credits: ${user.credits_remaining}`);
        const contentType = req.headers["content-type"] || "";
        console.log("[Upload] Content-Type:", contentType);
        if (!contentType.includes("multipart/form-data")) {
          return res.status(400).json({
            error: "Invalid content type. Expected multipart/form-data",
            received: contentType
          });
        }
        console.log("[Upload] Parsing multipart form data...");
        let files;
        try {
          const parsed = await parseMultipartForm(req);
          files = parsed.files;
          console.log("[Upload] Files parsed:", files.length);
        } catch (parseError) {
          console.error("[Upload] Parse error:", parseError);
          return res.status(400).json({
            error: "Failed to parse upload",
            details: parseError instanceof Error ? parseError.message : String(parseError)
          });
        }
        if (!files || files.length === 0) {
          return res.status(400).json({ error: "No file uploaded" });
        }
        const file = files[0];
        const { filename, mimetype, data } = file;
        console.log("[Upload] Processing file:", filename, mimetype, `${data.length} bytes`);
        let originalText;
        try {
          originalText = await parseFile(data, mimetype, filename);
        } catch (parseError) {
          const message = parseError instanceof Error ? parseError.message : "Failed to parse file";
          console.error("[Upload] File parsing failed:", message);
          return res.status(400).json({
            error: "File parsing failed",
            message
          });
        }
        let contentHash = null;
        try {
          contentHash = crypto2.createHash("sha256").update(originalText).digest("hex");
          const existingResumes = await sql`
            SELECT id, created_at FROM resumes
            WHERE user_id = ${user.id} AND content_hash = ${contentHash}
            LIMIT 1
          `;
          if (existingResumes.length > 0) {
            const existing = existingResumes[0];
            console.log("[Upload] Duplicate detected:", existing.id);
            return res.status(200).json({
              resumeId: existing.id,
              status: "completed",
              isDuplicate: true,
              message: "This resume has already been analyzed.",
              originalUploadDate: existing.created_at
            });
          }
        } catch (dupError) {
          console.warn("[Upload] Duplicate detection failed:", dupError);
          contentHash = null;
        }
        if (user.plan !== "admin") {
          const updatedUsers = await sql`
            UPDATE users
            SET credits_remaining = credits_remaining - 1
            WHERE id = ${user.id} AND credits_remaining > 0
            RETURNING credits_remaining
          `;
          if (updatedUsers.length === 0) {
            console.log("[Upload] Credit deduction failed - no credits remaining");
            return res.status(403).json({
              error: "No credits remaining",
              message: "Please purchase more credits to continue"
            });
          }
          console.log("[Upload] Credit deducted atomically, remaining:", updatedUsers[0].credits_remaining);
        }
        let result2;
        if (contentHash) {
          result2 = await sql`
            INSERT INTO resumes (user_id, file_name, original_text, status, content_hash, original_file_name)
            VALUES (${user.id}, ${filename}, ${originalText}, 'processing', ${contentHash}, ${filename})
            RETURNING *
          `;
        } else {
          result2 = await sql`
            INSERT INTO resumes (user_id, file_name, original_text, status)
            VALUES (${user.id}, ${filename}, ${originalText}, 'processing')
            RETURNING *
          `;
        }
        const resume = result2[0];
        console.log("[Upload] Resume created:", resume.id);
        processResume(resume.id, originalText, user.id, user.plan).catch((err) => {
          console.error("[Upload] Background processing error:", err);
        });
        return res.json({ resumeId: resume.id, status: "processing" });
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : "Failed to process file";
        const errorStack = error instanceof Error ? error.stack : void 0;
        console.error("[Upload] Unexpected error:", errorMessage);
        if (errorStack) console.error("[Upload] Stack:", errorStack);
        return res.status(500).json({
          error: "Upload failed",
          message: errorMessage,
          stack: process.env.NODE_ENV === "development" ? errorStack : void 0
        });
      }
    }
    if (path === "/api/uploads/presign" && method === "POST") {
      const user = await getUserFromRequest(req);
      if (!user) return res.status(401).json({ error: "Not authenticated" });
      const body = await parseJSONBody(req);
      if (!body) return res.status(400).json({ error: "Empty request body" });
      const { filename, contentType } = body;
      if (!filename || !contentType) return res.status(400).json({ error: "filename and contentType required" });
      const bucket = process.env.S3_BUCKET;
      if (!bucket) return res.status(500).json({ error: "S3_BUCKET not configured" });
      const key = `uploads/${user.id}/${Date.now()}-${filename}`;
      const s3 = getS3Client();
      const cmd = new PutObjectCommand({ Bucket: bucket, Key: key, ContentType: contentType });
      try {
        const url = await getSignedUrl(s3, cmd, { expiresIn: 300 });
        return res.json({ url, key });
      } catch (err) {
        console.error("Presign error:", err);
        return res.status(500).json({ error: "Failed to create presigned URL" });
      }
    }
    if (path === "/api/uploads/complete" && method === "POST") {
      try {
        const user = await getUserFromRequest(req);
        if (!user) return res.status(401).json({ error: "Not authenticated" });
        const body = await parseJSONBody(req);
        if (!body) return res.status(400).json({ error: "Empty request body" });
        const { key, filename } = body;
        if (!key || !filename) return res.status(400).json({ error: "key and filename required" });
        const bucket = process.env.S3_BUCKET;
        if (!bucket) return res.status(500).json({ error: "S3_BUCKET not configured" });
        const result2 = await sql`
          INSERT INTO resumes (user_id, file_name, original_text, status, original_file_name)
          VALUES (${user.id}, ${filename}, ${""}, 'queued', ${filename})
          RETURNING *
        `;
        const resume = result2[0];
        await enqueueJob({ resumeId: resume.id, bucket, key, filename, userId: user.id });
        return res.json({ resumeId: resume.id, status: "queued" });
      } catch (err) {
        console.error("[UploadComplete] Error:", err);
        return res.status(500).json({ error: "Failed to complete upload" });
      }
    }
    if (path === "/api/payments/create-checkout" && method === "POST") {
      const user = await getUserFromRequest(req);
      if (!user) {
        return res.status(401).json({ error: "Not authenticated" });
      }
      const body = await parseJSONBody(req);
      if (!body) return res.status(400).json({ error: "Empty request body" });
      const { plan } = body;
      if (!plan || !PRICES[plan]) {
        return res.status(400).json({ error: "Invalid plan" });
      }
      const priceConfig = PRICES[plan];
      const session = await stripe.checkout.sessions.create({
        payment_method_types: ["card"],
        line_items: [
          {
            price_data: {
              currency: "usd",
              product_data: {
                name: priceConfig.name,
                description: `${priceConfig.credits === 999 ? "Unlimited" : priceConfig.credits} resume optimization${priceConfig.credits !== 1 ? "s" : ""}`
              },
              unit_amount: priceConfig.amount
            },
            quantity: 1
          }
        ],
        mode: "payment",
        success_url: `${process.env.APP_URL}/payment-success?session_id={CHECKOUT_SESSION_ID}`,
        cancel_url: `${process.env.APP_URL}/#pricing`,
        customer_email: user.email,
        metadata: {
          userId: user.id,
          plan,
          credits: priceConfig.credits.toString()
        }
      });
      return res.json({ url: session.url });
    }
    if (path === "/api/payments/verify" && method === "POST") {
      const body = await parseJSONBody(req);
      if (!body) return res.status(400).json({ error: "Empty request body" });
      const { sessionId } = body;
      if (!sessionId) {
        return res.status(400).json({ error: "Session ID required" });
      }
      const session = await stripe.checkout.sessions.retrieve(sessionId);
      if (session.payment_status === "paid") {
        const userId = session.metadata?.userId;
        const plan = session.metadata?.plan;
        const credits = parseInt(session.metadata?.credits || "0");
        if (userId && plan) {
          await sql`
            UPDATE users 
            SET plan = ${plan}, credits_remaining = credits_remaining + ${credits}
            WHERE id = ${userId}
          `;
          await sql`
            INSERT INTO payments (user_id, stripe_session_id, plan, amount, status)
            VALUES (${userId}, ${sessionId}, ${plan}, ${session.amount_total}, 'completed')
            ON CONFLICT (stripe_session_id) DO NOTHING
          `;
          return res.json({ success: true, plan, credits });
        }
      }
      return res.status(400).json({ error: "Payment not completed" });
    }
    if (path === "/api/webhooks/stripe" && method === "POST") {
      const sig = req.headers["stripe-signature"];
      let event;
      try {
        const rawBody = await getRawBody(req);
        event = stripe.webhooks.constructEvent(rawBody, sig, process.env.STRIPE_WEBHOOK_SECRET);
      } catch (err) {
        const message = err instanceof Error ? err.message : "Unknown error";
        console.error("Webhook signature verification failed:", message);
        return res.status(400).json({ error: "Webhook signature verification failed" });
      }
      if (event.type === "checkout.session.completed") {
        const session = event.data.object;
        const userId = session.metadata?.userId;
        const plan = session.metadata?.plan;
        const credits = parseInt(session.metadata?.credits || "0");
        if (userId && plan && session.payment_status === "paid") {
          await sql`
            UPDATE users
            SET plan = ${plan}, credits_remaining = credits_remaining + ${credits}
            WHERE id = ${userId}
          `;
          await sql`
            INSERT INTO payments (user_id, stripe_session_id, plan, amount, status)
            VALUES (${userId}, ${session.id}, ${plan}, ${session.amount_total}, 'completed')
            ON CONFLICT (stripe_session_id) DO NOTHING
          `;
        }
      }
      return res.json({ received: true });
    }
    if (path === "/api/analytics/event" && method === "POST") {
      const body = await parseJSONBody(req);
      if (!body) return res.status(400).json({ error: "Empty request body" });
      const { event, properties, page, referrer, sessionId } = body;
      if (!event || !sessionId) {
        return res.status(400).json({ error: "Event name and sessionId required" });
      }
      const user = await getUserFromRequest(req);
      const userId = user?.id || null;
      const userAgent = req.headers["user-agent"] || null;
      const ipAddress = req.headers["x-forwarded-for"] || req.headers["x-real-ip"] || null;
      try {
        await sql`
          INSERT INTO analytics_events (user_id, session_id, event, properties, page, referrer, user_agent, ip_address)
          VALUES (${userId}, ${sessionId}, ${event}, ${JSON.stringify(properties || {})}, ${page || null}, ${referrer || null}, ${userAgent}, ${ipAddress})
        `;
      } catch (err) {
        console.warn("Analytics event failed (table may not exist):", err);
      }
      return res.json({ success: true });
    }
    if (path.match(/^\/api\/analytics\/funnel\/[^/]+$/) && method === "POST") {
      const step = path.split("/").pop();
      const body = await parseJSONBody(req);
      if (!body) return res.status(400).json({ error: "Empty request body" });
      const { sessionId } = body;
      if (!step || !sessionId) {
        return res.status(400).json({ error: "Step and sessionId required" });
      }
      const user = await getUserFromRequest(req);
      const userId = user?.id || null;
      try {
        await sql`
          INSERT INTO funnel_steps (session_id, step, user_id)
          VALUES (${sessionId}, ${step}, ${userId})
        `;
      } catch (err) {
        console.warn("Funnel tracking failed (table may not exist):", err);
      }
      return res.json({ success: true });
    }
    return res.status(404).json({ error: "Not found" });
  } catch (error) {
    const err = error instanceof Error ? error : new Error(String(error));
    const errorMessage = err.message || "Unknown error";
    const errorStack = err.stack;
    console.error("API Error:", errorMessage, { method, path });
    if (errorStack) console.error("Stack:", errorStack);
    return res.status(500).json({
      error: "Internal server error",
      message: errorMessage,
      stack: process.env.NODE_ENV === "development" ? errorStack : void 0
    });
  }
}
export {
  config,
  handler as default
};
